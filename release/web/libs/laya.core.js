window.Laya = (function (exports) {
    'use strict';

    function dummy() { }
    function dummy2() { }
    function regClass() { return dummy; }
    function classInfo(info) { return dummy2; }
    function runInEditor(constructor) { }
    function property(info) { return dummy2; }

    class Config {
        static defaultFontStr() {
            return Config.defaultFontSize + "px " + Config.defaultFont;
        }
    }
    Config.isAntialias = true;
    Config.useWebGL2 = true;
    Config.FPS = 60;
    Config.useRetinalCanvas = false;
    Config.animationInterval = 50;
    Config.webGL2D_MeshAllocMaxMem = true;
    Config.defaultFontSize = 12;
    Config.defaultFont = "Arial";
    Config.isAlpha = false;
    Config.isDepth = false;
    Config.isfailIfMajorPerformanceCaveat = false;
    Config.powerPreference = "default";
    Config.premultipliedAlpha = true;
    Config.isStencil = false;
    Config.preserveDrawingBuffer = false;
    Config.printWebglOrder = false;
    Config.fontFamilyMap = { "报隶": "报隶-简", "黑体": "黑体-简", "楷体": "楷体-简", "兰亭黑": "兰亭黑-简", "隶变": "隶变-简", "凌慧体": "凌慧体-简", "翩翩体": "翩翩体-简", "苹方": "苹方-简", "手札体": "手札体-简", "宋体": "宋体-简", "娃娃体": "娃娃体-简", "魏碑": "魏碑-简", "行楷": "行楷-简", "雅痞": "雅痞-简", "圆体": "圆体-简" };

    class Const {
    }
    Const.ENUM_TEXTALIGN_DEFAULT = 0;
    Const.ENUM_TEXTALIGN_CENTER = 1;
    Const.ENUM_TEXTALIGN_RIGHT = 2;
    Const.BYTES_PE = 4;
    Const.BYTES_PIDX = 2;
    Const.MAX_CLIP_SIZE = 99999999;
    class NodeFlags {
    }
    NodeFlags.NOT_ACTIVE = 0x01;
    NodeFlags.ACTIVE_INHIERARCHY = 0x02;
    NodeFlags.AWAKED = 0x04;
    NodeFlags.NOT_READY = 0x08;
    NodeFlags.DISPLAY = 0x10;
    NodeFlags.HAS_ZORDER = 0x20;
    NodeFlags.HAS_MOUSE = 0x40;
    NodeFlags.DISPLAYED_INSTAGE = 0x80;
    NodeFlags.DRAWCALL_OPTIMIZE = 0x100;
    NodeFlags.PROCESS_COLLISIONS = 0x200;
    NodeFlags.PROCESS_TRIGGERS = 0x400;
    NodeFlags.HAS_SCRIPT = 0x800;
    NodeFlags.ESCAPE_DRAWING_TO_TEXTURE = 0x1000;
    NodeFlags.DISABLE_INNER_CLIPPING = 0x2000;
    NodeFlags.DISABLE_OUTER_CLIPPING = 0x4000;
    NodeFlags.DISABLE_VISIBILITY = 0x8000;
    NodeFlags.HIDE_BY_EDITOR = 0x10000;
    NodeFlags.LOCK_BY_EDITOR = 0x20000;
    class HideFlags {
    }
    HideFlags.HideInHierarchy = 0x1;
    HideFlags.HideInInspector = 0x2;
    HideFlags.DontSave = 0x4;
    HideFlags.HideAndDontSave = 0x7;

    class ILaya {
    }
    ILaya.Loader = null;
    ILaya.Context = null;
    ILaya.Browser = null;
    ILaya.Laya = null;
    ILaya.loader = null;
    ILaya.timer = null;
    ILaya.systemTimer = null;
    ILaya.physicsTimer = null;
    ILaya.stage = null;

    class Pool {
        static getPoolBySign(sign) {
            return Pool._poolDic[sign] || (Pool._poolDic[sign] = []);
        }
        static clearBySign(sign) {
            if (Pool._poolDic[sign])
                Pool._poolDic[sign].length = 0;
        }
        static recover(sign, item) {
            if (item[Pool.POOLSIGN])
                return;
            item[Pool.POOLSIGN] = true;
            Pool.getPoolBySign(sign).push(item);
        }
        static recoverByClass(instance) {
            if (instance) {
                var className = instance["__className"] || instance.constructor._$gid;
                if (className)
                    Pool.recover(className, instance);
            }
        }
        static _getClassSign(cla) {
            var className = cla["__className"] || cla["_$gid"];
            if (!className) {
                cla["_$gid"] = className = Pool._CLSID + "";
                Pool._CLSID++;
            }
            return className;
        }
        static createByClass(cls) {
            return Pool.getItemByClass(Pool._getClassSign(cls), cls);
        }
        static getItemByClass(sign, cls) {
            if (!Pool._poolDic[sign])
                return new cls();
            var pool = Pool.getPoolBySign(sign);
            if (pool.length) {
                var rst = pool.shift();
                rst[Pool.POOLSIGN] = false;
            }
            else {
                rst = new cls();
            }
            return rst;
        }
        static getItemByCreateFun(sign, createFun, caller = null) {
            var pool = Pool.getPoolBySign(sign);
            var rst = pool.length ? pool.pop() : createFun.call(caller);
            rst[Pool.POOLSIGN] = false;
            return rst;
        }
        static getItem(sign) {
            var pool = Pool.getPoolBySign(sign);
            var rst = pool.length ? pool.pop() : null;
            if (rst) {
                rst[Pool.POOLSIGN] = false;
            }
            return rst;
        }
    }
    Pool._CLSID = 0;
    Pool.POOLSIGN = "__InPool";
    Pool._poolDic = {};

    class Matrix {
        constructor(a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0, nums = 0) {
            this._bTransform = false;
            if (Matrix._createFun != null) {
                return Matrix._createFun(a, b, c, d, tx, ty, nums);
            }
            this.a = a;
            this.b = b;
            this.c = c;
            this.d = d;
            this.tx = tx;
            this.ty = ty;
            this._checkTransform();
        }
        identity() {
            this.a = this.d = 1;
            this.b = this.tx = this.ty = this.c = 0;
            this._bTransform = false;
            return this;
        }
        _checkTransform() {
            return this._bTransform = (this.a !== 1 || this.b !== 0 || this.c !== 0 || this.d !== 1);
        }
        setTranslate(x, y) {
            this.tx = x;
            this.ty = y;
            return this;
        }
        translate(x, y) {
            this.tx += x;
            this.ty += y;
            return this;
        }
        scale(x, y) {
            this.a *= x;
            this.d *= y;
            this.c *= x;
            this.b *= y;
            this.tx *= x;
            this.ty *= y;
            this._bTransform = true;
            return this;
        }
        rotate(angle) {
            var cos = Math.cos(angle);
            var sin = Math.sin(angle);
            var a1 = this.a;
            var c1 = this.c;
            var tx1 = this.tx;
            this.a = a1 * cos - this.b * sin;
            this.b = a1 * sin + this.b * cos;
            this.c = c1 * cos - this.d * sin;
            this.d = c1 * sin + this.d * cos;
            this.tx = tx1 * cos - this.ty * sin;
            this.ty = tx1 * sin + this.ty * cos;
            this._bTransform = true;
            return this;
        }
        skew(x, y) {
            var tanX = Math.tan(x);
            var tanY = Math.tan(y);
            var a1 = this.a;
            var b1 = this.b;
            this.a += tanY * this.c;
            this.b += tanY * this.d;
            this.c += tanX * a1;
            this.d += tanX * b1;
            return this;
        }
        invertTransformPoint(out) {
            var a1 = this.a;
            var b1 = this.b;
            var c1 = this.c;
            var d1 = this.d;
            var tx1 = this.tx;
            var n = a1 * d1 - b1 * c1;
            var a2 = d1 / n;
            var b2 = -b1 / n;
            var c2 = -c1 / n;
            var d2 = a1 / n;
            var tx2 = (c1 * this.ty - d1 * tx1) / n;
            var ty2 = -(a1 * this.ty - b1 * tx1) / n;
            return out.setTo(a2 * out.x + c2 * out.y + tx2, b2 * out.x + d2 * out.y + ty2);
        }
        transformPoint(out) {
            return out.setTo(this.a * out.x + this.c * out.y + this.tx, this.b * out.x + this.d * out.y + this.ty);
        }
        transformPointN(out) {
            return out.setTo(this.a * out.x + this.c * out.y, this.b * out.x + this.d * out.y);
        }
        getScaleX() {
            return this.b === 0 ? this.a : Math.sqrt(this.a * this.a + this.b * this.b);
        }
        getScaleY() {
            return this.c === 0 ? this.d : Math.sqrt(this.c * this.c + this.d * this.d);
        }
        invert() {
            var a1 = this.a;
            var b1 = this.b;
            var c1 = this.c;
            var d1 = this.d;
            var tx1 = this.tx;
            var n = a1 * d1 - b1 * c1;
            this.a = d1 / n;
            this.b = -b1 / n;
            this.c = -c1 / n;
            this.d = a1 / n;
            this.tx = (c1 * this.ty - d1 * tx1) / n;
            this.ty = -(a1 * this.ty - b1 * tx1) / n;
            return this;
        }
        setTo(a, b, c, d, tx, ty) {
            this.a = a, this.b = b, this.c = c, this.d = d, this.tx = tx, this.ty = ty;
            return this;
        }
        concat(matrix) {
            var a = this.a;
            var c = this.c;
            var tx = this.tx;
            this.a = a * matrix.a + this.b * matrix.c;
            this.b = a * matrix.b + this.b * matrix.d;
            this.c = c * matrix.a + this.d * matrix.c;
            this.d = c * matrix.b + this.d * matrix.d;
            this.tx = tx * matrix.a + this.ty * matrix.c + matrix.tx;
            this.ty = tx * matrix.b + this.ty * matrix.d + matrix.ty;
            return this;
        }
        static mul(m1, m2, out) {
            var aa = m1.a, ab = m1.b, ac = m1.c, ad = m1.d, atx = m1.tx, aty = m1.ty;
            var ba = m2.a, bb = m2.b, bc = m2.c, bd = m2.d, btx = m2.tx, bty = m2.ty;
            if (bb !== 0 || bc !== 0) {
                out.a = aa * ba + ab * bc;
                out.b = aa * bb + ab * bd;
                out.c = ac * ba + ad * bc;
                out.d = ac * bb + ad * bd;
                out.tx = ba * atx + bc * aty + btx;
                out.ty = bb * atx + bd * aty + bty;
            }
            else {
                out.a = aa * ba;
                out.b = ab * bd;
                out.c = ac * ba;
                out.d = ad * bd;
                out.tx = ba * atx + btx;
                out.ty = bd * aty + bty;
            }
            return out;
        }
        static mul16(m1, m2, out) {
            var aa = m1.a, ab = m1.b, ac = m1.c, ad = m1.d, atx = m1.tx, aty = m1.ty;
            var ba = m2.a, bb = m2.b, bc = m2.c, bd = m2.d, btx = m2.tx, bty = m2.ty;
            if (bb !== 0 || bc !== 0) {
                out[0] = aa * ba + ab * bc;
                out[1] = aa * bb + ab * bd;
                out[4] = ac * ba + ad * bc;
                out[5] = ac * bb + ad * bd;
                out[12] = ba * atx + bc * aty + btx;
                out[13] = bb * atx + bd * aty + bty;
            }
            else {
                out[0] = aa * ba;
                out[1] = ab * bd;
                out[4] = ac * ba;
                out[5] = ad * bd;
                out[12] = ba * atx + btx;
                out[13] = bd * aty + bty;
            }
            return out;
        }
        scaleEx(x, y) {
            var ba = this.a, bb = this.b, bc = this.c, bd = this.d;
            if (bb !== 0 || bc !== 0) {
                this.a = x * ba;
                this.b = x * bb;
                this.c = y * bc;
                this.d = y * bd;
            }
            else {
                this.a = x * ba;
                this.b = 0 * bd;
                this.c = 0 * ba;
                this.d = y * bd;
            }
            this._bTransform = true;
        }
        rotateEx(angle) {
            var cos = Math.cos(angle);
            var sin = Math.sin(angle);
            var ba = this.a, bb = this.b, bc = this.c, bd = this.d;
            if (bb !== 0 || bc !== 0) {
                this.a = cos * ba + sin * bc;
                this.b = cos * bb + sin * bd;
                this.c = -sin * ba + cos * bc;
                this.d = -sin * bb + cos * bd;
            }
            else {
                this.a = cos * ba;
                this.b = sin * bd;
                this.c = -sin * ba;
                this.d = cos * bd;
            }
            this._bTransform = true;
        }
        clone() {
            var dec = Matrix.create();
            dec.a = this.a;
            dec.b = this.b;
            dec.c = this.c;
            dec.d = this.d;
            dec.tx = this.tx;
            dec.ty = this.ty;
            dec._bTransform = this._bTransform;
            return dec;
        }
        copyTo(dec) {
            dec.a = this.a;
            dec.b = this.b;
            dec.c = this.c;
            dec.d = this.d;
            dec.tx = this.tx;
            dec.ty = this.ty;
            dec._bTransform = this._bTransform;
            return dec;
        }
        toString() {
            return this.a + "," + this.b + "," + this.c + "," + this.d + "," + this.tx + "," + this.ty;
        }
        destroy() {
            this.recover();
        }
        recover() {
            Pool.recover("Matrix", this.identity());
        }
        static create() {
            return Pool.getItemByClass("Matrix", Matrix);
        }
    }
    Matrix.EMPTY = new Matrix();
    Matrix.TEMP = new Matrix();
    Matrix._createFun = null;

    class Point {
        constructor(x = 0, y = 0) {
            this.x = x;
            this.y = y;
        }
        static create() {
            return Pool.getItemByClass("Point", Point);
        }
        setTo(x, y) {
            this.x = x;
            this.y = y;
            return this;
        }
        reset() {
            this.x = this.y = 0;
            return this;
        }
        recover() {
            Pool.recover("Point", this.reset());
        }
        distance(x, y) {
            return Math.sqrt((this.x - x) * (this.x - x) + (this.y - y) * (this.y - y));
        }
        toString() {
            return this.x + "," + this.y;
        }
        normalize() {
            var d = Math.sqrt(this.x * this.x + this.y * this.y);
            if (d > 0) {
                var id = 1.0 / d;
                this.x *= id;
                this.y *= id;
            }
        }
        copy(point) {
            return this.setTo(point.x, point.y);
        }
    }
    Point.TEMP = new Point();
    Point.EMPTY = new Point();

    class Rectangle {
        constructor(x = 0, y = 0, width = 0, height = 0) {
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
        }
        get right() {
            return this.x + this.width;
        }
        get bottom() {
            return this.y + this.height;
        }
        setTo(x, y, width, height) {
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
            return this;
        }
        reset() {
            this.x = this.y = this.width = this.height = 0;
            return this;
        }
        recover() {
            if (this == Rectangle.TEMP || this == Rectangle.EMPTY) {
                return;
            }
            Pool.recover("Rectangle", this.reset());
        }
        static create() {
            return Pool.getItemByClass("Rectangle", Rectangle);
        }
        copyFrom(source) {
            this.x = source.x;
            this.y = source.y;
            this.width = source.width;
            this.height = source.height;
            return this;
        }
        contains(x, y) {
            if (this.width <= 0 || this.height <= 0)
                return false;
            if (x >= this.x && x < this.right) {
                if (y >= this.y && y < this.bottom) {
                    return true;
                }
            }
            return false;
        }
        intersects(rect) {
            return !(rect.x > (this.x + this.width) || (rect.x + rect.width) < this.x || rect.y > (this.y + this.height) || (rect.y + rect.height) < this.y);
        }
        intersection(rect, out = null) {
            if (!this.intersects(rect))
                return null;
            out || (out = new Rectangle());
            out.x = Math.max(this.x, rect.x);
            out.y = Math.max(this.y, rect.y);
            out.width = Math.min(this.right, rect.right) - out.x;
            out.height = Math.min(this.bottom, rect.bottom) - out.y;
            return out;
        }
        union(source, out = null) {
            out || (out = new Rectangle());
            this.clone(out);
            if (source.width <= 0 || source.height <= 0)
                return out;
            out.addPoint(source.x, source.y);
            out.addPoint(source.right, source.bottom);
            return this;
        }
        clone(out = null) {
            out || (out = new Rectangle());
            out.x = this.x;
            out.y = this.y;
            out.width = this.width;
            out.height = this.height;
            return out;
        }
        toString() {
            return this.x + "," + this.y + "," + this.width + "," + this.height;
        }
        equals(rect) {
            if (!rect || rect.x !== this.x || rect.y !== this.y || rect.width !== this.width || rect.height !== this.height)
                return false;
            return true;
        }
        addPoint(x, y) {
            this.x > x && (this.width += this.x - x, this.x = x);
            this.y > y && (this.height += this.y - y, this.y = y);
            if (this.width < x - this.x)
                this.width = x - this.x;
            if (this.height < y - this.y)
                this.height = y - this.y;
            return this;
        }
        _getBoundPoints() {
            var rst = Rectangle._temB;
            rst.length = 0;
            if (this.width == 0 || this.height == 0)
                return rst;
            rst.push(this.x, this.y, this.x + this.width, this.y, this.x, this.y + this.height, this.x + this.width, this.y + this.height);
            return rst;
        }
        static _getBoundPointS(x, y, width, height, sp) {
            var rst = Rectangle._temA;
            rst.length = 0;
            if (width == 0 || height == 0)
                return rst;
            if (sp) {
                x *= sp.width;
                y *= sp.height;
                width *= sp.width;
                height *= sp.height;
            }
            rst.push(x, y, x + width, y, x, y + height, x + width, y + height);
            return rst;
        }
        static _getWrapRec(pointList, rst = null) {
            if (!pointList || pointList.length < 1)
                return rst ? rst.setTo(0, 0, 0, 0) : Rectangle.TEMP.setTo(0, 0, 0, 0);
            rst = rst ? rst : Rectangle.create();
            var i, len = pointList.length, minX, maxX, minY, maxY, tPoint = Point.TEMP;
            minX = minY = 99999;
            maxX = maxY = -minX;
            for (i = 0; i < len; i += 2) {
                tPoint.x = pointList[i];
                tPoint.y = pointList[i + 1];
                minX = minX < tPoint.x ? minX : tPoint.x;
                minY = minY < tPoint.y ? minY : tPoint.y;
                maxX = maxX > tPoint.x ? maxX : tPoint.x;
                maxY = maxY > tPoint.y ? maxY : tPoint.y;
            }
            return rst.setTo(minX, minY, maxX - minX, maxY - minY);
        }
        isEmpty() {
            if (this.width <= 0 || this.height <= 0)
                return true;
            return false;
        }
    }
    Rectangle.EMPTY = new Rectangle();
    Rectangle.TEMP = new Rectangle();
    Rectangle._temB = [];
    Rectangle._temA = [];

    class LayaGL {
    }

    exports.HDREncodeFormat = void 0;
    (function (HDREncodeFormat) {
        HDREncodeFormat[HDREncodeFormat["NONE"] = 0] = "NONE";
        HDREncodeFormat[HDREncodeFormat["RGBM"] = 1] = "RGBM";
        HDREncodeFormat[HDREncodeFormat["RGBD"] = 2] = "RGBD";
    })(exports.HDREncodeFormat || (exports.HDREncodeFormat = {}));

    exports.TextureFormat = void 0;
    (function (TextureFormat) {
        TextureFormat[TextureFormat["R8G8B8"] = 0] = "R8G8B8";
        TextureFormat[TextureFormat["R8G8B8A8"] = 1] = "R8G8B8A8";
        TextureFormat[TextureFormat["R5G6B5"] = 16] = "R5G6B5";
        TextureFormat[TextureFormat["Alpha8"] = 2] = "Alpha8";
        TextureFormat[TextureFormat["DXT1"] = 3] = "DXT1";
        TextureFormat[TextureFormat["DXT3"] = 29] = "DXT3";
        TextureFormat[TextureFormat["DXT5"] = 4] = "DXT5";
        TextureFormat[TextureFormat["ETC1RGB"] = 5] = "ETC1RGB";
        TextureFormat[TextureFormat["ETC2RGB"] = 6] = "ETC2RGB";
        TextureFormat[TextureFormat["ETC2RGBA"] = 7] = "ETC2RGBA";
        TextureFormat[TextureFormat["ETC2SRGB_Alpha8"] = 8] = "ETC2SRGB_Alpha8";
        TextureFormat[TextureFormat["ETC2SRGB"] = 28] = "ETC2SRGB";
        TextureFormat[TextureFormat["PVRTCRGB_2BPPV"] = 9] = "PVRTCRGB_2BPPV";
        TextureFormat[TextureFormat["PVRTCRGBA_2BPPV"] = 10] = "PVRTCRGBA_2BPPV";
        TextureFormat[TextureFormat["PVRTCRGB_4BPPV"] = 11] = "PVRTCRGB_4BPPV";
        TextureFormat[TextureFormat["PVRTCRGBA_4BPPV"] = 12] = "PVRTCRGBA_4BPPV";
        TextureFormat[TextureFormat["R32G32B32A32"] = 15] = "R32G32B32A32";
        TextureFormat[TextureFormat["R32G32B32"] = 30] = "R32G32B32";
        TextureFormat[TextureFormat["R16G16B16A16"] = 17] = "R16G16B16A16";
        TextureFormat[TextureFormat["R16G16B16"] = 31] = "R16G16B16";
        TextureFormat[TextureFormat["ASTC4x4"] = 18] = "ASTC4x4";
        TextureFormat[TextureFormat["ASTC4x4SRGB"] = 23] = "ASTC4x4SRGB";
        TextureFormat[TextureFormat["ASTC6x6"] = 19] = "ASTC6x6";
        TextureFormat[TextureFormat["ASTC6x6SRGB"] = 24] = "ASTC6x6SRGB";
        TextureFormat[TextureFormat["ASTC8x8"] = 20] = "ASTC8x8";
        TextureFormat[TextureFormat["ASTC8x8SRGB"] = 25] = "ASTC8x8SRGB";
        TextureFormat[TextureFormat["ASTC10x10"] = 21] = "ASTC10x10";
        TextureFormat[TextureFormat["ASTC10x10SRGB"] = 26] = "ASTC10x10SRGB";
        TextureFormat[TextureFormat["ASTC12x12"] = 22] = "ASTC12x12";
        TextureFormat[TextureFormat["ASTC12x12SRGB"] = 27] = "ASTC12x12SRGB";
        TextureFormat[TextureFormat["KTXTEXTURE"] = -1] = "KTXTEXTURE";
        TextureFormat[TextureFormat["PVRTEXTURE"] = -2] = "PVRTEXTURE";
    })(exports.TextureFormat || (exports.TextureFormat = {}));

    const ITEM_LAYOUT = 4;
    class Delegate {
        constructor() {
            this._flag = 0;
            this._items = [];
        }
        add(callback, target, args) {
            let arr = this._items;
            let index = arr.findIndex((value, index, arr) => value == callback && arr[index + 1] == target);
            if (index != -1) {
                arr[index + 2] = args;
                arr[index + 3] = 1;
            }
            else
                arr.push(callback, target, args, 1);
        }
        once(callback, target, args) {
            let arr = this._items;
            let index = arr.findIndex((value, index, arr) => value == callback && arr[index + 1] == target);
            if (index != -1) {
                arr[index + 2] = args;
                arr[index + 3] = 2;
            }
            else
                arr.push(callback, target, args, 2);
        }
        remove(callback, target) {
            let arr = this._items;
            let index = arr.findIndex((value, index, arr) => value == callback && arr[index + 1] == target);
            if (index != -1) {
                if (this._flag != 0) {
                    arr[index + 3] = 0;
                    this._flag = 2;
                }
                else
                    arr.splice(index, ITEM_LAYOUT);
            }
        }
        clear() {
            let arr = this._items;
            if (this._flag != 0) {
                arr.forEach((value, index, arr) => { if (index % ITEM_LAYOUT == 3)
                    arr[index] = 0; });
                this._flag = 2;
            }
            else {
                arr.length = 0;
            }
        }
        clearForTarget(target) {
            if (!target)
                return;
            let arr = this._items;
            if (this._flag != 0) {
                arr.forEach((value, index, arr) => { if ((index % ITEM_LAYOUT == 1) && arr[index] == target)
                    arr[index + 2] = 0; });
                this._flag = 2;
            }
            else {
                let i = arr.length - ITEM_LAYOUT;
                while (i >= 0) {
                    if (arr[i + 1] == target)
                        arr.splice(i, ITEM_LAYOUT);
                    i -= ITEM_LAYOUT;
                }
            }
        }
        get count() {
            return this._items.length / ITEM_LAYOUT;
        }
        invoke(...args) {
            if (this._flag != 0)
                return;
            this._flag = 1;
            let arr = this._items;
            let cnt = arr.length;
            for (let i = 0; i < cnt; i += ITEM_LAYOUT) {
                let fixedArgs = arr[i + 2];
                if (fixedArgs != null)
                    arr[i].call(arr[i + 1], ...fixedArgs, ...args);
                else
                    arr[i].call(arr[i + 1], ...args);
                if (arr[i + 3] == 2) {
                    arr[i + 3] = 0;
                    this._flag = 2;
                }
            }
            if (this._flag == 2) {
                let cnt = arr.length;
                let i = 0;
                while (i < cnt) {
                    if (arr[i + 3] == 0) {
                        arr.splice(i, ITEM_LAYOUT);
                        cnt -= ITEM_LAYOUT;
                        continue;
                    }
                    else
                        i += ITEM_LAYOUT;
                }
            }
            this._flag = 0;
        }
    }

    class Event {
        constructor() {
            this.touchId = 0;
            this.touchPos = new Point();
        }
        static isMouseEvent(type) {
            return MOUSE_EVENTS.has(type);
        }
        setTo(type, currentTarget, target) {
            this.type = type;
            this.currentTarget = currentTarget;
            this.target = target;
            return this;
        }
        stopPropagation() {
            this._stopped = true;
        }
        get touches() {
            return this._touches;
        }
        get button() {
            var _a, _b;
            return (_b = ((_a = this.nativeEvent) === null || _a === void 0 ? void 0 : _a.button)) !== null && _b !== void 0 ? _b : 0;
        }
        get altKey() {
            var _a;
            return (_a = this.nativeEvent) === null || _a === void 0 ? void 0 : _a.altKey;
        }
        get ctrlKey() {
            var _a;
            return (_a = this.nativeEvent) === null || _a === void 0 ? void 0 : _a.ctrlKey;
        }
        get shiftKey() {
            var _a;
            return (_a = this.nativeEvent) === null || _a === void 0 ? void 0 : _a.shiftKey;
        }
        get metaKey() {
            var _a;
            return (_a = this.nativeEvent) === null || _a === void 0 ? void 0 : _a.metaKey;
        }
        get key() {
            return this.nativeEvent.key;
        }
        get keyCode() {
            return this.nativeEvent.keyCode;
        }
        get charCode() {
            var _a;
            return (_a = this.nativeEvent) === null || _a === void 0 ? void 0 : _a.code;
        }
        get keyLocation() {
            if (this.nativeEvent)
                return this.nativeEvent.location || this.nativeEvent.keyLocation;
            else
                return 0;
        }
        get stageX() {
            return this.touchPos.x;
        }
        get stageY() {
            return this.touchPos.y;
        }
    }
    Event.EMPTY = new Event();
    Event.MOUSE_DOWN = "mousedown";
    Event.MOUSE_UP = "mouseup";
    Event.RIGHT_MOUSE_DOWN = "rightmousedown";
    Event.RIGHT_MOUSE_UP = "rightmouseup";
    Event.CLICK = "click";
    Event.RIGHT_CLICK = "rightclick";
    Event.MOUSE_MOVE = "mousemove";
    Event.MOUSE_OVER = "mouseover";
    Event.MOUSE_OUT = "mouseout";
    Event.MOUSE_WHEEL = "mousewheel";
    Event.ROLL_OVER = "mouseover";
    Event.ROLL_OUT = "mouseout";
    Event.DOUBLE_CLICK = "doubleclick";
    Event.MOUSE_DRAG = "mousedrag";
    Event.MOUSE_DRAG_END = "mousedragend";
    Event.DRAG_START = "dragstart";
    Event.DRAG_MOVE = "dragmove";
    Event.DRAG_END = "dragend";
    Event.KEY_DOWN = "keydown";
    Event.KEY_PRESS = "keypress";
    Event.KEY_UP = "keyup";
    Event.CHANGE = "change";
    Event.CHANGED = "changed";
    Event.WILL_RESIZE = "willResize";
    Event.RESIZE = "resize";
    Event.ADDED = "added";
    Event.REMOVED = "removed";
    Event.DISPLAY = "display";
    Event.UNDISPLAY = "undisplay";
    Event.ERROR = "error";
    Event.COMPLETE = "complete";
    Event.LOADED = "loaded";
    Event.READY = "ready";
    Event.PROGRESS = "progress";
    Event.INPUT = "input";
    Event.RENDER = "render";
    Event.OPEN = "open";
    Event.MESSAGE = "message";
    Event.CLOSE = "close";
    Event.FRAME = "enterframe";
    Event.ENTER = "enter";
    Event.SELECT = "select";
    Event.BLUR = "blur";
    Event.FOCUS = "focus";
    Event.VISIBILITY_CHANGE = "visibilitychange";
    Event.FOCUS_CHANGE = "focuschange";
    Event.PLAYED = "played";
    Event.PAUSED = "paused";
    Event.STOPPED = "stopped";
    Event.START = "start";
    Event.END = "end";
    Event.LINK = "link";
    Event.LABEL = "label";
    Event.FULL_SCREEN_CHANGE = "fullscreenchange";
    Event.DEVICE_LOST = "devicelost";
    Event.TRANSFORM_CHANGED = "transformchanged";
    Event.LAYERCHANGE = "layerChange";
    Event.staticMask = "staticMask";
    Event.TRIGGER_ENTER = "triggerenter";
    Event.TRIGGER_STAY = "triggerstay";
    Event.TRIGGER_EXIT = "triggerexit";
    Event.COLLISION_ENTER = "collisionenter";
    Event.COLLISION_STAY = "collisionstay";
    Event.COLLISION_EXIT = "collisionexit";
    Event.JOINT_BREAK = "jointbreak";
    const MOUSE_EVENTS = new Set([
        Event.MOUSE_DOWN, Event.MOUSE_UP, Event.MOUSE_MOVE, Event.CLICK, Event.RIGHT_CLICK, Event.DOUBLE_CLICK,
        Event.MOUSE_OVER, Event.MOUSE_OUT, Event.MOUSE_WHEEL
    ]);

    const eventPool = [];
    class EventDispatcher {
        onStartListeningToType(type) {
        }
        hasListener(type) {
            let listeners = this._events && this._events[type];
            return !!listeners && listeners.count > 0;
        }
        event(type, data) {
            let listeners = this._events && this._events[type];
            if (!listeners)
                return false;
            let ret = listeners.count > 0;
            if (Array.isArray(data))
                listeners.invoke(...data);
            else if (data !== undefined)
                listeners.invoke(data);
            else if (data === Event.EMPTY) {
                let ev = eventPool.length > 0 ? eventPool.pop() : new Event();
                listeners.invoke(ev.setTo(type, this, this));
                ev.target = ev.currentTarget = null;
                eventPool.push(ev);
            }
            else
                listeners.invoke();
            return ret;
        }
        on(type, caller, listener, args) {
            if (arguments.length == 2) {
                listener = caller;
                caller = null;
            }
            if (!this._events)
                this._events = {};
            let listeners = this._events[type];
            if (!listeners) {
                this.onStartListeningToType(type);
                this._events[type] = listeners = new Delegate();
            }
            listeners.add(listener, caller, args);
            return this;
        }
        once(type, caller, listener, args) {
            if (arguments.length == 2) {
                listener = caller;
                caller = null;
            }
            if (!this._events)
                this._events = {};
            let listeners = this._events[type];
            if (!listeners) {
                this.onStartListeningToType(type);
                this._events[type] = listeners = new Delegate();
            }
            listeners.once(listener, caller, args);
            return this;
        }
        off(type, caller, listener) {
            if (arguments.length == 2) {
                listener = caller;
                caller = null;
            }
            let listeners = this._events && this._events[type];
            if (listeners)
                listeners.remove(listener, caller);
            return this;
        }
        offAll(type) {
            if (type == null)
                this._events = null;
            else {
                let listeners = this._events && this._events[type];
                if (listeners)
                    listeners.clear();
            }
            return this;
        }
        offAllCaller(caller) {
            if (caller && this._events) {
                for (let type in this._events)
                    this._events[type].clearForTarget(caller);
            }
            return this;
        }
    }

    var _idCounter = 0;
    var _disposingCounter = 0;
    var _clearRetry = 0;
    class Resource extends EventDispatcher {
        constructor(managed) {
            super();
            this._cpuMemory = 0;
            this._gpuMemory = 0;
            this._id = 0;
            this._referenceCount = 0;
            this._id = ++_idCounter;
            this._destroyed = false;
            this._referenceCount = 0;
            if (managed == null || managed)
                Resource._idResourcesMap[this.id] = this;
            this.lock = false;
            this.destoryedImmediately = true;
        }
        static get cpuMemory() {
            return Resource._cpuMemory;
        }
        static get gpuMemory() {
            return Resource._gpuMemory;
        }
        static _addCPUMemory(size) {
            Resource._cpuMemory += size;
        }
        static _addGPUMemory(size) {
            Resource._gpuMemory += size;
        }
        static _addMemory(cpuSize, gpuSize) {
            Resource._cpuMemory += cpuSize;
            Resource._gpuMemory += gpuSize;
        }
        static destroyUnusedResources() {
            _disposingCounter = 0;
            _clearRetry = 0;
            if (!ILaya.loader.loading)
                Resource._destroyUnusedResources(true);
            else
                ILaya.timer.frameLoop(1, Resource, Resource._destroyUnusedResources);
        }
        static _destroyUnusedResources(force) {
            if (!force && ILaya.loader.loading)
                return;
            ILaya.timer.clear(Resource, Resource._destroyUnusedResources);
            let destroyCnt = 0;
            for (let k in Resource._idResourcesMap) {
                let res = Resource._idResourcesMap[k];
                if (!res.lock && res._referenceCount === 0) {
                    res.destroy();
                    destroyCnt++;
                }
            }
            if (Resource.DEBUG && destroyCnt > 0)
                console.debug(`destroyUnusedResources(${destroyCnt})`);
            if (destroyCnt > 0 && _clearRetry < 5) {
                _clearRetry++;
                ILaya.timer.frameLoop(1, Resource, Resource._destroyUnusedResources);
            }
        }
        get id() {
            return this._id;
        }
        get cpuMemory() {
            return this._cpuMemory;
        }
        get gpuMemory() {
            return this._gpuMemory;
        }
        get destroyed() {
            return this._destroyed;
        }
        get obsolute() {
            return this._obsolute;
        }
        set obsolute(value) {
            this._obsolute = value;
        }
        get referenceCount() {
            return this._referenceCount;
        }
        _setCPUMemory(value) {
            var offsetValue = value - this._cpuMemory;
            this._cpuMemory = value;
            Resource._addCPUMemory(offsetValue);
        }
        _setGPUMemory(value) {
            var offsetValue = value - this._gpuMemory;
            this._gpuMemory = value;
            Resource._addGPUMemory(offsetValue);
        }
        _setCreateURL(url, uuid) {
            this.url = url;
            this.uuid = uuid;
        }
        isCreateFromURL(url) {
            return this.uuid && url.length === this.uuid.length + 6 && url.endsWith(this.uuid)
                || this.url === url;
        }
        _addReference(count = 1) {
            this._referenceCount += count;
        }
        _removeReference(count = 1) {
            this._referenceCount -= count;
            if (_disposingCounter > 0 && this._referenceCount <= 0 && !this.lock && this.destoryedImmediately) {
                this.destroy();
            }
        }
        _clearReference() {
            this._referenceCount = 0;
        }
        _recoverResource() {
        }
        _disposeResource() {
        }
        _activeResource() {
        }
        destroy() {
            if (this._destroyed)
                return;
            this._destroyed = true;
            this.lock = false;
            _disposingCounter++;
            this._disposeResource();
            _disposingCounter--;
            this.offAll();
            delete Resource._idResourcesMap[this.id];
            if (this.url) {
                if (Resource.DEBUG)
                    console.debug(`destroy ${Object.getPrototypeOf(this).constructor.name} ${this.url}`);
                ILaya.loader.clearRes(this.url, this);
            }
        }
    }
    Resource._idResourcesMap = {};
    Resource._cpuMemory = 0;
    Resource._gpuMemory = 0;
    Resource.DEBUG = false;

    class BaseTexture extends Resource {
        constructor(width, height, format) {
            super();
            this._gammaSpace = false;
            this._width = width;
            this._height = height;
            this._format = format;
            this.destoryedImmediately = false;
            this.hdrEncodeFormat = exports.HDREncodeFormat.NONE;
        }
        get width() {
            return this._width;
        }
        set width(width) {
            this._width = width;
        }
        get height() {
            return this._height;
        }
        set height(height) {
            this._height = height;
        }
        get dimension() {
            return this._dimension;
        }
        get format() {
            return this._format;
        }
        get mipmap() {
            return this._texture.mipmap;
        }
        get mipmapCount() {
            return this._texture.mipmapCount;
        }
        get anisoLevel() {
            return this._texture.anisoLevel;
        }
        set anisoLevel(value) {
            this._texture.anisoLevel = value;
        }
        get filterMode() {
            return this._texture.filterMode;
        }
        set filterMode(value) {
            this._texture.filterMode = value;
        }
        get wrapModeU() {
            return this._texture.wrapU;
        }
        set wrapModeU(value) {
            this._texture.wrapU = value;
        }
        get wrapModeV() {
            return this._texture.wrapV;
        }
        set wrapModeV(value) {
            this._texture.wrapV = value;
        }
        get wrapModeW() {
            return this._texture.wrapW;
        }
        set wrapModeW(value) {
            this._texture.wrapW = value;
        }
        get compareMode() {
            return this._texture.compareMode;
        }
        set compareMode(value) {
            this._texture.compareMode = LayaGL.textureContext.setTextureCompareMode(this._texture, value);
        }
        get gammaCorrection() {
            return this._texture.gammaCorrection;
        }
        set baseMipmapLevel(value) {
            this._texture.baseMipmapLevel = value;
        }
        get baseMipmapLevel() {
            return this._texture.baseMipmapLevel;
        }
        set maxMipmapLevel(value) {
            this._texture.maxMipmapLevel = value;
        }
        get maxMipmapLevel() {
            return this._texture.maxMipmapLevel;
        }
        get gammaSpace() {
            return this._texture.useSRGBLoad || this._texture.gammaCorrection > 1;
        }
        gpuCompressFormat() {
            let format = this._format;
            switch (format) {
                case exports.TextureFormat.R8G8B8:
                case exports.TextureFormat.R8G8B8A8:
                case exports.TextureFormat.R16G16B16:
                case exports.TextureFormat.R16G16B16A16:
                case exports.TextureFormat.R32G32B32:
                case exports.TextureFormat.R32G32B32A32:
                case exports.TextureFormat.R5G6B5:
                case exports.TextureFormat.Alpha8:
                    return false;
                case exports.TextureFormat.DXT1:
                case exports.TextureFormat.DXT3:
                case exports.TextureFormat.DXT5:
                case exports.TextureFormat.ETC1RGB:
                case exports.TextureFormat.ETC2RGB:
                case exports.TextureFormat.ETC2RGBA:
                case exports.TextureFormat.ETC2SRGB_Alpha8:
                case exports.TextureFormat.ETC2SRGB:
                case exports.TextureFormat.PVRTCRGB_2BPPV:
                case exports.TextureFormat.PVRTCRGBA_2BPPV:
                case exports.TextureFormat.PVRTCRGB_4BPPV:
                case exports.TextureFormat.PVRTCRGBA_4BPPV:
                case exports.TextureFormat.ASTC4x4:
                case exports.TextureFormat.ASTC4x4SRGB:
                case exports.TextureFormat.ASTC6x6:
                case exports.TextureFormat.ASTC6x6SRGB:
                case exports.TextureFormat.ASTC8x8:
                case exports.TextureFormat.ASTC8x8SRGB:
                case exports.TextureFormat.ASTC10x10:
                case exports.TextureFormat.ASTC10x10SRGB:
                case exports.TextureFormat.ASTC12x12:
                case exports.TextureFormat.ASTC12x12SRGB:
                    return true;
                default:
                    return false;
            }
        }
        _getFormatByteCount() {
            switch (this._format) {
                case exports.TextureFormat.R8G8B8:
                    return 3;
                case exports.TextureFormat.R8G8B8A8:
                    return 4;
                case exports.TextureFormat.R5G6B5:
                    return 1;
                case exports.TextureFormat.Alpha8:
                    return 1;
                case exports.TextureFormat.R16G16B16A16:
                    return 2;
                case exports.TextureFormat.R32G32B32A32:
                    return 4;
                default:
                    throw "Texture2D: unknown format.";
            }
        }
        _getSource() {
            return this._texture.resource;
        }
        get defaultTexture() {
            throw "defaulte";
        }
        _disposeResource() {
            this._texture.dispose();
        }
    }

    class Byte {
        constructor(data = null) {
            this._xd_ = true;
            this._allocated_ = 8;
            this._pos_ = 0;
            this._length = 0;
            if (data) {
                this._u8d_ = new Uint8Array(data);
                this._d_ = new DataView(this._u8d_.buffer);
                this._length = this._d_.byteLength;
            }
            else {
                this._resizeBuffer(this._allocated_);
            }
        }
        static getSystemEndian() {
            if (!Byte._sysEndian) {
                var buffer = new ArrayBuffer(2);
                new DataView(buffer).setInt16(0, 256, true);
                Byte._sysEndian = (new Int16Array(buffer))[0] === 256 ? Byte.LITTLE_ENDIAN : Byte.BIG_ENDIAN;
            }
            return Byte._sysEndian;
        }
        get buffer() {
            var rstBuffer = this._d_.buffer;
            if (rstBuffer.byteLength === this._length)
                return rstBuffer;
            return rstBuffer.slice(0, this._length);
        }
        get endian() {
            return this._xd_ ? Byte.LITTLE_ENDIAN : Byte.BIG_ENDIAN;
        }
        set endian(value) {
            this._xd_ = (value === Byte.LITTLE_ENDIAN);
        }
        set length(value) {
            if (this._allocated_ < value)
                this._resizeBuffer(this._allocated_ = Math.floor(Math.max(value, this._allocated_ * 2)));
            else if (this._allocated_ > value)
                this._resizeBuffer(this._allocated_ = value);
            this._length = value;
        }
        get length() {
            return this._length;
        }
        _resizeBuffer(len) {
            try {
                var newByteView = new Uint8Array(len);
                if (this._u8d_ != null) {
                    if (this._u8d_.length <= len)
                        newByteView.set(this._u8d_);
                    else
                        newByteView.set(this._u8d_.subarray(0, len));
                }
                this._u8d_ = newByteView;
                this._d_ = new DataView(newByteView.buffer);
            }
            catch (err) {
                throw "Invalid typed array length:" + len;
            }
        }
        getString() {
            return this.readString();
        }
        readString() {
            return this._rUTF(this.getUint16());
        }
        getFloat32Array(start, len) {
            return this.readFloat32Array(start, len);
        }
        readFloat32Array(start, len) {
            var end = start + len;
            end = (end > this._length) ? this._length : end;
            var v = new Float32Array(this._d_.buffer.slice(start, end));
            this._pos_ = end;
            return v;
        }
        getUint8Array(start, len) {
            return this.readUint8Array(start, len);
        }
        readUint8Array(start, len) {
            var end = start + len;
            end = (end > this._length) ? this._length : end;
            var v = new Uint8Array(this._d_.buffer.slice(start, end));
            this._pos_ = end;
            return v;
        }
        getInt16Array(start, len) {
            return this.readInt16Array(start, len);
        }
        readInt16Array(start, len) {
            var end = start + len;
            end = (end > this._length) ? this._length : end;
            var v = new Int16Array(this._d_.buffer.slice(start, end));
            this._pos_ = end;
            return v;
        }
        getFloat32() {
            return this.readFloat32();
        }
        readFloat32() {
            if (this._pos_ + 4 > this._length)
                throw "getFloat32 error - Out of bounds";
            var v = this._d_.getFloat32(this._pos_, this._xd_);
            this._pos_ += 4;
            return v;
        }
        getFloat64() {
            return this.readFloat64();
        }
        readFloat64() {
            if (this._pos_ + 8 > this._length)
                throw "getFloat64 error - Out of bounds";
            var v = this._d_.getFloat64(this._pos_, this._xd_);
            this._pos_ += 8;
            return v;
        }
        writeFloat32(value) {
            this._ensureWrite(this._pos_ + 4);
            this._d_.setFloat32(this._pos_, value, this._xd_);
            this._pos_ += 4;
        }
        writeFloat64(value) {
            this._ensureWrite(this._pos_ + 8);
            this._d_.setFloat64(this._pos_, value, this._xd_);
            this._pos_ += 8;
        }
        getInt32() {
            return this.readInt32();
        }
        readInt32() {
            if (this._pos_ + 4 > this._length)
                throw "getInt32 error - Out of bounds";
            var float = this._d_.getInt32(this._pos_, this._xd_);
            this._pos_ += 4;
            return float;
        }
        getUint32() {
            return this.readUint32();
        }
        readUint32() {
            if (this._pos_ + 4 > this._length)
                throw "getUint32 error - Out of bounds";
            var v = this._d_.getUint32(this._pos_, this._xd_);
            this._pos_ += 4;
            return v;
        }
        writeInt32(value) {
            this._ensureWrite(this._pos_ + 4);
            this._d_.setInt32(this._pos_, value, this._xd_);
            this._pos_ += 4;
        }
        writeUint32(value) {
            this._ensureWrite(this._pos_ + 4);
            this._d_.setUint32(this._pos_, value, this._xd_);
            this._pos_ += 4;
        }
        getInt16() {
            return this.readInt16();
        }
        readInt16() {
            if (this._pos_ + 2 > this._length)
                throw "getInt16 error - Out of bounds";
            var us = this._d_.getInt16(this._pos_, this._xd_);
            this._pos_ += 2;
            return us;
        }
        getUint16() {
            return this.readUint16();
        }
        readUint16() {
            if (this._pos_ + 2 > this._length)
                throw "getUint16 error - Out of bounds";
            var us = this._d_.getUint16(this._pos_, this._xd_);
            this._pos_ += 2;
            return us;
        }
        writeUint16(value) {
            this._ensureWrite(this._pos_ + 2);
            this._d_.setUint16(this._pos_, value, this._xd_);
            this._pos_ += 2;
        }
        writeInt16(value) {
            this._ensureWrite(this._pos_ + 2);
            this._d_.setInt16(this._pos_, value, this._xd_);
            this._pos_ += 2;
        }
        getUint8() {
            return this.readUint8();
        }
        readUint8() {
            if (this._pos_ + 1 > this._length)
                throw "getUint8 error - Out of bounds";
            return this._u8d_[this._pos_++];
        }
        writeUint8(value) {
            this._ensureWrite(this._pos_ + 1);
            this._d_.setUint8(this._pos_, value);
            this._pos_++;
        }
        _getUInt8(pos) {
            return this._readUInt8(pos);
        }
        _readUInt8(pos) {
            return this._d_.getUint8(pos);
        }
        _getUint16(pos) {
            return this._readUint16(pos);
        }
        _readUint16(pos) {
            return this._d_.getUint16(pos, this._xd_);
        }
        _getMatrix() {
            return this._readMatrix();
        }
        _readMatrix() {
            var rst = new Matrix(this.getFloat32(), this.getFloat32(), this.getFloat32(), this.getFloat32(), this.getFloat32(), this.getFloat32());
            return rst;
        }
        _rUTF(len) {
            var max = this._pos_ + len, c, c2, c3, f = String.fromCharCode;
            var u = this._u8d_;
            var strs = [];
            var n = 0;
            strs.length = 1000;
            while (this._pos_ < max) {
                c = u[this._pos_++];
                if (c < 0x80) {
                    if (c != 0)
                        strs[n++] = f(c);
                }
                else if (c < 0xE0) {
                    strs[n++] = f(((c & 0x3F) << 6) | (u[this._pos_++] & 0x7F));
                }
                else if (c < 0xF0) {
                    c2 = u[this._pos_++];
                    strs[n++] = f(((c & 0x1F) << 12) | ((c2 & 0x7F) << 6) | (u[this._pos_++] & 0x7F));
                }
                else {
                    c2 = u[this._pos_++];
                    c3 = u[this._pos_++];
                    const _code = ((c & 0x0F) << 18) | ((c2 & 0x7F) << 12) | ((c3 & 0x7F) << 6) | (u[this._pos_++] & 0x7F);
                    if (_code >= 0x10000) {
                        const _offset = _code - 0x10000;
                        const _lead = 0xd800 | (_offset >> 10);
                        const _trail = 0xdc00 | (_offset & 0x3ff);
                        strs[n++] = f(_lead);
                        strs[n++] = f(_trail);
                    }
                    else {
                        strs[n++] = f(_code);
                    }
                }
            }
            strs.length = n;
            return strs.join('');
        }
        getCustomString(len) {
            return this.readCustomString(len);
        }
        readCustomString(len) {
            var v = "", ulen = 0, c, c2, f = String.fromCharCode;
            var u = this._u8d_;
            while (len > 0) {
                c = u[this._pos_];
                if (c < 0x80) {
                    v += f(c);
                    this._pos_++;
                    len--;
                }
                else {
                    ulen = c - 0x80;
                    this._pos_++;
                    len -= ulen;
                    while (ulen > 0) {
                        c = u[this._pos_++];
                        c2 = u[this._pos_++];
                        v += f((c2 << 8) | c);
                        ulen--;
                    }
                }
            }
            return v;
        }
        get pos() {
            return this._pos_;
        }
        set pos(value) {
            this._pos_ = value;
        }
        get bytesAvailable() {
            return this._length - this._pos_;
        }
        clear() {
            this._pos_ = 0;
            this.length = 0;
        }
        __getBuffer() {
            return this._d_.buffer;
        }
        writeUTFBytes(value) {
            value = value + "";
            for (var i = 0, sz = value.length; i < sz; i++) {
                var c = value.charCodeAt(i);
                if (c <= 0x7F) {
                    this.writeByte(c);
                }
                else if (c <= 0x7FF) {
                    this._ensureWrite(this._pos_ + 2);
                    this._u8d_.set([0xC0 | (c >> 6), 0x80 | (c & 0x3F)], this._pos_);
                    this._pos_ += 2;
                }
                else if (c >= 0xD800 && c <= 0xDBFF) {
                    i++;
                    const c2 = value.charCodeAt(i);
                    if (!Number.isNaN(c2) && c2 >= 0xDC00 && c2 <= 0xDFFF) {
                        const _p1 = (c & 0x3FF) + 0x40;
                        const _p2 = c2 & 0x3FF;
                        const _b1 = 0xF0 | ((_p1 >> 8) & 0x3F);
                        const _b2 = 0x80 | ((_p1 >> 2) & 0x3F);
                        const _b3 = 0x80 | ((_p1 & 0x3) << 4) | ((_p2 >> 6) & 0xF);
                        const _b4 = 0x80 | (_p2 & 0x3F);
                        this._ensureWrite(this._pos_ + 4);
                        this._u8d_.set([_b1, _b2, _b3, _b4], this._pos_);
                        this._pos_ += 4;
                    }
                }
                else if (c <= 0xFFFF) {
                    this._ensureWrite(this._pos_ + 3);
                    this._u8d_.set([0xE0 | (c >> 12), 0x80 | ((c >> 6) & 0x3F), 0x80 | (c & 0x3F)], this._pos_);
                    this._pos_ += 3;
                }
                else {
                    this._ensureWrite(this._pos_ + 4);
                    this._u8d_.set([0xF0 | (c >> 18), 0x80 | ((c >> 12) & 0x3F), 0x80 | ((c >> 6) & 0x3F), 0x80 | (c & 0x3F)], this._pos_);
                    this._pos_ += 4;
                }
            }
        }
        writeUTFString(value) {
            var tPos = this.pos;
            this.writeUint16(1);
            this.writeUTFBytes(value);
            var dPos = this.pos - tPos - 2;
            this._d_.setUint16(tPos, dPos, this._xd_);
        }
        writeUTFString32(value) {
            var tPos = this.pos;
            this.writeUint32(1);
            this.writeUTFBytes(value);
            var dPos = this.pos - tPos - 4;
            this._d_.setUint32(tPos, dPos, this._xd_);
        }
        readUTFString() {
            return this.readUTFBytes(this.getUint16());
        }
        readUTFString32() {
            return this.readUTFBytes(this.getUint32());
        }
        getUTFString() {
            return this.readUTFString();
        }
        readUTFBytes(len = -1) {
            if (len === 0)
                return "";
            var lastBytes = this.bytesAvailable;
            if (len > lastBytes)
                throw "readUTFBytes error - Out of bounds";
            len = len > 0 ? len : lastBytes;
            return this._rUTF(len);
        }
        getUTFBytes(len = -1) {
            return this.readUTFBytes(len);
        }
        writeByte(value) {
            this._ensureWrite(this._pos_ + 1);
            this._d_.setInt8(this._pos_, value);
            this._pos_ += 1;
        }
        readByte() {
            if (this._pos_ + 1 > this._length)
                throw "readByte error - Out of bounds";
            return this._d_.getInt8(this._pos_++);
        }
        getByte() {
            return this.readByte();
        }
        _ensureWrite(lengthToEnsure) {
            if (this._length < lengthToEnsure)
                this._length = lengthToEnsure;
            if (this._allocated_ < lengthToEnsure)
                this.length = lengthToEnsure;
        }
        writeArrayBuffer(arraybuffer, offset = 0, length = 0) {
            if (offset < 0 || length < 0)
                throw "writeArrayBuffer error - Out of bounds";
            if (length == 0)
                length = arraybuffer.byteLength - offset;
            this._ensureWrite(this._pos_ + length);
            var uint8array = new Uint8Array(arraybuffer);
            this._u8d_.set(uint8array.subarray(offset, offset + length), this._pos_);
            this._pos_ += length;
        }
        readArrayBuffer(length) {
            var rst;
            rst = this._u8d_.buffer.slice(this._pos_, this._pos_ + length);
            this._pos_ = this._pos_ + length;
            return rst;
        }
    }
    Byte.BIG_ENDIAN = "bigEndian";
    Byte.LITTLE_ENDIAN = "littleEndian";
    Byte._sysEndian = null;

    class HalfFloatUtils {
        static __init__() {
            for (var i = 0; i < 256; ++i) {
                var e = i - 127;
                if (e < -27) {
                    HalfFloatUtils._baseTable[i | 0x000] = 0x0000;
                    HalfFloatUtils._baseTable[i | 0x100] = 0x8000;
                    HalfFloatUtils._shiftTable[i | 0x000] = 24;
                    HalfFloatUtils._shiftTable[i | 0x100] = 24;
                }
                else if (e < -14) {
                    HalfFloatUtils._baseTable[i | 0x000] = 0x0400 >> (-e - 14);
                    HalfFloatUtils._baseTable[i | 0x100] = (0x0400 >> (-e - 14)) | 0x8000;
                    HalfFloatUtils._shiftTable[i | 0x000] = -e - 1;
                    HalfFloatUtils._shiftTable[i | 0x100] = -e - 1;
                }
                else if (e <= 15) {
                    HalfFloatUtils._baseTable[i | 0x000] = (e + 15) << 10;
                    HalfFloatUtils._baseTable[i | 0x100] = ((e + 15) << 10) | 0x8000;
                    HalfFloatUtils._shiftTable[i | 0x000] = 13;
                    HalfFloatUtils._shiftTable[i | 0x100] = 13;
                }
                else if (e < 128) {
                    HalfFloatUtils._baseTable[i | 0x000] = 0x7c00;
                    HalfFloatUtils._baseTable[i | 0x100] = 0xfc00;
                    HalfFloatUtils._shiftTable[i | 0x000] = 24;
                    HalfFloatUtils._shiftTable[i | 0x100] = 24;
                }
                else {
                    HalfFloatUtils._baseTable[i | 0x000] = 0x7c00;
                    HalfFloatUtils._baseTable[i | 0x100] = 0xfc00;
                    HalfFloatUtils._shiftTable[i | 0x000] = 13;
                    HalfFloatUtils._shiftTable[i | 0x100] = 13;
                }
            }
            HalfFloatUtils._mantissaTable[0] = 0;
            for (i = 1; i < 1024; ++i) {
                var m = i << 13;
                e = 0;
                while ((m & 0x00800000) === 0) {
                    e -= 0x00800000;
                    m <<= 1;
                }
                m &= ~0x00800000;
                e += 0x38800000;
                HalfFloatUtils._mantissaTable[i] = m | e;
            }
            for (i = 1024; i < 2048; ++i) {
                HalfFloatUtils._mantissaTable[i] = 0x38000000 + ((i - 1024) << 13);
            }
            HalfFloatUtils._exponentTable[0] = 0;
            for (i = 1; i < 31; ++i) {
                HalfFloatUtils._exponentTable[i] = i << 23;
            }
            HalfFloatUtils._exponentTable[31] = 0x47800000;
            HalfFloatUtils._exponentTable[32] = 0x80000000;
            for (i = 33; i < 63; ++i) {
                HalfFloatUtils._exponentTable[i] = 0x80000000 + ((i - 32) << 23);
            }
            HalfFloatUtils._exponentTable[63] = 0xc7800000;
            HalfFloatUtils._offsetTable[0] = 0;
            for (i = 1; i < 64; ++i) {
                if (i === 32) {
                    HalfFloatUtils._offsetTable[i] = 0;
                }
                else {
                    HalfFloatUtils._offsetTable[i] = 1024;
                }
            }
        }
        static roundToFloat16Bits(num) {
            HalfFloatUtils._floatView[0] = num;
            var f = HalfFloatUtils._uint32View[0];
            var e = (f >> 23) & 0x1ff;
            return HalfFloatUtils._baseTable[e] + ((f & 0x007fffff) >> HalfFloatUtils._shiftTable[e]);
        }
        static convertToNumber(float16bits) {
            var m = float16bits >> 10;
            HalfFloatUtils._uint32View[0] = HalfFloatUtils._mantissaTable[HalfFloatUtils._offsetTable[m] + (float16bits & 0x3ff)] + HalfFloatUtils._exponentTable[m];
            return HalfFloatUtils._floatView[0];
        }
    }
    HalfFloatUtils._buffer = new ArrayBuffer(4);
    HalfFloatUtils._floatView = new Float32Array(HalfFloatUtils._buffer);
    HalfFloatUtils._uint32View = new Uint32Array(HalfFloatUtils._buffer);
    HalfFloatUtils._baseTable = new Uint32Array(512);
    HalfFloatUtils._shiftTable = new Uint32Array(512);
    HalfFloatUtils._mantissaTable = new Uint32Array(2048);
    HalfFloatUtils._exponentTable = new Uint32Array(64);
    HalfFloatUtils._offsetTable = new Uint32Array(64);

    exports.FilterMode = void 0;
    (function (FilterMode) {
        FilterMode[FilterMode["Point"] = 0] = "Point";
        FilterMode[FilterMode["Bilinear"] = 1] = "Bilinear";
        FilterMode[FilterMode["Trilinear"] = 2] = "Trilinear";
    })(exports.FilterMode || (exports.FilterMode = {}));

    exports.RenderCapable = void 0;
    (function (RenderCapable) {
        RenderCapable[RenderCapable["Element_Index_Uint32"] = 0] = "Element_Index_Uint32";
        RenderCapable[RenderCapable["TextureFormat_R32G32B32A32"] = 1] = "TextureFormat_R32G32B32A32";
        RenderCapable[RenderCapable["TextureFormat_R16G16B16A16"] = 2] = "TextureFormat_R16G16B16A16";
        RenderCapable[RenderCapable["Texture_anisotropic"] = 3] = "Texture_anisotropic";
        RenderCapable[RenderCapable["RenderTextureFormat_R16G16B16A16"] = 4] = "RenderTextureFormat_R16G16B16A16";
        RenderCapable[RenderCapable["RenderTextureFormat_Depth"] = 5] = "RenderTextureFormat_Depth";
        RenderCapable[RenderCapable["RenderTextureFormat_ShadowMap"] = 6] = "RenderTextureFormat_ShadowMap";
        RenderCapable[RenderCapable["Vertex_VAO"] = 7] = "Vertex_VAO";
        RenderCapable[RenderCapable["DrawElement_Instance"] = 8] = "DrawElement_Instance";
        RenderCapable[RenderCapable["Shader_TextureLod"] = 9] = "Shader_TextureLod";
        RenderCapable[RenderCapable["COMPRESS_TEXTURE_S3TC"] = 10] = "COMPRESS_TEXTURE_S3TC";
        RenderCapable[RenderCapable["COMPRESS_TEXTURE_S3TC_SRGB"] = 11] = "COMPRESS_TEXTURE_S3TC_SRGB";
        RenderCapable[RenderCapable["COMPRESS_TEXTURE_PVRTC"] = 12] = "COMPRESS_TEXTURE_PVRTC";
        RenderCapable[RenderCapable["COMPRESS_TEXTURE_ETC1"] = 13] = "COMPRESS_TEXTURE_ETC1";
        RenderCapable[RenderCapable["COMPRESS_TEXTURE_ETC"] = 14] = "COMPRESS_TEXTURE_ETC";
        RenderCapable[RenderCapable["COMPRESS_TEXTURE_ASTC"] = 15] = "COMPRESS_TEXTURE_ASTC";
        RenderCapable[RenderCapable["Texture_SRGB"] = 16] = "Texture_SRGB";
        RenderCapable[RenderCapable["MSAA"] = 17] = "MSAA";
        RenderCapable[RenderCapable["UnifromBufferObject"] = 18] = "UnifromBufferObject";
        RenderCapable[RenderCapable["GRAPHICS_API_GLES3"] = 19] = "GRAPHICS_API_GLES3";
    })(exports.RenderCapable || (exports.RenderCapable = {}));

    const FOURCC_DXT1 = 827611204;
    const FOURCC_DXT3 = 861165636;
    const FOURCC_DXT5 = 894720068;
    const DDPF_FOURCC = 0x4;
    const DDPF_RGB = 0x40;
    const DDSCAPS2_CUBEMAP = 0x200;
    const DDPF_LUMINANCE = 0x20000;
    const DDSD_MIPMAPCOUNT = 0x20000;
    const DDS_MAGIC = 0x20534444;
    const DDS_HEADER_LENGTH = 31;
    const DDS_HEADER_MAGIC = 0;
    const DDS_HEADER_SIZE = 1;
    const DDS_HEADER_FLAGS = 2;
    const DDS_HEADER_HEIGHT = 3;
    const DDS_HEADER_WIDTH = 4;
    const DDS_HEADER_MIPMAPCOUNT = 7;
    const DDS_HEADER_PF_FLAGS = 20;
    const DDS_HEADER_PF_FOURCC = 21;
    const DDS_HEADER_PF_CAPS2 = 28;
    const FOURCC_D3DFMT_R16G16B16A16F = 113;
    const FOURCC_D3DFMT_R32G32B32A32F = 116;
    const Int32ToFourCC = (value) => {
        return String.fromCharCode(value & 0xff, (value >> 8) & 0xff, (value >> 16) & 0xff, (value >> 24) & 0xff);
    };
    class DDSTextureInfo {
        constructor(width, height, mipmapCount, isCube, bpp, blockBytes, dataOffset, format, compressed, sourceData) {
            this.width = width;
            this.height = height;
            this.mipmapCount = mipmapCount;
            this.isCube = isCube;
            this.blockBytes = blockBytes;
            this.dataOffset = dataOffset;
            this.format = format;
            this.source = sourceData;
            this.bpp = bpp;
            this.compressed = compressed;
        }
        static getDDSTextureInfo(source) {
            let header = new Int32Array(source, 0, DDS_HEADER_LENGTH);
            let width = header[DDS_HEADER_WIDTH];
            let height = header[DDS_HEADER_HEIGHT];
            let mipmapCount = 1;
            if (header[DDS_HEADER_FLAGS] & DDSD_MIPMAPCOUNT) {
                mipmapCount = Math.max(1, header[DDS_HEADER_MIPMAPCOUNT]);
            }
            let fourCC = header[DDS_HEADER_PF_FOURCC];
            let isFourCC = (header[DDS_HEADER_PF_FLAGS] & DDPF_FOURCC) === DDPF_FOURCC;
            let isRGB = (header[DDS_HEADER_PF_FLAGS] & DDPF_RGB) === DDPF_RGB;
            let isLuminance = (header[DDS_HEADER_PF_FLAGS] & DDPF_LUMINANCE) === DDPF_LUMINANCE;
            let isCube = (header[DDS_HEADER_PF_CAPS2] & DDSCAPS2_CUBEMAP) === DDSCAPS2_CUBEMAP;
            let isCompressed = (fourCC === FOURCC_DXT1 || fourCC === FOURCC_DXT3 || fourCC === FOURCC_DXT5);
            let layaTexFormat = exports.TextureFormat.DXT1;
            let dataOffset = header[DDS_HEADER_SIZE] + 4;
            let blockBytes = 1;
            switch (fourCC) {
                case FOURCC_DXT1:
                    layaTexFormat = exports.TextureFormat.DXT1;
                    blockBytes = 8;
                    break;
                case FOURCC_DXT3:
                    layaTexFormat = exports.TextureFormat.DXT3;
                    blockBytes = 16;
                    break;
                case FOURCC_DXT5:
                    layaTexFormat = exports.TextureFormat.DXT5;
                    blockBytes = 16;
                    break;
                case FOURCC_D3DFMT_R16G16B16A16F:
                    layaTexFormat = exports.TextureFormat.R16G16B16A16;
                    blockBytes = 4;
                    break;
                case FOURCC_D3DFMT_R32G32B32A32F:
                    layaTexFormat = exports.TextureFormat.R32G32B32A32;
                    blockBytes = 4;
                    break;
                default:
                    throw "Unsupported format " + Int32ToFourCC(fourCC);
            }
            if (header[DDS_HEADER_MAGIC] !== DDS_MAGIC) {
                throw "Invalid magic number in DDS header";
            }
            if (!isFourCC && !isRGB && !isLuminance) {
                throw "Unsupported format, must contain a FourCC, RGB or LUMINANCE code";
            }
            let ext = LayaGL.renderEngine.getCapable(exports.RenderCapable.COMPRESS_TEXTURE_S3TC) || LayaGL.renderEngine.getCapable(exports.RenderCapable.COMPRESS_TEXTURE_S3TC_SRGB);
            if (isCompressed && !ext) {
                throw "Compressed textures are not supported on this platform.";
            }
            return new DDSTextureInfo(width, height, mipmapCount, isCube, 0, blockBytes, dataOffset, layaTexFormat, isCompressed, source);
        }
    }

    exports.TextureDimension = void 0;
    (function (TextureDimension) {
        TextureDimension[TextureDimension["Tex2D"] = 0] = "Tex2D";
        TextureDimension[TextureDimension["Cube"] = 1] = "Cube";
        TextureDimension[TextureDimension["Tex3D"] = 2] = "Tex3D";
        TextureDimension[TextureDimension["Texture2DArray"] = 3] = "Texture2DArray";
        TextureDimension[TextureDimension["CubeArray"] = 4] = "CubeArray";
        TextureDimension[TextureDimension["Unkonw"] = 5] = "Unkonw";
        TextureDimension[TextureDimension["None"] = 6] = "None";
    })(exports.TextureDimension || (exports.TextureDimension = {}));

    const IdentifierByteSize = 12;
    const HeaderSize = 13;
    const COMPRESSED_RGB_ETC1_WEBGL = 36196;
    const COMPRESSED_RGB8_ETC2 = 37492;
    const COMPRESSED_RGBA8_ETC2_EAC = 37496;
    const COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 37497;
    const COMPRESSED_SRGB8_ETC2 = 37493;
    const COMPRESSED_RGBA_ASTC_4x4_KHR = 37808;
    const COMPRESSED_RGBA_ASTC_6x6_KHR = 37812;
    const COMPRESSED_RGBA_ASTC_8x8_KHR = 37815;
    const COMPRESSED_RGBA_ASTC_10x10_KHR = 37819;
    const COMPRESSED_RGBA_ASTC_12x12_KHR = 37821;
    const COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR = 37840;
    const COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR = 37844;
    const COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR = 37847;
    const COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR = 37851;
    const COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR = 37853;
    const GL_FORMAT_RGBA = 6408;
    const GL_FORMAT_RGB = 6407;
    const GL_FORMAT_RGBA32F = 0x8814;
    const GL_FORMAT_RGB32F = 0x8815;
    const GL_FORMAT_RGBA16F = 0x881A;
    const GL_FORMAT_RGB16F = 0x881B;
    const GL_FORMAT_SRGB8 = 0x8C41;
    const GL_INTERNALFORMAT_RGBA8 = 0x8058;
    const GL_INTERNALFORMAT_RGB8 = 0x8051;
    const GL_INTERNALFORMAT_SRGB8_ALPHA8 = 0x8C43;
    const GL_DATATYPE_UNSIGNED_BYTE = 0x1401;
    const GL_DATATYPE_FLOAT = 0x1406;
    const GL_DATATYPE_HALF_FLOAT = 0x140b;
    class KTXTextureInfo {
        constructor(source, compress, sRGB, dimension, width, height, format, mipmapCount, bytesOfKeyValueData, headerOffset) {
            this.source = source;
            this.compress = compress;
            this.sRGB = sRGB;
            this.dimension = dimension;
            this.width = width;
            this.height = height;
            this.format = format;
            this.mipmapCount = mipmapCount;
            this.bytesOfKeyValueData = bytesOfKeyValueData;
            this.headerOffset = headerOffset;
        }
        static getLayaFormat(glFormat, glInternalFormat, glType, glTypeSize) {
            if (glFormat == 0) {
                switch (glInternalFormat) {
                    case COMPRESSED_RGB_ETC1_WEBGL:
                        return { format: exports.TextureFormat.ETC1RGB, sRGB: false };
                    case COMPRESSED_RGBA8_ETC2_EAC:
                        return { format: exports.TextureFormat.ETC2RGBA, sRGB: false };
                    case COMPRESSED_RGB8_ETC2:
                        return { format: exports.TextureFormat.ETC2RGB, sRGB: false };
                    case COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:
                        return { format: exports.TextureFormat.ETC2SRGB_Alpha8, sRGB: true };
                    case COMPRESSED_SRGB8_ETC2:
                        return { format: exports.TextureFormat.ETC2SRGB, sRGB: true };
                    case COMPRESSED_RGBA_ASTC_4x4_KHR:
                        return { format: exports.TextureFormat.ASTC4x4, sRGB: false };
                    case COMPRESSED_RGBA_ASTC_6x6_KHR:
                        return { format: exports.TextureFormat.ASTC6x6, sRGB: false };
                    case COMPRESSED_RGBA_ASTC_8x8_KHR:
                        return { format: exports.TextureFormat.ASTC8x8, sRGB: false };
                    case COMPRESSED_RGBA_ASTC_10x10_KHR:
                        return { format: exports.TextureFormat.ASTC10x10, sRGB: false };
                    case COMPRESSED_RGBA_ASTC_12x12_KHR:
                        return { format: exports.TextureFormat.ASTC12x12, sRGB: false };
                    case COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:
                        return { format: exports.TextureFormat.ASTC4x4SRGB, sRGB: true };
                    case COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:
                        return { format: exports.TextureFormat.ASTC6x6SRGB, sRGB: true };
                    case COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:
                        return { format: exports.TextureFormat.ASTC8x8SRGB, sRGB: true };
                    case COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:
                        return { format: exports.TextureFormat.ASTC10x10SRGB, sRGB: true };
                    case COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:
                        return { format: exports.TextureFormat.ASTC12x12SRGB, sRGB: true };
                    default:
                        throw "KTX: UnSupported Compressed format.";
                }
            }
            else {
                if (glFormat == GL_FORMAT_RGBA && glInternalFormat == GL_INTERNALFORMAT_RGBA8 && glType == GL_DATATYPE_UNSIGNED_BYTE) {
                    return { format: exports.TextureFormat.R8G8B8A8, sRGB: false };
                }
                else if (glFormat == GL_FORMAT_RGBA && glInternalFormat == GL_INTERNALFORMAT_SRGB8_ALPHA8 && glType == GL_DATATYPE_UNSIGNED_BYTE) {
                    return { format: exports.TextureFormat.R8G8B8A8, sRGB: true };
                }
                else if (glFormat == GL_FORMAT_RGBA && glInternalFormat == GL_FORMAT_RGBA32F && glType == GL_DATATYPE_FLOAT) {
                    return { format: exports.TextureFormat.R32G32B32A32, sRGB: false };
                }
                else if (glFormat == GL_FORMAT_RGBA && glInternalFormat == GL_FORMAT_RGBA16F && glType == GL_DATATYPE_HALF_FLOAT) {
                    return { format: exports.TextureFormat.R16G16B16A16, sRGB: false };
                }
                else if (glFormat == GL_FORMAT_RGB && glInternalFormat == GL_FORMAT_RGB32F && glType == GL_DATATYPE_FLOAT) {
                    return { format: exports.TextureFormat.R32G32B32, sRGB: false };
                }
                else if (glFormat == GL_FORMAT_RGB && glInternalFormat == GL_FORMAT_RGB16F && glType == GL_DATATYPE_HALF_FLOAT) {
                    return { format: exports.TextureFormat.R16G16B16, sRGB: false };
                }
                else if (glFormat == GL_FORMAT_RGB && glInternalFormat == GL_FORMAT_SRGB8 && glType == GL_DATATYPE_UNSIGNED_BYTE) {
                    return { format: exports.TextureFormat.R8G8B8, sRGB: true };
                }
                else if (glFormat == GL_FORMAT_RGB && glInternalFormat == GL_INTERNALFORMAT_RGB8 && glType == GL_DATATYPE_UNSIGNED_BYTE) {
                    return { format: exports.TextureFormat.R8G8B8, sRGB: false };
                }
                else {
                    throw "ktx: Unsupported UnCompressed image data.";
                }
            }
        }
        static getKTXTextureInfo(source) {
            let FileIdentifier = new Uint8Array(source, 0, 12);
            if (FileIdentifier[0] === 0xAB && FileIdentifier[1] === 0x4B && FileIdentifier[2] === 0x54 && FileIdentifier[3] === 0x58 && FileIdentifier[4] === 0x20 && FileIdentifier[5] === 0x32 && FileIdentifier[6] === 0x30 && FileIdentifier[7] === 0xBB && FileIdentifier[8] === 0x0D && FileIdentifier[9] === 0x0A && FileIdentifier[10] === 0x1A && FileIdentifier[11] === 0x0A) {
                throw "ktx2 !";
            }
            else if (FileIdentifier[0] === 0xAB && FileIdentifier[1] === 0x4B && FileIdentifier[2] === 0x54 && FileIdentifier[3] === 0x58 && FileIdentifier[4] === 0x20 && FileIdentifier[5] === 0x31 && FileIdentifier[6] === 0x31 && FileIdentifier[7] === 0xBB && FileIdentifier[8] === 0x0D && FileIdentifier[9] === 0x0A && FileIdentifier[10] === 0x1A && FileIdentifier[11] === 0x0A) {
                return KTXTextureInfo.createKTX1Info(source);
            }
            else {
                throw "ktx data wrong, not ktx1 or ktx2 buffer!";
            }
        }
        static createKTX1Info(source) {
            let dataSize = Uint32Array.BYTES_PER_ELEMENT;
            let headerDataView = new DataView(source, IdentifierByteSize, dataSize * HeaderSize);
            let endianness = headerDataView.getUint32(0, true);
            let littleEndian = endianness == 0x04030201;
            let glType = headerDataView.getUint32(1 * dataSize, littleEndian);
            let glTypeSize = headerDataView.getUint32(2 * dataSize, littleEndian);
            let glFormat = headerDataView.getUint32(3 * dataSize, littleEndian);
            let glInternalFormat = headerDataView.getUint32(4 * dataSize, littleEndian);
            headerDataView.getUint32(5 * dataSize, littleEndian);
            let pixelWidth = headerDataView.getUint32(6 * dataSize, littleEndian);
            let pixelHeight = headerDataView.getUint32(7 * dataSize, littleEndian);
            headerDataView.getUint32(8 * dataSize, littleEndian);
            let numberOfArrayElements = headerDataView.getUint32(9 * dataSize, littleEndian);
            let numberOfFaces = headerDataView.getUint32(10 * dataSize, littleEndian);
            let numberOfMipmapLevels = headerDataView.getUint32(11 * dataSize, littleEndian);
            let bytesOfKeyValueData = headerDataView.getUint32(12 * dataSize, littleEndian);
            let formatInfo = KTXTextureInfo.getLayaFormat(glFormat, glInternalFormat, glType, glTypeSize);
            let layaFormat = formatInfo.format;
            let sRGBData = formatInfo.sRGB;
            let layaDemision = exports.TextureDimension.Tex2D;
            if (numberOfFaces > 1 && numberOfArrayElements > 1) {
                layaDemision = exports.TextureDimension.CubeArray;
            }
            else if (numberOfFaces > 1 && numberOfArrayElements <= 1) {
                layaDemision = exports.TextureDimension.Cube;
            }
            else if (numberOfFaces <= 1 && numberOfArrayElements > 1) {
                layaDemision = exports.TextureDimension.Texture2DArray;
            }
            let headerOffset = IdentifierByteSize + HeaderSize * 4;
            return new KTXTextureInfo(source, glFormat == 0, sRGBData, layaDemision, pixelWidth, pixelHeight, layaFormat, numberOfMipmapLevels || 1, bytesOfKeyValueData, headerOffset);
        }
    }

    class LayaEnv {
    }
    LayaEnv.version = "3.0.0rc";
    LayaEnv.isPlaying = true;
    LayaEnv.isPreview = false;
    LayaEnv.isConch = window.conch != null;

    class Texture2D extends BaseTexture {
        constructor(width, height, format, mipmap = true, canRead, sRGB = false) {
            super(width, height, format);
            this._canRead = false;
            this._dimension = exports.TextureDimension.Tex2D;
            this._gammaSpace = sRGB;
            this._canRead = canRead;
            this._texture = LayaGL.textureContext.createTextureInternal(this._dimension, width, height, format, mipmap, sRGB);
            return;
        }
        static __init__() {
            var pixels = new Uint8Array(3);
            pixels[0] = 128;
            pixels[1] = 128;
            pixels[2] = 128;
            Texture2D.grayTexture = new Texture2D(1, 1, exports.TextureFormat.R8G8B8, false, false);
            Texture2D.grayTexture.setPixelsData(pixels, false, false);
            Texture2D.grayTexture.lock = true;
            pixels[0] = 255;
            pixels[1] = 255;
            pixels[2] = 255;
            Texture2D.whiteTexture = new Texture2D(1, 1, exports.TextureFormat.R8G8B8, false, false);
            Texture2D.whiteTexture.setPixelsData(pixels, false, false);
            Texture2D.whiteTexture.lock = true;
            pixels[0] = 0;
            pixels[1] = 0;
            pixels[2] = 0;
            Texture2D.blackTexture = new Texture2D(1, 1, exports.TextureFormat.R8G8B8, false, false);
            Texture2D.blackTexture.setPixelsData(pixels, false, false);
            Texture2D.blackTexture.lock = true;
            if (LayaGL.renderEngine.getCapable(exports.RenderCapable.TextureFormat_R16G16B16A16)) {
                let floatPixle = new Uint16Array(3);
                floatPixle[0] = 14336;
                floatPixle[1] = 14336;
                floatPixle[1] = 15360;
                Texture2D.normalTexture = new Texture2D(1, 1, exports.TextureFormat.R16G16B16, false, false, false);
                Texture2D.normalTexture.setPixelsData(floatPixle, false, false);
            }
            else {
                pixels[0] = 128;
                pixels[1] = 128;
                pixels[2] = 255;
                Texture2D.normalTexture = new Texture2D(1, 1, exports.TextureFormat.R8G8B8, false, false, false);
                Texture2D.normalTexture.setPixelsData(pixels, false, false);
            }
            Texture2D.normalTexture.lock = true;
            pixels = new Uint8Array(9);
            pixels[0] = 255;
            pixels[1] = 255;
            pixels[2] = 255;
            pixels[3] = 255;
            pixels[4] = 255;
            pixels[5] = 128;
            pixels[6] = 128;
            pixels[7] = 128;
            pixels[8] = 0;
            Texture2D.defalutUITexture = new Texture2D(1, 3, exports.TextureFormat.R8G8B8, false, false);
            Texture2D.defalutUITexture.setPixelsData(pixels, false, false);
            Texture2D.defalutUITexture.lock = true;
            Texture2D.erroTextur = Texture2D.whiteTexture;
        }
        static _SimpleAnimatorTextureParse(data, propertyParams = null, constructParams = null) {
            var byte = new Byte(data);
            var version = byte.readUTFString();
            var texture;
            var pixelDataArrays;
            var usePixelData;
            switch (version) {
                case "LAYAANIMATORTEXTURE:0000":
                    var textureWidth = byte.readInt32();
                    var pixelDataLength = byte.readInt32();
                    pixelDataArrays = new Float32Array(textureWidth * textureWidth * 4);
                    usePixelData = new Float32Array(byte.readArrayBuffer(pixelDataLength * 4));
                    pixelDataArrays.set(usePixelData, 0);
                    var texture = new Texture2D(textureWidth, textureWidth, exports.TextureFormat.R32G32B32A32, false, false);
                    texture.setPixelsData(pixelDataArrays, false, false);
                    texture.filterMode = exports.FilterMode.Point;
                    break;
                case "LAYACOMPRESSANIMATORTEXTURE:0000":
                    var textureWidth = byte.readInt32();
                    var pixelDataLength = byte.readInt32();
                    pixelDataArrays = new Uint16Array(byte.readArrayBuffer(pixelDataLength * 2));
                    if (!LayaGL.renderEngine.getCapable(exports.RenderCapable.TextureFormat_R16G16B16A16)) {
                        console.log("The platform does not support 16-bit floating-point textures");
                        if (!LayaGL.renderEngine.getCapable(exports.RenderCapable.TextureFormat_R32G32B32A32))
                            console.error("The platform does not support 32-bit floating-point textures");
                        usePixelData = new Float32Array(textureWidth * textureWidth * 4);
                        for (var i = 0, n = pixelDataArrays.length; i < n; i++) {
                            usePixelData[i] = HalfFloatUtils.convertToNumber(pixelDataArrays[i]);
                        }
                        texture = new Texture2D(textureWidth, textureWidth, exports.TextureFormat.R32G32B32A32, false, false);
                        texture.setPixelsData(usePixelData, false, false);
                        texture.filterMode = exports.FilterMode.Point;
                    }
                    else {
                        usePixelData = new Uint16Array(textureWidth * textureWidth * 4);
                        usePixelData.set(pixelDataArrays, 0);
                        texture = new Texture2D(textureWidth, textureWidth, exports.TextureFormat.R16G16B16A16, false, false);
                        texture.setPixelsData(usePixelData, false, false);
                        texture.filterMode = exports.FilterMode.Point;
                    }
                    break;
                default:
                    throw "Laya3D:unknow version.";
            }
            return texture;
        }
        static _parseImage(imageSource, propertyParams = null, constructParams = null) {
            let format = constructParams ? constructParams[2] : exports.TextureFormat.R8G8B8A8;
            let mipmap = constructParams ? constructParams[3] : true;
            let canread = constructParams ? constructParams[4] : false;
            let srgb = constructParams ? constructParams[5] : false;
            let texture = new Texture2D(imageSource.width, imageSource.height, format, mipmap, canread, srgb);
            if (propertyParams) {
                let pma = propertyParams.premultiplyAlpha;
                texture.setImageData(imageSource, pma, false);
                texture.setProperties(propertyParams);
            }
            else
                texture.setImageData(imageSource, false, false);
            if (canread) {
                if (LayaEnv.isConch && imageSource._nativeObj) {
                    texture._pixels = new Uint8Array(imageSource._nativeObj.getImageData(0, 0, imageSource.width, imageSource.height));
                }
                else {
                    ILaya.Browser.canvas.size(imageSource.width, imageSource.height);
                    ILaya.Browser.canvas.clear();
                    ILaya.Browser.context.drawImage(imageSource, 0, 0, imageSource.width, imageSource.height);
                    texture._pixels = new Uint8Array(ILaya.Browser.context.getImageData(0, 0, imageSource.width, imageSource.height).data.buffer);
                }
            }
            return texture;
        }
        static _parseDDS(data, propertyParams = null, constructParams = null) {
            let ddsInfo = DDSTextureInfo.getDDSTextureInfo(data);
            let texture = new Texture2D(ddsInfo.width, ddsInfo.height, ddsInfo.format, ddsInfo.mipmapCount > 1, false, false);
            texture.setDDSData(ddsInfo);
            if (propertyParams)
                texture.setProperties(propertyParams);
            return texture;
        }
        static _parseKTX(data, propertyParams = null, constructParams = null) {
            let ktxInfo = KTXTextureInfo.getKTXTextureInfo(data);
            let texture = new Texture2D(ktxInfo.width, ktxInfo.height, ktxInfo.format, ktxInfo.mipmapCount > 1, false, ktxInfo.sRGB);
            texture.setKTXData(ktxInfo);
            if (propertyParams)
                texture.setProperties(propertyParams);
            return texture;
        }
        static _parsePVR(data, propertyParams = null, constructParams = null) {
            throw "pvr !";
        }
        static load(url, complete) {
            ILaya.loader.load(url, complete, null, ILaya.Loader.TEXTURE2D);
        }
        setImageData(source, premultiplyAlpha, invertY) {
            let texture = this._texture;
            LayaGL.textureContext.setTextureImageData(texture, source, premultiplyAlpha, invertY);
        }
        setPixelsData(source, premultiplyAlpha, invertY) {
            let texture = this._texture;
            LayaGL.textureContext.setTexturePixelsData(texture, source, premultiplyAlpha, invertY);
        }
        setSubPixelsData(xOffset, yOffset, width, height, pixels, mipmapLevel, generateMipmap, premultiplyAlpha, invertY) {
            let texture = this._texture;
            LayaGL.textureContext.setTextureSubPixelsData(texture, pixels, mipmapLevel, generateMipmap, xOffset, yOffset, width, height, premultiplyAlpha, invertY);
        }
        setDDSData(ddsInfo) {
            let texture = this._texture;
            LayaGL.textureContext.setTextureDDSData(texture, ddsInfo);
        }
        setKTXData(ktxInfo) {
            let texture = this._texture;
            LayaGL.textureContext.setTextureKTXData(texture, ktxInfo);
        }
        setHDRData(hdrInfo) {
            let texture = this._texture;
            LayaGL.textureContext.setTextureHDRData(texture, hdrInfo);
        }
        get defaultTexture() {
            return Texture2D.grayTexture;
        }
        getPixels() {
            if (this._canRead && this._pixels) {
                return this._pixels;
            }
            else {
                throw new Error("Texture2D: must set texture canRead is true.");
            }
        }
        setProperties(propertyParams) {
            if (propertyParams) {
                if (propertyParams.wrapModeU != null)
                    this.wrapModeU = propertyParams.wrapModeU;
                if (propertyParams.wrapModeV != null)
                    this.wrapModeV = propertyParams.wrapModeV;
                if (propertyParams.filterMode != null)
                    this.filterMode = propertyParams.filterMode;
                if (propertyParams.anisoLevel != null)
                    this.anisoLevel = propertyParams.anisoLevel;
            }
        }
    }
    Texture2D.TEXTURE2D = "TEXTURE2D";
    Texture2D.grayTexture = null;
    Texture2D.whiteTexture = null;
    Texture2D.blackTexture = null;
    Texture2D.normalTexture = null;
    Texture2D.erroTextur = null;
    Texture2D.defalutUITexture = null;

    class BaseShader extends Resource {
        constructor() {
            super();
        }
    }

    class RenderState2D {
        static mat2MatArray(mat, matArray) {
            var m = mat;
            var m4 = matArray;
            m4[0] = m.a;
            m4[1] = m.b;
            m4[2] = RenderState2D.EMPTYMAT4_ARRAY[2];
            m4[3] = RenderState2D.EMPTYMAT4_ARRAY[3];
            m4[4] = m.c;
            m4[5] = m.d;
            m4[6] = RenderState2D.EMPTYMAT4_ARRAY[6];
            m4[7] = RenderState2D.EMPTYMAT4_ARRAY[7];
            m4[8] = RenderState2D.EMPTYMAT4_ARRAY[8];
            m4[9] = RenderState2D.EMPTYMAT4_ARRAY[9];
            m4[10] = RenderState2D.EMPTYMAT4_ARRAY[10];
            m4[11] = RenderState2D.EMPTYMAT4_ARRAY[11];
            m4[12] = m.tx;
            m4[13] = m.ty;
            m4[14] = RenderState2D.EMPTYMAT4_ARRAY[14];
            m4[15] = RenderState2D.EMPTYMAT4_ARRAY[15];
            return matArray;
        }
        static restoreTempArray() {
            RenderState2D.TEMPMAT4_ARRAY[0] = 1;
            RenderState2D.TEMPMAT4_ARRAY[1] = 0;
            RenderState2D.TEMPMAT4_ARRAY[4] = 0;
            RenderState2D.TEMPMAT4_ARRAY[5] = 1;
            RenderState2D.TEMPMAT4_ARRAY[12] = 0;
            RenderState2D.TEMPMAT4_ARRAY[13] = 0;
        }
        static clear() {
            RenderState2D.worldScissorTest = false;
            RenderState2D.worldAlpha = 1;
        }
    }
    RenderState2D._MAXSIZE = 99999999;
    RenderState2D.EMPTYMAT4_ARRAY = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    RenderState2D.TEMPMAT4_ARRAY = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    RenderState2D.worldMatrix4 = RenderState2D.TEMPMAT4_ARRAY;
    RenderState2D.worldMatrix = new Matrix();
    RenderState2D.matWVP = null;
    RenderState2D.worldAlpha = 1.0;
    RenderState2D.worldScissorTest = false;
    RenderState2D.width = 0;
    RenderState2D.height = 0;
    RenderState2D.InvertY = false;

    exports.RenderTargetFormat = void 0;
    (function (RenderTargetFormat) {
        RenderTargetFormat[RenderTargetFormat["None"] = -1] = "None";
        RenderTargetFormat[RenderTargetFormat["R8G8B8"] = 0] = "R8G8B8";
        RenderTargetFormat[RenderTargetFormat["R8G8B8A8"] = 1] = "R8G8B8A8";
        RenderTargetFormat[RenderTargetFormat["R16G16B16A16"] = 17] = "R16G16B16A16";
        RenderTargetFormat[RenderTargetFormat["R32G32B32"] = 30] = "R32G32B32";
        RenderTargetFormat[RenderTargetFormat["R32G32B32A32"] = 15] = "R32G32B32A32";
        RenderTargetFormat[RenderTargetFormat["R16G16B16"] = 31] = "R16G16B16";
        RenderTargetFormat[RenderTargetFormat["DEPTH_16"] = 35] = "DEPTH_16";
        RenderTargetFormat[RenderTargetFormat["STENCIL_8"] = 36] = "STENCIL_8";
        RenderTargetFormat[RenderTargetFormat["DEPTHSTENCIL_24_8"] = 37] = "DEPTHSTENCIL_24_8";
        RenderTargetFormat[RenderTargetFormat["DEPTH_32"] = 38] = "DEPTH_32";
    })(exports.RenderTargetFormat || (exports.RenderTargetFormat = {}));

    exports.RenderClearFlag = void 0;
    (function (RenderClearFlag) {
        RenderClearFlag[RenderClearFlag["Nothing"] = 0] = "Nothing";
        RenderClearFlag[RenderClearFlag["Color"] = 1] = "Color";
        RenderClearFlag[RenderClearFlag["Depth"] = 2] = "Depth";
        RenderClearFlag[RenderClearFlag["Stencil"] = 4] = "Stencil";
    })(exports.RenderClearFlag || (exports.RenderClearFlag = {}));

    class Color {
        constructor(r = 1, g = 1, b = 1, a = 1) {
            this.r = r;
            this.g = g;
            this.b = b;
            this.a = a;
        }
        static gammaToLinearSpace(value) {
            if (value <= 0.04045)
                return value / 12.92;
            else if (value < 1.0)
                return Math.pow((value + 0.055) / 1.055, 2.4);
            else
                return Math.pow(value, 2.4);
        }
        static linearToGammaSpace(value) {
            if (value <= 0.0)
                return 0.0;
            else if (value <= 0.0031308)
                return 12.92 * value;
            else if (value <= 1.0)
                return 1.055 * Math.pow(value, 0.41666) - 0.055;
            else
                return Math.pow(value, 0.41666);
        }
        equal(c) {
            if (!c)
                return false;
            const toFIxed = (a, b) => {
                var delta = 1e-5;
                return -delta < a - b && a - b < delta;
            };
            return toFIxed(c.r, this.r) && toFIxed(c.g, this.g) && toFIxed(c.b, this.b) && toFIxed(c.a, this.a);
        }
        toLinear(out) {
            out.r = Color.gammaToLinearSpace(this.r);
            out.g = Color.gammaToLinearSpace(this.g);
            out.b = Color.gammaToLinearSpace(this.b);
            out.a = this.a;
        }
        toGamma(out) {
            out.r = Color.linearToGammaSpace(this.r);
            out.g = Color.linearToGammaSpace(this.g);
            out.b = Color.linearToGammaSpace(this.b);
            out.a = this.a;
        }
        cloneTo(destObject) {
            var destColor = destObject;
            destColor.r = this.r;
            destColor.g = this.g;
            destColor.b = this.b;
            destColor.a = this.a;
        }
        scale(value) {
            this.r = this.r * value;
            this.g = this.g * value;
            this.b = this.b * value;
            return this;
        }
        setValue(r, g, b, a) {
            this.r = r;
            this.g = g;
            this.b = b;
            this.a = a;
        }
        fromArray(array, offset = 0) {
            this.r = array[offset + 0];
            this.g = array[offset + 1];
            this.b = array[offset + 2];
            this.a = array[offset + 3];
        }
        toArray() {
            return [this.r, this.g, this.b, this.a];
        }
        clone() {
            var dest = new Color();
            this.cloneTo(dest);
            return dest;
        }
    }
    Color.RED = new Color(1, 0, 0, 1);
    Color.GREEN = new Color(0, 1, 0, 1);
    Color.BLUE = new Color(0, 0, 1, 1);
    Color.CYAN = new Color(0, 1, 1, 1);
    Color.YELLOW = new Color(1, 0.92, 0.016, 1);
    Color.MAGENTA = new Color(1, 0, 1, 1);
    Color.GRAY = new Color(0.5, 0.5, 0.5, 1);
    Color.WHITE = new Color(1, 1, 1, 1);
    Color.BLACK = new Color(0, 0, 0, 1);
    Color.CLEAR = new Color(0, 0, 0, 0);

    class NativeRenderTexture2D extends BaseTexture {
        constructor(width, height, format = exports.RenderTargetFormat.R8G8B8, depthStencilFormat = exports.RenderTargetFormat.DEPTH_16, create = true) {
            super(width, height, format);
            this._mgrKey = 0;
            this._colorFormat = format;
            this._depthStencilFormat = depthStencilFormat;
            if (width != 0 && height != 0 && create) {
                this._create();
            }
            this.lock = true;
        }
        static get currentActive() {
            return NativeRenderTexture2D._currentActive;
        }
        get depthStencilFormat() {
            return this._depthStencilFormat;
        }
        get defaultTexture() {
            return Texture2D.grayTexture;
        }
        getIsReady() {
            return true;
        }
        get sourceWidth() {
            return this._width;
        }
        get sourceHeight() {
            return this._height;
        }
        get offsetX() {
            return 0;
        }
        get offsetY() {
            return 0;
        }
        get isCube() {
            return this._nativeObj.isCube;
        }
        get samples() {
            return this._nativeObj.samples;
        }
        get generateMipmap() {
            return this._nativeObj.generateMipmap;
        }
        _start() {
            throw new Error("Method not implemented.");
        }
        _end() {
            throw new Error("Method not implemented.");
        }
        _create() {
            this._nativeObj = new window.conchRenderTexture2D(LayaGL.renderEngine._nativeObj, this.width, this.height, this._colorFormat, this.depthStencilFormat);
            this._texture = this._nativeObj._renderTarget._textures[0];
        }
        static pushRT() {
            throw new Error("Method not implemented.");
        }
        static popRT() {
            throw new Error("Method not implemented.");
        }
        start() {
            this._nativeObj.start();
        }
        end() {
            this._nativeObj.end();
        }
        restore() {
            this._nativeObj.restore();
        }
        clear(r = 0.0, g = 0.0, b = 0.0, a = 1.0) {
            this._nativeObj.clear(r, g, b, a);
        }
        getData(x, y, width, height) {
            return this._nativeObj.getData(x, y, width, height);
        }
        recycle() {
        }
        _disposeResource() {
            this._nativeObj._disposeResource();
        }
    }
    NativeRenderTexture2D._clearColor = new Color();
    NativeRenderTexture2D.rtStack = [];
    NativeRenderTexture2D.defuv = [0, 0, 1, 0, 1, 1, 0, 1];
    NativeRenderTexture2D.flipyuv = [0, 1, 1, 1, 1, 0, 0, 0];

    class RenderTexture2D extends BaseTexture {
        constructor(width, height, format = exports.RenderTargetFormat.R8G8B8, depthStencilFormat = exports.RenderTargetFormat.None) {
            super(width, height, format);
            this._mgrKey = 0;
            this._colorFormat = format;
            this._depthStencilFormat = depthStencilFormat;
            if (width != 0 && height != 0) {
                this._create();
            }
            this.lock = true;
        }
        static get currentActive() {
            return RenderTexture2D._currentActive;
        }
        get depthStencilFormat() {
            return this._depthStencilFormat;
        }
        get defaultTexture() {
            return Texture2D.grayTexture;
        }
        getIsReady() {
            return true;
        }
        get sourceWidth() {
            return this._width;
        }
        get sourceHeight() {
            return this._height;
        }
        get offsetX() {
            return 0;
        }
        get offsetY() {
            return 0;
        }
        get isCube() {
            return this._renderTarget._isCube;
        }
        get samples() {
            return this._renderTarget._samples;
        }
        get generateMipmap() {
            return this._renderTarget._generateMipmap;
        }
        _start() {
            throw new Error("Method not implemented.");
        }
        _end() {
            throw new Error("Method not implemented.");
        }
        _create() {
            this._renderTarget = LayaGL.textureContext.createRenderTargetInternal(this.width, this.height, this._colorFormat, this.depthStencilFormat, false, true, 1);
            this._texture = this._renderTarget._textures[0];
        }
        static pushRT() {
            RenderTexture2D.rtStack.push({ rt: RenderTexture2D._currentActive, w: RenderState2D.width, h: RenderState2D.height });
        }
        static popRT() {
            var top = RenderTexture2D.rtStack.pop();
            if (top) {
                if (RenderTexture2D._currentActive != top.rt) {
                    top.rt ? LayaGL.textureContext.bindRenderTarget(top.rt._renderTarget) : LayaGL.textureContext.bindoutScreenTarget();
                    RenderTexture2D._currentActive = top.rt;
                }
                LayaGL.renderEngine.viewport(0, 0, top.w, top.h);
                RenderState2D.width = top.w;
                RenderState2D.height = top.h;
            }
        }
        start() {
            LayaGL.textureContext.bindRenderTarget(this._renderTarget);
            this._lastRT = RenderTexture2D._currentActive;
            RenderTexture2D._currentActive = this;
            LayaGL.renderEngine.viewport(0, 0, this._width, this._height);
            this._lastWidth = RenderState2D.width;
            this._lastHeight = RenderState2D.height;
            RenderState2D.width = this._width;
            RenderState2D.height = this._height;
            BaseShader.activeShader = null;
        }
        end() {
            LayaGL.textureContext.unbindRenderTarget(this._renderTarget);
            RenderTexture2D._currentActive = null;
        }
        restore() {
            if (this._lastRT != RenderTexture2D._currentActive) {
                if (this._lastRT) {
                    LayaGL.textureContext.bindRenderTarget(this._lastRT._renderTarget);
                }
                else {
                    LayaGL.textureContext.unbindRenderTarget(this._renderTarget);
                }
                RenderTexture2D._currentActive = this._lastRT;
            }
            LayaGL.renderEngine.viewport(0, 0, this._lastWidth, this._lastHeight);
            RenderState2D.width = this._lastWidth;
            RenderState2D.height = this._lastHeight;
            BaseShader.activeShader = null;
        }
        clear(r = 0.0, g = 0.0, b = 0.0, a = 1.0) {
            RenderTexture2D._clearColor.r = r;
            RenderTexture2D._clearColor.g = g;
            RenderTexture2D._clearColor.b = b;
            RenderTexture2D._clearColor.a = a;
            RenderTexture2D._clearColor.toLinear(RenderTexture2D._clearLinearColor);
            LayaGL.renderEngine.clearRenderTexture(exports.RenderClearFlag.Color | exports.RenderClearFlag.Depth, RenderTexture2D._clearLinearColor, 1);
        }
        getData(x, y, width, height) {
            return LayaGL.textureContext.getRenderTextureData(this._renderTarget, x, y, width, height);
        }
        recycle() {
        }
        _disposeResource() {
            this._renderTarget && this._renderTarget.dispose();
        }
    }
    RenderTexture2D._clearColor = new Color();
    RenderTexture2D._clearLinearColor = new Color();
    RenderTexture2D.rtStack = [];
    RenderTexture2D.defuv = [0, 0, 1, 0, 1, 1, 0, 1];
    RenderTexture2D.flipyuv = [0, 1, 1, 1, 1, 0, 0, 0];
    if (window.conch && !window.conchConfig.conchWebGL) {
        RenderTexture2D = NativeRenderTexture2D;
    }

    class WebGLRTMgr {
        static getRT(w, h) {
            w = w | 0;
            h = h | 0;
            if (w >= 10000) {
                console.error('getRT error! w too big');
            }
            var ret;
            ret = new RenderTexture2D(w, h, exports.RenderTargetFormat.R8G8B8A8, exports.RenderTargetFormat.None);
            return ret;
        }
        static releaseRT(rt) {
            rt.destroy();
            return;
        }
    }
    WebGLRTMgr.dict = {};

    exports.BlendFactor = void 0;
    (function (BlendFactor) {
        BlendFactor[BlendFactor["Zero"] = 0] = "Zero";
        BlendFactor[BlendFactor["One"] = 1] = "One";
        BlendFactor[BlendFactor["SourceColor"] = 2] = "SourceColor";
        BlendFactor[BlendFactor["OneMinusSourceColor"] = 3] = "OneMinusSourceColor";
        BlendFactor[BlendFactor["DestinationColor"] = 4] = "DestinationColor";
        BlendFactor[BlendFactor["OneMinusDestinationColor"] = 5] = "OneMinusDestinationColor";
        BlendFactor[BlendFactor["SourceAlpha"] = 6] = "SourceAlpha";
        BlendFactor[BlendFactor["OneMinusSourceAlpha"] = 7] = "OneMinusSourceAlpha";
        BlendFactor[BlendFactor["DestinationAlpha"] = 8] = "DestinationAlpha";
        BlendFactor[BlendFactor["OneMinusDestinationAlpha"] = 9] = "OneMinusDestinationAlpha";
        BlendFactor[BlendFactor["SourceAlphaSaturate"] = 10] = "SourceAlphaSaturate";
        BlendFactor[BlendFactor["BlendColor"] = 11] = "BlendColor";
        BlendFactor[BlendFactor["OneMinusBlendColor"] = 12] = "OneMinusBlendColor";
    })(exports.BlendFactor || (exports.BlendFactor = {}));

    exports.BlendType = void 0;
    (function (BlendType) {
        BlendType[BlendType["BLEND_DISABLE"] = 0] = "BLEND_DISABLE";
        BlendType[BlendType["BLEND_ENABLE_ALL"] = 1] = "BLEND_ENABLE_ALL";
        BlendType[BlendType["BLEND_ENABLE_SEPERATE"] = 2] = "BLEND_ENABLE_SEPERATE";
    })(exports.BlendType || (exports.BlendType = {}));

    exports.RenderStateType = void 0;
    (function (RenderStateType) {
        RenderStateType[RenderStateType["DepthTest"] = 0] = "DepthTest";
        RenderStateType[RenderStateType["DepthMask"] = 1] = "DepthMask";
        RenderStateType[RenderStateType["DepthFunc"] = 2] = "DepthFunc";
        RenderStateType[RenderStateType["StencilTest"] = 3] = "StencilTest";
        RenderStateType[RenderStateType["StencilMask"] = 4] = "StencilMask";
        RenderStateType[RenderStateType["StencilFunc"] = 5] = "StencilFunc";
        RenderStateType[RenderStateType["StencilOp"] = 6] = "StencilOp";
        RenderStateType[RenderStateType["BlendType"] = 7] = "BlendType";
        RenderStateType[RenderStateType["BlendEquation"] = 8] = "BlendEquation";
        RenderStateType[RenderStateType["BlendEquationSeparate"] = 9] = "BlendEquationSeparate";
        RenderStateType[RenderStateType["BlendFunc"] = 10] = "BlendFunc";
        RenderStateType[RenderStateType["BlendFuncSeperate"] = 11] = "BlendFuncSeperate";
        RenderStateType[RenderStateType["CullFace"] = 12] = "CullFace";
        RenderStateType[RenderStateType["FrontFace"] = 13] = "FrontFace";
    })(exports.RenderStateType || (exports.RenderStateType = {}));

    class RenderStateContext {
        static __init__() {
            RenderStateContext.DepthTestCMD = LayaGL.renderEngine.createRenderStateComand();
            RenderStateContext.DepthMaskCMD = LayaGL.renderEngine.createRenderStateComand();
            RenderStateContext.DepthFuncCMD = LayaGL.renderEngine.createRenderStateComand();
            RenderStateContext.StencilTestCMD = LayaGL.renderEngine.createRenderStateComand();
            RenderStateContext.StencilMaskCMD = LayaGL.renderEngine.createRenderStateComand();
            RenderStateContext.StencilFuncCMD = LayaGL.renderEngine.createRenderStateComand();
            RenderStateContext.stencilOpCMD = LayaGL.renderEngine.createRenderStateComand();
            RenderStateContext.BlendCMD = LayaGL.renderEngine.createRenderStateComand();
            RenderStateContext.BlendEquationCMD = LayaGL.renderEngine.createRenderStateComand();
            RenderStateContext.BlendEquationSeparateCMD = LayaGL.renderEngine.createRenderStateComand();
            RenderStateContext.BlendFuncCMD = LayaGL.renderEngine.createRenderStateComand();
            RenderStateContext.BlendFuncSeperateCMD = LayaGL.renderEngine.createRenderStateComand();
            RenderStateContext.CullFaceCMD = LayaGL.renderEngine.createRenderStateComand();
            RenderStateContext.FrontFaceCMD = LayaGL.renderEngine.createRenderStateComand();
        }
        static setDepthTest(value) {
            RenderStateContext.DepthTestCMD.clear();
            RenderStateContext.DepthTestCMD.addCMD(exports.RenderStateType.DepthTest, value);
            RenderStateContext.DepthTestCMD.applyCMD();
        }
        static setDepthMask(value) {
            RenderStateContext.DepthMaskCMD.clear();
            RenderStateContext.DepthMaskCMD.addCMD(exports.RenderStateType.DepthMask, value);
            RenderStateContext.DepthMaskCMD.applyCMD();
        }
        static setDepthFunc(value) {
            RenderStateContext.DepthFuncCMD.clear();
            RenderStateContext.DepthFuncCMD.addCMD(exports.RenderStateType.DepthFunc, value);
            RenderStateContext.DepthFuncCMD.applyCMD();
        }
        static setStencilTest(value) {
            RenderStateContext.StencilTestCMD.clear();
            RenderStateContext.StencilTestCMD.addCMD(exports.RenderStateType.StencilTest, value);
            RenderStateContext.StencilTestCMD.applyCMD();
        }
        static setStencilMask(value) {
            RenderStateContext.StencilMaskCMD.clear();
            RenderStateContext.StencilMaskCMD.addCMD(exports.RenderStateType.StencilMask, value);
            RenderStateContext.StencilMaskCMD.applyCMD();
        }
        static setStencilFunc(fun, ref) {
            RenderStateContext.StencilFuncCMD.clear();
            RenderStateContext.stencilFuncArray[0] = fun;
            RenderStateContext.stencilFuncArray[1] = ref;
            RenderStateContext.StencilFuncCMD.addCMD(exports.RenderStateType.StencilFunc, RenderStateContext.stencilFuncArray);
            RenderStateContext.StencilFuncCMD.applyCMD();
        }
        static setstencilOp(fail, zfail, zpass) {
            RenderStateContext.stencilOpCMD.clear();
            RenderStateContext.stencilOpArray[0] = fail;
            RenderStateContext.stencilOpArray[1] = zfail;
            RenderStateContext.stencilOpArray[2] = zpass;
            RenderStateContext.stencilOpCMD.addCMD(exports.RenderStateType.StencilOp, RenderStateContext.stencilOpArray);
            RenderStateContext.stencilOpCMD.applyCMD();
        }
        static setBlend(value) {
            RenderStateContext.BlendCMD.clear();
            if (!value)
                RenderStateContext.BlendCMD.addCMD(exports.RenderStateType.BlendType, exports.BlendType.BLEND_DISABLE);
            else
                RenderStateContext.BlendCMD.addCMD(exports.RenderStateType.BlendType, exports.BlendType.BLEND_ENABLE_SEPERATE);
            RenderStateContext.BlendCMD.applyCMD();
        }
        static setBlendEquation(blendEquation) {
            RenderStateContext.BlendEquationCMD.clear();
            RenderStateContext.BlendEquationCMD.addCMD(exports.RenderStateType.BlendEquation, blendEquation);
            RenderStateContext.BlendEquationCMD.applyCMD();
        }
        static setBlendEquationSeparate(blendEquationRGB, blendEquationAlpha) {
            RenderStateContext.BlendEquationSeparateCMD.clear();
            RenderStateContext.blendEquationSeparateArray[0] = blendEquationRGB;
            RenderStateContext.blendEquationSeparateArray[1] = blendEquationAlpha;
            RenderStateContext.BlendEquationSeparateCMD.addCMD(exports.RenderStateType.BlendEquationSeparate, RenderStateContext.blendEquationSeparateArray);
            RenderStateContext.BlendEquationSeparateCMD.applyCMD();
        }
        static setBlendFunc(sFactor, dFactor, force = false) {
            RenderStateContext.BlendFuncCMD.clear();
            RenderStateContext.blenfunArray[0] = sFactor;
            RenderStateContext.blenfunArray[1] = dFactor;
            RenderStateContext.BlendFuncCMD.addCMD(exports.RenderStateType.BlendFunc, RenderStateContext.blenfunArray);
            RenderStateContext.BlendFuncCMD.applyCMD();
        }
        static setBlendFuncSeperate(srcRGB, dstRGB, srcAlpha, dstAlpha) {
            RenderStateContext.BlendFuncSeperateCMD.clear();
            RenderStateContext.blendFuncSeperateArray[0] = srcRGB;
            RenderStateContext.blendFuncSeperateArray[1] = dstRGB;
            RenderStateContext.blendFuncSeperateArray[2] = srcAlpha;
            RenderStateContext.blendFuncSeperateArray[3] = dstAlpha;
            RenderStateContext.BlendFuncSeperateCMD.addCMD(exports.RenderStateType.BlendFuncSeperate, RenderStateContext.blendFuncSeperateArray);
            RenderStateContext.BlendFuncSeperateCMD.applyCMD();
        }
    }
    RenderStateContext.stencilFuncArray = new Array(2);
    RenderStateContext.blendEquationSeparateArray = new Array(2);
    RenderStateContext.blenfunArray = new Array(2);
    RenderStateContext.blendFuncSeperateArray = new Array(4);
    RenderStateContext.stencilOpArray = new Array(3);

    class BlendMode {
        static _init_() {
            BlendMode.fns = [
                BlendMode.BlendNormal,
                BlendMode.BlendAdd,
                BlendMode.BlendMultiply,
                BlendMode.BlendScreen,
                BlendMode.BlendOverlay,
                BlendMode.BlendLight,
                BlendMode.BlendMask,
                BlendMode.BlendDestinationOut,
                BlendMode.BlendAddOld
            ];
            BlendMode.targetFns = [
                BlendMode.BlendNormalTarget,
                BlendMode.BlendAddTarget,
                BlendMode.BlendMultiplyTarget,
                BlendMode.BlendScreenTarget,
                BlendMode.BlendOverlayTarget,
                BlendMode.BlendLightTarget,
                BlendMode.BlendMask,
                BlendMode.BlendDestinationOut,
                BlendMode.BlendAddTargetOld
            ];
        }
        static BlendNormal() {
            RenderStateContext.setBlendFunc(exports.BlendFactor.One, exports.BlendFactor.OneMinusSourceAlpha, true);
        }
        static BlendAddOld() {
            RenderStateContext.setBlendFunc(exports.BlendFactor.One, exports.BlendFactor.DestinationAlpha, true);
        }
        static BlendAdd() {
            RenderStateContext.setBlendFunc(exports.BlendFactor.One, exports.BlendFactor.One, true);
        }
        static BlendMultiply() {
            RenderStateContext.setBlendFunc(exports.BlendFactor.DestinationColor, exports.BlendFactor.OneMinusSourceAlpha, true);
        }
        static BlendScreen() {
            RenderStateContext.setBlendFunc(exports.BlendFactor.One, exports.BlendFactor.One, true);
        }
        static BlendOverlay() {
            RenderStateContext.setBlendFunc(exports.BlendFactor.One, exports.BlendFactor.OneMinusSourceAlpha, true);
        }
        static BlendLight() {
            RenderStateContext.setBlendFunc(exports.BlendFactor.One, exports.BlendFactor.One, true);
        }
        static BlendNormalTarget() {
            RenderStateContext.setBlendFunc(exports.BlendFactor.One, exports.BlendFactor.OneMinusSourceAlpha, true);
        }
        static BlendAddTargetOld() {
            RenderStateContext.setBlendFunc(exports.BlendFactor.One, exports.BlendFactor.DestinationAlpha, true);
        }
        static BlendAddTarget() {
            RenderStateContext.setBlendFunc(exports.BlendFactor.One, exports.BlendFactor.One, true);
        }
        static BlendMultiplyTarget() {
            RenderStateContext.setBlendFunc(exports.BlendFactor.DestinationColor, exports.BlendFactor.OneMinusSourceAlpha, true);
        }
        static BlendScreenTarget() {
            RenderStateContext.setBlendFunc(exports.BlendFactor.One, exports.BlendFactor.One, true);
        }
        static BlendOverlayTarget() {
            RenderStateContext.setBlendFunc(exports.BlendFactor.One, exports.BlendFactor.OneMinusSourceColor, true);
        }
        static BlendLightTarget() {
            RenderStateContext.setBlendFunc(exports.BlendFactor.One, exports.BlendFactor.One, true);
        }
        static BlendMask() {
            RenderStateContext.setBlendFunc(exports.BlendFactor.Zero, exports.BlendFactor.SourceAlpha, true);
        }
        static BlendDestinationOut() {
            RenderStateContext.setBlendFunc(exports.BlendFactor.Zero, exports.BlendFactor.Zero, true);
        }
    }
    BlendMode.activeBlendFunction = null;
    BlendMode.NAMES = [
        "normal",
        "add",
        "multiply",
        "screen",
        "overlay",
        "light",
        "mask",
        "destination-out",
        "add_old"
    ];
    BlendMode.TOINT = {
        "normal": 0,
        "add": 1,
        "multiply": 2,
        "screen": 3,
        "overlay": 4,
        "light": 5,
        "mask": 6,
        "destination-out": 7,
        "lighter": 1,
        "lighter_old": 8,
        "add_old": 8
    };
    BlendMode.NORMAL = "normal";
    BlendMode.MASK = "mask";
    BlendMode.LIGHTER = "lighter";

    class ShaderDefinesBase {
        constructor(name2int, int2name, int2nameMap) {
            this._value = 0;
            this._name2int = name2int;
            this._int2name = int2name;
            this._int2nameMap = int2nameMap;
        }
        add(value) {
            if (typeof (value) == 'string') {
                this._value |= this._name2int[value];
            }
            else {
                this._value |= value;
            }
            return this._value;
        }
        addInt(value) {
            this._value |= value;
            return this._value;
        }
        remove(value) {
            if (typeof (value) == 'string') {
                this._value &= ~(this._name2int[value]);
            }
            else {
                this._value &= (~value);
            }
            return this._value;
        }
        isDefine(def) {
            return (this._value & def) === def;
        }
        getValue() {
            return this._value;
        }
        setValue(value) {
            this._value = value;
        }
        toNameDic() {
            var r = this._int2nameMap[this._value];
            return r ? r : ShaderDefinesBase._toText(this._value, this._int2name, this._int2nameMap);
        }
        static _reg(name, value, _name2int, _int2name) {
            _name2int[name] = value;
            _int2name[value] = name;
        }
        static _toText(value, _int2name, _int2nameMap) {
            var r = _int2nameMap[value];
            if (r)
                return r;
            var o = {};
            var d = 1;
            for (var i = 0; i < 32; i++) {
                d = 1 << i;
                if (d > value)
                    break;
                if (value & d) {
                    var name = _int2name[d];
                    name && (o[name] = "");
                }
            }
            _int2nameMap[value] = o;
            return o;
        }
        static _toInt(names, _name2int) {
            var words = names.split('.');
            var num = 0;
            for (var i = 0, n = words.length; i < n; i++) {
                var value = _name2int[words[i]];
                if (!value)
                    throw new Error("Defines to int err:" + names + "/" + words[i]);
                num |= value;
            }
            return num;
        }
    }

    class ShaderDefines2D extends ShaderDefinesBase {
        constructor() {
            super(ShaderDefines2D.__name2int, ShaderDefines2D.__int2name, ShaderDefines2D.__int2nameMap);
        }
        static __init__() {
            ShaderDefines2D.reg("TEXTURE2D", ShaderDefines2D.TEXTURE2D);
            ShaderDefines2D.reg("PRIMITIVE", ShaderDefines2D.PRIMITIVE);
            ShaderDefines2D.reg("GLOW_FILTER", ShaderDefines2D.FILTERGLOW);
            ShaderDefines2D.reg("BLUR_FILTER", ShaderDefines2D.FILTERBLUR);
            ShaderDefines2D.reg("COLOR_FILTER", ShaderDefines2D.FILTERCOLOR);
            ShaderDefines2D.reg("COLOR_ADD", ShaderDefines2D.COLORADD);
            ShaderDefines2D.reg("WORLDMAT", ShaderDefines2D.WORLDMAT);
            ShaderDefines2D.reg("FILLTEXTURE", ShaderDefines2D.FILLTEXTURE);
            ShaderDefines2D.reg('MVP3D', ShaderDefines2D.MVP3D);
            ShaderDefines2D.reg('GAMMASPACE', ShaderDefines2D.GAMMASPACE);
            ShaderDefines2D.reg('INVERTY', ShaderDefines2D.INVERTY);
        }
        static reg(name, value) {
            this._reg(name, value, ShaderDefines2D.__name2int, ShaderDefines2D.__int2name);
        }
        static toText(value, int2name, int2nameMap) {
            return this._toText(value, int2name, int2nameMap);
        }
        static toInt(names) {
            return this._toInt(names, ShaderDefines2D.__name2int);
        }
    }
    ShaderDefines2D.TEXTURE2D = 0x01;
    ShaderDefines2D.PRIMITIVE = 0x04;
    ShaderDefines2D.FILTERGLOW = 0x08;
    ShaderDefines2D.FILTERBLUR = 0x10;
    ShaderDefines2D.FILTERCOLOR = 0x20;
    ShaderDefines2D.COLORADD = 0x40;
    ShaderDefines2D.WORLDMAT = 0x80;
    ShaderDefines2D.FILLTEXTURE = 0x100;
    ShaderDefines2D.SKINMESH = 0x200;
    ShaderDefines2D.MVP3D = 0x800;
    ShaderDefines2D.GAMMASPACE = 0x1000;
    ShaderDefines2D.INVERTY = 0x2000;
    ShaderDefines2D.NOOPTMASK = ShaderDefines2D.FILTERGLOW | ShaderDefines2D.FILTERBLUR | ShaderDefines2D.FILTERCOLOR | ShaderDefines2D.FILLTEXTURE;
    ShaderDefines2D.__name2int = {};
    ShaderDefines2D.__int2name = [];
    ShaderDefines2D.__int2nameMap = [];

    const _rect1 = new Rectangle();
    const _rect2 = new Rectangle();
    class Texture extends Resource {
        constructor(source = null, uv = null, sourceWidth = 0, sourceHeight = 0) {
            super(false);
            this.uvrect = [0, 0, 1, 1];
            this._w = 0;
            this._h = 0;
            this.offsetX = 0;
            this.offsetY = 0;
            this.sourceWidth = 0;
            this.sourceHeight = 0;
            this.scaleRate = 1;
            let bitmap = (source instanceof Texture) ? source.bitmap : source;
            this.setTo(bitmap, uv, sourceWidth, sourceHeight);
        }
        static create(source, x, y, width, height, offsetX = 0, offsetY = 0, sourceWidth = 0, sourceHeight = 0) {
            return Texture._create(source, x, y, width, height, offsetX, offsetY, sourceWidth, sourceHeight);
        }
        static _create(source, x, y, width, height, offsetX = 0, offsetY = 0, sourceWidth = 0, sourceHeight = 0, outTexture = null) {
            var btex = source instanceof Texture;
            var uv = btex ? source.uv : Texture.DEF_UV;
            var bitmap = btex ? source.bitmap : source;
            if (bitmap.width && (x + width) > bitmap.width)
                width = bitmap.width - x;
            if (bitmap.height && (y + height) > bitmap.height)
                height = bitmap.height - y;
            var tex;
            if (outTexture) {
                tex = outTexture;
                tex.setTo(bitmap, null, sourceWidth || width, sourceHeight || height);
            }
            else {
                tex = new Texture(bitmap, null, sourceWidth || width, sourceHeight || height);
            }
            tex.width = width;
            tex.height = height;
            tex.offsetX = offsetX;
            tex.offsetY = offsetY;
            var dwidth = 1 / bitmap.width;
            var dheight = 1 / bitmap.height;
            x *= dwidth;
            y *= dheight;
            width *= dwidth;
            height *= dheight;
            var u1 = tex.uv[0], v1 = tex.uv[1], u2 = tex.uv[4], v2 = tex.uv[5];
            var inAltasUVWidth = (u2 - u1), inAltasUVHeight = (v2 - v1);
            var oriUV = moveUV(uv[0], uv[1], [x, y, x + width, y, x + width, y + height, x, y + height]);
            tex.uv = new Float32Array([u1 + oriUV[0] * inAltasUVWidth, v1 + oriUV[1] * inAltasUVHeight,
                u2 - (1 - oriUV[2]) * inAltasUVWidth, v1 + oriUV[3] * inAltasUVHeight,
                u2 - (1 - oriUV[4]) * inAltasUVWidth, v2 - (1 - oriUV[5]) * inAltasUVHeight,
                u1 + oriUV[6] * inAltasUVWidth, v2 - (1 - oriUV[7]) * inAltasUVHeight]);
            var bitmapScale = bitmap.scaleRate;
            if (bitmapScale && bitmapScale != 1) {
                tex.sourceWidth /= bitmapScale;
                tex.sourceHeight /= bitmapScale;
                tex.width /= bitmapScale;
                tex.height /= bitmapScale;
                tex.scaleRate = bitmapScale;
                tex.offsetX /= bitmapScale;
                tex.offsetY /= bitmapScale;
            }
            else {
                tex.scaleRate = 1;
            }
            return tex;
        }
        static createFromTexture(texture, x, y, width, height) {
            var texScaleRate = texture.scaleRate;
            if (texScaleRate != 1) {
                x *= texScaleRate;
                y *= texScaleRate;
                width *= texScaleRate;
                height *= texScaleRate;
            }
            var rect = Rectangle.TEMP.setTo(x - texture.offsetX, y - texture.offsetY, width, height);
            var result = rect.intersection(_rect1.setTo(0, 0, texture.width, texture.height), _rect2);
            if (result)
                var tex = Texture.create(texture, result.x, result.y, result.width, result.height, result.x - rect.x, result.y - rect.y, width, height);
            else
                return null;
            return tex;
        }
        get uv() {
            return this._uv;
        }
        set uv(value) {
            this.uvrect[0] = Math.min(value[0], value[2], value[4], value[6]);
            this.uvrect[1] = Math.min(value[1], value[3], value[5], value[7]);
            this.uvrect[2] = Math.max(value[0], value[2], value[4], value[6]) - this.uvrect[0];
            this.uvrect[3] = Math.max(value[1], value[3], value[5], value[7]) - this.uvrect[1];
            this._uv = value;
        }
        get width() {
            if (this._w)
                return this._w;
            if (!this.bitmap)
                return 0;
            return (this.uv && this.uv !== Texture.DEF_UV) ? (this.uv[2] - this.uv[0]) * this.bitmap.width : this.bitmap.width;
        }
        set width(value) {
            this._w = value;
            this.sourceWidth || (this.sourceWidth = value);
        }
        get height() {
            if (this._h)
                return this._h;
            if (!this.bitmap)
                return 0;
            return (this.uv && this.uv !== Texture.DEF_UV) ? (this.uv[5] - this.uv[1]) * this.bitmap.height : this.bitmap.height;
        }
        set height(value) {
            this._h = value;
            this.sourceHeight || (this.sourceHeight = value);
        }
        get bitmap() {
            return this._bitmap;
        }
        set bitmap(value) {
            if (this._bitmap == value)
                return;
            this._bitmap && this._bitmap._removeReference(this._referenceCount);
            this._bitmap = value;
            value && (value._addReference(this._referenceCount));
        }
        _addReference(count = 1) {
            super._addReference(count);
            this._bitmap && this._bitmap._addReference(count);
        }
        _removeReference(count = 1) {
            super._removeReference(count);
            this._bitmap && this._bitmap._removeReference(count);
        }
        _getSource(cb = null) {
            if (this._destroyed || !this._bitmap)
                return null;
            this.recoverBitmap(cb);
            return this._bitmap.destroyed ? null : this.bitmap._getSource();
        }
        setTo(bitmap = null, uv = null, sourceWidth = 0, sourceHeight = 0) {
            this.bitmap = bitmap;
            this.sourceWidth = sourceWidth;
            this.sourceHeight = sourceHeight;
            if (bitmap) {
                this._w = bitmap.width;
                this._h = bitmap.height;
                this.sourceWidth = this.sourceWidth || bitmap.width;
                this.sourceHeight = this.sourceHeight || bitmap.height;
            }
            this.uv = uv || Texture.DEF_UV;
        }
        load(url, complete) {
            if (this._destroyed)
                return Promise.resolve();
            return ILaya.loader.load(url).then((tex) => {
                let bit = tex.bitmap;
                this.bitmap = bit;
                this.sourceWidth = this._w = bit.width;
                this.sourceHeight = this._h = bit.height;
                complete && complete.run();
                this.event(Event.READY, this);
            });
        }
        getTexturePixels(x, y, width, height) {
            var st, dst, i;
            var tex2d = this.bitmap;
            var texw = this._w;
            var texh = this._h;
            var sourceWidth = this.sourceWidth;
            var sourceHeight = this.sourceHeight;
            var tex2dw = tex2d.width;
            var tex2dh = tex2d.height;
            var offsetX = this.offsetX;
            var offsetY = this.offsetY;
            let draww = width;
            let drawh = height;
            if (x + width > texw + offsetX)
                draww -= (x + width) - texw - offsetX;
            if (x + width > sourceWidth)
                width -= (x + width) - sourceWidth;
            if (y + height > texh + offsetY)
                drawh -= (y + height) - texh - offsetY;
            if (y + height > sourceHeight)
                height -= (y + height) - sourceHeight;
            if (width <= 0 || height <= 0)
                return null;
            let marginL = offsetX > x ? offsetX - x : 0;
            let marginT = offsetY > y ? offsetY - y : 0;
            let rePosX = x > offsetX ? x - offsetX : 0;
            let rePosY = y > offsetY ? y - offsetY : 0;
            draww -= marginL;
            drawh -= marginT;
            var wstride = width * 4;
            var pix = null;
            try {
                pix = tex2d.getPixels();
            }
            catch (e) {
            }
            if (pix) {
                if (x == 0 && y == 0 && width == tex2dw && height == tex2dh)
                    return pix;
                let uv = this._uv.slice();
                let atlasPosX = Math.round(uv[0] * tex2dw);
                let atlasPosY = Math.round(uv[1] * tex2dh);
                var ret = new Uint8Array(width * height * 4);
                wstride = tex2dw * 4;
                dst = (atlasPosY + rePosY) * wstride;
                st = atlasPosX * 4 + rePosX * 4 + dst;
                for (i = 0; i < drawh; i++) {
                    ret.set(pix.slice(st, st + draww * 4), width * 4 * (i + marginT) + marginL * 4);
                    st += wstride;
                }
                return ret;
            }
            var ctx = new ILaya.Context();
            ctx.size(width, height);
            ctx.asBitmap = true;
            var uv = null;
            if (x != 0 || y != 0 || width != tex2dw || height != tex2dh) {
                uv = this._uv.slice();
                var stu = uv[0];
                var stv = uv[1];
                var uvw = uv[2] - stu;
                var uvh = uv[7] - stv;
                var uk = uvw / texw;
                var vk = uvh / texh;
                uv = [stu + rePosX * uk, stv + rePosY * vk,
                    stu + (rePosX + draww) * uk, stv + rePosY * vk,
                    stu + (rePosX + draww) * uk, stv + (rePosY + drawh) * vk,
                    stu + rePosX * uk, stv + (rePosY + drawh) * vk];
            }
            ctx._drawTextureM(this, marginL, marginT, draww, drawh, null, 1.0, uv);
            ctx._targets.start();
            ctx.flush();
            ctx._targets.end();
            ctx._targets.restore();
            var dt = ctx._targets.getData(0, 0, width, height);
            ctx.destroy();
            ret = new Uint8Array(width * height * 4);
            st = 0;
            dst = (height - 1) * wstride;
            for (i = height - 1; i >= 0; i--) {
                ret.set(dt.slice(dst, dst + wstride), st);
                st += wstride;
                dst -= wstride;
            }
            return ret;
        }
        getPixels(x, y, width, height) {
            return this.getTexturePixels(x, y, width, height);
        }
        recoverBitmap(onok = null) {
            var url = this._bitmap.url;
            if (!this._destroyed && (!this._bitmap || this._bitmap.destroyed) && url) {
                ILaya.loader.load(url).then((tex) => {
                    this.bitmap = tex.bitmap;
                    onok && onok();
                });
            }
        }
        disposeBitmap() {
            if (!this._destroyed && this._bitmap) {
                this._bitmap.destroy();
            }
        }
        get valid() {
            return !this._destroyed && this._bitmap && !this._bitmap.destroyed;
        }
        get obsolute() {
            return this._obsolute || !this._bitmap || this._bitmap.destroyed || this._bitmap.obsolute;
        }
        set obsolute(value) {
            this._obsolute = value;
        }
        _disposeResource() {
            let bit = this._bitmap;
            this._bitmap = null;
            if (bit)
                bit._removeReference(this._referenceCount);
        }
        getCachedClip(x, y, width, height) {
            let key = `${x}_${y}_${width}_${height}`;
            if (!this.clipCache)
                this.clipCache = new Map();
            let tex = this.clipCache.get(key);
            if (tex)
                return tex;
            tex = Texture.createFromTexture(this, x, y, width, height);
            if (this.clipCache.size > 100)
                this.clipCache.clear();
            this.clipCache.set(key, tex);
            return tex;
        }
    }
    Texture.DEF_UV = new Float32Array([0, 0, 1.0, 0, 1.0, 1.0, 0, 1.0]);
    Texture.NO_UV = new Float32Array([0, 0, 0, 0, 0, 0, 0, 0]);
    Texture.INV_UV = new Float32Array([0, 1, 1.0, 1, 1.0, 0.0, 0, 0.0]);
    function moveUV(offsetX, offsetY, uv) {
        for (var i = 0; i < 8; i += 2) {
            uv[i] += offsetX;
            uv[i + 1] += offsetY;
        }
        return uv;
    }

    class StringKey {
        constructor() {
            this._strsToID = {};
            this._idToStrs = [];
            this._length = 0;
        }
        add(str) {
            var index = this._strsToID[str];
            if (index != null)
                return index;
            this._idToStrs[this._length] = str;
            return this._strsToID[str] = this._length++;
        }
        getID(str) {
            var index = this._strsToID[str];
            return index == null ? -1 : index;
        }
        getName(id) {
            var str = this._idToStrs[id];
            return str == null ? undefined : str;
        }
    }

    var _gid = 1;
    const _pi = 180 / Math.PI;
    const _pi2 = Math.PI / 180;
    class Utils {
        static toRadian(angle) {
            return angle * _pi2;
        }
        static toAngle(radian) {
            return radian * _pi;
        }
        static toHexColor(color) {
            if (color < 0 || isNaN(color))
                return null;
            var str = color.toString(16);
            while (str.length < 6)
                str = "0" + str;
            return "#" + str;
        }
        static fromStringColor(value) {
            if (!value)
                return 0;
            if (value.indexOf("rgba(") >= 0 || value.indexOf("rgb(") >= 0) {
                let p1 = value.indexOf("(");
                let p2 = value.indexOf(")");
                if (p1 == -1 || p2 == -1)
                    return 0;
                value = value.substring(p1 + 1, p2);
                let arr = value.split(",");
                let len = arr.length;
                for (let i = 0; i < len; i++) {
                    arr[i] = parseFloat(arr[i]);
                    if (isNaN(arr[i]))
                        arr[i] = 0;
                }
                if (arr.length == 4)
                    return (arr[0] << 24) + (arr[1] << 16) + (arr[2] << 8) + Math.round(arr[3] * 255);
                else
                    return (arr[0] << 16) + (arr[1] << 8) + arr[2];
            }
            else {
                value.charAt(0) === '#' && (value = value.substring(1));
                let len = value.length;
                if (len === 3 || len === 4) {
                    let temp = "";
                    for (let i = 0; i < len; i++) {
                        temp += (value[i] + value[i]);
                    }
                    value = temp;
                }
                return parseInt(value, 16);
            }
        }
        static getGID() {
            return _gid++;
        }
        static copyArray(source, array) {
            source || (source = []);
            if (!array)
                return source;
            source.length = array.length;
            var len = array.length;
            for (let i = 0; i < len; i++) {
                source[i] = array[i];
            }
            return source;
        }
        static transPointList(points, x, y) {
            var i, len = points.length;
            for (i = 0; i < len; i += 2) {
                points[i] += x;
                points[i + 1] += y;
            }
        }
        static parseInt(str, radix = 0) {
            var result = parseInt(str, radix);
            if (isNaN(result))
                return 0;
            return result;
        }
        static getBaseName(path) {
            let i = path.lastIndexOf("/");
            if (i != -1)
                path = path.substring(i + 1);
            i = path.indexOf("?");
            if (i != -1)
                path = path.substring(0, i);
            return path;
        }
        static getFileExtension(path) {
            let i = path.lastIndexOf(".");
            if (i != -1) {
                let ext = path.substring(i + 1).toLowerCase();
                let j = ext.indexOf("?");
                if (j != -1)
                    ext = ext.substring(0, j);
                if (ext === "ls") {
                    let k = path.lastIndexOf(".", i - 1);
                    if (k != -1) {
                        let ext2 = path.substring(k + 1, i + 1) + ext;
                        if (ext2 === "lanit.ls" || ext2 === "ltcb.ls")
                            return ext2;
                    }
                }
                return ext;
            }
            else
                return "";
        }
        static replaceFileExtension(path, newExt) {
            if (!path)
                return path;
            let i = path.lastIndexOf(".");
            if (newExt.length > 0)
                newExt = "." + newExt;
            if (i != -1) {
                let j = path.indexOf("?", i);
                if (j != -1)
                    return path.substring(0, i) + newExt + path.substring(j);
                else
                    return path.substring(0, i) + newExt;
            }
            else
                return path + newExt;
        }
    }
    Utils.parseXMLFromString = function (value) {
        var rst;
        value = value.replace(/>\s+</g, '><');
        rst = (new DOMParser()).parseFromString(value, 'text/xml');
        if (rst.firstChild.textContent.indexOf("This page contains the following errors") > -1) {
            throw new Error(rst.firstChild.firstChild.textContent);
        }
        return rst;
    };

    class AssetDb {
        constructor() {
            this.uuidMap = {};
            this.shaderNameMap = {};
            this.metaMap = {};
            this.enableImageMetaFile = false;
        }
        UUID_to_URL(uuid) {
            return this.uuidMap[uuid];
        }
        UUID_to_URL_async(uuid) {
            return null;
        }
        URL_to_UUID_async(url) {
            return null;
        }
        resolveURL(url, onResolve) {
            if (url.startsWith("res://")) {
                let uuid = url.substring(6);
                url = this.UUID_to_URL(uuid);
                if (url) {
                    onResolve(url);
                    return;
                }
                let promise = AssetDb.inst.UUID_to_URL_async(uuid);
                if (promise) {
                    promise.then(onResolve);
                    return;
                }
            }
            onResolve(url);
        }
        shaderName_to_URL(shaderName) {
            return this.shaderNameMap[shaderName];
        }
        shaderName_to_URL_async(shaderName) {
            console.warn(`unknown shaderName: ${shaderName}`);
            return null;
        }
        getMeta(url, uuid) {
            let meta = this.metaMap[url];
            if (meta)
                return meta;
            else if (this.enableImageMetaFile)
                return url + ".json";
            else
                return null;
        }
        getSubAssetURL(url, uuid, subAssetName, subAssetExt) {
            if (subAssetName)
                return `${Utils.replaceFileExtension(url, "")}@${subAssetName}.${subAssetExt}`;
            else
                return url;
        }
    }
    AssetDb.inst = new AssetDb();

    class URL {
        constructor(url) {
            this._url = URL.formatURL(url);
            this._path = URL.getPath(url);
        }
        static __init__() {
            URL.rootPath = URL.basePath = (location && location.protocol != undefined && location.protocol != "") ? URL.getPath(location.protocol + "//" + location.host + location.pathname) : "";
        }
        static initMiniGameExtensionOverrides() {
            if (!LayaEnv.isPlaying || LayaEnv.isPreview)
                return;
            URL.overrideExtension(["rendertexture", "videotexture"], "rt.json");
            URL.overrideExtension(["controller"], "controller.json");
            URL.overrideExtension(["mc"], "mc.bin");
            URL.overrideExtension(["mcc"], "mcc.json");
            URL.overrideExtension(["shader"], "shader.json");
            URL.overrideExtension(["scene3d", "scene", "taa", "prefab"], "json");
        }
        get url() {
            return this._url;
        }
        get path() {
            return this._path;
        }
        static formatURL(url, base) {
            if (!url)
                return base || URL.basePath || "";
            if (url.startsWith("res://")) {
                let uuid = url.substring(6);
                let url2 = AssetDb.inst.UUID_to_URL(uuid);
                if (!url2)
                    return url;
                url = url2;
            }
            let char1 = url.charCodeAt(0);
            if (url.indexOf(":") == -1 && char1 !== 47) {
                if (URL.customFormat != null)
                    url = URL.customFormat(url);
                if (char1 === 126)
                    url = URL.join(URL.rootPath, url.substring(2));
                else
                    url = URL.join(base != null ? base : URL.basePath, url);
            }
            return url;
        }
        static postFormatURL(url) {
            if (URL.hasExtOverrides) {
                let extold = Utils.getFileExtension(url);
                let ext = URL.overrideFileExts[extold];
                if (ext != null)
                    url = Utils.replaceFileExtension(url, ext);
            }
            return url;
        }
        static normalize(url) {
            if (url.indexOf("./") == -1)
                return url;
            let parts = url.split("/");
            let len = parts.length;
            let i = 0;
            while (i < len) {
                if (parts[i] == ".") {
                    parts.splice(i, 1);
                    len--;
                    continue;
                }
                else if (parts[i] == '..') {
                    let index = i - 1;
                    if (index >= 0 && parts[index] !== '..') {
                        parts.splice(index, 2);
                        len -= 2;
                        i--;
                        continue;
                    }
                }
                i++;
            }
            parts.length = len;
            return parts.join('/');
        }
        static getResURLByUUID(url) {
            if (url.length >= 36 && url.charCodeAt(8) === 45 && url.charCodeAt(13) === 45)
                return "res://" + url;
            else
                return url;
        }
        static join(base, path) {
            if (!path)
                return "";
            if (path.indexOf(":") > 0)
                return path;
            if (base) {
                let char1 = path.charCodeAt(0);
                if (char1 !== 126 && char1 !== 47) {
                    if (base.charCodeAt(base.length - 1) !== 47)
                        path = base + "/" + path;
                    else
                        path = base + path;
                }
            }
            return URL.normalize(path);
        }
        static getPath(url) {
            var ofs = url.lastIndexOf('/');
            return ofs > 0 ? url.substring(0, ofs + 1) : "";
        }
        static getFileName(url) {
            var ofs = url.lastIndexOf('/');
            return ofs > 0 ? url.substring(ofs + 1) : url;
        }
        static getURLVerion(url) {
            var index = url.indexOf("?");
            return index >= 0 ? url.substring(index) : null;
        }
        static overrideExtension(originalExts, targetExt) {
            for (let ext of originalExts)
                URL.overrideFileExts[ext] = targetExt;
            URL.hasExtOverrides = true;
        }
    }
    URL.version = {};
    URL.basePath = "";
    URL.rootPath = "";
    URL.overrideFileExts = {};
    URL.customFormat = function (url) {
        let ver = URL.version[url];
        if (!window.conch && ver != null) {
            if (url.indexOf("?") != -1) {
                if (url.indexOf("&v=") == -1 && url.indexOf("?v=") == -1)
                    url += "&v=" + ver;
            }
            else
                url += "?v=" + ver;
        }
        return url;
    };

    class IncludeFile {
        constructor(txt) {
            this.codes = {};
            this.funs = {};
            this.curUseID = -1;
            this.funnames = "";
            this.script = txt;
            var begin = 0, ofs, end;
            while (true) {
                begin = txt.indexOf("#begin", begin);
                if (begin < 0)
                    break;
                end = begin + 5;
                while (true) {
                    end = txt.indexOf("#end", end);
                    if (end < 0)
                        break;
                    if (txt.charAt(end + 4) === 'i')
                        end += 5;
                    else
                        break;
                }
                if (end < 0) {
                    throw "add include err,no #end:" + txt;
                }
                ofs = txt.indexOf('\n', begin);
                var words = IncludeFile.splitToWords(txt.substr(begin, ofs - begin), null);
                if (words[1] == 'code') {
                    this.codes[words[2]] = txt.substr(ofs + 1, end - ofs - 1);
                }
                else if (words[1] == 'function') {
                    ofs = txt.indexOf("function", begin);
                    ofs += "function".length;
                    this.funs[words[3]] = txt.substr(ofs + 1, end - ofs - 1);
                    this.funnames += words[3] + ";";
                }
                begin = end + 1;
            }
        }
        static splitToWords(str, block) {
            var out = [];
            var c;
            var ofs = -1;
            var word;
            for (var i = 0, n = str.length; i < n; i++) {
                c = str.charAt(i);
                if (" \t=+-*/&%!<>()'\",;".indexOf(c) >= 0) {
                    if (ofs >= 0 && (i - ofs) > 1) {
                        word = str.substr(ofs, i - ofs);
                        out.push(word);
                    }
                    if (c == '"' || c == "'") {
                        var ofs2 = str.indexOf(c, i + 1);
                        if (ofs2 < 0) {
                            throw "Sharder err:" + str;
                        }
                        out.push(str.substr(i + 1, ofs2 - i - 1));
                        i = ofs2;
                        ofs = -1;
                        continue;
                    }
                    if (c == '(' && block && out.length > 0) {
                        word = out[out.length - 1] + ";";
                        if ("vec4;main;".indexOf(word) < 0)
                            block.useFuns += word;
                    }
                    ofs = -1;
                    continue;
                }
                if (ofs < 0)
                    ofs = i;
            }
            if (ofs < n && (n - ofs) > 1) {
                word = str.substr(ofs, n - ofs);
                out.push(word);
            }
            return out;
        }
        getWith(name = null) {
            var r = name ? this.codes[name] : this.script;
            if (!r) {
                throw "get with error:" + name;
            }
            return r;
        }
        getFunsScript(funsdef) {
            var r = "";
            for (var i in this.funs) {
                if (funsdef.indexOf(i + ";") >= 0) {
                    r += this.funs[i];
                }
            }
            return r;
        }
    }

    class ShaderNode {
        constructor(includefiles) {
            this.childs = [];
            this.text = "";
            this.useFuns = "";
            this.z = 0;
            this.includefiles = includefiles;
        }
        setParent(parent) {
            parent.childs.push(this);
            this.z = parent.z + 1;
            this.parent = parent;
        }
        setCondition(condition, type) {
            if (condition) {
                this.conditionType = type;
                condition = condition.replace(/(\s*$)/g, "");
                this.condition = function () {
                    return this[condition];
                };
                this.condition.__condition = condition;
            }
        }
        toscript(def, out) {
            return this._toscript(def, out, ++ShaderNode.__id);
        }
        _toscript(def, out, id) {
            if (this.childs.length < 1 && !this.text)
                return out;
            out.length;
            if (this.condition) {
                var ifdef = !!this.condition.call(def);
                this.conditionType === 2 && (ifdef = !ifdef);
                if (!ifdef && ShaderNode.__noCompileEnable)
                    return out;
            }
            if (this.noCompile || !ShaderNode.__noCompileEnable)
                this.text && out.push(this.text);
            this.childs.length > 0 && this.childs.forEach(function (o, index, arr) {
                o._toscript(def, out, id);
            });
            if (this.includefiles.length > 0 && this.useFuns.length > 0) {
                var funsCode;
                for (var i = 0, n = this.includefiles.length; i < n; i++) {
                    if (this.includefiles[i].curUseID == id) {
                        continue;
                    }
                    funsCode = this.includefiles[i].file.getFunsScript(this.useFuns);
                    if (funsCode.length > 0) {
                        this.includefiles[i].curUseID = id;
                        out[0] = funsCode + out[0];
                    }
                }
            }
            return out;
        }
    }
    ShaderNode.__id = 1;
    ShaderNode.__noCompileEnable = true;

    const _clearCR = new RegExp("\r", "g");
    const _splitToWordExps3 = new RegExp("[ \\t=\\+\\-*/&%!<>!%\(\),;\\|]", "g");
    class ShaderCompile {
        static addInclude(fileName, txt, allowReplace) {
            if (!txt || txt.length === 0) {
                console.error("shader include file err:" + fileName);
                return null;
            }
            if (!allowReplace && ShaderCompile.includes[fileName]) {
                console.warn("shader include file already exists:" + fileName);
                return ShaderCompile.includes[fileName];
            }
            txt = txt.replace(_clearCR, "");
            let file = new IncludeFile(txt);
            ShaderCompile.includes[fileName] = file;
            return file;
        }
        static compile(vs, ps, basePath) {
            let result = {
                vsNode: new ShaderNode([]),
                psNode: new ShaderNode([]),
                includeNames: new Set(),
                defs: new Set()
            };
            let includes = [];
            vs = vs.replace(_clearCR, "");
            ps = ps.replace(_clearCR, "");
            ShaderCompile._compileToTree(result.vsNode, vs, result.defs, includes, basePath);
            ShaderCompile._compileToTree(result.psNode, ps, result.defs, includes, basePath);
            for (let inc of includes) {
                if (inc.file)
                    result.includeNames.add(inc.name);
                else
                    console.warn(`ShaderCompile missing file ${inc.name}`);
            }
            return result;
        }
        static compileAsync(vs, ps, basePath) {
            let result = {
                vsNode: new ShaderNode([]),
                psNode: new ShaderNode([]),
                includeNames: new Set(),
                defs: new Set()
            };
            let includes = [];
            vs = vs.replace(_clearCR, "");
            ps = ps.replace(_clearCR, "");
            ShaderCompile._compileToTree(result.vsNode, vs, result.defs, includes, basePath);
            ShaderCompile._compileToTree(result.psNode, ps, result.defs, includes, basePath);
            return this._loadIncludesDeep(result, includes, 0);
        }
        static _loadIncludesDeep(result, includes, index) {
            let toLoad;
            let includesCnt = includes.length;
            for (let i = index; i < includesCnt; i++) {
                let inc = includes[i];
                if (inc.file)
                    result.includeNames.add(inc.name);
                else {
                    if (!toLoad)
                        toLoad = [];
                    toLoad.push(inc);
                }
            }
            if (!toLoad)
                return Promise.resolve(result);
            return ILaya.loader.load(toLoad.map(tc => tc.name)).then(files => {
                let cnt = toLoad.length;
                for (let i = 0; i < cnt; i++) {
                    let inc = toLoad[i];
                    let file = files[i];
                    if (!file) {
                        let childs = inc.node.parent.childs;
                        childs.splice(childs.indexOf(inc.node), 1);
                    }
                    else {
                        result.includeNames.add(inc.name);
                        let text = file.getWith(inc.codeName);
                        if (inc.node.condition)
                            inc.node.text = text;
                        else {
                            ShaderCompile._compileToTree(inc.node, text, result.defs, includes, URL.getPath(inc.name));
                            inc.node.text = "";
                        }
                    }
                }
                if (includes.length > includesCnt)
                    return ShaderCompile._loadIncludesDeep(result, includes, includesCnt);
                else
                    return result;
            });
        }
        static _compileToTree(parent, script, defs, includes, basePath) {
            let node, preNode;
            let text, name, fname;
            let ofs, words;
            let i, n, j;
            let lines = script.split("\n");
            for (i = 0; i < lines.length; i++) {
                text = lines[i];
                if (text.length < 1)
                    continue;
                ofs = text.indexOf("//");
                if (ofs === 0)
                    continue;
                if (ofs >= 0)
                    text = text.substr(0, ofs);
                if ((ofs = text.indexOf("#")) < 0) {
                    preNode = parent.childs[parent.childs.length - 1];
                    let includefiles = parent.includefiles;
                    if (preNode && !preNode.name) {
                        includefiles.length > 0 && IncludeFile.splitToWords(text, preNode);
                        preNode.text += "\n" + text;
                        continue;
                    }
                    node = new ShaderNode(includefiles);
                    node.text = text;
                    node.noCompile = true;
                    includefiles.length > 0 && IncludeFile.splitToWords(text, node);
                    node.setParent(parent);
                    continue;
                }
                node = new ShaderNode(parent.includefiles);
                node.text = text;
                node.noCompile = true;
                name = "#";
                for (j = ofs + 1, n = text.length; j < n; j++) {
                    let c = text.charAt(j);
                    if (c === ' ' || c === '\t' || c === '?')
                        break;
                    name += c;
                }
                node.name = name;
                switch (name) {
                    case "#ifdef":
                    case "#ifndef":
                        node.src = text;
                        node.noCompile = text.match(/[!&|()=<>]/) != null;
                        if (!node.noCompile) {
                            words = text.replace(/^\s*/, '').split(/\s+/);
                            node.setCondition(words[1], name === "#ifdef" ? ShaderCompile.IFDEF_YES : ShaderCompile.IFDEF_ELSE);
                            node.text = node.text;
                        }
                        else {
                            console.log("function():Boolean{return " + text.substr(ofs + node.name.length) + "}");
                        }
                        node.setParent(parent);
                        parent = node;
                        words = text.substr(j).split(_splitToWordExps3);
                        for (j = 0; j < words.length; j++) {
                            text = words[j];
                            text.length && defs.add(text);
                        }
                        break;
                    case "#if":
                    case "#elif":
                        node.src = text;
                        node.noCompile = true;
                        if (name == "#elif") {
                            parent = parent.parent;
                            preNode = parent.childs[parent.childs.length - 1];
                            preNode.text = preNode.src;
                            preNode.noCompile = true;
                            preNode.condition = null;
                        }
                        node.setParent(parent);
                        parent = node;
                        words = text.substr(j).split(_splitToWordExps3);
                        for (j = 0; j < words.length; j++) {
                            text = words[j];
                            text.length && text != "defined" && defs.add(text);
                        }
                        break;
                    case "#else":
                        node.src = text;
                        parent = parent.parent;
                        preNode = parent.childs[parent.childs.length - 1];
                        node.noCompile = preNode.noCompile;
                        if (!node.noCompile) {
                            node.condition = preNode.condition;
                            node.conditionType = preNode.conditionType == ShaderCompile.IFDEF_YES ? ShaderCompile.IFDEF_ELSE : ShaderCompile.IFDEF_YES;
                        }
                        node.setParent(parent);
                        parent = node;
                        break;
                    case "#endif":
                        parent = parent.parent;
                        preNode = parent.childs[parent.childs.length - 1];
                        node.noCompile = preNode.noCompile;
                        if (!node.noCompile) {
                            node.text = node.text;
                        }
                        node.setParent(parent);
                        break;
                    case "#include":
                        words = IncludeFile.splitToWords(text, null);
                        let includeName = words[1];
                        let includeFile;
                        if (includeName.startsWith("."))
                            includeName = URL.join(basePath, includeName);
                        includeFile = ShaderCompile.includes[includeName];
                        if (!includeFile && ShaderCompile.loadIncludeFileSync) {
                            ShaderCompile.loadIncludeFileSync(includeName);
                            includeFile = ShaderCompile.includes[includeName];
                        }
                        let codeName = words[2] == 'with' ? words[3] : null;
                        includes.push({ name: includeName, codeName: codeName, node: node, file: includeFile });
                        node.setParent(parent);
                        if ((ofs = words[0].indexOf("?")) < 0) {
                            if (includeFile) {
                                text = includeFile.getWith(codeName);
                                this._compileToTree(node, text, defs, includes, URL.getPath(includeName));
                            }
                            node.text = "";
                        }
                        else {
                            node.setCondition(words[0].substr(ofs + 1), ShaderCompile.IFDEF_YES);
                            if (includeFile)
                                node.text = includeFile.getWith(codeName);
                        }
                        break;
                    case "#import":
                        words = IncludeFile.splitToWords(text, null);
                        fname = words[1];
                        node.includefiles.push({ node: node, file: ShaderCompile.includes[fname], ofs: node.text.length });
                        break;
                    default:
                        node.setParent(parent);
                        break;
                }
            }
        }
    }
    ShaderCompile.IFDEF_NO = 0;
    ShaderCompile.IFDEF_YES = 1;
    ShaderCompile.IFDEF_ELSE = 2;
    ShaderCompile.IFDEF_PARENT = 3;
    ShaderCompile.includes = {};

    class Shader extends BaseShader {
        constructor(vs, ps, saveName = null, nameMap = null, bindAttrib = null) {
            super();
            this._attribInfo = null;
            this._curActTexIndex = 0;
            this.tag = {};
            this._program = null;
            this._params = null;
            this._paramsMap = {};
            if ((!vs) || (!ps))
                throw "Shader Error";
            this._attribInfo = bindAttrib;
            this._id = ++Shader._count;
            this._vs = vs;
            this._ps = ps;
            this._nameMap = nameMap ? nameMap : {};
            saveName != null && (Shader.sharders[saveName] = this);
            this.recreateResource();
            this.lock = true;
            this._render2DContext = LayaGL.render2DContext;
        }
        static create(vs, ps, saveName = null, nameMap = null, bindAttrib = null) {
            return new Shader(vs, ps, saveName, nameMap, bindAttrib);
        }
        static withCompile2D(nameID, mainID, define, shaderName, createShader, bindAttrib = null) {
            if (shaderName && Shader.sharders[shaderName])
                return Shader.sharders[shaderName];
            var pre = Shader._preCompileShader[Shader.SHADERNAME2ID * nameID + mainID];
            if (!pre)
                throw new Error("withCompile shader err!" + nameID + " " + mainID);
            var defMap = {};
            var defineStr = "";
            if (define) {
                for (var i in define) {
                    defineStr += "#define " + i + "\n";
                    defMap[i] = true;
                }
            }
            var vs = pre.vsNode.toscript(defMap, []);
            var ps = pre.psNode.toscript(defMap, []);
            return (createShader
                || Shader.create)(defineStr + vs.join('\n'), defineStr + ps.join('\n'), shaderName, pre.nameMap, bindAttrib);
        }
        static addInclude(fileName, txt) {
            ShaderCompile.addInclude(fileName, txt);
        }
        static preCompile(nameID, vs, ps, nameMap) {
            let id = Shader.SHADERNAME2ID * nameID;
            let obj = ShaderCompile.compile(vs, ps);
            obj.nameMap = nameMap;
            Shader._preCompileShader[id] = obj;
        }
        static preCompile2D(nameID, mainID, vs, ps, nameMap) {
            let id = Shader.SHADERNAME2ID * nameID + mainID;
            let obj = ShaderCompile.compile(vs, ps);
            obj.nameMap = nameMap;
            Shader._preCompileShader[id] = obj;
        }
        recreateResource() {
            this._compile();
            this._setGPUMemory(0);
        }
        _disposeResource() {
            RenderStateContext.mainContext.deleteShader(this._vshader);
            RenderStateContext.mainContext.deleteShader(this._pshader);
            RenderStateContext.mainContext.deleteProgram(this._program);
            this._vshader = this._pshader = this._program = null;
            this._params = null;
            this._paramsMap = {};
            this._setGPUMemory(0);
            this._curActTexIndex = 0;
        }
        _compile() {
            if (!this._vs || !this._ps || this._params)
                return;
            this._reCompile = true;
            this._params = [];
            var gl = RenderStateContext.mainContext;
            this._program = gl.createProgram();
            this._vshader = Shader._createShader(gl, this._vs, gl.VERTEX_SHADER);
            this._pshader = Shader._createShader(gl, this._ps, gl.FRAGMENT_SHADER);
            gl.attachShader(this._program, this._vshader);
            gl.attachShader(this._program, this._pshader);
            var one, i, n, location;
            var attribDescNum = this._attribInfo ? this._attribInfo.length : 0;
            for (i = 0; i < attribDescNum; i += 2) {
                gl.bindAttribLocation(this._program, this._attribInfo[i + 1], this._attribInfo[i]);
            }
            gl.linkProgram(this._program);
            if (!gl.getProgramParameter(this._program, gl.LINK_STATUS)) {
                throw gl.getProgramInfoLog(this._program);
            }
            var nUniformNum = gl.getProgramParameter(this._program, gl.ACTIVE_UNIFORMS);
            for (i = 0; i < nUniformNum; i++) {
                var uniform = gl.getActiveUniform(this._program, i);
                location = gl.getUniformLocation(this._program, uniform.name);
                one = { vartype: "uniform", glfun: null, ivartype: 1, location: location, name: uniform.name, type: uniform.type, isArray: false, isSame: false, preValue: null, indexOfParams: 0 };
                if (one.name.indexOf('[0]') > 0) {
                    one.name = one.name.substr(0, one.name.length - 3);
                    one.isArray = true;
                    one.location = gl.getUniformLocation(this._program, one.name);
                }
                this._params.push(one);
            }
            for (i = 0, n = this._params.length; i < n; i++) {
                one = this._params[i];
                one.indexOfParams = i;
                one.index = 1;
                one.value = [one.location, null];
                one.codename = one.name;
                one.name = this._nameMap[one.codename] ? this._nameMap[one.codename] : one.codename;
                this._paramsMap[one.name] = one;
                one._this = this;
                one.uploadedValue = [];
                switch (one.type) {
                    case gl.INT:
                        one.fun = one.isArray ? this._uniform1iv : this._uniform1i;
                        break;
                    case gl.FLOAT:
                        one.fun = one.isArray ? this._uniform1fv : this._uniform1f;
                        break;
                    case gl.FLOAT_VEC2:
                        one.fun = one.isArray ? this._uniform_vec2v : this._uniform_vec2;
                        break;
                    case gl.FLOAT_VEC3:
                        one.fun = one.isArray ? this._uniform_vec3v : this._uniform_vec3;
                        break;
                    case gl.FLOAT_VEC4:
                        one.fun = one.isArray ? this._uniform_vec4v : this._uniform_vec4;
                        break;
                    case gl.SAMPLER_2D:
                        one.fun = this._uniform_sampler2D;
                        break;
                    case gl.SAMPLER_CUBE:
                        one.fun = this._uniform_samplerCube;
                        break;
                    case gl.FLOAT_MAT4:
                        one.glfun = gl.uniformMatrix4fv;
                        one.fun = this._uniformMatrix4fv;
                        break;
                    case gl.BOOL:
                        one.fun = this._uniform1i;
                        break;
                    case gl.FLOAT_MAT2:
                    case gl.FLOAT_MAT3:
                        throw new Error("compile shader err!");
                    default:
                        throw new Error("compile shader err!");
                }
            }
        }
        static _createShader(gl, str, type) {
            var shader = gl.createShader(type);
            gl.shaderSource(shader, str);
            gl.compileShader(shader);
            if (gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                return shader;
            }
            else {
                console.log(gl.getShaderInfoLog(shader));
                return null;
            }
        }
        getUniform(name) {
            return this._paramsMap[name];
        }
        _uniform1f(one, value) {
            var uploadedValue = one.uploadedValue;
            if (uploadedValue[0] !== value) {
                RenderStateContext.mainContext.uniform1f(one.location, uploadedValue[0] = value);
                return 1;
            }
            return 0;
        }
        _uniform1fv(one, value) {
            if (value.length < 4) {
                var uploadedValue = one.uploadedValue;
                if (uploadedValue[0] !== value[0] || uploadedValue[1] !== value[1] || uploadedValue[2] !== value[2] || uploadedValue[3] !== value[3]) {
                    RenderStateContext.mainContext.uniform1fv(one.location, value);
                    uploadedValue[0] = value[0];
                    uploadedValue[1] = value[1];
                    uploadedValue[2] = value[2];
                    uploadedValue[3] = value[3];
                    return 1;
                }
                return 0;
            }
            else {
                RenderStateContext.mainContext.uniform1fv(one.location, value);
                return 1;
            }
        }
        _uniform_vec2(one, value) {
            var uploadedValue = one.uploadedValue;
            if (uploadedValue[0] !== value[0] || uploadedValue[1] !== value[1]) {
                RenderStateContext.mainContext.uniform2f(one.location, uploadedValue[0] = value[0], uploadedValue[1] = value[1]);
                return 1;
            }
            return 0;
        }
        _uniform_vec2v(one, value) {
            if (value.length < 2) {
                var uploadedValue = one.uploadedValue;
                if (uploadedValue[0] !== value[0] || uploadedValue[1] !== value[1] || uploadedValue[2] !== value[2] || uploadedValue[3] !== value[3]) {
                    RenderStateContext.mainContext.uniform2fv(one.location, value);
                    uploadedValue[0] = value[0];
                    uploadedValue[1] = value[1];
                    uploadedValue[2] = value[2];
                    uploadedValue[3] = value[3];
                    return 1;
                }
                return 0;
            }
            else {
                RenderStateContext.mainContext.uniform2fv(one.location, value);
                return 1;
            }
        }
        _uniform_vec3(one, value) {
            var uploadedValue = one.uploadedValue;
            if (uploadedValue[0] !== value[0] || uploadedValue[1] !== value[1] || uploadedValue[2] !== value[2]) {
                RenderStateContext.mainContext.uniform3f(one.location, uploadedValue[0] = value[0], uploadedValue[1] = value[1], uploadedValue[2] = value[2]);
                return 1;
            }
            return 0;
        }
        _uniform_vec3v(one, value) {
            RenderStateContext.mainContext.uniform3fv(one.location, value);
            return 1;
        }
        _uniform_vec4(one, value) {
            var uploadedValue = one.uploadedValue;
            if (uploadedValue[0] !== value[0] || uploadedValue[1] !== value[1] || uploadedValue[2] !== value[2] || uploadedValue[3] !== value[3]) {
                RenderStateContext.mainContext.uniform4f(one.location, uploadedValue[0] = value[0], uploadedValue[1] = value[1], uploadedValue[2] = value[2], uploadedValue[3] = value[3]);
                return 1;
            }
            return 0;
        }
        _uniform_vec4v(one, value) {
            RenderStateContext.mainContext.uniform4fv(one.location, value);
            return 1;
        }
        _uniformMatrix4fv(one, value) {
            RenderStateContext.mainContext.uniformMatrix4fv(one.location, false, value);
            return 1;
        }
        _uniform1i(one, value) {
            var uploadedValue = one.uploadedValue;
            if (uploadedValue[0] !== value) {
                RenderStateContext.mainContext.uniform1i(one.location, uploadedValue[0] = value);
                return 1;
            }
            return 0;
        }
        _uniform1iv(one, value) {
            RenderStateContext.mainContext.uniform1iv(one.location, value);
            return 1;
        }
        _uniform_sampler2D(one, value) {
            var gl = RenderStateContext.mainContext;
            var uploadedValue = one.uploadedValue;
            if (uploadedValue[0] == null) {
                uploadedValue[0] = this._curActTexIndex;
                gl.uniform1i(one.location, this._curActTexIndex);
                this._render2DContext.activeTexture(gl.TEXTURE0 + this._curActTexIndex);
                this._render2DContext.bindTexture(gl.TEXTURE_2D, value);
                this._curActTexIndex++;
                return 1;
            }
            else {
                this._render2DContext.activeTexture(gl.TEXTURE0 + uploadedValue[0]);
                this._render2DContext.bindTexture(gl.TEXTURE_2D, value);
                return 0;
            }
        }
        _uniform_samplerCube(one, value) {
            var gl = RenderStateContext.mainContext;
            var uploadedValue = one.uploadedValue;
            if (uploadedValue[0] == null) {
                uploadedValue[0] = this._curActTexIndex;
                gl.uniform1i(one.location, this._curActTexIndex);
                this._render2DContext.activeTexture(gl.TEXTURE0 + this._curActTexIndex);
                this._render2DContext.bindTexture(gl.TEXTURE_CUBE_MAP, value);
                this._curActTexIndex++;
                return 1;
            }
            else {
                this._render2DContext.activeTexture(gl.TEXTURE0 + uploadedValue[0]);
                this._render2DContext.bindTexture(gl.TEXTURE_CUBE_MAP, value);
                return 0;
            }
        }
        uploadTexture2D(value) {
            this._render2DContext.bindTexture(RenderStateContext.mainContext.TEXTURE_2D, value);
        }
        upload(shaderValue, params = null) {
            BaseShader.activeShader = BaseShader.bindShader = this;
            this._render2DContext.bindUseProgram(this._program);
            if (this._reCompile) {
                params = this._params;
                this._reCompile = false;
            }
            else {
                params = params || this._params;
            }
            var one, value, n = params.length, shaderCall = 0;
            for (var i = 0; i < n; i++) {
                one = params[i];
                if ((value = shaderValue[one.name]) !== null)
                    shaderCall += one.fun.call(this, one, value);
            }
        }
    }
    Shader._count = 0;
    Shader._preCompileShader = {};
    Shader.SHADERNAME2ID = 0.0002;
    Shader.nameKey = new StringKey();
    Shader.sharders = new Array(0x20);

    class Shader2X extends Shader {
        constructor(vs, ps, saveName = null, nameMap = null, bindAttrib = null) {
            super(vs, ps, saveName, nameMap, bindAttrib);
            this._params2dQuick2 = null;
            this._shaderValueWidth = 0;
            this._shaderValueHeight = 0;
        }
        _disposeResource() {
            super._disposeResource();
            this._params2dQuick2 = null;
        }
        upload2dQuick2(shaderValue) {
            this.upload(shaderValue, this._params2dQuick2 || this._make2dQuick2());
        }
        _make2dQuick2() {
            if (!this._params2dQuick2) {
                this._params2dQuick2 = [];
                var params = this._params, one;
                for (var i = 0, n = params.length; i < n; i++) {
                    one = params[i];
                    if (one.name !== "size")
                        this._params2dQuick2.push(one);
                }
            }
            return this._params2dQuick2;
        }
        static create(vs, ps, saveName = null, nameMap = null, bindAttrib = null) {
            return new Shader2X(vs, ps, saveName, nameMap, bindAttrib);
        }
    }

    class Value2D {
        constructor(mainID, subID) {
            this.defines = new ShaderDefines2D();
            this.size = [0, 0];
            this.alpha = 1.0;
            this.ALPHA = 1.0;
            this.subID = 0;
            this.ref = 1;
            this._cacheID = 0;
            this.clipMatDir = [Const.MAX_CLIP_SIZE, 0, 0, Const.MAX_CLIP_SIZE];
            this.clipMatPos = [0, 0];
            this.clipOff = [0, 0];
            this.mainID = mainID;
            this.subID = subID;
            this.textureHost = null;
            this.texture = null;
            this.color = null;
            this.colorAdd = null;
            this.u_mmat2 = null;
            this._cacheID = mainID | subID;
            this._inClassCache = Value2D._cache[this._cacheID];
            if (mainID > 0 && !this._inClassCache) {
                this._inClassCache = Value2D._cache[this._cacheID] = [];
                this._inClassCache._length = 0;
            }
            this.clear();
        }
        static _initone(type, classT) {
            Value2D._typeClass[type] = classT;
            Value2D._cache[type] = [];
            Value2D._cache[type]._length = 0;
        }
        static create(mainType, subType) {
            var types = Value2D._cache[mainType | subType];
            if (types._length)
                return types[--types._length];
            else
                return new Value2D._typeClass[mainType | subType](subType);
        }
        static __init__() {
        }
        setValue(value) { }
        _ShaderWithCompile() {
            var ret = Shader.withCompile2D(0, this.mainID, this.defines.toNameDic(), this.mainID | this.defines._value, Shader2X.create, this._attribLocation);
            return ret;
        }
        upload() {
            var renderstate2d = RenderState2D;
            RenderState2D.worldMatrix4 === RenderState2D.TEMPMAT4_ARRAY || this.defines.addInt(ShaderDefines2D.WORLDMAT);
            this.mmat = renderstate2d.worldMatrix4;
            if (RenderState2D.matWVP) {
                this.defines.addInt(ShaderDefines2D.MVP3D);
                this.u_MvpMatrix = RenderState2D.matWVP.elements;
            }
            let returnGamma = !(RenderTexture2D.currentActive);
            if (returnGamma && this.textureHost) {
                if (this.textureHost instanceof RenderTexture2D) {
                    returnGamma = this.textureHost.gammaCorrection == 1;
                }
                else if (this.textureHost instanceof Texture) {
                    returnGamma = this.textureHost.bitmap.gammaCorrection == 1;
                }
            }
            if (returnGamma) {
                this.defines.addInt(ShaderDefines2D.GAMMASPACE);
            }
            else {
                this.defines.remove(ShaderDefines2D.GAMMASPACE);
            }
            if (RenderState2D.InvertY) {
                this.defines.addInt(ShaderDefines2D.INVERTY);
            }
            else {
                this.defines.remove(ShaderDefines2D.INVERTY);
            }
            var sd = Shader.sharders[this.mainID | this.defines._value] || this._ShaderWithCompile();
            if (sd._shaderValueWidth !== renderstate2d.width || sd._shaderValueHeight !== renderstate2d.height) {
                this.size[0] = renderstate2d.width;
                this.size[1] = renderstate2d.height;
                sd._shaderValueWidth = renderstate2d.width;
                sd._shaderValueHeight = renderstate2d.height;
                sd.upload(this, null);
            }
            else {
                sd.upload(this, sd._params2dQuick2 || sd._make2dQuick2());
            }
        }
        setFilters(value) {
            this.filters = value;
            if (!value)
                return;
            var n = value.length, f;
            for (var i = 0; i < n; i++) {
                f = value[i];
                if (f) {
                    this.defines.add(f.type);
                    f.action.setValue(this);
                }
            }
        }
        clear() {
            this.defines._value = this.subID;
            this.clipOff[0] = 0;
        }
        release() {
            if ((--this.ref) < 1) {
                this._inClassCache && (this._inClassCache[this._inClassCache._length++] = this);
                this.clear();
                this.filters = null;
                this.ref = 1;
                this.clipOff[0] = 0;
            }
        }
    }
    Value2D._cache = [];
    Value2D._typeClass = [];
    Value2D.TEMPMAT4_ARRAY = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];

    class SubmitKey {
        constructor() {
            this.clear();
        }
        clear() {
            this.submitType = -1;
            this.blendShader = this.other = 0;
        }
        copyFrom(src) {
            this.other = src.other;
            this.blendShader = src.blendShader;
            this.submitType = src.submitType;
        }
        copyFrom2(src, submitType, other) {
            this.other = other;
            this.submitType = submitType;
        }
        equal3_2(next, submitType, other) {
            return this.submitType === submitType && this.other === other && this.blendShader === next.blendShader;
        }
        equal4_2(next, submitType, other) {
            return this.submitType === submitType && this.other === other && this.blendShader === next.blendShader;
        }
        equal_3(next) {
            return this.submitType === next.submitType && this.blendShader === next.blendShader;
        }
        equal(next) {
            return this.other === next.other && this.submitType === next.submitType && this.blendShader === next.blendShader;
        }
    }

    class SubmitCMD {
        constructor() {
            this._ref = 1;
            this._key = new SubmitKey();
        }
        renderSubmit() {
            this.fun.apply(this._this, this.args);
            return 1;
        }
        getRenderType() {
            return 0;
        }
        releaseRender() {
            if ((--this._ref) < 1) {
                var pool = SubmitCMD.POOL;
                pool[pool._length++] = this;
                this.args = null;
                this.fun = null;
                this._this = null;
            }
        }
        static create(args, fun, thisobj) {
            var o = SubmitCMD.POOL._length ? SubmitCMD.POOL[--SubmitCMD.POOL._length] : new SubmitCMD();
            o.fun = fun;
            o.args = args;
            o._this = thisobj;
            o._ref = 1;
            o._key.clear();
            return o;
        }
    }
    SubmitCMD.POOL = [];
    {
        SubmitCMD.POOL._length = 0;
    }

    class Filter {
        constructor() { }
        get type() { return -1; }
    }
    Filter.BLUR = 0x10;
    Filter.COLOR = 0x20;
    Filter.GLOW = 0x08;
    Filter._filter = function (sprite, context, x, y) {
        var webglctx = context;
        var next = this._next;
        if (next) {
            var filters = sprite.filters, len = filters.length;
            if (len == 1 && (filters[0].type == Filter.COLOR)) {
                context.save();
                context.setColorFilter(filters[0]);
                next._fun.call(next, sprite, context, x, y);
                context.restore();
                return;
            }
            var svCP = Value2D.create(ShaderDefines2D.TEXTURE2D, 0);
            var b;
            var p = Point.TEMP;
            var tMatrix = webglctx._curMat;
            var mat = Matrix.create();
            tMatrix.copyTo(mat);
            var tPadding = 0;
            var tHalfPadding = 0;
            var tIsHaveGlowFilter = false;
            var source = null;
            var out = sprite._cacheStyle.filterCache || null;
            if (!out || sprite.getRepaint() != 0) {
                tIsHaveGlowFilter = sprite._isHaveGlowFilter();
                if (tIsHaveGlowFilter) {
                    tPadding = 50;
                    tHalfPadding = 25;
                }
                b = new Rectangle();
                b.copyFrom(sprite.getSelfBounds());
                b.x += sprite.x;
                b.y += sprite.y;
                b.x -= sprite.pivotX + 4;
                b.y -= sprite.pivotY + 4;
                var tSX = b.x;
                var tSY = b.y;
                b.width += (tPadding + 8);
                b.height += (tPadding + 8);
                p.x = b.x * mat.a + b.y * mat.c;
                p.y = b.y * mat.d + b.x * mat.b;
                b.x = p.x;
                b.y = p.y;
                p.x = b.width * mat.a + b.height * mat.c;
                p.y = b.height * mat.d + b.width * mat.b;
                b.width = p.x;
                b.height = p.y;
                if (b.width <= 0 || b.height <= 0) {
                    return;
                }
                out && WebGLRTMgr.releaseRT(out);
                source = WebGLRTMgr.getRT(b.width, b.height);
                var outRT = out = WebGLRTMgr.getRT(b.width, b.height);
                sprite._getCacheStyle().filterCache = out;
                webglctx.pushRT();
                webglctx.useRT(source);
                var tX = sprite.x - tSX + tHalfPadding;
                var tY = sprite.y - tSY + tHalfPadding;
                next._fun.call(next, sprite, context, tX, tY);
                webglctx.useRT(outRT);
                for (var i = 0; i < len; i++) {
                    if (i != 0) {
                        webglctx.useRT(source);
                        webglctx.drawTarget(outRT, 0, 0, b.width, b.height, Matrix.TEMP.identity(), svCP, null, BlendMode.TOINT.overlay);
                        webglctx.useRT(outRT);
                    }
                    var fil = filters[i];
                    switch (fil.type) {
                        case Filter.BLUR:
                            fil._glRender && fil._glRender.render(source, context, b.width, b.height, fil);
                            break;
                        case Filter.GLOW:
                            fil._glRender && fil._glRender.render(source, context, b.width, b.height, fil);
                            break;
                        case Filter.COLOR:
                            webglctx.setColorFilter(fil);
                            webglctx.drawTarget(source, 0, 0, b.width, b.height, Matrix.EMPTY.identity(), Value2D.create(ShaderDefines2D.TEXTURE2D, 0));
                            webglctx.setColorFilter(null);
                            break;
                    }
                }
                webglctx.popRT();
            }
            else {
                tIsHaveGlowFilter = sprite._isHaveGlowFilter() || false;
                if (tIsHaveGlowFilter) {
                    tPadding = 50;
                    tHalfPadding = 25;
                }
                b = sprite.getBounds();
                if (b.width <= 0 || b.height <= 0) {
                    return;
                }
                b.width += (tPadding + 8);
                b.height += (tPadding + 8);
                b.x -= sprite.pivotX + 4;
                b.y -= sprite.pivotY + 4;
                p.x = b.x * mat.a + b.y * mat.c;
                p.y = b.y * mat.d + b.x * mat.b;
                b.x = p.x;
                b.y = p.y;
                p.x = b.width * mat.a + b.height * mat.c;
                p.y = b.height * mat.d + b.width * mat.b;
                b.width = p.x;
                b.height = p.y;
            }
            x = x - tHalfPadding - sprite.x;
            y = y - tHalfPadding - sprite.y;
            p.setTo(x, y);
            mat.transformPoint(p);
            x = p.x + b.x;
            y = p.y + b.y;
            webglctx._drawRenderTexture(out, x, y, b.width, b.height, Matrix.TEMP.identity(), 1.0, RenderTexture2D.defuv);
            if (source) {
                var submit = SubmitCMD.create([source], function (s) {
                    s.destroy();
                }, this);
                source = null;
                context.addRenderObject(submit);
            }
            mat.destroy();
        }
    };

    const _COLOR_MAP = { "purple": "#800080", "orange": "#ffa500", "white": '#FFFFFF', "red": '#FF0000', "green": '#00FF00', "blue": '#0000FF', "black": '#000000', "yellow": '#FFFF00', 'gray': '#808080' };
    class ColorUtils {
        constructor(value) {
            this.arrColor = [];
            if (value == null || value == 'none') {
                this.strColor = "#00000000";
                this.numColor = 0;
                this.arrColor = [0, 0, 0, 0];
                return;
            }
            let color;
            if (typeof (value) == 'string') {
                color = Utils.fromStringColor(value);
                this.strColor = value;
            }
            else {
                color = value;
                this.strColor = Utils.toHexColor(color);
            }
            if (this.strColor.indexOf("rgba") >= 0 || this.strColor.length === 9) {
                this.arrColor = [((0xFF000000 & color) >>> 24) / 255, ((0xFF0000 & color) >> 16) / 255, ((0xFF00 & color) >> 8) / 255, (0xFF & color) / 255];
                this.numColor = (0xff000000 & color) >>> 24 | (color & 0xff0000) >> 8 | (color & 0x00ff00) << 8 | ((color & 0xff) << 24);
            }
            else {
                this.arrColor = [((0xFF0000 & color) >> 16) / 255, ((0xFF00 & color) >> 8) / 255, (0xFF & color) / 255, 1];
                this.numColor = 0xff000000 | (color & 0xff0000) >> 16 | (color & 0x00ff00) | (color & 0xff) << 16;
            }
        }
        static _initDefault() {
            ColorUtils._DEFAULT = {};
            for (var i in _COLOR_MAP)
                ColorUtils._SAVE[i] = ColorUtils._DEFAULT[i] = new ColorUtils(_COLOR_MAP[i]);
            return ColorUtils._DEFAULT;
        }
        static _initSaveMap() {
            ColorUtils._SAVE_SIZE = 0;
            ColorUtils._SAVE = Object.assign({}, ColorUtils._DEFAULT);
        }
        static create(value) {
            let key = value + "";
            let color = ColorUtils._SAVE[key];
            if (color != null)
                return color;
            if (ColorUtils._SAVE_SIZE > 500)
                ColorUtils._initSaveMap();
            ColorUtils._SAVE_SIZE++;
            return ColorUtils._SAVE[key] = new ColorUtils(value);
        }
    }
    ColorUtils._SAVE = {};
    ColorUtils._SAVE_SIZE = 0;
    ColorUtils._DEFAULT = ColorUtils._initDefault();

    const DELTA_INDEX = [0, 0.01, 0.02, 0.04, 0.05, 0.06, 0.07, 0.08, 0.1, 0.11, 0.12, 0.14, 0.15, 0.16, 0.17, 0.18, 0.20, 0.21, 0.22, 0.24, 0.25, 0.27, 0.28, 0.30, 0.32, 0.34, 0.36, 0.38, 0.40, 0.42, 0.44, 0.46, 0.48, 0.5, 0.53, 0.56, 0.59, 0.62, 0.65, 0.68, 0.71, 0.74, 0.77, 0.80, 0.83, 0.86, 0.89, 0.92, 0.95, 0.98, 1.0, 1.06, 1.12, 1.18, 1.24, 1.30, 1.36, 1.42, 1.48, 1.54, 1.60, 1.66, 1.72, 1.78, 1.84, 1.90, 1.96, 2.0, 2.12, 2.25, 2.37, 2.50, 2.62, 2.75, 2.87, 3.0, 3.2, 3.4, 3.6, 3.8, 4.0, 4.3, 4.7, 4.9, 5.0, 5.5, 6.0, 6.5, 6.8, 7.0, 7.3, 7.5, 7.8, 8.0, 8.4, 8.7, 9.0, 9.4, 9.6, 9.8, 10.0];
    const GRAY_MATRIX = [0.3086, 0.6094, 0.082, 0, 0, 0.3086, 0.6094, 0.082, 0, 0, 0.3086, 0.6094, 0.082, 0, 0, 0, 0, 0, 1, 0];
    const IDENTITY_MATRIX = [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1];
    const LENGTH = 25;
    class ColorFilter extends Filter {
        constructor(mat = null) {
            super();
            if (!mat)
                mat = this._copyMatrix(IDENTITY_MATRIX);
            this._mat = new Float32Array(16);
            this._alpha = new Float32Array(4);
            this.setByMatrix(mat);
        }
        gray() {
            return this.setByMatrix(GRAY_MATRIX);
        }
        color(red = 0, green = 0, blue = 0, alpha = 1) {
            return this.setByMatrix([red, 0, 0, 0, 1, 0, green, 0, 0, 1, 0, 0, blue, 0, 1, 0, 0, 0, alpha, 0]);
        }
        setColor(color) {
            var arr = ColorUtils.create(color).arrColor;
            var mt = [0, 0, 0, 0, 256 * arr[0], 0, 0, 0, 0, 256 * arr[1], 0, 0, 0, 0, 256 * arr[2], 0, 0, 0, 1, 0];
            return this.setByMatrix(mt);
        }
        setByMatrix(matrix) {
            if (this._matrix != matrix)
                this._copyMatrix(matrix);
            var j = 0;
            var z = 0;
            for (var i = 0; i < 20; i++) {
                if (i % 5 != 4) {
                    this._mat[j++] = matrix[i];
                }
                else {
                    this._alpha[z++] = matrix[i];
                }
            }
            return this;
        }
        get type() {
            return Filter.COLOR;
        }
        adjustColor(brightness, contrast, saturation, hue) {
            this.adjustHue(hue);
            this.adjustContrast(contrast);
            this.adjustBrightness(brightness);
            this.adjustSaturation(saturation);
            return this;
        }
        adjustBrightness(brightness) {
            brightness = this._clampValue(brightness, 100);
            if (brightness == 0 || isNaN(brightness))
                return this;
            return this._multiplyMatrix([1, 0, 0, 0, brightness, 0, 1, 0, 0, brightness, 0, 0, 1, 0, brightness, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1]);
        }
        adjustContrast(contrast) {
            contrast = this._clampValue(contrast, 100);
            if (contrast == 0 || isNaN(contrast))
                return this;
            var x;
            if (contrast < 0) {
                x = 127 + contrast / 100 * 127;
            }
            else {
                x = contrast % 1;
                if (x == 0) {
                    x = DELTA_INDEX[contrast];
                }
                else {
                    x = DELTA_INDEX[(contrast << 0)] * (1 - x) + DELTA_INDEX[(contrast << 0) + 1] * x;
                }
                x = x * 127 + 127;
            }
            var x1 = x / 127;
            var x2 = (127 - x) * 0.5;
            return this._multiplyMatrix([x1, 0, 0, 0, x2, 0, x1, 0, 0, x2, 0, 0, x1, 0, x2, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1]);
        }
        adjustSaturation(saturation) {
            saturation = this._clampValue(saturation, 100);
            if (saturation == 0 || isNaN(saturation))
                return this;
            var x = 1 + ((saturation > 0) ? 3 * saturation / 100 : saturation / 100);
            var dx = 1 - x;
            var r = 0.3086 * dx;
            var g = 0.6094 * dx;
            var b = 0.0820 * dx;
            return this._multiplyMatrix([r + x, g, b, 0, 0, r, g + x, b, 0, 0, r, g, b + x, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1]);
        }
        adjustHue(hue) {
            hue = this._clampValue(hue, 180) / 180 * Math.PI;
            if (hue == 0 || isNaN(hue))
                return this;
            var cos = Math.cos(hue);
            var sin = Math.sin(hue);
            var r = 0.213;
            var g = 0.715;
            var b = 0.072;
            return this._multiplyMatrix([r + cos * (1 - r) + sin * (-r), g + cos * (-g) + sin * (-g), b + cos * (-b) + sin * (1 - b), 0, 0, r + cos * (-r) + sin * (0.143), g + cos * (1 - g) + sin * (0.140), b + cos * (-b) + sin * (-0.283), 0, 0, r + cos * (-r) + sin * (-(1 - r)), g + cos * (-g) + sin * (g), b + cos * (1 - b) + sin * (b), 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1]);
        }
        reset() {
            return this.setByMatrix(this._copyMatrix(IDENTITY_MATRIX));
        }
        _multiplyMatrix(matrix) {
            var col = [];
            this._matrix = this._fixMatrix(this._matrix);
            for (var i = 0; i < 5; i++) {
                for (var j = 0; j < 5; j++) {
                    col[j] = this._matrix[j + i * 5];
                }
                for (j = 0; j < 5; j++) {
                    var val = 0;
                    for (var k = 0; k < 5; k++) {
                        val += matrix[j + k * 5] * col[k];
                    }
                    this._matrix[j + i * 5] = val;
                }
            }
            return this.setByMatrix(this._matrix);
        }
        _clampValue(val, limit) {
            return Math.min(limit, Math.max(-limit, val));
        }
        _fixMatrix(matrix = null) {
            if (matrix == null)
                return IDENTITY_MATRIX;
            if (matrix.length < LENGTH)
                matrix = matrix.slice(0, matrix.length).concat(IDENTITY_MATRIX.slice(matrix.length, LENGTH));
            else if (matrix.length > LENGTH)
                matrix = matrix.slice(0, LENGTH);
            return matrix;
        }
        _copyMatrix(matrix) {
            var len = LENGTH;
            if (!this._matrix)
                this._matrix = [];
            for (var i = 0; i < len; i++) {
                this._matrix[i] = matrix[i];
            }
            return this._matrix;
        }
        onAfterDeserialize() {
            let arr = ColorUtils.create(this._color || "#FFFFFF").arrColor;
            this.color(arr[0], arr[1], arr[2], arr[3]);
            this.adjustColor(this._brightness || 0, this._contrast || 0, this._saturation || 0, this._hue || 0);
        }
    }

    class GrahamScan {
        static multiply(p1, p2, p0) {
            return ((p1.x - p0.x) * (p2.y - p0.y) - (p2.x - p0.x) * (p1.y - p0.y));
        }
        static dis(p1, p2) {
            return (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y);
        }
        static _getPoints(count, tempUse = false, rst = null) {
            if (!GrahamScan._mPointList)
                GrahamScan._mPointList = [];
            while (GrahamScan._mPointList.length < count)
                GrahamScan._mPointList.push(new Point());
            if (!rst)
                rst = [];
            rst.length = 0;
            if (tempUse) {
                GrahamScan.getFrom(rst, GrahamScan._mPointList, count);
            }
            else {
                GrahamScan.getFromR(rst, GrahamScan._mPointList, count);
            }
            return rst;
        }
        static getFrom(rst, src, count) {
            var i;
            for (i = 0; i < count; i++) {
                rst.push(src[i]);
            }
            return rst;
        }
        static getFromR(rst, src, count) {
            var i;
            for (i = 0; i < count; i++) {
                rst.push(src.pop());
            }
            return rst;
        }
        static pListToPointList(pList, tempUse = false) {
            var i, len = pList.length / 2, rst = GrahamScan._getPoints(len, tempUse, GrahamScan._tempPointList);
            for (i = 0; i < len; i++) {
                rst[i].setTo(pList[i + i], pList[i + i + 1]);
            }
            return rst;
        }
        static pointListToPlist(pointList) {
            var i, len = pointList.length, rst = GrahamScan._temPList, tPoint;
            rst.length = 0;
            for (i = 0; i < len; i++) {
                tPoint = pointList[i];
                rst.push(tPoint.x, tPoint.y);
            }
            return rst;
        }
        static scanPList(pList) {
            return Utils.copyArray(pList, GrahamScan.pointListToPlist(GrahamScan.scan(GrahamScan.pListToPointList(pList, true))));
        }
        static scan(PointSet) {
            var i, j, k = 0, tmp, n = PointSet.length, ch;
            var _tmpDic = {};
            var key;
            ch = GrahamScan._temArr;
            ch.length = 0;
            n = PointSet.length;
            for (i = n - 1; i >= 0; i--) {
                tmp = PointSet[i];
                key = tmp.x + "_" + tmp.y;
                if (!(key in _tmpDic)) {
                    _tmpDic[key] = true;
                    ch.push(tmp);
                }
            }
            n = ch.length;
            Utils.copyArray(PointSet, ch);
            for (i = 1; i < n; i++)
                if ((PointSet[i].y < PointSet[k].y) || ((PointSet[i].y == PointSet[k].y) && (PointSet[i].x < PointSet[k].x)))
                    k = i;
            tmp = PointSet[0];
            PointSet[0] = PointSet[k];
            PointSet[k] = tmp;
            for (i = 1; i < n - 1; i++) {
                k = i;
                for (j = i + 1; j < n; j++)
                    if ((GrahamScan.multiply(PointSet[j], PointSet[k], PointSet[0]) > 0) || ((GrahamScan.multiply(PointSet[j], PointSet[k], PointSet[0]) == 0) && (GrahamScan.dis(PointSet[0], PointSet[j]) < GrahamScan.dis(PointSet[0], PointSet[k]))))
                        k = j;
                tmp = PointSet[i];
                PointSet[i] = PointSet[k];
                PointSet[k] = tmp;
            }
            ch = GrahamScan._temArr;
            ch.length = 0;
            if (PointSet.length < 3) {
                return Utils.copyArray(ch, PointSet);
            }
            ch.push(PointSet[0], PointSet[1], PointSet[2]);
            for (i = 3; i < n; i++) {
                while (ch.length >= 2 && GrahamScan.multiply(PointSet[i], ch[ch.length - 1], ch[ch.length - 2]) >= 0)
                    ch.pop();
                PointSet[i] && ch.push(PointSet[i]);
            }
            return ch;
        }
    }
    GrahamScan._tempPointList = [];
    GrahamScan._temPList = [];
    GrahamScan._temArr = [];

    class SpriteConst {
    }
    SpriteConst.ALPHA = 0x01;
    SpriteConst.TRANSFORM = 0x02;
    SpriteConst.BLEND = 0x04;
    SpriteConst.CANVAS = 0x08;
    SpriteConst.FILTERS = 0x10;
    SpriteConst.MASK = 0x20;
    SpriteConst.CLIP = 0x40;
    SpriteConst.STYLE = 0x80;
    SpriteConst.TEXTURE = 0x100;
    SpriteConst.GRAPHICS = 0x200;
    SpriteConst.LAYAGL3D = 0x400;
    SpriteConst.CUSTOM = 0x800;
    SpriteConst.ONECHILD = 0x1000;
    SpriteConst.HITAREA = 0x2000;
    SpriteConst.CHILDS = 0x4000;
    SpriteConst.REPAINT_NONE = 0;
    SpriteConst.REPAINT_NODE = 0x01;
    SpriteConst.REPAINT_CACHE = 0x02;
    SpriteConst.REPAINT_ALL = 0x03;

    exports.RenderStatisticsInfo = void 0;
    (function (RenderStatisticsInfo) {
        RenderStatisticsInfo[RenderStatisticsInfo["DrawCall"] = 0] = "DrawCall";
        RenderStatisticsInfo[RenderStatisticsInfo["InstanceDrawCall"] = 1] = "InstanceDrawCall";
        RenderStatisticsInfo[RenderStatisticsInfo["Triangle"] = 2] = "Triangle";
        RenderStatisticsInfo[RenderStatisticsInfo["UniformUpload"] = 3] = "UniformUpload";
        RenderStatisticsInfo[RenderStatisticsInfo["GPUMemory"] = 4] = "GPUMemory";
        RenderStatisticsInfo[RenderStatisticsInfo["TextureMemeory"] = 5] = "TextureMemeory";
        RenderStatisticsInfo[RenderStatisticsInfo["RenderTextureMemory"] = 6] = "RenderTextureMemory";
        RenderStatisticsInfo[RenderStatisticsInfo["BufferMemory"] = 7] = "BufferMemory";
    })(exports.RenderStatisticsInfo || (exports.RenderStatisticsInfo = {}));

    class Stat {
        static show(x = 0, y = 0, views = Stat.AllShow) {
            Stat._currentShowArray = views;
            Stat._StatRender.show(x, y, views);
        }
        static showToggle(x = 0, y = 0, views = Stat.AllToggle) {
            Stat._currentToggleArray = views;
            Stat._StatRender.showToggle(x, y, views);
        }
        static setStat(stat, value) {
            if (!Stat[stat])
                Stat[stat] = 0;
            Stat[stat] += value;
        }
        static enable() {
            Stat._StatRender.enable();
        }
        static hide() {
            Stat._StatRender.hide();
        }
        static updateEngineData() {
            Stat.trianglesFaces = LayaGL.renderEngine.getStatisticsInfo(exports.RenderStatisticsInfo.Triangle);
            Stat.drawCall = LayaGL.renderEngine.getStatisticsInfo(exports.RenderStatisticsInfo.DrawCall);
            Stat.instanceDrawCall = LayaGL.renderEngine.getStatisticsInfo(exports.RenderStatisticsInfo.InstanceDrawCall);
            Stat.gpuMemory = LayaGL.renderEngine.getStatisticsInfo(exports.RenderStatisticsInfo.GPUMemory);
            Stat.textureMemory = LayaGL.renderEngine.getStatisticsInfo(exports.RenderStatisticsInfo.TextureMemeory);
            Stat.renderTextureMemory = LayaGL.renderEngine.getStatisticsInfo(exports.RenderStatisticsInfo.RenderTextureMemory);
            Stat.bufferMemory = LayaGL.renderEngine.getStatisticsInfo(exports.RenderStatisticsInfo.BufferMemory);
        }
        static clear() {
            if (!Stat._currentShowArray)
                return;
            Stat._currentShowArray.forEach(element => {
                if (element.mode == "average")
                    Stat[element.value] = 0;
            });
            LayaGL.renderEngine.clearStatisticsInfo(exports.RenderStatisticsInfo.Triangle);
            LayaGL.renderEngine.clearStatisticsInfo(exports.RenderStatisticsInfo.DrawCall);
            LayaGL.renderEngine.clearStatisticsInfo(exports.RenderStatisticsInfo.InstanceDrawCall);
        }
        static set onclick(fn) {
            Stat._StatRender.set_onclick(fn);
        }
    }
    Stat.FPSStatUIParams = { title: "FPS(WebGL)", value: "_fpsStr", color: "yellow", units: "int", mode: "summit" };
    Stat.NodeStatUIParams = { title: "NodeNums", value: "spriteCount", color: "white", units: "int", mode: "summit" };
    Stat.Sprite3DStatUIParams = { title: "Sprite3D", value: "sprite3DCount", color: "white", units: "int", mode: "summit" };
    Stat.DrawCall = { title: "DrawCall", value: "drawCall", color: "white", units: "int", mode: "average" };
    Stat.TriangleFace = { title: "TriangleFace", value: "trianglesFaces", color: "white", units: "int", mode: "average" };
    Stat.RenderNode = { title: "RenderNode", value: "renderNode", color: "white", units: "int", mode: "summit" };
    Stat.SkinRenderNode = { title: "SkinRenderNode", value: "skinRenderNode", color: "white", units: "int", mode: "summit" };
    Stat.ParticleRenderNode = { title: "ParticleRenderNode", value: "particleRenderNode", color: "white", units: "int", mode: "summit" };
    Stat.FrustumCulling = { title: "FrustumCulling", value: "frustumCulling", color: "white", units: "int", mode: "average" };
    Stat.UniformUpload = { title: "UniformUpload", value: "uniformUpload", color: "white", units: "int", mode: "average" };
    Stat.OpaqueDrawCall = { title: "OpaqueDrawCall", value: "opaqueDrawCall", color: "white", units: "int", mode: "average" };
    Stat.TransDrawCall = { title: "TransDrawCall", value: "transDrawCall", color: "white", units: "int", mode: "average" };
    Stat.DepthCastDrawCall = { title: "DepthCastDrawCall", value: "depthCastDrawCall", color: "white", units: "int", mode: "average" };
    Stat.InstanceDrawCall = { title: "InstanceDrawCall", value: "instanceDrawCall", color: "white", units: "int", mode: "average" };
    Stat.CMDDrawCall = { title: "CMDDrawCall", value: "cmdDrawCall", color: "white", units: "int", mode: "average" };
    Stat.BlitDrawCall = { title: "BlitDrawCall", value: "blitDrawCall", color: "white", units: "int", mode: "average" };
    Stat.GPUMemory = { title: "GPUMemory", value: "gpuMemory", color: "white", units: "M", mode: "summit" };
    Stat.TextureMemeory = { title: "TextureMemory", value: "textureMemory", color: "white", units: "M", mode: "summit" };
    Stat.RenderTextureMemory = { title: "RenderTextureMemory", value: "renderTextureMemory", color: "white", units: "M", mode: "summit" };
    Stat.BufferMemory = { title: "BufferMemory", value: "bufferMemory", color: "white", units: "M", mode: "summit" };
    Stat.AllShow = [Stat.FPSStatUIParams, Stat.NodeStatUIParams, Stat.Sprite3DStatUIParams, Stat.DrawCall, Stat.TriangleFace, Stat.RenderNode, Stat.SkinRenderNode, Stat.ParticleRenderNode,
        Stat.FrustumCulling, Stat.OpaqueDrawCall, Stat.TransDrawCall, Stat.DepthCastDrawCall, Stat.InstanceDrawCall, Stat.CMDDrawCall, Stat.BlitDrawCall, Stat.GPUMemory, Stat.TextureMemeory, Stat.RenderTextureMemory, Stat.BufferMemory];
    Stat.memoryShow = [Stat.GPUMemory, Stat.TextureMemeory, Stat.RenderTextureMemory, Stat.BufferMemory];
    Stat.renderShow = [Stat.DrawCall, Stat.TriangleFace, Stat.OpaqueDrawCall, Stat.TransDrawCall, Stat.DepthCastDrawCall, Stat.InstanceDrawCall, Stat.CMDDrawCall, Stat.BlitDrawCall];
    Stat.toogle_Shadow = { title: "Shadow", value: "enableShadow", color: "white" };
    Stat.toogle_MulLight = { title: "MulLight", value: "enableMulLight", color: "white" };
    Stat.toogle_Light = { title: "Light", value: "enableLight", color: "white" };
    Stat.toogle_Postprocess = { title: "Postprocess", value: "enablePostprocess", color: "white" };
    Stat.toogle_AnimatorUpdate = { title: "AnimatorUpdate", value: "enableAnimatorUpdate", color: "white" };
    Stat.toogle_PhysicsUpdate = { title: "PhysicsUpdate", value: "enablePhysicsUpdate", color: "white" };
    Stat.toogle_Skin = { title: "Skin", value: "enableSkin", color: "white" };
    Stat.toogle_Transparent = { title: "Transparent", value: "enableTransparent", color: "white" };
    Stat.toogle_Particle = { title: "Particle", value: "enableParticle", color: "white" };
    Stat.toogle_msaa = { title: "MSAA", value: "enablemsaa", color: "white" };
    Stat.toogle_CameraCMD = { title: "CameraCMD", value: "enableCameraCMD", color: "white" };
    Stat.toogle_Opaque = { title: "Opaque", value: "enableOpaque", color: "white" };
    Stat.AllToggle = [Stat.toogle_Shadow, Stat.toogle_Light, Stat.toogle_MulLight, Stat.toogle_Postprocess, Stat.toogle_AnimatorUpdate, Stat.toogle_PhysicsUpdate, Stat.toogle_Opaque, Stat.toogle_Transparent, Stat.toogle_CameraCMD, Stat.toogle_Skin, Stat.toogle_Particle, Stat.toogle_msaa];
    Stat.RenderModeToggle = [Stat.toogle_Shadow, Stat.toogle_Light, Stat.toogle_MulLight, Stat.toogle_Postprocess, Stat.toogle_AnimatorUpdate, Stat.toogle_PhysicsUpdate];
    Stat.RenderFuncToggle = [Stat.toogle_Opaque, Stat.toogle_Transparent, Stat.toogle_CameraCMD, Stat.toogle_Skin, Stat.toogle_Particle, Stat.toogle_msaa];
    Stat.FPS = 0;
    Stat.loopCount = 0;
    Stat.spriteRenderUseCacheCount = 0;
    Stat.canvasNormal = 0;
    Stat.canvasBitmap = 0;
    Stat.canvasReCache = 0;
    Stat.renderSlow = false;
    Stat._fpsData = [];
    Stat._timer = 0;
    Stat._count = 0;
    Stat._fpsStr = "";
    Stat.spriteCount = 0;
    Stat.sprite3DCount = 0;
    Stat.drawCall = 0;
    Stat.trianglesFaces = 0;
    Stat.renderNode = 0;
    Stat.skinRenderNode = 0;
    Stat.particleRenderNode = 0;
    Stat.frustumCulling = 0;
    Stat.uniformUpload = 0;
    Stat.opaqueDrawCall = 0;
    Stat.transDrawCall = 0;
    Stat.depthCastDrawCall = 0;
    Stat.instanceDrawCall = 0;
    Stat.cmdDrawCall = 0;
    Stat.blitDrawCall = 0;
    Stat.textureMemory = 0;
    Stat.renderTextureMemory = 0;
    Stat.bufferMemory = 0;
    Stat.enableShadow = true;
    Stat.enableMulLight = true;
    Stat.enableLight = true;
    Stat.enableCameraCMD = true;
    Stat.enablePostprocess = true;
    Stat.enableSkin = true;
    Stat.enableTransparent = true;
    Stat.enableParticle = true;
    Stat.enableAnimatorUpdate = true;
    Stat.enablePhysicsUpdate = true;
    Stat.enablemsaa = true;
    Stat.enableOpaque = true;
    window.Stat = Stat;

    class SubmitBase {
        constructor(renderType = SubmitBase.TYPE_2D) {
            this.clipInfoID = -1;
            this._mesh = null;
            this._blendFn = null;
            this._id = 0;
            this._renderType = 0;
            this._parent = null;
            this._key = new SubmitKey();
            this._startIdx = 0;
            this._numEle = 0;
            this._ref = 1;
            this.shaderValue = null;
            this._renderType = renderType;
            this._id = ++SubmitBase.ID;
        }
        static __init__() {
            var s = SubmitBase.RENDERBASE = new SubmitBase(-1);
            s.shaderValue = new Value2D(0, 0);
            s.shaderValue.ALPHA = 1;
            s._ref = 0xFFFFFFFF;
        }
        getID() {
            return this._id;
        }
        getRenderType() {
            return this._renderType;
        }
        toString() {
            return "ibindex:" + this._startIdx + " num:" + this._numEle + " key=" + this._key;
        }
        renderSubmit() { return 1; }
        releaseRender() { }
    }
    SubmitBase.TYPE_2D = 10000;
    SubmitBase.TYPE_CANVAS = 10003;
    SubmitBase.TYPE_CMDSETRT = 10004;
    SubmitBase.TYPE_CUSTOM = 10005;
    SubmitBase.TYPE_BLURRT = 10006;
    SubmitBase.TYPE_CMDDESTORYPRERT = 10007;
    SubmitBase.TYPE_DISABLESTENCIL = 10008;
    SubmitBase.TYPE_OTHERIBVB = 10009;
    SubmitBase.TYPE_PRIMITIVE = 10010;
    SubmitBase.TYPE_RT = 10011;
    SubmitBase.TYPE_BLUR_RT = 10012;
    SubmitBase.TYPE_TARGET = 10013;
    SubmitBase.TYPE_CHANGE_VALUE = 10014;
    SubmitBase.TYPE_SHAPE = 10015;
    SubmitBase.TYPE_TEXTURE = 10016;
    SubmitBase.TYPE_FILLTEXTURE = 10017;
    SubmitBase.KEY_ONCE = -1;
    SubmitBase.KEY_FILLRECT = 1;
    SubmitBase.KEY_DRAWTEXTURE = 2;
    SubmitBase.KEY_VG = 3;
    SubmitBase.KEY_TRIANGLES = 4;
    SubmitBase.ID = 1;
    SubmitBase.preRender = null;

    exports.RenderParams = void 0;
    (function (RenderParams) {
        RenderParams[RenderParams["Max_Active_Texture_Count"] = 0] = "Max_Active_Texture_Count";
        RenderParams[RenderParams["Max_Uniform_Count"] = 1] = "Max_Uniform_Count";
        RenderParams[RenderParams["Max_AnisoLevel_Count"] = 2] = "Max_AnisoLevel_Count";
        RenderParams[RenderParams["MAX_Texture_Size"] = 3] = "MAX_Texture_Size";
        RenderParams[RenderParams["MAX_Texture_Image_Uint"] = 4] = "MAX_Texture_Image_Uint";
        RenderParams[RenderParams["SHADER_CAPAILITY_LEVEL"] = 5] = "SHADER_CAPAILITY_LEVEL";
        RenderParams[RenderParams["FLOAT"] = 6] = "FLOAT";
        RenderParams[RenderParams["UNSIGNED_BYTE"] = 7] = "UNSIGNED_BYTE";
        RenderParams[RenderParams["BYTE"] = 8] = "BYTE";
        RenderParams[RenderParams["UNSIGNED_SHORT"] = 9] = "UNSIGNED_SHORT";
    })(exports.RenderParams || (exports.RenderParams = {}));

    class VertexElementFormat {
        static __init__() {
            VertexElementFormat._elementInfos = {
                "single": [1, LayaGL.renderEngine.getParams(exports.RenderParams.FLOAT), 0],
                "vector2": [2, LayaGL.renderEngine.getParams(exports.RenderParams.FLOAT), 0],
                "vector3": [3, LayaGL.renderEngine.getParams(exports.RenderParams.FLOAT), 0],
                "vector4": [4, LayaGL.renderEngine.getParams(exports.RenderParams.FLOAT), 0],
                "color": [4, LayaGL.renderEngine.getParams(exports.RenderParams.FLOAT), 0],
                "byte4": [4, LayaGL.renderEngine.getParams(exports.RenderParams.UNSIGNED_BYTE), 0],
                "byte3": [3, LayaGL.renderEngine.getParams(exports.RenderParams.UNSIGNED_BYTE), 0],
                "byte2": [2, LayaGL.renderEngine.getParams(exports.RenderParams.UNSIGNED_BYTE), 0],
                "byte": [1, LayaGL.renderEngine.getParams(exports.RenderParams.UNSIGNED_BYTE), 0],
                "short2": [2, LayaGL.renderEngine.getParams(exports.RenderParams.UNSIGNED_SHORT), 0],
                "short4": [4, LayaGL.renderEngine.getParams(exports.RenderParams.UNSIGNED_SHORT), 0],
                "normalizedshort2": [2, LayaGL.renderEngine.getParams(exports.RenderParams.UNSIGNED_SHORT), 1],
                "normalizedshort4": [4, LayaGL.renderEngine.getParams(exports.RenderParams.UNSIGNED_SHORT), 1],
                "halfvector2": [2, LayaGL.renderEngine.getParams(exports.RenderParams.FLOAT), 0],
                "halfvector4": [4, LayaGL.renderEngine.getParams(exports.RenderParams.FLOAT), 0],
                "nbyte4": [4, LayaGL.renderEngine.getParams(exports.RenderParams.BYTE), 1],
            };
        }
        static getElementInfos(element) {
            var info = VertexElementFormat._elementInfos[element];
            if (info)
                return info;
            else
                throw "VertexElementFormat: this vertexElementFormat is not implement.";
        }
    }
    VertexElementFormat.Single = "single";
    VertexElementFormat.Vector2 = "vector2";
    VertexElementFormat.Vector3 = "vector3";
    VertexElementFormat.Vector4 = "vector4";
    VertexElementFormat.Color = "color";
    VertexElementFormat.Byte4 = "byte4";
    VertexElementFormat.Byte3 = "byte3";
    VertexElementFormat.Byte2 = "byte2";
    VertexElementFormat.ByteOne = "byte";
    VertexElementFormat.Short2 = "short2";
    VertexElementFormat.Short4 = "short4";
    VertexElementFormat.NormalizedShort2 = "normalizedshort2";
    VertexElementFormat.NormalizedShort4 = "normalizedshort4";
    VertexElementFormat.HalfVector2 = "halfvector2";
    VertexElementFormat.HalfVector4 = "halfvector4";
    VertexElementFormat.NorByte4 = "nbyte4";

    class VertexDeclaration {
        constructor(vertexStride, vertexElements) {
            this._id = ++VertexDeclaration._uniqueIDCounter;
            this._vertexElementsDic = {};
            this._vertexStride = vertexStride;
            this._vertexElements = vertexElements;
            var count = vertexElements.length;
            this._shaderValues = {};
            for (var j = 0; j < count; j++) {
                var vertexElement = vertexElements[j];
                var name = vertexElement._elementUsage;
                this._vertexElementsDic[name] = vertexElement;
                var value = new Int32Array(5);
                var elmentInfo = VertexElementFormat.getElementInfos(vertexElement._elementFormat);
                value[0] = elmentInfo[0];
                value[1] = elmentInfo[1];
                value[2] = elmentInfo[2];
                value[3] = this._vertexStride;
                value[4] = vertexElement._offset;
                this._shaderValues[name] = value;
            }
        }
        get id() {
            return this._id;
        }
        get vertexStride() {
            return this._vertexStride;
        }
        get vertexElementCount() {
            return this._vertexElements.length;
        }
        getVertexElementByIndex(index) {
            return this._vertexElements[index];
        }
        getVertexElementByUsage(usage) {
            return this._vertexElementsDic[usage];
        }
    }
    VertexDeclaration._uniqueIDCounter = 1;

    class VertexElement {
        constructor(offset, elementFormat, elementUsage) {
            this._offset = offset;
            this._elementFormat = elementFormat;
            this._elementUsage = elementUsage;
        }
        get offset() {
            return this._offset;
        }
        get elementFormat() {
            return this._elementFormat;
        }
        get elementUsage() {
            return this._elementUsage;
        }
    }

    exports.BufferTargetType = void 0;
    (function (BufferTargetType) {
        BufferTargetType[BufferTargetType["ARRAY_BUFFER"] = 0] = "ARRAY_BUFFER";
        BufferTargetType[BufferTargetType["ELEMENT_ARRAY_BUFFER"] = 1] = "ELEMENT_ARRAY_BUFFER";
        BufferTargetType[BufferTargetType["UNIFORM_BUFFER"] = 2] = "UNIFORM_BUFFER";
        BufferTargetType[BufferTargetType["COPY_READ_BUFFER"] = 3] = "COPY_READ_BUFFER";
        BufferTargetType[BufferTargetType["COPY_WRITE_BUFFER"] = 4] = "COPY_WRITE_BUFFER";
        BufferTargetType[BufferTargetType["TRANSFORM_FEEDBACK_BUFFER"] = 5] = "TRANSFORM_FEEDBACK_BUFFER";
        BufferTargetType[BufferTargetType["PIXEL_PACK_BUFFER"] = 6] = "PIXEL_PACK_BUFFER";
        BufferTargetType[BufferTargetType["PIXEL_UNPACK_BUFFER"] = 7] = "PIXEL_UNPACK_BUFFER";
    })(exports.BufferTargetType || (exports.BufferTargetType = {}));
    exports.BufferUsage = void 0;
    (function (BufferUsage) {
        BufferUsage[BufferUsage["Static"] = 0] = "Static";
        BufferUsage[BufferUsage["Dynamic"] = 1] = "Dynamic";
        BufferUsage[BufferUsage["Stream"] = 2] = "Stream";
    })(exports.BufferUsage || (exports.BufferUsage = {}));

    class BufferState {
        constructor() {
            this._nativeVertexArrayObject = LayaGL.renderEngine.createVertexState();
        }
        applyVertexBuffers() {
            this._nativeVertexArrayObject.applyVertexBuffer(this._vertexBuffers);
        }
        applyIndexBuffers() {
            this._nativeVertexArrayObject.applyIndexBuffer(this._bindedIndexBuffer);
        }
        applyState(vertexBuffers, indexBuffer) {
            this._vertexBuffers = vertexBuffers;
            this._bindedIndexBuffer = indexBuffer;
            indexBuffer && indexBuffer.unbind();
            this.bind();
            this.applyVertexBuffers();
            this.applyIndexBuffers();
            this.unBind();
            indexBuffer && indexBuffer.unbind();
        }
        bind() {
            this._nativeVertexArrayObject.bindVertexArray();
            BufferState._curBindedBufferState = this;
        }
        unBind() {
            if (BufferState._curBindedBufferState == this) {
                this._nativeVertexArrayObject.unbindVertexArray();
                BufferState._curBindedBufferState = null;
            }
            else {
                throw "BufferState: must call bind() function first.";
            }
        }
        isbind() {
            return (BufferState._curBindedBufferState == this);
        }
        destroy() {
            this._nativeVertexArrayObject.destroy();
            this._nativeVertexArrayObject = null;
        }
    }

    exports.IndexFormat = void 0;
    (function (IndexFormat) {
        IndexFormat[IndexFormat["UInt8"] = 0] = "UInt8";
        IndexFormat[IndexFormat["UInt16"] = 1] = "UInt16";
        IndexFormat[IndexFormat["UInt32"] = 2] = "UInt32";
    })(exports.IndexFormat || (exports.IndexFormat = {}));

    class Buffer {
        constructor(targetType, bufferUsageType) {
            this._byteLength = 0;
            this._glBuffer = LayaGL.renderEngine.createBuffer(targetType, bufferUsageType);
            this._bufferType = targetType;
            this._bufferUsage = bufferUsageType;
        }
        get bufferUsage() {
            return this._bufferUsage;
        }
        bind() {
            return this._glBuffer.bindBuffer();
        }
        unbind() {
            return this._glBuffer.unbindBuffer();
        }
        resizelength(bytelength) {
            this._byteLength = bytelength;
            this._glBuffer.resizeBuffer(this._byteLength);
        }
        destroy() {
            if (this._glBuffer) {
                this._glBuffer.destroy();
                this._glBuffer = null;
            }
        }
    }

    class IndexBuffer extends Buffer {
        constructor(targetType, bufferUsageType) {
            super(targetType, bufferUsageType);
            this._indexType = exports.IndexFormat.UInt16;
        }
        _setIndexData(data, bufferOffset) {
            var curBufSta = BufferState._curBindedBufferState;
            if (curBufSta) {
                if (curBufSta._bindedIndexBuffer === this) {
                    this._glBuffer.setDataLength(0);
                }
                else {
                    curBufSta.unBind();
                    this.bind();
                    if (typeof data === "number")
                        this._glBuffer.setDataLength(data);
                    else
                        this._glBuffer.setData(data, bufferOffset);
                    curBufSta.bind();
                }
            }
            else {
                this.bind();
                if (typeof data === "number")
                    this._glBuffer.setDataLength(data);
                else
                    this._glBuffer.setData(data, bufferOffset);
            }
        }
    }

    class RenderInfo {
    }
    RenderInfo.loopStTm = 0;
    RenderInfo.loopCount = 0;

    class Buffer2D {
        constructor(buffer) {
            this._maxsize = 0;
            this._upload = true;
            this._uploadSize = 0;
            this._bufferSize = 0;
            this._u8Array = null;
            this.constBuffer = buffer;
        }
        get bufferLength() {
            return this.constBuffer._buffer.byteLength;
        }
        set byteLength(value) {
            this.setByteLength(value);
        }
        setByteLength(value) {
            if (this.constBuffer._byteLength !== value) {
                value <= this._bufferSize || (this._resizeBuffer(value * 2 + 256, true));
                this.constBuffer._byteLength = value;
            }
        }
        needSize(sz) {
            var old = this.constBuffer._byteLength;
            if (sz) {
                var needsz = this.constBuffer._byteLength + sz;
                needsz <= this._bufferSize || (this._resizeBuffer(needsz << 1, true));
                this.constBuffer._byteLength = needsz;
            }
            return old;
        }
        getFloat32Array() {
            if (!this._floatArray32) {
                this._floatArray32 = new Float32Array(this.constBuffer._buffer.buffer);
            }
            return this._floatArray32;
        }
        _bufferData() {
            this._maxsize = Math.max(this._maxsize, this.constBuffer._byteLength);
            if (RenderInfo.loopCount % 30 == 0) {
                if (this.constBuffer._buffer.byteLength > (this._maxsize + 64)) {
                    this.constBuffer._buffer = this.constBuffer._buffer.slice(0, this._maxsize + 64);
                    this._bufferSize = this.constBuffer._buffer.byteLength;
                    this._checkArrayUse();
                    let buff = this.constBuffer._buffer.buffer;
                    ((this._bufferSize % 4) == 0) && (this._floatArray32 = new Float32Array(buff));
                    ((this._bufferSize % 4) == 0) && (this._uint32Array = new Uint32Array(buff));
                    this._uint16Array = new Uint16Array(buff);
                }
                this._maxsize = this.constBuffer._byteLength;
            }
            if (this._uploadSize < this.constBuffer._buffer.byteLength) {
                this._uploadSize = this.constBuffer._buffer.byteLength;
                this.constBuffer._glBuffer.setDataLength(this._uploadSize);
            }
            this.constBuffer._glBuffer.setData(new Uint8Array(this.constBuffer._buffer.buffer, 0, this.constBuffer._byteLength), 0);
            this.constBuffer.unbind();
        }
        _bufferSubData(offset = 0, dataStart = 0, dataLength = 0) {
            this._maxsize = Math.max(this._maxsize, this.constBuffer._byteLength);
            if (RenderInfo.loopCount % 30 == 0) {
                if (this.constBuffer._buffer.byteLength > (this._maxsize + 64)) {
                    this.constBuffer._buffer = this.constBuffer._buffer.slice(0, this._maxsize + 64);
                    this._bufferSize = this.constBuffer._buffer.byteLength;
                    this._checkArrayUse();
                }
                this._maxsize = this.constBuffer._byteLength;
            }
            if (this._uploadSize < this.constBuffer._buffer.byteLength) {
                this._uploadSize = this.constBuffer._buffer.byteLength;
                this.constBuffer._glBuffer.setDataLength(this._uploadSize);
            }
            if (dataStart || dataLength) {
                var subBuffer = this.constBuffer._buffer.buffer.slice(dataStart, dataLength);
                this.constBuffer._glBuffer.setData(subBuffer, offset);
            }
            else {
                this.constBuffer._glBuffer.setData(this.constBuffer._buffer.buffer, offset);
            }
        }
        _checkArrayUse() {
        }
        _bind_upload() {
            if (!this._upload)
                return false;
            this._upload = false;
            this.constBuffer.bind();
            this._bufferData();
            return true;
        }
        _bind_subUpload(offset = 0, dataStart = 0, dataLength = 0) {
            if (!this._upload)
                return false;
            this._upload = false;
            this.constBuffer.bind();
            this._bufferSubData(offset, dataStart, dataLength);
            return true;
        }
        _resizeBuffer(nsz, copy) {
            var buff = this.constBuffer._buffer;
            if (buff && nsz <= buff.byteLength)
                return this;
            this._u8Array;
            if (copy && buff && buff.byteLength > 0) {
                var oldU8Arr = new Uint8Array(buff.buffer);
                var newbuffer = new Uint8Array(nsz);
                newbuffer.set(oldU8Arr, 0);
                buff = this.constBuffer._buffer = newbuffer;
                this._u8Array = new Uint8Array(this.constBuffer._buffer.buffer);
            }
            else {
                var data = new ArrayBuffer(nsz);
                buff = this.constBuffer._buffer = new Uint8Array(data);
                this._u8Array = new Uint8Array(buff.buffer);
            }
            buff = this.constBuffer._buffer.buffer;
            ((nsz % 4) == 0) && (this._floatArray32 = new Float32Array(buff));
            ((nsz % 4) == 0) && (this._uint32Array = new Uint32Array(buff));
            this._uint16Array = new Uint16Array(buff);
            this._checkArrayUse();
            this._upload = true;
            this._bufferSize = buff.byteLength;
            return this;
        }
        append(data) {
            this._upload = true;
            var byteLen, n;
            byteLen = data.byteLength;
            if (data instanceof Uint8Array) {
                this._resizeBuffer(this.constBuffer._byteLength + byteLen, true);
                n = new Uint8Array(this.constBuffer._buffer.buffer, this.constBuffer._byteLength);
            }
            else if (data instanceof Uint16Array) {
                this._resizeBuffer(this.constBuffer._byteLength + byteLen, true);
                n = new Uint16Array(this.constBuffer._buffer.buffer, this.constBuffer._byteLength);
            }
            else if (data instanceof Float32Array) {
                this._resizeBuffer(this.constBuffer._byteLength + byteLen, true);
                n = new Float32Array(this.constBuffer._buffer.buffer, this.constBuffer._byteLength);
            }
            n.set(data, 0);
            this.constBuffer._byteLength += byteLen;
            this._checkArrayUse();
        }
        appendU16Array(data, len) {
            this._resizeBuffer(this.constBuffer._byteLength + len * 2, true);
            var u = new Uint16Array(this.constBuffer._buffer.buffer, this.constBuffer._byteLength, len);
            if (len == 6) {
                u[0] = data[0];
                u[1] = data[1];
                u[2] = data[2];
                u[3] = data[3];
                u[4] = data[4];
                u[5] = data[5];
            }
            else if (len >= 100) {
                u.set(new Uint16Array(data.buffer, 0, len));
            }
            else {
                for (var i = 0; i < len; i++) {
                    u[i] = data[i];
                }
            }
            this.constBuffer._byteLength += len * 2;
            this._checkArrayUse();
        }
        getBuffer() {
            return this.constBuffer._buffer.buffer;
        }
        setNeedUpload() {
            this._upload = true;
        }
        subUpload(offset = 0, dataStart = 0, dataLength = 0) {
            var scuess = this._bind_subUpload();
            this.constBuffer.unbind();
            BaseShader.activeShader = null;
            return scuess;
        }
        _disposeResource() {
            this._upload = true;
            this._uploadSize = 0;
            this._floatArray32 = null;
            this._uint32Array = null;
            this._u8Array = null;
        }
        clear() {
            this.constBuffer._byteLength = 0;
            this._upload = true;
        }
    }
    Buffer2D.FLOAT32 = 4;
    Buffer2D.SHORT = 2;

    class IndexBuffer2D extends IndexBuffer {
        constructor(bufferUsage = exports.BufferUsage.Static) {
            super(exports.BufferTargetType.ELEMENT_ARRAY_BUFFER, bufferUsage);
            this.buffer2D = new Buffer2D(this);
            this._bufferUsage = bufferUsage;
            this._buffer = new Uint8Array(8);
        }
        _bindForVAO() {
            this._glBuffer.bindBuffer();
        }
        destory() {
            this._uint16Array = null;
            this._buffer = null;
        }
        disposeResource() {
            this.buffer2D._disposeResource();
        }
    }
    IndexBuffer2D.create = function (bufferUsage = exports.BufferUsage.Static) {
        return new IndexBuffer2D(bufferUsage);
    };

    class VertexBuffer extends Buffer {
        constructor(targetType, bufferUsageType) {
            super(targetType, bufferUsageType);
            this._instanceBuffer = false;
            this._vertexDeclaration = null;
        }
        get vertexDeclaration() {
            return this._vertexDeclaration;
        }
        set vertexDeclaration(value) {
            this._vertexDeclaration = value;
        }
        get instanceBuffer() {
            return this._instanceBuffer;
        }
        set instanceBuffer(value) {
            this._instanceBuffer = value;
        }
    }

    class VertexBuffer2D extends VertexBuffer {
        constructor(vertexStride, bufferUsage) {
            super(exports.BufferTargetType.ARRAY_BUFFER, bufferUsage);
            this.buffer2D = new Buffer2D(this);
            this._vertexStride = vertexStride;
            this._bufferUsage = bufferUsage;
        }
        get vertexStride() {
            return this._vertexStride;
        }
        getFloat32Array() {
            return this.buffer2D._floatArray32;
        }
        get _floatArray32() {
            return this.buffer2D._floatArray32;
        }
        get _uint32Array() {
            return this.buffer2D._uint32Array;
        }
        appendArray(data) {
            var oldoff = this._byteLength >> 2;
            this.buffer2D.setByteLength(this._byteLength + data.length * 4);
            var vbdata = this.getFloat32Array();
            vbdata.set(data, oldoff);
            this.buffer2D._upload = true;
        }
        deleteBuffer() {
            this.buffer2D._disposeResource();
        }
        _bindForVAO() {
            this._glBuffer.bindBuffer();
        }
        destroy() {
            super.destroy();
            this._byteLength = 0;
            this.buffer2D._upload = true;
            this._buffer = null;
        }
    }
    VertexBuffer2D.create = function (vertexStride, bufferUsage = exports.BufferUsage.Dynamic) {
        return new VertexBuffer2D(vertexStride, bufferUsage);
    };

    class Mesh2D {
        constructor(stride, vballoc, iballoc) {
            this._stride = 0;
            this.vertNum = 0;
            this.indexNum = 0;
            this._applied = false;
            this._quadNum = 0;
            this.canReuse = false;
            this._stride = stride;
            this._vb = new VertexBuffer2D(stride, exports.BufferUsage.Dynamic);
            if (vballoc) {
                this._vb.buffer2D._resizeBuffer(vballoc, false);
            }
            else {
                Config.webGL2D_MeshAllocMaxMem && this._vb.buffer2D._resizeBuffer(64 * 1024 * stride, false);
            }
            this._ib = new IndexBuffer2D();
            if (iballoc) {
                this._ib.buffer2D._resizeBuffer(iballoc, false);
            }
        }
        createQuadIB(QuadNum) {
            this._quadNum = QuadNum;
            this._ib.buffer2D._resizeBuffer(QuadNum * 6 * 2, false);
            this._ib.buffer2D.byteLength = this._ib.buffer2D.bufferLength;
            var bd = this._ib.buffer2D._uint16Array;
            var idx = 0;
            var curvert = 0;
            for (var i = 0; i < QuadNum; i++) {
                bd[idx++] = curvert;
                bd[idx++] = curvert + 2;
                bd[idx++] = curvert + 1;
                bd[idx++] = curvert;
                bd[idx++] = curvert + 3;
                bd[idx++] = curvert + 2;
                curvert += 4;
            }
            this._ib.buffer2D.setNeedUpload();
        }
        setAttributes(attribs) {
            this._attribInfo = attribs;
            if (this._attribInfo.length % 3 != 0) {
                throw 'Mesh2D setAttributes error!';
            }
        }
        configVAO() {
            if (this._applied)
                return;
            this._applied = true;
            if (!this._vao) {
                this._vao = new BufferState();
            }
            this._vao.applyState([this._vb], this._ib);
        }
        useMesh() {
            if ((this._vao && !this._vao.isbind()) || this._ib.buffer2D._upload || this._vb.buffer2D._upload) {
                BufferState._curBindedBufferState && BufferState._curBindedBufferState.unBind();
            }
            this._applied || this.configVAO();
            this._ib.buffer2D._bind_upload();
            this._vb.buffer2D._bind_upload();
            this._vao.bind();
        }
        releaseMesh() { }
        destroy() {
        }
        clearVB() {
            this._vb.buffer2D.clear();
        }
    }
    Mesh2D._gvaoid = 0;

    class MeshQuadTexture extends Mesh2D {
        constructor() {
            super(MeshQuadTexture.const_stride, 4, 4);
            this.canReuse = true;
            this.setAttributes(MeshQuadTexture._fixattriInfo);
            if (!MeshQuadTexture._fixib) {
                this.createQuadIB(MeshQuadTexture._maxIB);
                MeshQuadTexture._fixib = this._ib;
            }
            else {
                this._ib = MeshQuadTexture._fixib;
                this._quadNum = MeshQuadTexture._maxIB;
            }
            if (!MeshQuadTexture.VertexDeclarition)
                MeshQuadTexture.VertexDeclarition = new VertexDeclaration(24, [
                    new VertexElement(0, VertexElementFormat.Vector4, 0),
                    new VertexElement(16, VertexElementFormat.Byte4, 1),
                    new VertexElement(20, VertexElementFormat.Byte4, 2),
                ]);
            this._vb.vertexDeclaration = MeshQuadTexture.VertexDeclarition;
        }
        static __int__() {
            MeshQuadTexture._fixattriInfo = [5126, 4, 0,
                5121, 4, 16,
                5121, 4, 20];
        }
        static getAMesh(mainctx) {
            var ret = null;
            if (MeshQuadTexture._POOL.length) {
                ret = MeshQuadTexture._POOL.pop();
            }
            else
                ret = new MeshQuadTexture();
            mainctx && ret._vb.buffer2D._resizeBuffer(64 * 1024 * MeshQuadTexture.const_stride, false);
            return ret;
        }
        releaseMesh() {
            this._vb.buffer2D.setByteLength(0);
            this.vertNum = 0;
            this.indexNum = 0;
            MeshQuadTexture._POOL.push(this);
        }
        destroy() {
            this._vb.destroy();
            this._vb.deleteBuffer();
        }
        addQuad(pos, uv, color, useTex) {
            var vb = this._vb;
            var vpos = (vb._byteLength >> 2);
            vb.buffer2D.setByteLength((vpos + MeshQuadTexture.const_stride) << 2);
            var vbdata = vb._floatArray32 || vb.getFloat32Array();
            var vbu32Arr = vb._uint32Array;
            var cpos = vpos;
            var useTexVal = useTex ? 0xff : 0;
            vbdata[cpos++] = pos[0];
            vbdata[cpos++] = pos[1];
            vbdata[cpos++] = uv[0];
            vbdata[cpos++] = uv[1];
            vbu32Arr[cpos++] = color;
            vbu32Arr[cpos++] = useTexVal;
            vbdata[cpos++] = pos[2];
            vbdata[cpos++] = pos[3];
            vbdata[cpos++] = uv[2];
            vbdata[cpos++] = uv[3];
            vbu32Arr[cpos++] = color;
            vbu32Arr[cpos++] = useTexVal;
            vbdata[cpos++] = pos[4];
            vbdata[cpos++] = pos[5];
            vbdata[cpos++] = uv[4];
            vbdata[cpos++] = uv[5];
            vbu32Arr[cpos++] = color;
            vbu32Arr[cpos++] = useTexVal;
            vbdata[cpos++] = pos[6];
            vbdata[cpos++] = pos[7];
            vbdata[cpos++] = uv[6];
            vbdata[cpos++] = uv[7];
            vbu32Arr[cpos++] = color;
            vbu32Arr[cpos++] = useTexVal;
            vb.buffer2D._upload = true;
        }
    }
    MeshQuadTexture.const_stride = 24;
    MeshQuadTexture._maxIB = 16 * 1024;
    MeshQuadTexture._POOL = [];

    class MeshTexture extends Mesh2D {
        constructor() {
            super(MeshTexture.const_stride, 4, 4);
            this.canReuse = true;
            this.setAttributes(MeshTexture._fixattriInfo);
            if (!MeshTexture.VertexDeclarition)
                MeshTexture.VertexDeclarition = new VertexDeclaration(24, [
                    new VertexElement(0, VertexElementFormat.Vector4, 0),
                    new VertexElement(16, VertexElementFormat.Byte4, 1),
                    new VertexElement(20, VertexElementFormat.Byte4, 2),
                ]);
            this._vb.vertexDeclaration = MeshTexture.VertexDeclarition;
        }
        static __init__() {
            MeshTexture._fixattriInfo = [5126, 4, 0,
                5121, 4, 16,
                5121, 4, 20];
        }
        static getAMesh(mainctx) {
            var ret;
            if (MeshTexture._POOL.length) {
                ret = MeshTexture._POOL.pop();
            }
            else
                ret = new MeshTexture();
            mainctx && ret._vb.buffer2D._resizeBuffer(64 * 1024 * MeshTexture.const_stride, false);
            return ret;
        }
        addData(vertices, uvs, idx, matrix, rgba) {
            var vb = this._vb;
            var ib = this._ib;
            var vertsz = vertices.length >> 1;
            var startpos = vb.buffer2D.needSize(vertsz * MeshTexture.const_stride);
            var f32pos = startpos >> 2;
            var vbdata = vb._floatArray32 || vb.getFloat32Array();
            var vbu32Arr = vb._uint32Array;
            var ci = 0;
            var m00 = matrix.a;
            var m01 = matrix.b;
            var m10 = matrix.c;
            var m11 = matrix.d;
            var tx = matrix.tx;
            var ty = matrix.ty;
            var i = 0;
            for (i = 0; i < vertsz; i++) {
                var x = vertices[ci], y = vertices[ci + 1];
                vbdata[f32pos] = x * m00 + y * m10 + tx;
                vbdata[f32pos + 1] = x * m01 + y * m11 + ty;
                vbdata[f32pos + 2] = uvs[ci];
                vbdata[f32pos + 3] = uvs[ci + 1];
                vbu32Arr[f32pos + 4] = rgba;
                vbu32Arr[f32pos + 5] = 0xff;
                f32pos += 6;
                ci += 2;
            }
            vb.buffer2D.setNeedUpload();
            var vertN = this.vertNum;
            var sz = idx.length;
            var stib = ib.buffer2D.needSize(idx.byteLength);
            var cidx = ib.buffer2D._uint16Array;
            var stibid = stib >> 1;
            if (vertN > 0) {
                var end = stibid + sz;
                var si = 0;
                for (i = stibid; i < end; i++, si++) {
                    cidx[i] = idx[si] + vertN;
                }
            }
            else {
                cidx.set(idx, stibid);
            }
            ib.buffer2D.setNeedUpload();
            this.vertNum += vertsz;
            this.indexNum += idx.length;
        }
        releaseMesh() {
            this._vb.buffer2D.setByteLength(0);
            this._ib.buffer2D.setByteLength(0);
            this.vertNum = 0;
            this.indexNum = 0;
            MeshTexture._POOL.push(this);
        }
        destroy() {
            this._ib.destroy();
            this._vb.destroy();
            this._ib.disposeResource();
            this._vb.deleteBuffer();
        }
    }
    MeshTexture.const_stride = 24;
    MeshTexture._POOL = [];

    class MeshVG extends Mesh2D {
        constructor() {
            super(MeshVG.const_stride, 4, 4);
            this.canReuse = true;
            this.setAttributes(MeshVG._fixattriInfo);
            if (!MeshVG.vertexDeclaration)
                MeshVG.vertexDeclaration = new VertexDeclaration(12, [
                    new VertexElement(0, VertexElementFormat.Vector2, 0),
                    new VertexElement(8, VertexElementFormat.Byte4, 1),
                ]);
            this._vb.vertexDeclaration = MeshVG.vertexDeclaration;
        }
        static __init__() {
            MeshVG._fixattriInfo = [5126, 2, 0,
                5121, 4, 8];
        }
        static getAMesh(mainctx) {
            var ret;
            if (MeshVG._POOL.length) {
                ret = MeshVG._POOL.pop();
            }
            else
                ret = new MeshVG();
            mainctx && ret._vb.buffer2D._resizeBuffer(64 * 1024 * MeshVG.const_stride, false);
            return ret;
        }
        addVertAndIBToMesh(ctx, points, rgba, ib) {
            var startpos = this._vb.buffer2D.needSize(points.length / 2 * MeshVG.const_stride);
            var f32pos = startpos >> 2;
            var vbdata = this._vb._floatArray32 || this._vb.getFloat32Array();
            var vbu32Arr = this._vb._uint32Array;
            var ci = 0;
            var sz = points.length / 2;
            for (var i = 0; i < sz; i++) {
                vbdata[f32pos++] = points[ci];
                vbdata[f32pos++] = points[ci + 1];
                ci += 2;
                vbu32Arr[f32pos++] = rgba;
            }
            this._vb.buffer2D.setNeedUpload();
            this._ib.buffer2D.append(new Uint16Array(ib));
            this._ib.buffer2D.setNeedUpload();
            this.vertNum += sz;
            this.indexNum += ib.length;
        }
        releaseMesh() {
            this._vb.buffer2D.setByteLength(0);
            this._ib.buffer2D.setByteLength(0);
            this.vertNum = 0;
            this.indexNum = 0;
            MeshVG._POOL.push(this);
        }
        destroy() {
            this._ib.destroy();
            this._vb.destroy();
            this._ib.disposeResource();
            this._vb.deleteBuffer();
        }
    }
    MeshVG.const_stride = 12;
    MeshVG._POOL = [];
    MeshVG.vertexDeclaration = null;

    class NativeWebGLCacheAsNormalCanvas {
        constructor(ctx, sp) {
            this._context = ctx;
            this._nativeObj = new window._conchWebGLCacheAsNormalCanvas(ctx._nativeObj, 0);
        }
        startRec() {
            this._nativeObj.startRec();
        }
        endRec() {
            this._nativeObj.endRec();
        }
        isCacheValid() {
            return this._nativeObj.isCacheValid();
        }
        isTextNeedRestore() {
            return this._nativeObj.isTextNeedRestore();
        }
        get context() {
            return this._context;
        }
    }

    class WebGLCacheAsNormalCanvas {
        constructor(ctx, sp) {
            this.submitStartPos = 0;
            this.submitEndPos = 0;
            this.touches = [];
            this.submits = [];
            this.sprite = null;
            this.meshlist = [];
            this.cachedClipInfo = new Matrix();
            this.oldTx = 0;
            this.oldTy = 0;
            this.invMat = new Matrix();
            this.context = ctx;
            this.sprite = sp;
            ctx._globalClipMatrix.copyTo(this.cachedClipInfo);
        }
        startRec() {
            let context = this.context;
            if (context._charSubmitCache && context._charSubmitCache._enable) {
                context._charSubmitCache.enable(false, context);
                context._charSubmitCache.enable(true, context);
            }
            context._incache = true;
            this.touches.length = 0;
            context.touches = this.touches;
            context._globalClipMatrix.copyTo(this.cachedClipInfo);
            this.submits.length = 0;
            this.submitStartPos = context._submits._length;
            for (var i = 0, sz = this.meshlist.length; i < sz; i++) {
                var curm = this.meshlist[i];
                curm.canReuse ? (curm.releaseMesh()) : (curm.destroy());
            }
            this.meshlist.length = 0;
            this._mesh = MeshQuadTexture.getAMesh(false);
            this._pathMesh = MeshVG.getAMesh(false);
            this._triangleMesh = MeshTexture.getAMesh(false);
            this.meshlist.push(this._mesh);
            this.meshlist.push(this._pathMesh);
            this.meshlist.push(this._triangleMesh);
            context._curSubmit = SubmitBase.RENDERBASE;
            this._oldMesh = context._mesh;
            this._oldPathMesh = context._pathMesh;
            this._oldTriMesh = context._triangleMesh;
            this._oldMeshList = context.meshlist;
            context._mesh = this._mesh;
            context._pathMesh = this._pathMesh;
            context._triangleMesh = this._triangleMesh;
            context.meshlist = this.meshlist;
            this.oldTx = context._curMat.tx;
            this.oldTy = context._curMat.ty;
            context._curMat.tx = 0;
            context._curMat.ty = 0;
            context._curMat.copyTo(this.invMat);
            this.invMat.invert();
        }
        endRec() {
            let context = this.context;
            if (context._charSubmitCache && context._charSubmitCache._enable) {
                context._charSubmitCache.enable(false, context);
                context._charSubmitCache.enable(true, context);
            }
            var parsubmits = context._submits;
            this.submitEndPos = parsubmits._length;
            var num = this.submitEndPos - this.submitStartPos;
            for (var i = 0; i < num; i++) {
                this.submits.push(parsubmits[this.submitStartPos + i]);
            }
            parsubmits._length -= num;
            context._mesh = this._oldMesh;
            context._pathMesh = this._oldPathMesh;
            context._triangleMesh = this._oldTriMesh;
            context.meshlist = this._oldMeshList;
            context._curSubmit = SubmitBase.RENDERBASE;
            context._curMat.tx = this.oldTx;
            context._curMat.ty = this.oldTy;
            context.touches = null;
            context._incache = false;
        }
        isCacheValid() {
            var curclip = this.context._globalClipMatrix;
            if (curclip.a != this.cachedClipInfo.a || curclip.b != this.cachedClipInfo.b || curclip.c != this.cachedClipInfo.c
                || curclip.d != this.cachedClipInfo.d || curclip.tx != this.cachedClipInfo.tx || curclip.ty != this.cachedClipInfo.ty)
                return false;
            return true;
        }
        isTextNeedRestore() {
            var textNeedRestore = false;
            var charRIs = this.touches;
            if (charRIs) {
                for (var ci = 0; ci < charRIs.length; ci++) {
                    if (charRIs[ci].deleted) {
                        textNeedRestore = true;
                        break;
                    }
                }
            }
            return textNeedRestore;
        }
        flushsubmit() {
            var curSubmit = SubmitBase.RENDERBASE;
            this.submits.forEach(function (subm) {
                if (subm == SubmitBase.RENDERBASE)
                    return;
                SubmitBase.preRender = curSubmit;
                curSubmit = subm;
                subm.renderSubmit();
            });
        }
        releaseMem() {
        }
    }
    WebGLCacheAsNormalCanvas.matI = new Matrix();
    if (window.conch && !window.conchConfig.conchWebGL) {
        WebGLCacheAsNormalCanvas = NativeWebGLCacheAsNormalCanvas;
    }

    class LayaGLQuickRunner {
        static __init__() {
            LayaGLQuickRunner.map[SpriteConst.ALPHA | SpriteConst.TRANSFORM | SpriteConst.GRAPHICS] = LayaGLQuickRunner.alpha_transform_drawLayaGL;
            LayaGLQuickRunner.map[SpriteConst.ALPHA | SpriteConst.GRAPHICS] = LayaGLQuickRunner.alpha_drawLayaGL;
            LayaGLQuickRunner.map[SpriteConst.TRANSFORM | SpriteConst.GRAPHICS] = LayaGLQuickRunner.transform_drawLayaGL;
            LayaGLQuickRunner.map[SpriteConst.TRANSFORM | SpriteConst.CHILDS] = LayaGLQuickRunner.transform_drawNodes;
            LayaGLQuickRunner.map[SpriteConst.ALPHA | SpriteConst.TRANSFORM | SpriteConst.TEXTURE] = LayaGLQuickRunner.alpha_transform_drawTexture;
            LayaGLQuickRunner.map[SpriteConst.ALPHA | SpriteConst.TEXTURE] = LayaGLQuickRunner.alpha_drawTexture;
            LayaGLQuickRunner.map[SpriteConst.TRANSFORM | SpriteConst.TEXTURE] = LayaGLQuickRunner.transform_drawTexture;
            LayaGLQuickRunner.map[SpriteConst.GRAPHICS | SpriteConst.CHILDS] = LayaGLQuickRunner.drawLayaGL_drawNodes;
        }
        static transform_drawTexture(sprite, context, x, y) {
            sprite._style;
            var tex = sprite.texture;
            context.saveTransform(LayaGLQuickRunner.curMat);
            context.transformByMatrix(sprite.transform, x, y);
            var width = sprite._width || tex.sourceWidth;
            var height = sprite._height || tex.sourceHeight;
            var wRate = width / tex.sourceWidth;
            var hRate = height / tex.sourceHeight;
            width = tex.width * wRate;
            height = tex.height * hRate;
            if (width <= 0 || height <= 0)
                return null;
            var px = -sprite.pivotX + tex.offsetX * wRate;
            var py = -sprite.pivotY + tex.offsetY * hRate;
            if (!sprite._getBit(NodeFlags.HIDE_BY_EDITOR))
                context.drawTexture(tex, px, py, width, height);
            context.restoreTransform(LayaGLQuickRunner.curMat);
        }
        static alpha_drawTexture(sprite, context, x, y) {
            var style = sprite._style;
            var alpha;
            var tex = sprite.texture;
            if ((alpha = style.alpha) > 0.01 || sprite._needRepaint()) {
                var temp = context.globalAlpha;
                context.globalAlpha *= alpha;
                var width = sprite._width || tex.width;
                var height = sprite._height || tex.height;
                var wRate = width / tex.sourceWidth;
                var hRate = height / tex.sourceHeight;
                width = tex.width * wRate;
                height = tex.height * hRate;
                if (width <= 0 || height <= 0)
                    return null;
                var px = x - style.pivotX + tex.offsetX * wRate;
                var py = y - style.pivotY + tex.offsetY * hRate;
                if (!sprite._getBit(NodeFlags.HIDE_BY_EDITOR))
                    context.drawTexture(tex, px, py, width, height);
                context.globalAlpha = temp;
            }
        }
        static alpha_transform_drawTexture(sprite, context, x, y) {
            var style = sprite._style;
            var alpha;
            var tex = sprite.texture;
            if ((alpha = style.alpha) > 0.01 || sprite._needRepaint()) {
                var temp = context.globalAlpha;
                context.globalAlpha *= alpha;
                context.saveTransform(LayaGLQuickRunner.curMat);
                context.transformByMatrix(sprite.transform, x, y);
                var width = sprite._width || tex.sourceWidth;
                var height = sprite._height || tex.sourceHeight;
                var wRate = width / tex.sourceWidth;
                var hRate = height / tex.sourceHeight;
                width = tex.width * wRate;
                height = tex.height * hRate;
                if (width <= 0 || height <= 0)
                    return null;
                var px = -style.pivotX + tex.offsetX * wRate;
                var py = -style.pivotY + tex.offsetY * hRate;
                if (!sprite._getBit(NodeFlags.HIDE_BY_EDITOR))
                    context.drawTexture(tex, px, py, width, height);
                context.restoreTransform(LayaGLQuickRunner.curMat);
                context.globalAlpha = temp;
            }
        }
        static alpha_transform_drawLayaGL(sprite, context, x, y) {
            var style = sprite._style;
            var alpha;
            if ((alpha = style.alpha) > 0.01 || sprite._needRepaint()) {
                var temp = context.globalAlpha;
                context.globalAlpha *= alpha;
                context.saveTransform(LayaGLQuickRunner.curMat);
                context.transformByMatrix(sprite.transform, x, y);
                if (!sprite._getBit(NodeFlags.HIDE_BY_EDITOR))
                    sprite._graphics && sprite._graphics._render(sprite, context, -style.pivotX, -style.pivotY);
                context.restoreTransform(LayaGLQuickRunner.curMat);
                context.globalAlpha = temp;
            }
        }
        static alpha_drawLayaGL(sprite, context, x, y) {
            var style = sprite._style;
            var alpha;
            if ((alpha = style.alpha) > 0.01 || sprite._needRepaint()) {
                var temp = context.globalAlpha;
                context.globalAlpha *= alpha;
                if (!sprite._getBit(NodeFlags.HIDE_BY_EDITOR))
                    sprite._graphics && sprite._graphics._render(sprite, context, x - style.pivotX, y - style.pivotY);
                context.globalAlpha = temp;
            }
        }
        static transform_drawLayaGL(sprite, context, x, y) {
            var style = sprite._style;
            context.saveTransform(LayaGLQuickRunner.curMat);
            context.transformByMatrix(sprite.transform, x, y);
            if (!sprite._getBit(NodeFlags.HIDE_BY_EDITOR))
                sprite._graphics && sprite._graphics._render(sprite, context, -style.pivotX, -style.pivotY);
            context.restoreTransform(LayaGLQuickRunner.curMat);
        }
        static transform_drawNodes(sprite, context, x, y) {
            var textLastRender = sprite._getBit(NodeFlags.DRAWCALL_OPTIMIZE) && context.drawCallOptimize(true);
            let drawingToTexture = context._drawingToTexture;
            var style = sprite._style;
            context.saveTransform(LayaGLQuickRunner.curMat);
            context.transformByMatrix(sprite.transform, x, y);
            x = -style.pivotX;
            y = -style.pivotY;
            var childs = sprite._children, n = childs.length;
            let rect;
            let left, top, right, bottom, _x, _y;
            if (style.viewport) {
                rect = style.viewport;
                left = rect.x;
                top = rect.y;
                right = rect.right;
                bottom = rect.bottom;
            }
            for (let i = 0; i < n; ++i) {
                let ele = childs[i];
                let visFlag;
                if (drawingToTexture)
                    visFlag = ele._visible && !ele._getBit(NodeFlags.ESCAPE_DRAWING_TO_TEXTURE);
                else
                    visFlag = ele._visible || ele._getBit(NodeFlags.DISABLE_VISIBILITY);
                if (rect && ((_x = ele._x) >= right || (_x + ele.width) <= left || (_y = ele._y) >= bottom || (_y + ele.height) <= top))
                    visFlag = false;
                if (visFlag)
                    ele.render(context, x, y);
            }
            context.restoreTransform(LayaGLQuickRunner.curMat);
            textLastRender && context.drawCallOptimize(false);
        }
        static drawLayaGL_drawNodes(sprite, context, x, y) {
            var textLastRender = sprite._getBit(NodeFlags.DRAWCALL_OPTIMIZE) && context.drawCallOptimize(true);
            let drawingToTexture = context._drawingToTexture;
            var style = sprite._style;
            x = x - style.pivotX;
            y = y - style.pivotY;
            if (!sprite._getBit(NodeFlags.HIDE_BY_EDITOR))
                sprite._graphics && sprite._graphics._render(sprite, context, x, y);
            var childs = sprite._children, n = childs.length;
            let rect;
            let left, top, right, bottom, _x, _y;
            if (style.viewport) {
                rect = style.viewport;
                left = rect.x;
                top = rect.y;
                right = rect.right;
                bottom = rect.bottom;
            }
            for (let i = 0; i < n; ++i) {
                let ele = childs[i];
                let visFlag;
                if (drawingToTexture)
                    visFlag = ele._visible && !ele._getBit(NodeFlags.ESCAPE_DRAWING_TO_TEXTURE);
                else
                    visFlag = ele._visible || ele._getBit(NodeFlags.DISABLE_VISIBILITY);
                if (rect && ((_x = ele._x) >= right || (_x + ele.width) <= left || (_y = ele._y) >= bottom || (_y + ele.height) <= top))
                    visFlag = false;
                if (visFlag)
                    ele.render(context, x, y);
            }
            textLastRender && context.drawCallOptimize(false);
        }
    }
    LayaGLQuickRunner.map = [];
    LayaGLQuickRunner.curMat = new Matrix();

    class NativeFilter {
        constructor() { }
        get type() { return -1; }
    }
    NativeFilter.BLUR = 0x10;
    NativeFilter.COLOR = 0x20;
    NativeFilter.GLOW = 0x08;
    NativeFilter._filter = function (sprite, context, x, y) {
        var webglctx = context;
        var next = this._next;
        if (next) {
            var filters = sprite.filters, len = filters.length;
            if (len == 1 && (filters[0].type == NativeFilter.COLOR)) {
                context.save();
                context.setColorFilter(filters[0]);
                next._fun.call(next, sprite, context, x, y);
                context.restore();
                return;
            }
            var svCP = Value2D.create(ShaderDefines2D.TEXTURE2D, 0);
            var b;
            var p = Point.TEMP;
            var tMatrix = webglctx._curMat;
            var mat = Matrix.create();
            tMatrix.copyTo(mat);
            var tPadding = 0;
            var tHalfPadding = 0;
            var tIsHaveGlowFilter = false;
            var source = null;
            var out = sprite._cacheStyle.filterCache || null;
            if (!out || sprite.getRepaint() != 0) {
                tIsHaveGlowFilter = sprite._isHaveGlowFilter();
                if (tIsHaveGlowFilter) {
                    tPadding = 50;
                    tHalfPadding = 25;
                }
                b = new Rectangle();
                b.copyFrom(sprite.getSelfBounds());
                b.x += sprite.x;
                b.y += sprite.y;
                b.x -= sprite.pivotX + 4;
                b.y -= sprite.pivotY + 4;
                var tSX = b.x;
                var tSY = b.y;
                b.width += (tPadding + 8);
                b.height += (tPadding + 8);
                p.x = b.x * mat.a + b.y * mat.c;
                p.y = b.y * mat.d + b.x * mat.b;
                b.x = p.x;
                b.y = p.y;
                p.x = b.width * mat.a + b.height * mat.c;
                p.y = b.height * mat.d + b.width * mat.b;
                b.width = p.x;
                b.height = p.y;
                if (b.width <= 0 || b.height <= 0) {
                    return;
                }
                out && out.destroy();
                source = new window.conchRenderTexture2D(LayaGL.renderEngine._nativeObj, b.width, b.height, exports.RenderTargetFormat.R8G8B8A8, exports.RenderTargetFormat.None);
                var outRT = out = new window.conchRenderTexture2D(LayaGL.renderEngine._nativeObj, b.width, b.height, exports.RenderTargetFormat.R8G8B8A8, exports.RenderTargetFormat.None);
                sprite._getCacheStyle().filterCache = out;
                webglctx.pushRT();
                webglctx.useRT(source);
                var tX = sprite.x - tSX + tHalfPadding;
                var tY = sprite.y - tSY + tHalfPadding;
                next._fun.call(next, sprite, context, tX, tY);
                webglctx.useRT(outRT);
                for (var i = 0; i < len; i++) {
                    if (i != 0) {
                        webglctx.useRT(source);
                        webglctx.drawTarget(outRT, 0, 0, b.width, b.height, Matrix.TEMP.identity(), svCP, null, BlendMode.TOINT.overlay);
                        webglctx.useRT(outRT);
                    }
                    var fil = filters[i];
                    switch (fil.type) {
                        case NativeFilter.BLUR:
                            webglctx.drawTargetBlurFilter(source, 0, 0, b.width, b.height, fil.strength);
                            break;
                        case NativeFilter.GLOW:
                            fil._glRender && fil._glRender.render(source, context, b.width, b.height, fil);
                            break;
                        case NativeFilter.COLOR:
                            webglctx.setColorFilter(fil);
                            webglctx.drawTarget(source, 0, 0, b.width, b.height, Matrix.EMPTY.identity(), Value2D.create(ShaderDefines2D.TEXTURE2D, 0));
                            webglctx.setColorFilter(null);
                            break;
                    }
                }
                webglctx.popRT();
            }
            else {
                tIsHaveGlowFilter = sprite._isHaveGlowFilter() || false;
                if (tIsHaveGlowFilter) {
                    tPadding = 50;
                    tHalfPadding = 25;
                }
                b = sprite.getBounds();
                if (b.width <= 0 || b.height <= 0) {
                    return;
                }
                b.width += (tPadding + 8);
                b.height += (tPadding + 8);
                b.x -= sprite.pivotX + 4;
                b.y -= sprite.pivotY + 4;
                p.x = b.x * mat.a + b.y * mat.c;
                p.y = b.y * mat.d + b.x * mat.b;
                b.x = p.x;
                b.y = p.y;
                p.x = b.width * mat.a + b.height * mat.c;
                p.y = b.height * mat.d + b.width * mat.b;
                b.width = p.x;
                b.height = p.y;
            }
            x = x - tHalfPadding - sprite.x;
            y = y - tHalfPadding - sprite.y;
            p.setTo(x, y);
            mat.transformPoint(p);
            x = p.x + b.x;
            y = p.y + b.y;
            webglctx.drawFilter(out, source, x, y, b.width, b.height);
            mat.destroy();
        }
    };

    class RenderSprite {
        constructor(type, next) {
            if (LayaGLQuickRunner.map[type]) {
                this._fun = LayaGLQuickRunner.map[type];
                this._next = RenderSprite.NORENDER;
                return;
            }
            this._next = next || RenderSprite.NORENDER;
            switch (type) {
                case 0:
                    this._fun = this._no;
                    return;
                case SpriteConst.ALPHA:
                    this._fun = this._alpha;
                    return;
                case SpriteConst.TRANSFORM:
                    this._fun = this._transform;
                    return;
                case SpriteConst.BLEND:
                    this._fun = this._blend;
                    return;
                case SpriteConst.CANVAS:
                    this._fun = this._canvas;
                    return;
                case SpriteConst.MASK:
                    if (LayaEnv.isConch && !window.conchConfig.conchWebGL) {
                        this._fun = this._maskNative;
                    }
                    else {
                        this._fun = this._mask;
                    }
                    return;
                case SpriteConst.CLIP:
                    this._fun = this._clip;
                    return;
                case SpriteConst.STYLE:
                    this._fun = this._style;
                    return;
                case SpriteConst.GRAPHICS:
                    this._fun = this._graphics;
                    return;
                case SpriteConst.CHILDS:
                    this._fun = this._children;
                    return;
                case SpriteConst.CUSTOM:
                    this._fun = this._custom;
                    return;
                case SpriteConst.TEXTURE:
                    this._fun = this._texture;
                    return;
                case SpriteConst.FILTERS:
                    if (LayaEnv.isConch && !window.conchConfig.conchWebGL) {
                        this._fun = NativeFilter._filter;
                    }
                    else {
                        this._fun = Filter._filter;
                    }
                    return;
                case SpriteConst.HITAREA:
                    this._fun = this._hitarea;
                    return;
                case RenderSprite.INIT:
                    this._fun = RenderSprite._initRenderFun;
                    return;
            }
            this.onCreate(type);
        }
        static __init__() {
            LayaGLQuickRunner.__init__();
            var i, len;
            var initRender;
            initRender = new RenderSprite(RenderSprite.INIT, null);
            len = RenderSprite.renders.length = SpriteConst.CHILDS * 2;
            for (i = 0; i < len; i++)
                RenderSprite.renders[i] = initRender;
            RenderSprite.renders[0] = new RenderSprite(0, null);
        }
        static _initRenderFun(sprite, context, x, y) {
            var type = sprite._renderType;
            var r = RenderSprite.renders[type] = RenderSprite._getTypeRender(type);
            r._fun(sprite, context, x, y);
        }
        static _getTypeRender(type) {
            if (LayaGLQuickRunner.map[type])
                return new RenderSprite(type, null);
            var rst = null;
            var tType = SpriteConst.CHILDS;
            while (tType > 0) {
                if (tType & type)
                    rst = new RenderSprite(tType, rst);
                tType = tType >> 1;
            }
            return rst;
        }
        onCreate(type) {
        }
        _style(sprite, context, x, y) {
            var style = sprite._style;
            if (style.render != null)
                style.render(sprite, context, x, y);
            var next = this._next;
            next._fun.call(next, sprite, context, x, y);
        }
        _no(sprite, context, x, y) {
        }
        _custom(sprite, context, x, y) {
            sprite.customRender(context, x, y);
            this._next._fun.call(this._next, sprite, context, 0, 0);
        }
        _clip(sprite, context, x, y) {
            var next = this._next;
            if (next == RenderSprite.NORENDER)
                return;
            if (sprite._getBit(NodeFlags.DISABLE_INNER_CLIPPING)) {
                next._fun.call(next, sprite, context, x, y);
                return;
            }
            var r = sprite._style.scrollRect;
            var width = r.width;
            var height = r.height;
            if (width === 0 || height === 0) {
                return;
            }
            context.save();
            context.clipRect(x, y, width, height);
            next._fun.call(next, sprite, context, x - r.x, y - r.y);
            context.restore();
        }
        _texture(sprite, context, x, y) {
            if (!sprite._getBit(NodeFlags.HIDE_BY_EDITOR)) {
                var tex = sprite.texture;
                if (tex._getSource()) {
                    var width = sprite._width || tex.sourceWidth;
                    var height = sprite._height || tex.sourceHeight;
                    var wRate = width / tex.sourceWidth;
                    var hRate = height / tex.sourceHeight;
                    width = tex.width * wRate;
                    height = tex.height * hRate;
                    if (width <= 0 || height <= 0)
                        return;
                    var px = x - sprite.pivotX + tex.offsetX * wRate;
                    var py = y - sprite.pivotY + tex.offsetY * hRate;
                    context.drawTexture(tex, px, py, width, height);
                }
            }
            var next = this._next;
            if (next != RenderSprite.NORENDER)
                next._fun.call(next, sprite, context, x, y);
        }
        _graphics(sprite, context, x, y) {
            if (!sprite._getBit(NodeFlags.HIDE_BY_EDITOR)) {
                var style = sprite._style;
                var g = sprite._graphics;
                g && g._render(sprite, context, x - style.pivotX, y - style.pivotY);
            }
            var next = this._next;
            if (next != RenderSprite.NORENDER)
                next._fun.call(next, sprite, context, x, y);
        }
        _hitarea(sprite, context, x, y) {
            if (!context._drawingToTexture && sprite.hitArea) {
                var style = sprite._style;
                var g = sprite.hitArea._hit;
                var temp = context.globalAlpha;
                context.globalAlpha *= 0.5;
                g && g._render(sprite, context, x - style.pivotX, y - style.pivotY);
                g = sprite.hitArea._unHit;
                g && g._render(sprite, context, x - style.pivotX, y - style.pivotY);
                context.globalAlpha = temp;
            }
            var next = this._next;
            if (next != RenderSprite.NORENDER)
                next._fun.call(next, sprite, context, x, y);
        }
        _alpha(sprite, context, x, y) {
            var style = sprite._style;
            var alpha;
            if ((alpha = style.alpha) > 0.01 || sprite._needRepaint()) {
                var temp = context.globalAlpha;
                context.globalAlpha *= alpha;
                var next = this._next;
                next._fun.call(next, sprite, context, x, y);
                context.globalAlpha = temp;
            }
        }
        _transform(sprite, context, x, y) {
            var transform = sprite.transform, _next = this._next;
            sprite._style;
            if (transform && _next != RenderSprite.NORENDER) {
                context.save();
                context.transform(transform.a, transform.b, transform.c, transform.d, transform.tx + x, transform.ty + y);
                _next._fun.call(_next, sprite, context, 0, 0);
                context.restore();
            }
            else {
                if (_next != RenderSprite.NORENDER)
                    _next._fun.call(_next, sprite, context, x, y);
            }
        }
        _children(sprite, context, x, y) {
            let style = sprite._style;
            let childs = sprite._children, n = childs.length;
            x = x - sprite.pivotX;
            y = y - sprite.pivotY;
            let textLastRender = sprite._getBit(NodeFlags.DRAWCALL_OPTIMIZE) && context.drawCallOptimize(true);
            let drawingToTexture = context._drawingToTexture;
            let rect;
            let left, top, right, bottom, _x, _y;
            if (style.viewport) {
                rect = style.viewport;
                left = rect.x;
                top = rect.y;
                right = rect.right;
                bottom = rect.bottom;
            }
            for (let i = 0; i < n; ++i) {
                let ele = childs[i];
                let visFlag;
                if (drawingToTexture)
                    visFlag = ele._visible && !ele._getBit(NodeFlags.ESCAPE_DRAWING_TO_TEXTURE);
                else
                    visFlag = ele._visible || ele._getBit(NodeFlags.DISABLE_VISIBILITY);
                if (visFlag) {
                    if (rect && ((_x = ele._x) >= right || (_x + ele.width) <= left || (_y = ele._y) >= bottom || (_y + ele.height) <= top))
                        visFlag = false;
                    else if (sprite._cacheStyle.mask == ele && !ele._getBit(NodeFlags.DISABLE_VISIBILITY))
                        visFlag = false;
                }
                if (visFlag) {
                    if (ele._getBit(NodeFlags.DISABLE_OUTER_CLIPPING))
                        context.clipRect(0, 0, 1, 1, true);
                    ele.render(context, x, y);
                }
            }
            textLastRender && context.drawCallOptimize(false);
        }
        _canvas(sprite, context, x, y) {
            var _cacheStyle = sprite._cacheStyle;
            var _next = this._next;
            if (!_cacheStyle.enableCanvasRender || !context._drawingToTexture && _cacheStyle.mask && _cacheStyle.mask._getBit(NodeFlags.DISABLE_VISIBILITY)) {
                _next._fun.call(_next, sprite, context, x, y);
                return;
            }
            _cacheStyle.cacheAs === 'bitmap' ? (Stat.canvasBitmap++) : (Stat.canvasNormal++);
            var cacheNeedRebuild = false;
            var textNeedRestore = false;
            if (_cacheStyle.canvas) {
                var canv = _cacheStyle.canvas;
                textNeedRestore = canv.isTextNeedRestore && canv.isTextNeedRestore();
                cacheNeedRebuild = canv.isCacheValid && !canv.isCacheValid();
            }
            if (sprite._needRepaint() || (!_cacheStyle.canvas) || textNeedRestore || cacheNeedRebuild || ILaya.stage.isGlobalRepaint()) {
                if (_cacheStyle.cacheAs === 'normal') {
                    if (context._targets) {
                        _next._fun.call(_next, sprite, context, x, y);
                        return;
                    }
                    else {
                        this._canvas_webgl_normal_repaint(sprite, context);
                    }
                }
                else {
                    this._canvas_repaint(sprite, context, x, y);
                }
            }
            var tRec = _cacheStyle.cacheRect;
            context.drawCanvas(_cacheStyle.canvas, x + tRec.x, y + tRec.y, tRec.width, tRec.height);
        }
        _canvas_repaint(sprite, context, x, y) {
            var _cacheStyle = sprite._cacheStyle;
            var _next = this._next;
            var tx;
            var canvas = _cacheStyle.canvas;
            var left;
            var top;
            var tRec;
            var tCacheType = _cacheStyle.cacheAs;
            var w, h;
            var scaleX, scaleY;
            var scaleInfo;
            scaleInfo = _cacheStyle._calculateCacheRect(sprite, tCacheType, x, y);
            scaleX = scaleInfo.x;
            scaleY = scaleInfo.y;
            tRec = _cacheStyle.cacheRect;
            w = tRec.width * scaleX;
            h = tRec.height * scaleY;
            left = tRec.x;
            top = tRec.y;
            if (tCacheType === 'bitmap' && (w > 2048 || h > 2048)) {
                console.warn("cache bitmap size larger than 2048,cache ignored");
                _cacheStyle.releaseContext();
                _next._fun.call(_next, sprite, context, x, y);
                return;
            }
            if (!canvas) {
                _cacheStyle.createContext();
                canvas = _cacheStyle.canvas;
            }
            tx = canvas.context;
            tx.sprite = sprite;
            (canvas.width != w || canvas.height != h) && canvas.size(w, h);
            if (tCacheType === 'bitmap')
                tx.asBitmap = true;
            else if (tCacheType === 'normal')
                tx.asBitmap = false;
            tx.clear();
            if (scaleX != 1 || scaleY != 1) {
                var ctx = tx;
                ctx.save();
                ctx.scale(scaleX, scaleY);
                _next._fun.call(_next, sprite, tx, -left, -top);
                ctx.restore();
                sprite._applyFilters();
            }
            else {
                ctx = tx;
                _next._fun.call(_next, sprite, tx, -left, -top);
                sprite._applyFilters();
            }
            if (_cacheStyle.staticCache)
                _cacheStyle.reCache = false;
            Stat.canvasReCache++;
        }
        _canvas_webgl_normal_repaint(sprite, context) {
            var _cacheStyle = sprite._cacheStyle;
            var _next = this._next;
            var canvas = _cacheStyle.canvas;
            var tCacheType = _cacheStyle.cacheAs;
            _cacheStyle._calculateCacheRect(sprite, tCacheType, 0, 0);
            if (!canvas) {
                canvas = new WebGLCacheAsNormalCanvas(context, sprite);
                _cacheStyle.canvas = canvas;
            }
            var tx = canvas.context;
            canvas.startRec();
            _next._fun.call(_next, sprite, tx, sprite.pivotX, sprite.pivotY);
            sprite._applyFilters();
            Stat.canvasReCache++;
            canvas.endRec();
        }
        _blend(sprite, context, x, y) {
            var style = sprite._style;
            var next = this._next;
            if (style.blendMode) {
                context.save();
                context.globalCompositeOperation = style.blendMode;
                next._fun.call(next, sprite, context, x, y);
                context.restore();
            }
            else {
                next._fun.call(next, sprite, context, x, y);
            }
        }
        _mask(sprite, context, x, y) {
            var next = this._next;
            var mask = sprite.mask;
            var ctx = context;
            if (mask && (!mask._getBit(NodeFlags.DISABLE_VISIBILITY) || context._drawingToTexture)) {
                ctx.save();
                var preBlendMode = ctx.globalCompositeOperation;
                var tRect = new Rectangle();
                tRect.copyFrom(mask.getBounds());
                tRect.width = Math.round(tRect.width);
                tRect.height = Math.round(tRect.height);
                tRect.x = Math.round(tRect.x);
                tRect.y = Math.round(tRect.y);
                if (tRect.width > 0 && tRect.height > 0) {
                    var w = tRect.width;
                    var h = tRect.height;
                    var tmpRT = WebGLRTMgr.getRT(w, h);
                    ctx.breakNextMerge();
                    ctx.pushRT();
                    ctx.addRenderObject(SubmitCMD.create([ctx, tmpRT, w, h], RenderSprite.tmpTarget, this));
                    mask.render(ctx, -tRect.x, -tRect.y);
                    ctx.breakNextMerge();
                    ctx.popRT();
                    ctx.save();
                    let shrink = 0.1;
                    ctx.clipRect(x + tRect.x - sprite.getStyle().pivotX + shrink, y + tRect.y - sprite.getStyle().pivotY + shrink, w - shrink * 2, h - shrink * 2);
                    next._fun.call(next, sprite, ctx, x, y);
                    ctx.restore();
                    preBlendMode = ctx.globalCompositeOperation;
                    ctx.addRenderObject(SubmitCMD.create(["mask"], RenderSprite.setBlendMode, this));
                    var shaderValue = Value2D.create(ShaderDefines2D.TEXTURE2D, 0);
                    var uv = Texture.INV_UV;
                    ctx.drawTarget(tmpRT, x + tRect.x - sprite.getStyle().pivotX, y + tRect.y - sprite.getStyle().pivotY, w, h, Matrix.TEMP.identity(), shaderValue, uv, 6);
                    ctx.addRenderObject(SubmitCMD.create([tmpRT], RenderSprite.recycleTarget, this));
                    ctx.addRenderObject(SubmitCMD.create([preBlendMode], RenderSprite.setBlendMode, this));
                }
                ctx.restore();
            }
            else {
                next._fun.call(next, sprite, context, x, y);
            }
        }
        _maskNative(sprite, context, x, y) {
            var next = this._next;
            var mask = sprite.mask;
            var ctx = context;
            if (mask) {
                ctx.save();
                ctx.globalCompositeOperation;
                var tRect = new Rectangle();
                tRect.copyFrom(mask.getBounds());
                tRect.width = Math.round(tRect.width);
                tRect.height = Math.round(tRect.height);
                tRect.x = Math.round(tRect.x);
                tRect.y = Math.round(tRect.y);
                if (tRect.width > 0 && tRect.height > 0) {
                    var w = tRect.width;
                    var h = tRect.height;
                    var tmpRT = ctx.drawMask(w, h);
                    mask.render(ctx, -tRect.x, -tRect.y);
                    let shrink = 0.1;
                    ctx.drawMasked(x + tRect.x - sprite.getStyle().pivotX + shrink, y + tRect.y - sprite.getStyle().pivotY + shrink, w - shrink * 2, h - shrink * 2);
                    next._fun.call(next, sprite, ctx, x, y);
                    ctx.drawMaskComposite(tmpRT, x + tRect.x - sprite.getStyle().pivotX, y + tRect.y - sprite.getStyle().pivotY, w, h);
                }
                ctx.restore();
            }
            else {
                next._fun.call(next, sprite, context, x, y);
            }
        }
        static tmpTarget(ctx, rt, w, h) {
            rt.start();
            rt.clear(0, 0, 0, 0);
        }
        static recycleTarget(rt) {
            WebGLRTMgr.releaseRT(rt);
        }
        static setBlendMode(blendMode) {
            BlendMode.targetFns[BlendMode.TOINT[blendMode]]();
        }
    }
    RenderSprite.INIT = 0x11111;
    RenderSprite.renders = [];
    RenderSprite.NORENDER = new RenderSprite(0, null);

    class Bezier {
        constructor() {
            this._controlPoints = [new Point(), new Point(), new Point()];
            this._calFun = this.getPoint2;
        }
        _switchPoint(x, y) {
            var tPoint = this._controlPoints.shift();
            tPoint.setTo(x, y);
            this._controlPoints.push(tPoint);
        }
        getPoint2(t, rst) {
            var p1 = this._controlPoints[0];
            var p2 = this._controlPoints[1];
            var p3 = this._controlPoints[2];
            var lineX = Math.pow((1 - t), 2) * p1.x + 2 * t * (1 - t) * p2.x + Math.pow(t, 2) * p3.x;
            var lineY = Math.pow((1 - t), 2) * p1.y + 2 * t * (1 - t) * p2.y + Math.pow(t, 2) * p3.y;
            rst.push(lineX, lineY);
        }
        getPoint3(t, rst) {
            var p1 = this._controlPoints[0];
            var p2 = this._controlPoints[1];
            var p3 = this._controlPoints[2];
            var p4 = this._controlPoints[3];
            var lineX = Math.pow((1 - t), 3) * p1.x + 3 * p2.x * t * (1 - t) * (1 - t) + 3 * p3.x * t * t * (1 - t) + p4.x * Math.pow(t, 3);
            var lineY = Math.pow((1 - t), 3) * p1.y + 3 * p2.y * t * (1 - t) * (1 - t) + 3 * p3.y * t * t * (1 - t) + p4.y * Math.pow(t, 3);
            rst.push(lineX, lineY);
        }
        insertPoints(count, rst) {
            var i;
            count = count > 0 ? count : 5;
            var dLen;
            dLen = 1 / count;
            for (i = 0; i <= 1; i += dLen) {
                this._calFun(i, rst);
            }
        }
        getBezierPoints(pList, inSertCount = 5, count = 2) {
            var i, len;
            len = pList.length;
            if (len < (count + 1) * 2)
                return [];
            var rst = [];
            switch (count) {
                case 2:
                    this._calFun = this.getPoint2;
                    break;
                case 3:
                    this._calFun = this.getPoint3;
                    break;
                default:
                    return [];
            }
            while (this._controlPoints.length <= count) {
                this._controlPoints.push(Point.create());
            }
            for (i = 0; i < count * 2; i += 2) {
                this._switchPoint(pList[i], pList[i + 1]);
            }
            for (i = count * 2; i < len; i += 2) {
                this._switchPoint(pList[i], pList[i + 1]);
                if ((i / 2) % count == 0)
                    this.insertPoints(inSertCount, rst);
            }
            return rst;
        }
    }
    Bezier.I = new Bezier();

    exports.BlendEquationSeparate = void 0;
    (function (BlendEquationSeparate) {
        BlendEquationSeparate[BlendEquationSeparate["ADD"] = 0] = "ADD";
        BlendEquationSeparate[BlendEquationSeparate["SUBTRACT"] = 1] = "SUBTRACT";
        BlendEquationSeparate[BlendEquationSeparate["REVERSE_SUBTRACT"] = 2] = "REVERSE_SUBTRACT";
        BlendEquationSeparate[BlendEquationSeparate["MIN"] = 3] = "MIN";
        BlendEquationSeparate[BlendEquationSeparate["MAX"] = 4] = "MAX";
    })(exports.BlendEquationSeparate || (exports.BlendEquationSeparate = {}));

    exports.CullMode = void 0;
    (function (CullMode) {
        CullMode[CullMode["Off"] = 0] = "Off";
        CullMode[CullMode["Front"] = 1] = "Front";
        CullMode[CullMode["Back"] = 2] = "Back";
    })(exports.CullMode || (exports.CullMode = {}));

    class DrawStyle {
        constructor(value) {
            this.setValue(value);
        }
        static create(value) {
            if (value) {
                var color = (value instanceof ColorUtils) ? value : ColorUtils.create(value);
                return color._drawStyle || (color._drawStyle = new DrawStyle(value));
            }
            return DrawStyle.DEFAULT;
        }
        setValue(value) {
            if (value) {
                this._color = (value instanceof ColorUtils) ? value : ColorUtils.create(value);
            }
            else
                this._color = ColorUtils.create("#000000");
        }
        reset() {
            this._color = ColorUtils.create("#000000");
        }
        toInt() {
            return this._color.numColor;
        }
        equal(value) {
            if (typeof (value) == 'string')
                return this._color.strColor === value;
            if (value instanceof ColorUtils)
                return this._color.numColor === value.numColor;
            return false;
        }
        toColorStr() {
            return this._color.strColor;
        }
    }
    DrawStyle.DEFAULT = new DrawStyle("#000000");

    class Path {
        constructor() {
            this._lastOriX = 0;
            this._lastOriY = 0;
            this.paths = [];
            this._curPath = null;
        }
        beginPath(convex) {
            this.paths.length = 1;
            this._curPath = this.paths[0] = new renderPath();
            this._curPath.convex = convex;
        }
        closePath() {
            this._curPath.loop = true;
        }
        newPath() {
            this._curPath = new renderPath();
            this.paths.push(this._curPath);
        }
        addPoint(pointX, pointY) {
            this._curPath.path.push(pointX, pointY);
        }
        push(points, convex) {
            if (!this._curPath) {
                this._curPath = new renderPath();
                this.paths.push(this._curPath);
            }
            else if (this._curPath.path.length > 0) {
                this._curPath = new renderPath();
                this.paths.push(this._curPath);
            }
            var rp = this._curPath;
            rp.path = points.slice();
            rp.convex = convex;
        }
        reset() {
            this.paths.length = 0;
        }
    }
    class renderPath {
        constructor() {
            this.path = [];
            this.loop = false;
            this.convex = false;
        }
    }

    class SaveBase {
        constructor() {
        }
        static _createArray() {
            var value = [];
            value._length = 0;
            return value;
        }
        static _init() {
            var namemap = SaveBase._namemap = {};
            namemap[SaveBase.TYPE_ALPHA] = "ALPHA";
            namemap[SaveBase.TYPE_FILESTYLE] = "fillStyle";
            namemap[SaveBase.TYPE_FONT] = "font";
            namemap[SaveBase.TYPE_LINEWIDTH] = "lineWidth";
            namemap[SaveBase.TYPE_STROKESTYLE] = "strokeStyle";
            namemap[SaveBase.TYPE_ENABLEMERGE] = "_mergeID";
            namemap[SaveBase.TYPE_MARK] = namemap[SaveBase.TYPE_TRANSFORM] = namemap[SaveBase.TYPE_TRANSLATE] = [];
            namemap[SaveBase.TYPE_TEXTBASELINE] = "textBaseline";
            namemap[SaveBase.TYPE_TEXTALIGN] = "textAlign";
            namemap[SaveBase.TYPE_GLOBALCOMPOSITEOPERATION] = "_nBlendType";
            namemap[SaveBase.TYPE_SHADER] = "shader";
            namemap[SaveBase.TYPE_FILTERS] = "filters";
            namemap[SaveBase.TYPE_COLORFILTER] = '_colorFiler';
            return namemap;
        }
        isSaveMark() { return false; }
        restore(context) {
            this._dataObj[this._valueName] = this._value;
            SaveBase.POOL[SaveBase.POOL._length++] = this;
            this._newSubmit && (context._curSubmit = SubmitBase.RENDERBASE);
        }
        static save(context, type, dataObj, newSubmit) {
            if ((context._saveMark._saveuse & type) !== type) {
                context._saveMark._saveuse |= type;
                var cache = SaveBase.POOL;
                var o = cache._length > 0 ? cache[--cache._length] : (new SaveBase());
                o._value = dataObj[o._valueName = SaveBase._namemap[type]];
                o._dataObj = dataObj;
                o._newSubmit = newSubmit;
                var _save = context._save;
                _save[_save._length++] = o;
            }
        }
    }
    SaveBase.TYPE_ALPHA = 0x1;
    SaveBase.TYPE_FILESTYLE = 0x2;
    SaveBase.TYPE_FONT = 0x8;
    SaveBase.TYPE_LINEWIDTH = 0x100;
    SaveBase.TYPE_STROKESTYLE = 0x200;
    SaveBase.TYPE_MARK = 0x400;
    SaveBase.TYPE_TRANSFORM = 0x800;
    SaveBase.TYPE_TRANSLATE = 0x1000;
    SaveBase.TYPE_ENABLEMERGE = 0x2000;
    SaveBase.TYPE_TEXTBASELINE = 0x4000;
    SaveBase.TYPE_TEXTALIGN = 0x8000;
    SaveBase.TYPE_GLOBALCOMPOSITEOPERATION = 0x10000;
    SaveBase.TYPE_CLIPRECT = 0x20000;
    SaveBase.TYPE_CLIPRECT_STENCIL = 0x40000;
    SaveBase.TYPE_IBVB = 0x80000;
    SaveBase.TYPE_SHADER = 0x100000;
    SaveBase.TYPE_FILTERS = 0x200000;
    SaveBase.TYPE_FILTERS_TYPE = 0x400000;
    SaveBase.TYPE_COLORFILTER = 0x800000;
    SaveBase.POOL = SaveBase._createArray();
    SaveBase._namemap = SaveBase._init();

    class SaveClipRect {
        constructor() {
            this._globalClipMatrix = new Matrix();
            this._clipInfoID = -1;
            this._clipRect = new Rectangle();
            this.incache = false;
        }
        isSaveMark() { return false; }
        restore(context) {
            this._globalClipMatrix.copyTo(context._globalClipMatrix);
            this._clipRect.clone(context._clipRect);
            context._clipInfoID = this._clipInfoID;
            SaveClipRect.POOL[SaveClipRect.POOL._length++] = this;
            context._clipInCache = this.incache;
        }
        static save(context) {
            if ((context._saveMark._saveuse & SaveBase.TYPE_CLIPRECT) == SaveBase.TYPE_CLIPRECT)
                return;
            context._saveMark._saveuse |= SaveBase.TYPE_CLIPRECT;
            var cache = SaveClipRect.POOL;
            var o = cache._length > 0 ? cache[--cache._length] : (new SaveClipRect());
            context._globalClipMatrix.copyTo(o._globalClipMatrix);
            context._clipRect.clone(o._clipRect);
            o._clipInfoID = context._clipInfoID;
            o.incache = context._clipInCache;
            var _save = context._save;
            _save[_save._length++] = o;
        }
    }
    SaveClipRect.POOL = SaveBase._createArray();

    class SaveMark {
        constructor() {
            this._saveuse = 0;
        }
        isSaveMark() {
            return true;
        }
        restore(context) {
            context._saveMark = this._preSaveMark;
            SaveMark.POOL[SaveMark.POOL._length++] = this;
        }
        static Create(context) {
            var no = SaveMark.POOL;
            var o = no._length > 0 ? no[--no._length] : (new SaveMark());
            o._saveuse = 0;
            o._preSaveMark = context._saveMark;
            context._saveMark = o;
            return o;
        }
    }
    SaveMark.POOL = SaveBase._createArray();

    class SaveTransform {
        constructor() {
            this._matrix = new Matrix();
        }
        isSaveMark() { return false; }
        restore(context) {
            context._curMat = this._savematrix;
            SaveTransform.POOL[SaveTransform.POOL._length++] = this;
        }
        static save(context) {
            var _saveMark = context._saveMark;
            if ((_saveMark._saveuse & SaveBase.TYPE_TRANSFORM) === SaveBase.TYPE_TRANSFORM)
                return;
            _saveMark._saveuse |= SaveBase.TYPE_TRANSFORM;
            var no = SaveTransform.POOL;
            var o = no._length > 0 ? no[--no._length] : (new SaveTransform());
            o._savematrix = context._curMat;
            context._curMat = context._curMat.copyTo(o._matrix);
            var _save = context._save;
            _save[_save._length++] = o;
        }
    }
    SaveTransform.POOL = SaveBase._createArray();

    class SaveTranslate {
        constructor() {
            this._mat = new Matrix();
        }
        isSaveMark() { return false; }
        restore(context) {
            this._mat.copyTo(context._curMat);
            SaveTranslate.POOL[SaveTranslate.POOL._length++] = this;
        }
        static save(context) {
            var no = SaveTranslate.POOL;
            var o = no._length > 0 ? no[--no._length] : (new SaveTranslate());
            context._curMat.copyTo(o._mat);
            var _save = context._save;
            _save[_save._length++] = o;
        }
    }
    SaveTranslate.POOL = SaveBase._createArray();

    var texture_vs = "/*\r\n\ttexture和fillrect使用的。\r\n*/\r\nattribute vec4 posuv;\r\nattribute vec4 attribColor;\r\nattribute vec4 attribFlags;\r\n//attribute vec4 clipDir;\r\n//attribute vec2 clipRect;\r\nuniform vec4 clipMatDir;\r\nuniform vec2 clipMatPos;\t\t// 这个是全局的，不用再应用矩阵了。\r\nvarying vec2 cliped;\r\nuniform vec2 size;\r\nuniform vec2 clipOff;\t\t\t// 使用要把clip偏移。cacheas normal用. 只用了[0]\r\n#ifdef WORLDMAT\r\n\tuniform mat4 mmat;\r\n#endif\r\n#ifdef MVP3D\r\n\tuniform mat4 u_MvpMatrix;\r\n#endif\r\nvarying vec4 v_texcoordAlpha;\r\nvarying vec4 v_color;\r\nvarying float v_useTex;\r\n\r\nvoid main() {\r\n\r\n\tvec4 pos = vec4(posuv.xy,0.,1.);\r\n#ifdef WORLDMAT\r\n\tpos=mmat*pos;\r\n#endif\r\n\tvec4 pos1  =vec4((pos.x/size.x-0.5)*2.0,(0.5-pos.y/size.y)*2.0,0.,1.0);\r\n#ifdef MVP3D\r\n\tgl_Position=u_MvpMatrix*pos1;\r\n#else\r\n\tgl_Position=pos1;\r\n#endif\r\n\tv_texcoordAlpha.xy = posuv.zw;\r\n\t//v_texcoordAlpha.z = attribColor.a/255.0;\r\n\tv_color = attribColor/255.0;\r\n\tv_color.xyz*=v_color.w;//反正后面也要预乘\r\n\t\r\n\tv_useTex = attribFlags.r/255.0;\r\n\tfloat clipw = length(clipMatDir.xy);\r\n\tfloat cliph = length(clipMatDir.zw);\r\n\t\r\n\tvec2 clpos = clipMatPos.xy;\r\n\t#ifdef WORLDMAT\r\n\t\t// 如果有mmat，需要修改clipMatPos,因为 这是cacheas normal （如果不是就错了）， clipMatPos被去掉了偏移\r\n\t\tif(clipOff[0]>0.0){\r\n\t\t\tclpos.x+=mmat[3].x;\t//tx\t最简单处理\r\n\t\t\tclpos.y+=mmat[3].y;\t//ty\r\n\t\t}\r\n\t#endif\r\n\tvec2 clippos = pos.xy - clpos;\t//pos已经应用矩阵了，为了减的有意义，clip的位置也要缩放\r\n\tif(clipw>20000. && cliph>20000.)\r\n\t\tcliped = vec2(0.5,0.5);\r\n\telse {\r\n\t\t//转成0到1之间。/clipw/clipw 表示clippos与normalize之后的clip朝向点积之后，再除以clipw\r\n\t\tcliped=vec2( dot(clippos,clipMatDir.xy)/clipw/clipw, dot(clippos,clipMatDir.zw)/cliph/cliph);\r\n\t}\r\n\r\n\t#ifdef INVERTY\r\n\t\tgl_Position.y = -gl_Position.y;\r\n\t#endif\r\n\r\n}";

    var texture_ps = "/*\r\n\ttexture和fillrect使用的。\r\n*/\r\n#if defined(GL_FRAGMENT_PRECISION_HIGH) // 原来的写法会被我们自己的解析流程处理，而我们的解析是不认内置宏的，导致被删掉，所以改成 if defined 了\r\nprecision highp float;\r\n#else\r\nprecision mediump float;\r\n#endif\r\n\r\nvec3 linearToGamma(in vec3 value)\r\n{\r\n    return vec3(mix(pow(value.rgb, vec3(0.41666)) * 1.055 - vec3(0.055), value.rgb * 12.92, vec3(lessThanEqual(value.rgb, vec3(0.0031308)))));\r\n\r\n    // return pow(value, vec3(1.0 / 2.2));\r\n    // return pow(value, vec3(0.455));\r\n}\r\n\r\nvec4 linearToGamma(in vec4 value)\r\n{\r\n    return vec4(linearToGamma(value.rgb), value.a);\r\n}\r\n\r\n\r\nvarying vec4 v_texcoordAlpha;\r\nvarying vec4 v_color;\r\nvarying float v_useTex;\r\nuniform sampler2D texture;\r\nvarying vec2 cliped;\r\n\r\nvec4 sampleTexture(sampler2D texture, vec2 uv)\r\n{\r\n    vec4 color = texture2D(texture, uv);\r\n#ifdef GAMMASPACE\r\n    color.xyz = linearToGamma(color.xyz);\r\n#endif\r\n    return color;\r\n}\r\n\r\n#ifdef BLUR_FILTER\r\nuniform vec4 strength_sig2_2sig2_gauss1; // TODO模糊的过程中会导致变暗变亮\r\nuniform vec2 blurInfo;\r\n\r\n    #define PI 3.141593\r\n\r\nfloat getGaussian(float x, float y)\r\n{\r\n    return strength_sig2_2sig2_gauss1.w * exp(-(x * x + y * y) / strength_sig2_2sig2_gauss1.z);\r\n}\r\n\r\nvec4 blur()\r\n{\r\n    const float blurw = 9.0;\r\n    vec4 vec4Color = vec4(0.0, 0.0, 0.0, 0.0);\r\n    vec2 halfsz = vec2(blurw, blurw) / 2.0 / blurInfo;\r\n    vec2 startpos = v_texcoordAlpha.xy - halfsz;\r\n    vec2 ctexcoord = startpos;\r\n    vec2 step = 1.0 / blurInfo; //每个像素\r\n\r\n    for (float y = 0.0; y <= blurw; ++y)\r\n\t{\r\n\t    ctexcoord.x = startpos.x;\r\n\t    for (float x = 0.0; x <= blurw; ++x)\r\n\t\t{\r\n\t\t    // TODO 纹理坐标的固定偏移应该在vs中处理\r\n\t\t    vec4Color += sampleTexture(texture, ctexcoord) * getGaussian(x - blurw / 2.0, y - blurw / 2.0);\r\n\t\t    ctexcoord.x += step.x;\r\n\t\t}\r\n\t    ctexcoord.y += step.y;\r\n\t}\r\n    // vec4Color.w=1.0;  这个会导致丢失alpha。以后有时间再找模糊会导致透明的问题\r\n    return vec4Color;\r\n}\r\n#endif\r\n\r\n#ifdef COLOR_FILTER\r\nuniform vec4 colorAlpha;\r\nuniform mat4 colorMat;\r\n#endif\r\n\r\n#ifdef GLOW_FILTER\r\nuniform vec4 u_color;\r\nuniform vec4 u_blurInfo1;\r\nuniform vec4 u_blurInfo2;\r\n#endif\r\n\r\n#ifdef COLOR_ADD\r\nuniform vec4 colorAdd;\r\n#endif\r\n\r\n#ifdef FILLTEXTURE\r\nuniform vec4 u_TexRange; // startu,startv,urange, vrange\r\n#endif\r\n\r\nvoid main()\r\n{\r\n    if (cliped.x < 0.)\r\n\tdiscard;\r\n    if (cliped.x > 1.)\r\n\tdiscard;\r\n    if (cliped.y < 0.)\r\n\tdiscard;\r\n    if (cliped.y > 1.)\r\n\tdiscard;\r\n\r\n#ifdef FILLTEXTURE\r\n    vec4 color = sampleTexture(texture, fract(v_texcoordAlpha.xy) * u_TexRange.zw + u_TexRange.xy);\r\n#else\r\n    vec4 color = sampleTexture(texture, v_texcoordAlpha.xy);\r\n#endif\r\n\r\n    if (v_useTex <= 0.)\r\n\tcolor = vec4(1., 1., 1., 1.);\r\n    color.a *= v_color.w;\r\n    // color.rgb*=v_color.w;\r\n    color.rgb *= v_color.rgb;\r\n    gl_FragColor = color;\r\n\r\n#ifdef COLOR_ADD\r\n    gl_FragColor = vec4(colorAdd.rgb, colorAdd.a * gl_FragColor.a);\r\n    gl_FragColor.xyz *= colorAdd.a;\r\n#endif\r\n\r\n#ifdef BLUR_FILTER\r\n    gl_FragColor = blur();\r\n    gl_FragColor.w *= v_color.w;\r\n#endif\r\n\r\n#ifdef COLOR_FILTER\r\n    mat4 alphaMat = colorMat;\r\n\r\n    alphaMat[0][3] *= gl_FragColor.a;\r\n    alphaMat[1][3] *= gl_FragColor.a;\r\n    alphaMat[2][3] *= gl_FragColor.a;\r\n\r\n    gl_FragColor = gl_FragColor * alphaMat;\r\n    gl_FragColor += colorAlpha / 255.0 * gl_FragColor.a;\r\n#endif\r\n\r\n#ifdef GLOW_FILTER\r\n    const float c_IterationTime = 10.0;\r\n    float floatIterationTotalTime = c_IterationTime * c_IterationTime;\r\n    vec4 vec4Color = vec4(0.0, 0.0, 0.0, 0.0);\r\n    vec2 vec2FilterDir = vec2(-(u_blurInfo1.z) / u_blurInfo2.x, -(u_blurInfo1.w) / u_blurInfo2.y);\r\n    vec2 vec2FilterOff = vec2(u_blurInfo1.x / u_blurInfo2.x / c_IterationTime * 2.0, u_blurInfo1.y / u_blurInfo2.y / c_IterationTime * 2.0);\r\n    float maxNum = u_blurInfo1.x * u_blurInfo1.y;\r\n    vec2 vec2Off = vec2(0.0, 0.0);\r\n    float floatOff = c_IterationTime / 2.0;\r\n    for (float i = 0.0; i <= c_IterationTime; ++i)\r\n\t{\r\n\t    for (float j = 0.0; j <= c_IterationTime; ++j)\r\n\t\t{\r\n\t\t    vec2Off = vec2(vec2FilterOff.x * (i - floatOff), vec2FilterOff.y * (j - floatOff));\r\n\t\t    vec4Color += sampleTexture(texture, v_texcoordAlpha.xy + vec2FilterDir + vec2Off) / floatIterationTotalTime;\r\n\t\t}\r\n\t}\r\n    gl_FragColor = vec4(u_color.rgb, vec4Color.a * u_blurInfo2.z);\r\n    gl_FragColor.rgb *= gl_FragColor.a;\r\n#endif\r\n}";

    var prime_vs = "attribute vec4 position;\r\nattribute vec4 attribColor;\r\n//attribute vec4 clipDir;\r\n//attribute vec2 clipRect;\r\nuniform vec4 clipMatDir;\r\nuniform vec2 clipMatPos;\r\n#ifdef WORLDMAT\r\n\tuniform mat4 mmat;\r\n#endif\r\nuniform mat4 u_mmat2;\r\n//uniform vec2 u_pos;\r\nuniform vec2 size;\r\nvarying vec4 color;\r\n//vec4 dirxy=vec4(0.9,0.1, -0.1,0.9);\r\n//vec4 clip=vec4(100.,30.,300.,600.);\r\nvarying vec2 cliped;\r\nvoid main(){\r\n\t\r\n#ifdef WORLDMAT\r\n\tvec4 pos=mmat*vec4(position.xy,0.,1.);\r\n\tgl_Position =vec4((pos.x/size.x-0.5)*2.0,(0.5-pos.y/size.y)*2.0,pos.z,1.0);\r\n#else\r\n\tgl_Position =vec4((position.x/size.x-0.5)*2.0,(0.5-position.y/size.y)*2.0,position.z,1.0);\r\n#endif\t\r\n\tfloat clipw = length(clipMatDir.xy);\r\n\tfloat cliph = length(clipMatDir.zw);\r\n\tvec2 clippos = position.xy - clipMatPos.xy;\t//pos已经应用矩阵了，为了减的有意义，clip的位置也要缩放\r\n\tif(clipw>20000. && cliph>20000.)\r\n\t\tcliped = vec2(0.5,0.5);\r\n\telse {\r\n\t\t//clipdir是带缩放的方向，由于上面clippos是在缩放后的空间计算的，所以需要把方向先normalize一下\r\n\t\tcliped=vec2( dot(clippos,clipMatDir.xy)/clipw/clipw, dot(clippos,clipMatDir.zw)/cliph/cliph);\r\n\t}\r\n  //pos2d.x = dot(clippos,dirx);\r\n  color=attribColor/255.;\r\n}";

    var prime_ps = "precision mediump float;\r\n//precision mediump float;\r\nvarying vec4 color;\r\n//uniform float alpha;\r\nvarying vec2 cliped;\r\n\r\nvec3 gammaToLinear(in vec3 value)\r\n{\r\n    return pow((value + 0.055) / 1.055, vec3(2.4));\r\n}\r\n\r\nvec4 gammaToLinear(in vec4 value)\r\n{\r\n    return vec4(gammaToLinear(value.rgb), value.a);\r\n}\r\n\r\nvoid main(){\r\n\t//vec4 a=vec4(color.r, color.g, color.b, 1);\r\n\t//a.a*=alpha;\r\n\t#ifdef GAMMASPACE\r\n    \tgl_FragColor= color;// vec4(color.r, color.g, color.b, alpha);\r\n\t#else\r\n\t\tgl_FragColor= gammaToLinear(color);\r\n\t#endif\r\n\tgl_FragColor.rgb*=color.a;\r\n\tif(cliped.x<0.) discard;\r\n\tif(cliped.x>1.) discard;\r\n\tif(cliped.y<0.) discard;\r\n\tif(cliped.y>1.) discard;\r\n}";

    var skin_vs = "attribute vec2 position;\r\nattribute vec2 texcoord;\r\nattribute vec4 color;\r\nuniform vec2 size;\r\nuniform float offsetX;\r\nuniform float offsetY;\r\nuniform mat4 mmat;\r\nuniform mat4 u_mmat2;\r\nvarying vec2 v_texcoord;\r\nvarying vec4 v_color;\r\nvoid main() {\r\n  vec4 pos=mmat*u_mmat2*vec4(offsetX+position.x,offsetY+position.y,0,1 );\r\n  gl_Position = vec4((pos.x/size.x-0.5)*2.0,(0.5-pos.y/size.y)*2.0,pos.z,1.0);\r\n  v_color = color;\r\n  v_color.rgb *= v_color.a;\r\n  v_texcoord = texcoord;  \r\n}";

    var skin_ps = "precision mediump float;\r\nvarying vec2 v_texcoord;\r\nvarying vec4 v_color;\r\nuniform sampler2D texture;\r\nuniform float alpha;\r\n\r\nvec4 sampleTexture(sampler2D texture,vec2 uv){\r\n   vec4 color = texture2D(texture,uv);\r\n   #ifdef GAMMASPACE\r\n      color.xyz = color.xyz*color.xyz;\r\n   #endif\r\n   return color;\r\n}\r\n\r\nvoid main() {\r\n\tvec4 t_color = sampleTexture(texture, v_texcoord);\r\n\tgl_FragColor = t_color.rgba * v_color;\r\n\tgl_FragColor *= alpha;\r\n}";

    class Shader2D {
        constructor() {
            this.ALPHA = 1;
            this.defines = new ShaderDefines2D();
            this.shaderType = 0;
            this.fillStyle = DrawStyle.DEFAULT;
            this.strokeStyle = DrawStyle.DEFAULT;
        }
        destroy() {
            this.defines = null;
            this.filters = null;
        }
        static __init__() {
            if (window.conch && !window.conchConfig.conchWebGL) {
                window.preCompile2D(ShaderDefines2D.TEXTURE2D, texture_vs, texture_ps);
                window.preCompile2D(ShaderDefines2D.PRIMITIVE, prime_vs, prime_ps);
                window.preCompile2D(ShaderDefines2D.SKINMESH, skin_vs, skin_ps);
            }
            else {
                Shader.preCompile2D(0, ShaderDefines2D.TEXTURE2D, texture_vs, texture_ps, null);
                Shader.preCompile2D(0, ShaderDefines2D.PRIMITIVE, prime_vs, prime_ps, null);
                Shader.preCompile2D(0, ShaderDefines2D.SKINMESH, skin_vs, skin_ps, null);
            }
        }
    }

    class SkinMeshBuffer {
        constructor() {
            this.ib = IndexBuffer2D.create(exports.BufferUsage.Dynamic);
            this.vb = VertexBuffer2D.create(8);
        }
        static getInstance() {
            return SkinMeshBuffer.instance = SkinMeshBuffer.instance || new SkinMeshBuffer();
        }
        addSkinMesh(skinMesh) {
            skinMesh.getData2(this.vb, this.ib, this.vb._byteLength / 32);
        }
        reset() {
            this.vb.buffer2D.clear();
            this.ib.buffer2D.clear();
        }
    }

    class BasePoly {
        static createLine2(p, indices, lineWidth, indexBase, outVertex, loop) {
            if (p.length < 4)
                return null;
            var points = BasePoly.tempData.length > (p.length + 2) ? BasePoly.tempData : new Array(p.length + 2);
            points[0] = p[0];
            points[1] = p[1];
            var newlen = 2;
            var i = 0;
            var length = p.length;
            for (i = 2; i < length; i += 2) {
                if (Math.abs(p[i] - p[i - 2]) + Math.abs(p[i + 1] - p[i - 1]) > 0.01) {
                    points[newlen++] = p[i];
                    points[newlen++] = p[i + 1];
                }
            }
            if (loop && Math.abs(p[0] - points[newlen - 2]) + Math.abs(p[1] - points[newlen - 1]) > 0.01) {
                points[newlen++] = p[0];
                points[newlen++] = p[1];
            }
            var result = outVertex;
            length = newlen / 2;
            var w = lineWidth / 2;
            var px, py, p1x, p1y, p2x, p2y, p3x, p3y;
            var perpx, perpy, perp2x, perp2y;
            var a1, b1, c1, a2, b2, c2;
            var denom, dist;
            p1x = points[0];
            p1y = points[1];
            p2x = points[2];
            p2y = points[3];
            perpx = -(p1y - p2y);
            perpy = p1x - p2x;
            dist = Math.sqrt(perpx * perpx + perpy * perpy);
            perpx = perpx / dist * w;
            perpy = perpy / dist * w;
            result.push(p1x - perpx, p1y - perpy, p1x + perpx, p1y + perpy);
            for (i = 1; i < length - 1; i++) {
                p1x = points[(i - 1) * 2];
                p1y = points[(i - 1) * 2 + 1];
                p2x = points[(i) * 2];
                p2y = points[(i) * 2 + 1];
                p3x = points[(i + 1) * 2];
                p3y = points[(i + 1) * 2 + 1];
                perpx = -(p1y - p2y);
                perpy = p1x - p2x;
                dist = Math.sqrt(perpx * perpx + perpy * perpy);
                perpx = perpx / dist * w;
                perpy = perpy / dist * w;
                perp2x = -(p2y - p3y);
                perp2y = p2x - p3x;
                dist = Math.sqrt(perp2x * perp2x + perp2y * perp2y);
                perp2x = perp2x / dist * w;
                perp2y = perp2y / dist * w;
                a1 = (-perpy + p1y) - (-perpy + p2y);
                b1 = (-perpx + p2x) - (-perpx + p1x);
                c1 = (-perpx + p1x) * (-perpy + p2y) - (-perpx + p2x) * (-perpy + p1y);
                a2 = (-perp2y + p3y) - (-perp2y + p2y);
                b2 = (-perp2x + p2x) - (-perp2x + p3x);
                c2 = (-perp2x + p3x) * (-perp2y + p2y) - (-perp2x + p2x) * (-perp2y + p3y);
                denom = a1 * b2 - a2 * b1;
                if (Math.abs(denom) < 0.1) {
                    denom += 10.1;
                    result.push(p2x - perpx, p2y - perpy, p2x + perpx, p2y + perpy);
                    continue;
                }
                px = (b1 * c2 - b2 * c1) / denom;
                py = (a2 * c1 - a1 * c2) / denom;
                result.push(px, py, p2x - (px - p2x), p2y - (py - p2y));
            }
            p1x = points[newlen - 4];
            p1y = points[newlen - 3];
            p2x = points[newlen - 2];
            p2y = points[newlen - 1];
            perpx = -(p1y - p2y);
            perpy = p1x - p2x;
            dist = Math.sqrt(perpx * perpx + perpy * perpy);
            perpx = perpx / dist * w;
            perpy = perpy / dist * w;
            result.push(p2x - perpx, p2y - perpy, p2x + perpx, p2y + perpy);
            for (i = 1; i < length; i++) {
                indices.push(indexBase + (i - 1) * 2, indexBase + (i - 1) * 2 + 1, indexBase + i * 2 + 1, indexBase + i * 2 + 1, indexBase + i * 2, indexBase + (i - 1) * 2);
            }
            return result;
        }
        static createLineTriangle(path, color, width, loop, outvb, vbstride, outib) {
            var points = path.slice();
            var ptlen = points.length;
            var p1x = points[0], p1y = points[1];
            var p2x = points[2], p2y = points[2];
            var len = 0;
            var rp = 0;
            var dx = 0, dy = 0;
            var pointnum = ptlen / 2;
            if (pointnum <= 1)
                return;
            if (pointnum == 2) {
                return;
            }
            var tmpData = new Array(pointnum * 4);
            var realPtNum = 0;
            var ci = 0;
            for (var i = 0; i < pointnum - 1; i++) {
                p1x = points[ci++], p1y = points[ci++];
                p2x = points[ci++], p2y = points[ci++];
                dx = p2x - p1x, dy = p2y - p1y;
                if (dx != 0 && dy != 0) {
                    len = Math.sqrt(dx * dx + dy * dy);
                    if (len > 1e-3) {
                        rp = realPtNum * 4;
                        tmpData[rp] = p1x;
                        tmpData[rp + 1] = p1y;
                        tmpData[rp + 2] = dx / len;
                        tmpData[rp + 3] = dy / len;
                        realPtNum++;
                    }
                }
            }
            if (loop) {
                p1x = points[ptlen - 2], p1y = points[ptlen - 1];
                p2x = points[0], p2y = points[1];
                dx = p2x - p1x, dy = p2y - p1y;
                if (dx != 0 && dy != 0) {
                    len = Math.sqrt(dx * dx + dy * dy);
                    if (len > 1e-3) {
                        rp = realPtNum * 4;
                        tmpData[rp] = p1x;
                        tmpData[rp + 1] = p1y;
                        tmpData[rp + 2] = dx / len;
                        tmpData[rp + 3] = dy / len;
                        realPtNum++;
                    }
                }
            }
            else {
                rp = realPtNum * 4;
                tmpData[rp] = p1x;
                tmpData[rp + 1] = p1y;
                tmpData[rp + 2] = dx / len;
                tmpData[rp + 3] = dy / len;
                realPtNum++;
            }
            ci = 0;
            for (i = 0; i < pointnum; i++) {
                p1x = points[ci], p1y = points[ci + 1];
                p2x = points[ci + 2], p2y = points[ci + 3];
            }
        }
    }
    BasePoly.tempData = new Array(256);

    class EarcutNode {
        constructor(i, x, y) {
            this.i = i;
            this.x = x;
            this.y = y;
            this.prev = null;
            this.next = null;
            this.z = null;
            this.prevZ = null;
            this.nextZ = null;
            this.steiner = false;
        }
    }

    class Earcut {
        static earcut(data, holeIndices, dim) {
            dim = dim || 2;
            var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = Earcut.linkedList(data, 0, outerLen, dim, true), triangles = [];
            if (!outerNode)
                return triangles;
            var minX, minY, maxX, maxY, x, y, invSize;
            if (hasHoles)
                outerNode = Earcut.eliminateHoles(data, holeIndices, outerNode, dim);
            if (data.length > 80 * dim) {
                minX = maxX = data[0];
                minY = maxY = data[1];
                for (var i = dim; i < outerLen; i += dim) {
                    x = data[i];
                    y = data[i + 1];
                    if (x < minX)
                        minX = x;
                    if (y < minY)
                        minY = y;
                    if (x > maxX)
                        maxX = x;
                    if (y > maxY)
                        maxY = y;
                }
                invSize = Math.max(maxX - minX, maxY - minY);
                invSize = invSize !== 0 ? 1 / invSize : 0;
            }
            Earcut.earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
            return triangles;
        }
        static linkedList(data, start, end, dim, clockwise) {
            var i, last;
            if (clockwise === (Earcut.signedArea(data, start, end, dim) > 0)) {
                for (i = start; i < end; i += dim)
                    last = Earcut.insertNode(i, data[i], data[i + 1], last);
            }
            else {
                for (i = end - dim; i >= start; i -= dim)
                    last = Earcut.insertNode(i, data[i], data[i + 1], last);
            }
            if (last && Earcut.equals(last, last.next)) {
                Earcut.removeNode(last);
                last = last.next;
            }
            return last;
        }
        static filterPoints(start, end) {
            if (!start)
                return start;
            if (!end)
                end = start;
            var p = start, again;
            do {
                again = false;
                if (!p.steiner && (Earcut.equals(p, p.next) || Earcut.area(p.prev, p, p.next) === 0)) {
                    Earcut.removeNode(p);
                    p = end = p.prev;
                    if (p === p.next)
                        break;
                    again = true;
                }
                else {
                    p = p.next;
                }
            } while (again || p !== end);
            return end;
        }
        static earcutLinked(ear, triangles, dim, minX, minY, invSize, pass = null) {
            if (!ear)
                return;
            if (!pass && invSize)
                Earcut.indexCurve(ear, minX, minY, invSize);
            var stop = ear, prev, next;
            while (ear.prev !== ear.next) {
                prev = ear.prev;
                next = ear.next;
                if (invSize ? Earcut.isEarHashed(ear, minX, minY, invSize) : Earcut.isEar(ear)) {
                    triangles.push(prev.i / dim);
                    triangles.push(ear.i / dim);
                    triangles.push(next.i / dim);
                    Earcut.removeNode(ear);
                    ear = next.next;
                    stop = next.next;
                    continue;
                }
                ear = next;
                if (ear === stop) {
                    if (!pass) {
                        Earcut.earcutLinked(Earcut.filterPoints(ear, null), triangles, dim, minX, minY, invSize, 1);
                    }
                    else if (pass === 1) {
                        ear = Earcut.cureLocalIntersections(ear, triangles, dim);
                        Earcut.earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
                    }
                    else if (pass === 2) {
                        Earcut.splitEarcut(ear, triangles, dim, minX, minY, invSize);
                    }
                    break;
                }
            }
        }
        static isEar(ear) {
            var a = ear.prev, b = ear, c = ear.next;
            if (Earcut.area(a, b, c) >= 0)
                return false;
            var p = ear.next.next;
            while (p !== ear.prev) {
                if (Earcut.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
                    Earcut.area(p.prev, p, p.next) >= 0)
                    return false;
                p = p.next;
            }
            return true;
        }
        static isEarHashed(ear, minX, minY, invSize) {
            var a = ear.prev, b = ear, c = ear.next;
            if (Earcut.area(a, b, c) >= 0)
                return false;
            var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x), minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y), maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x), maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);
            var minZ = Earcut.zOrder(minTX, minTY, minX, minY, invSize), maxZ = Earcut.zOrder(maxTX, maxTY, minX, minY, invSize);
            var p = ear.nextZ;
            while (p && p.z <= maxZ) {
                if (p !== ear.prev && p !== ear.next &&
                    Earcut.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
                    Earcut.area(p.prev, p, p.next) >= 0)
                    return false;
                p = p.nextZ;
            }
            p = ear.prevZ;
            while (p && p.z >= minZ) {
                if (p !== ear.prev && p !== ear.next &&
                    Earcut.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
                    Earcut.area(p.prev, p, p.next) >= 0)
                    return false;
                p = p.prevZ;
            }
            return true;
        }
        static cureLocalIntersections(start, triangles, dim) {
            var p = start;
            do {
                var a = p.prev, b = p.next.next;
                if (!Earcut.equals(a, b) && Earcut.intersects(a, p, p.next, b) && Earcut.locallyInside(a, b) && Earcut.locallyInside(b, a)) {
                    triangles.push(a.i / dim);
                    triangles.push(p.i / dim);
                    triangles.push(b.i / dim);
                    Earcut.removeNode(p);
                    Earcut.removeNode(p.next);
                    p = start = b;
                }
                p = p.next;
            } while (p !== start);
            return p;
        }
        static splitEarcut(start, triangles, dim, minX, minY, invSize) {
            var a = start;
            do {
                var b = a.next.next;
                while (b !== a.prev) {
                    if (a.i !== b.i && Earcut.isValidDiagonal(a, b)) {
                        var c = Earcut.splitPolygon(a, b);
                        a = Earcut.filterPoints(a, a.next);
                        c = Earcut.filterPoints(c, c.next);
                        Earcut.earcutLinked(a, triangles, dim, minX, minY, invSize);
                        Earcut.earcutLinked(c, triangles, dim, minX, minY, invSize);
                        return;
                    }
                    b = b.next;
                }
                a = a.next;
            } while (a !== start);
        }
        static eliminateHoles(data, holeIndices, outerNode, dim) {
            var queue = [], i, len, start, end, list;
            for (i = 0, len = holeIndices.length; i < len; i++) {
                start = holeIndices[i] * dim;
                end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
                list = Earcut.linkedList(data, start, end, dim, false);
                if (list === list.next)
                    list.steiner = true;
                queue.push(Earcut.getLeftmost(list));
            }
            queue.sort(Earcut.compareX);
            for (i = 0; i < queue.length; i++) {
                Earcut.eliminateHole(queue[i], outerNode);
                outerNode = Earcut.filterPoints(outerNode, outerNode.next);
            }
            return outerNode;
        }
        static compareX(a, b) {
            return a.x - b.x;
        }
        static eliminateHole(hole, outerNode) {
            outerNode = Earcut.findHoleBridge(hole, outerNode);
            if (outerNode) {
                var b = Earcut.splitPolygon(outerNode, hole);
                Earcut.filterPoints(b, b.next);
            }
        }
        static findHoleBridge(hole, outerNode) {
            var p = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m;
            do {
                if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
                    var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
                    if (x <= hx && x > qx) {
                        qx = x;
                        if (x === hx) {
                            if (hy === p.y)
                                return p;
                            if (hy === p.next.y)
                                return p.next;
                        }
                        m = p.x < p.next.x ? p : p.next;
                    }
                }
                p = p.next;
            } while (p !== outerNode);
            if (!m)
                return null;
            if (hx === qx)
                return m.prev;
            var stop = m, mx = m.x, my = m.y, tanMin = Infinity, tan;
            p = m.next;
            while (p !== stop) {
                if (hx >= p.x && p.x >= mx && hx !== p.x &&
                    Earcut.pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
                    tan = Math.abs(hy - p.y) / (hx - p.x);
                    if ((tan < tanMin || (tan === tanMin && p.x > m.x)) && Earcut.locallyInside(p, hole)) {
                        m = p;
                        tanMin = tan;
                    }
                }
                p = p.next;
            }
            return m;
        }
        static indexCurve(start, minX, minY, invSize) {
            var p = start;
            do {
                if (p.z === null)
                    p.z = Earcut.zOrder(p.x, p.y, minX, minY, invSize);
                p.prevZ = p.prev;
                p.nextZ = p.next;
                p = p.next;
            } while (p !== start);
            p.prevZ.nextZ = null;
            p.prevZ = null;
            Earcut.sortLinked(p);
        }
        static sortLinked(list) {
            var i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
            do {
                p = list;
                list = null;
                tail = null;
                numMerges = 0;
                while (p) {
                    numMerges++;
                    q = p;
                    pSize = 0;
                    for (i = 0; i < inSize; i++) {
                        pSize++;
                        q = q.nextZ;
                        if (!q)
                            break;
                    }
                    qSize = inSize;
                    while (pSize > 0 || (qSize > 0 && q)) {
                        if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                            e = p;
                            p = p.nextZ;
                            pSize--;
                        }
                        else {
                            e = q;
                            q = q.nextZ;
                            qSize--;
                        }
                        if (tail)
                            tail.nextZ = e;
                        else
                            list = e;
                        e.prevZ = tail;
                        tail = e;
                    }
                    p = q;
                }
                tail.nextZ = null;
                inSize *= 2;
            } while (numMerges > 1);
            return list;
        }
        static zOrder(x, y, minX, minY, invSize) {
            x = 32767 * (x - minX) * invSize;
            y = 32767 * (y - minY) * invSize;
            x = (x | (x << 8)) & 0x00FF00FF;
            x = (x | (x << 4)) & 0x0F0F0F0F;
            x = (x | (x << 2)) & 0x33333333;
            x = (x | (x << 1)) & 0x55555555;
            y = (y | (y << 8)) & 0x00FF00FF;
            y = (y | (y << 4)) & 0x0F0F0F0F;
            y = (y | (y << 2)) & 0x33333333;
            y = (y | (y << 1)) & 0x55555555;
            return x | (y << 1);
        }
        static getLeftmost(start) {
            var p = start, leftmost = start;
            do {
                if (p.x < leftmost.x)
                    leftmost = p;
                p = p.next;
            } while (p !== start);
            return leftmost;
        }
        static pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
            return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&
                (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&
                (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
        }
        static isValidDiagonal(a, b) {
            return a.next.i !== b.i && a.prev.i !== b.i && !Earcut.intersectsPolygon(a, b) &&
                Earcut.locallyInside(a, b) && Earcut.locallyInside(b, a) && Earcut.middleInside(a, b);
        }
        static area(p, q, r) {
            return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
        }
        static equals(p1, p2) {
            return p1.x === p2.x && p1.y === p2.y;
        }
        static intersects(p1, q1, p2, q2) {
            if ((Earcut.equals(p1, q1) && Earcut.equals(p2, q2)) ||
                (Earcut.equals(p1, q2) && Earcut.equals(p2, q1)))
                return true;
            return Earcut.area(p1, q1, p2) > 0 !== Earcut.area(p1, q1, q2) > 0 &&
                Earcut.area(p2, q2, p1) > 0 !== Earcut.area(p2, q2, q1) > 0;
        }
        static intersectsPolygon(a, b) {
            var p = a;
            do {
                if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
                    Earcut.intersects(p, p.next, a, b))
                    return true;
                p = p.next;
            } while (p !== a);
            return false;
        }
        static locallyInside(a, b) {
            return Earcut.area(a.prev, a, a.next) < 0 ?
                Earcut.area(a, b, a.next) >= 0 && Earcut.area(a, a.prev, b) >= 0 :
                Earcut.area(a, b, a.prev) < 0 || Earcut.area(a, a.next, b) < 0;
        }
        static middleInside(a, b) {
            var p = a, inside = false, px = (a.x + b.x) / 2, py = (a.y + b.y) / 2;
            do {
                if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&
                    (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
                    inside = !inside;
                p = p.next;
            } while (p !== a);
            return inside;
        }
        static splitPolygon(a, b) {
            var a2 = new EarcutNode(a.i, a.x, a.y), b2 = new EarcutNode(b.i, b.x, b.y), an = a.next, bp = b.prev;
            a.next = b;
            b.prev = a;
            a2.next = an;
            an.prev = a2;
            b2.next = a2;
            a2.prev = b2;
            bp.next = b2;
            b2.prev = bp;
            return b2;
        }
        static insertNode(i, x, y, last) {
            var p = new EarcutNode(i, x, y);
            if (!last) {
                p.prev = p;
                p.next = p;
            }
            else {
                p.next = last.next;
                p.prev = last;
                last.next.prev = p;
                last.next = p;
            }
            return p;
        }
        static removeNode(p) {
            p.next.prev = p.prev;
            p.prev.next = p.next;
            if (p.prevZ)
                p.prevZ.nextZ = p.nextZ;
            if (p.nextZ)
                p.nextZ.prevZ = p.prevZ;
        }
        static signedArea(data, start, end, dim) {
            var sum = 0;
            for (var i = start, j = end - dim; i < end; i += dim) {
                sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
                j = i;
            }
            return sum;
        }
    }

    exports.MeshTopology = void 0;
    (function (MeshTopology) {
        MeshTopology[MeshTopology["Points"] = 0] = "Points";
        MeshTopology[MeshTopology["Lines"] = 1] = "Lines";
        MeshTopology[MeshTopology["LineLoop"] = 2] = "LineLoop";
        MeshTopology[MeshTopology["LineStrip"] = 3] = "LineStrip";
        MeshTopology[MeshTopology["Triangles"] = 4] = "Triangles";
        MeshTopology[MeshTopology["TriangleStrip"] = 5] = "TriangleStrip";
        MeshTopology[MeshTopology["TriangleFan"] = 6] = "TriangleFan";
    })(exports.MeshTopology || (exports.MeshTopology = {}));

    class Submit extends SubmitBase {
        constructor(renderType = SubmitBase.TYPE_2D) {
            super(renderType);
        }
        renderSubmit() {
            if (this._numEle === 0 || !this._mesh || this._numEle == 0)
                return 1;
            var _tex = this.shaderValue.textureHost;
            if (_tex) {
                var source = _tex._getSource();
                if (!source)
                    return 1;
                this.shaderValue.texture = source;
            }
            this._mesh.useMesh();
            this.shaderValue.upload();
            if (BlendMode.activeBlendFunction !== this._blendFn) {
                RenderStateContext.setBlend(true);
                this._blendFn();
                BlendMode.activeBlendFunction = this._blendFn;
            }
            LayaGL.renderDrawContext.drawElements(exports.MeshTopology.Triangles, this._numEle, exports.IndexFormat.UInt16, this._startIdx);
            return 1;
        }
        releaseRender() {
            if (SubmitBase.RENDERBASE == this)
                return;
            if ((--this._ref) < 1) {
                Submit.POOL[Submit._poolSize++] = this;
                this.shaderValue.release();
                this.shaderValue = null;
                this._mesh = null;
                this._parent && (this._parent.releaseRender(), this._parent = null);
            }
        }
        static create(context, mesh, sv) {
            var o = Submit._poolSize ? Submit.POOL[--Submit._poolSize] : new Submit();
            o._ref = 1;
            o._mesh = mesh;
            o._key.clear();
            o._startIdx = mesh.indexNum * Const.BYTES_PIDX;
            o._numEle = 0;
            var blendType = context._nBlendType;
            o._blendFn = context._targets ? BlendMode.targetFns[blendType] : BlendMode.fns[blendType];
            o.shaderValue = sv;
            o.shaderValue.setValue(context._shader2D);
            var filters = context._shader2D.filters;
            filters && o.shaderValue.setFilters(filters);
            return o;
        }
        static createShape(ctx, mesh, numEle, sv) {
            var o = Submit._poolSize ? Submit.POOL[--Submit._poolSize] : (new Submit());
            o._mesh = mesh;
            o._numEle = numEle;
            o._startIdx = mesh.indexNum * 2;
            o._ref = 1;
            o.shaderValue = sv;
            o.shaderValue.setValue(ctx._shader2D);
            var blendType = ctx._nBlendType;
            o._key.blendShader = blendType;
            o._blendFn = ctx._targets ? BlendMode.targetFns[blendType] : BlendMode.fns[blendType];
            return o;
        }
    }
    Submit._poolSize = 0;
    Submit.POOL = [];

    class SubmitCanvas extends SubmitBase {
        constructor() {
            super(SubmitBase.TYPE_2D);
            this._matrix = new Matrix();
            this._matrix4 = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
            this.shaderValue = new Value2D(0, 0);
        }
        static create(canvas, alpha, filters) {
            var o = (!SubmitCanvas.POOL._length) ? (new SubmitCanvas()) : SubmitCanvas.POOL[--SubmitCanvas.POOL._length];
            o.canv = canvas;
            o._ref = 1;
            o._numEle = 0;
            var v = o.shaderValue;
            v.alpha = alpha;
            v.defines.setValue(0);
            filters && filters.length && v.setFilters(filters);
            return o;
        }
        renderSubmit() {
            var preAlpha = RenderState2D.worldAlpha;
            var preMatrix4 = RenderState2D.worldMatrix4;
            var preMatrix = RenderState2D.worldMatrix;
            var preFilters = RenderState2D.worldFilters;
            var preWorldShaderDefines = RenderState2D.worldShaderDefines;
            var v = this.shaderValue;
            var m = this._matrix;
            var m4 = this._matrix4;
            var mout = Matrix.TEMP;
            Matrix.mul(m, preMatrix, mout);
            m4[0] = mout.a;
            m4[1] = mout.b;
            m4[4] = mout.c;
            m4[5] = mout.d;
            m4[12] = mout.tx;
            m4[13] = mout.ty;
            RenderState2D.worldMatrix = mout.clone();
            RenderState2D.worldMatrix4 = m4;
            RenderState2D.worldAlpha = RenderState2D.worldAlpha * v.alpha;
            if (v.filters && v.filters.length) {
                RenderState2D.worldFilters = v.filters;
                RenderState2D.worldShaderDefines = v.defines;
            }
            this.canv['flushsubmit']();
            RenderState2D.worldAlpha = preAlpha;
            RenderState2D.worldMatrix4 = preMatrix4;
            RenderState2D.worldMatrix.destroy();
            RenderState2D.worldMatrix = preMatrix;
            RenderState2D.worldFilters = preFilters;
            RenderState2D.worldShaderDefines = preWorldShaderDefines;
            return 1;
        }
        releaseRender() {
            if ((--this._ref) < 1) {
                var cache = SubmitCanvas.POOL;
                this._mesh = null;
                cache[cache._length++] = this;
            }
        }
        getRenderType() {
            return SubmitBase.TYPE_CANVAS;
        }
    }
    SubmitCanvas.POOL = [];
    {
        SubmitCanvas.POOL._length = 0;
    }

    class SubmitTarget {
        constructor() {
            this.blendType = 0;
            this._ref = 1;
            this._key = new SubmitKey();
        }
        renderSubmit() {
            this._mesh.useMesh();
            var target = this.srcRT;
            if (target) {
                this.shaderValue.texture = target._getSource();
                this.shaderValue.upload();
                this.blend();
                LayaGL.renderDrawContext.drawElements(exports.MeshTopology.Triangles, this._numEle, exports.IndexFormat.UInt16, this._startIdx);
            }
            return 1;
        }
        blend() {
            if (BlendMode.activeBlendFunction !== BlendMode.fns[this.blendType]) {
                RenderStateContext.setBlend(true);
                BlendMode.fns[this.blendType]();
                BlendMode.activeBlendFunction = BlendMode.fns[this.blendType];
            }
        }
        getRenderType() {
            return 0;
        }
        releaseRender() {
            if ((--this._ref) < 1) {
                var pool = SubmitTarget.POOL;
                pool[pool._length++] = this;
            }
        }
        static create(context, mesh, sv, rt) {
            var o = SubmitTarget.POOL._length ? SubmitTarget.POOL[--SubmitTarget.POOL._length] : new SubmitTarget();
            o._mesh = mesh;
            o.srcRT = rt;
            o._startIdx = mesh.indexNum * Const.BYTES_PIDX;
            o._ref = 1;
            o._key.clear();
            o._numEle = 0;
            o.blendType = context._nBlendType;
            o._key.blendShader = o.blendType;
            o.shaderValue = sv;
            o.shaderValue.setValue(context._shader2D);
            if (context._colorFiler) {
                var ft = context._colorFiler;
                sv.defines.add(ft.type);
                sv.colorMat = ft._mat;
                sv.colorAlpha = ft._alpha;
            }
            return o;
        }
    }
    SubmitTarget.POOL = [];
    {
        SubmitTarget.POOL._length = 0;
    }

    class SubmitTexture extends SubmitBase {
        constructor(renderType = SubmitBase.TYPE_2D) {
            super(renderType);
        }
        releaseRender() {
            if ((--this._ref) < 1) {
                SubmitTexture.POOL[SubmitTexture._poolSize++] = this;
                this.shaderValue.release();
                this._mesh = null;
                this._parent && (this._parent.releaseRender(), this._parent = null);
            }
        }
        renderSubmit() {
            if (this._numEle === 0)
                return 1;
            var tex = this.shaderValue.textureHost;
            if (tex) {
                var source = tex ? tex._getSource() : null;
                if (!source)
                    return 1;
            }
            this._mesh.useMesh();
            var lastSubmit = SubmitBase.preRender;
            var prekey = SubmitBase.preRender._key;
            if (this._key.blendShader === 0 && (this._key.submitType === prekey.submitType && this._key.blendShader === prekey.blendShader) && BaseShader.activeShader &&
                SubmitBase.preRender.clipInfoID == this.clipInfoID &&
                lastSubmit.shaderValue.defines._value === this.shaderValue.defines._value &&
                (this.shaderValue.defines._value & ShaderDefines2D.NOOPTMASK) == 0) {
                BaseShader.activeShader.uploadTexture2D(source);
            }
            else {
                if (BlendMode.activeBlendFunction !== this._blendFn) {
                    RenderStateContext.setBlend(true);
                    this._blendFn();
                    BlendMode.activeBlendFunction = this._blendFn;
                }
                this.shaderValue.texture = source;
                this.shaderValue.upload();
            }
            LayaGL.renderDrawContext.drawElements(exports.MeshTopology.Triangles, this._numEle, exports.IndexFormat.UInt16, this._startIdx);
            return 1;
        }
        static create(context, mesh, sv) {
            var o = SubmitTexture._poolSize ? SubmitTexture.POOL[--SubmitTexture._poolSize] : new SubmitTexture(SubmitBase.TYPE_TEXTURE);
            o._mesh = mesh;
            o._key.clear();
            o._key.submitType = SubmitBase.KEY_DRAWTEXTURE;
            o._ref = 1;
            o._startIdx = mesh.indexNum * Const.BYTES_PIDX;
            o._numEle = 0;
            var blendType = context._nBlendType;
            o._key.blendShader = blendType;
            o._blendFn = context._targets ? BlendMode.targetFns[blendType] : BlendMode.fns[blendType];
            o.shaderValue = sv;
            if (context._colorFiler) {
                var ft = context._colorFiler;
                sv.defines.add(ft.type);
                sv.colorMat = ft._mat;
                sv.colorAlpha = ft._alpha;
            }
            return o;
        }
    }
    SubmitTexture._poolSize = 0;
    SubmitTexture.POOL = [];

    class CharSubmitCache {
        constructor() {
            this._data = [];
            this._ndata = 0;
            this._clipid = -1;
            this._clipMatrix = new Matrix();
            this._enable = false;
        }
        clear() {
            this._tex = null;
            this._imgId = -1;
            this._ndata = 0;
            this._enable = false;
            this._colorFiler = null;
        }
        destroy() {
            this.clear();
            this._data.length = 0;
            this._data = null;
        }
        add(ctx, tex, imgid, pos, uv, color) {
            if (this._ndata > 0 && (this._tex != tex || this._imgId != imgid ||
                (this._clipid >= 0 && this._clipid != ctx._clipInfoID))) {
                this.submit(ctx);
            }
            this._clipid = ctx._clipInfoID;
            ctx._globalClipMatrix.copyTo(this._clipMatrix);
            this._tex = tex;
            this._imgId = imgid;
            this._colorFiler = ctx._colorFiler;
            this._data[this._ndata] = pos;
            this._data[this._ndata + 1] = uv;
            this._data[this._ndata + 2] = color;
            this._ndata += 3;
        }
        getPos() {
            if (CharSubmitCache.__nPosPool == 0)
                return new Array(8);
            return CharSubmitCache.__posPool[--CharSubmitCache.__nPosPool];
        }
        enable(value, ctx) {
            if (value === this._enable)
                return;
            this._enable = value;
            this._enable || this.submit(ctx);
        }
        submit(ctx) {
            var n = this._ndata;
            if (!n)
                return;
            var _mesh = ctx._mesh;
            var colorFiler = ctx._colorFiler;
            ctx._colorFiler = this._colorFiler;
            var submit = SubmitTexture.create(ctx, _mesh, Value2D.create(ShaderDefines2D.TEXTURE2D, 0));
            ctx._submits[ctx._submits._length++] = ctx._curSubmit = submit;
            submit.shaderValue.textureHost = this._tex;
            submit._key.other = this._imgId;
            ctx._colorFiler = colorFiler;
            ctx._copyClipInfo(submit, this._clipMatrix);
            submit.clipInfoID = this._clipid;
            for (var i = 0; i < n; i += 3) {
                _mesh.addQuad(this._data[i], this._data[i + 1], this._data[i + 2], true);
                CharSubmitCache.__posPool[CharSubmitCache.__nPosPool++] = this._data[i];
            }
            n /= 3;
            submit._numEle += n * 6;
            _mesh.indexNum += n * 6;
            _mesh.vertNum += n * 4;
            ctx._drawCount += n;
            this._ndata = 0;
            if (RenderInfo.loopCount % 100 == 0)
                this._data.length = 0;
        }
    }
    CharSubmitCache.__posPool = [];
    CharSubmitCache.__nPosPool = 0;

    class AtlasGrid {
        constructor(width = 0, height = 0, id = 0) {
            this.atlasID = 0;
            this._width = 0;
            this._height = 0;
            this._texCount = 0;
            this._rowInfo = null;
            this._cells = null;
            this._used = 0;
            this._cells = null;
            this._rowInfo = null;
            this.atlasID = id;
            this._init(width, height);
        }
        addRect(type, width, height, pt) {
            if (!this._get(width, height, pt))
                return false;
            this._fill(pt.x, pt.y, width, height, type);
            this._texCount++;
            return true;
        }
        _release() {
            this._cells = null;
            this._rowInfo = null;
        }
        _init(width, height) {
            this._width = width;
            this._height = height;
            this._release();
            if (this._width == 0)
                return false;
            this._cells = new Uint8Array(this._width * this._height * 3);
            this._rowInfo = new Uint8Array(this._height);
            this._used = 0;
            this._clear();
            return true;
        }
        _get(width, height, pt) {
            if (width > this._width || height > this._height) {
                return false;
            }
            var rx = -1;
            var ry = -1;
            var nWidth = this._width;
            var nHeight = this._height;
            var pCellBox = this._cells;
            for (var y = 0; y < nHeight; y++) {
                if (this._rowInfo[y] < width)
                    continue;
                for (var x = 0; x < nWidth;) {
                    var tm = (y * nWidth + x) * 3;
                    if (pCellBox[tm] != 0 || pCellBox[tm + 1] < width || pCellBox[tm + 2] < height) {
                        x += pCellBox[tm + 1];
                        continue;
                    }
                    rx = x;
                    ry = y;
                    for (var xx = 0; xx < width; xx++) {
                        if (pCellBox[3 * xx + tm + 2] < height) {
                            rx = -1;
                            break;
                        }
                    }
                    if (rx < 0) {
                        x += pCellBox[tm + 1];
                        continue;
                    }
                    pt.x = rx;
                    pt.y = ry;
                    return true;
                }
            }
            return false;
        }
        _fill(x, y, w, h, type) {
            var nWidth = this._width;
            var nHeghit = this._height;
            this._check((x + w) <= nWidth && (y + h) <= nHeghit);
            for (var yy = y; yy < (h + y); ++yy) {
                this._check(this._rowInfo[yy] >= w);
                this._rowInfo[yy] -= w;
                for (var xx = 0; xx < w; xx++) {
                    var tm = (x + yy * nWidth + xx) * 3;
                    this._check(this._cells[tm] == 0);
                    this._cells[tm] = type;
                    this._cells[tm + 1] = w;
                    this._cells[tm + 2] = h;
                }
            }
            if (x > 0) {
                for (yy = 0; yy < h; ++yy) {
                    var s = 0;
                    for (xx = x - 1; xx >= 0; --xx, ++s) {
                        if (this._cells[((y + yy) * nWidth + xx) * 3] != 0)
                            break;
                    }
                    for (xx = s; xx > 0; --xx) {
                        this._cells[((y + yy) * nWidth + x - xx) * 3 + 1] = xx;
                        this._check(xx > 0);
                    }
                }
            }
            if (y > 0) {
                for (xx = x; xx < (x + w); ++xx) {
                    s = 0;
                    for (yy = y - 1; yy >= 0; --yy, s++) {
                        if (this._cells[(xx + yy * nWidth) * 3] != 0)
                            break;
                    }
                    for (yy = s; yy > 0; --yy) {
                        this._cells[(xx + (y - yy) * nWidth) * 3 + 2] = yy;
                        this._check(yy > 0);
                    }
                }
            }
            this._used += (w * h) / (this._width * this._height);
        }
        _check(ret) {
            if (ret == false) {
                console.log("xtexMerger 错误啦");
            }
        }
        _clear() {
            this._texCount = 0;
            for (var y = 0; y < this._height; y++) {
                this._rowInfo[y] = this._width;
            }
            for (var i = 0; i < this._height; i++) {
                for (var j = 0; j < this._width; j++) {
                    var tm = (i * this._width + j) * 3;
                    this._cells[tm] = 0;
                    this._cells[tm + 1] = this._width - j;
                    this._cells[tm + 2] = this._width - i;
                }
            }
        }
    }

    exports.WrapMode = void 0;
    (function (WrapMode) {
        WrapMode[WrapMode["Repeat"] = 0] = "Repeat";
        WrapMode[WrapMode["Clamp"] = 1] = "Clamp";
        WrapMode[WrapMode["Mirrored"] = 2] = "Mirrored";
    })(exports.WrapMode || (exports.WrapMode = {}));

    class TextTexture extends Resource {
        constructor(textureW, textureH) {
            super();
            this._texW = 0;
            this._texH = 0;
            this._discardTm = 0;
            this.genID = 0;
            this.bitmap = { id: 0, _glTexture: null };
            this.curUsedCovRate = 0;
            this.curUsedCovRateAtlas = 0;
            this.lastTouchTm = 0;
            this.ri = null;
            this._texW = textureW || TextRender.atlasWidth;
            this._texH = textureH || TextRender.atlasWidth;
            this.bitmap.id = this.id;
            this.lock = true;
            this._render2DContext = LayaGL.render2DContext;
        }
        get gammaCorrection() {
            return this.bitmap._glTexture.gammaCorrection;
        }
        recreateResource() {
            if (this._source)
                return;
            var glTex = this._source = new Texture2D(this._texW, this._texH, exports.TextureFormat.R8G8B8A8, false, false, true);
            glTex.setPixelsData(null, true, false);
            glTex.lock = true;
            this.bitmap._glTexture = glTex;
            this._source.filterMode = exports.FilterMode.Bilinear;
            this._source.wrapModeU = exports.WrapMode.Clamp;
            this._source.wrapModeV = exports.WrapMode.Clamp;
            if (TextRender.debugUV) {
                this.fillWhite();
            }
        }
        addChar(data, x, y, uv = null) {
            if (TextRender.isWan1Wan) {
                return this.addCharCanvas(data, x, y, uv);
            }
            var dt = data.data;
            if (data.data instanceof Uint8ClampedArray)
                dt = new Uint8Array(dt.buffer);
            !this._source && this.recreateResource();
            LayaGL.textureContext.setTextureSubPixelsData(this._source._texture, dt, 0, false, x, y, data.width, data.height, true, false);
            var u0;
            var v0;
            var u1;
            var v1;
            u0 = x / this._texW;
            v0 = y / this._texH;
            u1 = (x + data.width) / this._texW;
            v1 = (y + data.height) / this._texH;
            uv = uv || new Array(8);
            uv[0] = u0, uv[1] = v0;
            uv[2] = u1, uv[3] = v0;
            uv[4] = u1, uv[5] = v1;
            uv[6] = u0, uv[7] = v1;
            return uv;
        }
        addCharCanvas(canv, x, y, uv = null) {
            !this._source && this.recreateResource();
            LayaGL.textureContext.setTexturebySubImageData(this._source._texture, canv, x, y, true, false);
            var u0;
            var v0;
            var u1;
            var v1;
            if (LayaEnv.isConch) {
                u0 = x / this._texW;
                v0 = y / this._texH;
                u1 = (x + canv.width) / this._texW;
                v1 = (y + canv.height) / this._texH;
            }
            else {
                u0 = (x + 1) / this._texW;
                v0 = (y + 1) / this._texH;
                u1 = (x + canv.width - 1) / this._texW;
                v1 = (y + canv.height - 1) / this._texH;
            }
            uv = uv || new Array(8);
            uv[0] = u0, uv[1] = v0;
            uv[2] = u1, uv[3] = v0;
            uv[4] = u1, uv[5] = v1;
            uv[6] = u0, uv[7] = v1;
            return uv;
        }
        fillWhite() {
            !this._source && this.recreateResource();
            var dt = new Uint8Array(this._texW * this._texH * 4);
            dt.fill(0xff);
            LayaGL.textureContext.setTextureImageData(this._source._getSource(), dt, true, false);
        }
        discard() {
            ILaya.stage.setGlobalRepaint();
            this.destroy();
            return;
        }
        static getTextTexture(w, h) {
            return new TextTexture(w, h);
        }
        _disposeResource() {
            this._source && this._source.destroy();
            this._source = null;
        }
        static clean() {
            var curtm = RenderInfo.loopStTm;
            if (TextTexture.cleanTm === 0)
                TextTexture.cleanTm = curtm;
            if (curtm - TextTexture.cleanTm >= TextRender.checkCleanTextureDt) {
                for (var i = 0; i < TextTexture.poolLen; i++) {
                    var p = TextTexture.pool[i];
                    if (curtm - p._discardTm >= TextRender.destroyUnusedTextureDt) {
                        p.destroy();
                        TextTexture.pool[i] = TextTexture.pool[TextTexture.poolLen - 1];
                        TextTexture.poolLen--;
                        i--;
                    }
                }
                TextTexture.cleanTm = curtm;
            }
        }
        touchRect(ri, curloop) {
            if (this.lastTouchTm != curloop) {
                this.curUsedCovRate = 0;
                this.curUsedCovRateAtlas = 0;
                this.lastTouchTm = curloop;
            }
            var texw2 = TextRender.atlasWidth * TextRender.atlasWidth;
            var gridw2 = TextAtlas.atlasGridW * TextAtlas.atlasGridW;
            this.curUsedCovRate += (ri.bmpWidth * ri.bmpHeight) / texw2;
            this.curUsedCovRateAtlas += (Math.ceil(ri.bmpWidth / TextAtlas.atlasGridW) * Math.ceil(ri.bmpHeight / TextAtlas.atlasGridW)) / (texw2 / gridw2);
        }
        get texture() {
            return this;
        }
        _getSource() {
            return this._source._getSource();
        }
        drawOnScreen(x, y) {
        }
    }
    TextTexture.pool = new Array(10);
    TextTexture.poolLen = 0;
    TextTexture.cleanTm = 0;

    class TextAtlas {
        constructor() {
            this.texWidth = 1024;
            this.texHeight = 1024;
            this.texture = null;
            this.charMaps = {};
            this.texHeight = this.texWidth = TextRender.atlasWidth;
            this.texture = TextTexture.getTextTexture(this.texWidth, this.texHeight);
            if (this.texWidth / TextAtlas.atlasGridW > 256) {
                TextAtlas.atlasGridW = Math.ceil(this.texWidth / 256);
            }
            this.atlasgrid = new AtlasGrid(this.texWidth / TextAtlas.atlasGridW, this.texHeight / TextAtlas.atlasGridW, this.texture.id);
        }
        setProtecteDist(d) {
        }
        getAEmpty(w, h, pt) {
            var find = this.atlasgrid.addRect(1, Math.ceil(w / TextAtlas.atlasGridW), Math.ceil(h / TextAtlas.atlasGridW), pt);
            if (find) {
                pt.x *= TextAtlas.atlasGridW;
                pt.y *= TextAtlas.atlasGridW;
            }
            return find;
        }
        get usedRate() {
            return this.atlasgrid._used;
        }
        destroy() {
            for (var k in this.charMaps) {
                var ri = this.charMaps[k];
                ri.deleted = true;
            }
            this.texture.discard();
        }
        printDebugInfo() {
        }
    }
    TextAtlas.atlasGridW = 16;

    class FontInfo {
        constructor(font) {
            this._font = "14px Arial";
            this._family = "Arial";
            this._size = 14;
            this._italic = false;
            this._bold = false;
            this._id = FontInfo._gfontID++;
            this.setFont(font || this._font);
        }
        static Parse(font) {
            if (font === FontInfo._lastFont) {
                return FontInfo._lastFontInfo;
            }
            var r = FontInfo._cache[font];
            if (!r) {
                r = FontInfo._cache[font] = new FontInfo(font);
            }
            FontInfo._lastFont = font;
            FontInfo._lastFontInfo = r;
            return r;
        }
        setFont(value) {
            this._font = value;
            var _words = value.split(' ');
            var l = _words.length;
            if (l < 2) {
                if (l == 1) {
                    if (_words[0].indexOf('px') > 0) {
                        this._size = parseInt(_words[0]);
                    }
                }
                return;
            }
            var szpos = -1;
            for (var i = 0; i < l; i++) {
                if (_words[i].indexOf('px') > 0 || _words[i].indexOf('pt') > 0) {
                    szpos = i;
                    this._size = parseInt(_words[i]);
                    if (this._size <= 0) {
                        console.error('font parse error:' + value);
                        this._size = 14;
                    }
                    break;
                }
            }
            var fpos = szpos + 1;
            var familys = _words[fpos];
            fpos++;
            for (; fpos < l; fpos++) {
                familys += ' ' + _words[fpos];
            }
            this._family = (familys.split(','))[0];
            this._italic = _words.indexOf('italic') >= 0;
            this._bold = _words.indexOf('bold') >= 0;
        }
    }
    FontInfo.EMPTY = new FontInfo(null);
    FontInfo._cache = {};
    FontInfo._gfontID = 0;
    FontInfo._lastFont = '';

    class NativeWordText {
        constructor() {
            this._nativeObj = new window._conchWordText();
        }
        setText(txt) {
            this._nativeObj._text = txt;
            this.cleanCache();
        }
        cleanCache() {
            this._nativeObj.cleanCache();
        }
        set splitRender(value) {
            this._nativeObj.splitRender = value;
        }
    }

    class WordText {
        constructor() {
            this.save = [];
            this.toUpperCase = null;
            this.width = -1;
            this.pageChars = [];
            this.startID = 0;
            this.startIDStroke = 0;
            this.lastGCCnt = 0;
            this.splitRender = false;
            this.scalex = 1;
            this.scaley = 1;
        }
        setText(txt) {
            this.changed = true;
            this._text = txt;
            this.width = -1;
            this.cleanCache();
        }
        toString() {
            return this._text;
        }
        get length() {
            return this._text ? this._text.length : 0;
        }
        charCodeAt(i) {
            return this._text ? this._text.charCodeAt(i) : NaN;
        }
        charAt(i) {
            return this._text ? this._text.charAt(i) : null;
        }
        cleanCache() {
            let pagecharse = this.pageChars;
            for (var i in pagecharse) {
                let p = pagecharse[i];
                var tex = p.tex;
                var words = p.words;
                if (words.length == 1 && tex && tex.ri) {
                    tex.destroy();
                }
            }
            this.pageChars = [];
            this.startID = 0;
            this.scalex = 1;
            this.scaley = 1;
        }
    }
    if (window.conch && !window.conchConfig.conchWebGL) {
        WordText = NativeWordText;
    }

    class CharRenderInfo {
        constructor() {
            this.char = '';
            this.deleted = false;
            this.uv = new Array(8);
            this.pos = 0;
            this.orix = 0;
            this.oriy = 0;
            this.touchTick = 0;
            this.isSpace = false;
        }
        touch() {
            var curLoop = RenderInfo.loopCount;
            if (this.touchTick != curLoop) {
                this.tex.touchRect(this, curLoop);
            }
            this.touchTick = curLoop;
        }
    }

    class ICharRender {
        constructor() {
            this.fontsz = 16;
        }
        getWidth(font, str) { return 0; }
        scale(sx, sy) {
        }
        get canvasWidth() {
            return 0;
        }
        set canvasWidth(w) {
        }
        getCharBmp(char, font, lineWidth, colStr, strokeColStr, size, margin_left, margin_top, margin_right, margin_bottom, rect = null) {
            return null;
        }
    }

    class Browser {
        static __init__() {
            let Laya = window.Laya || ILaya.Laya;
            if (Browser._window)
                return Browser._window;
            let win = Browser._window = window;
            let doc = Browser._document = win.document;
            let u = Browser.userAgent = win.navigator.userAgent;
            let maxTouchPoints = win.navigator.maxTouchPoints || 0;
            let platform = win.navigator.platform;
            if (!!window.conch && "conchUseWXAdapter" in Browser.window) {
                window.wxMiniGame(Laya, Laya);
                Laya["MiniAdpter"].enable();
            }
            if ("my" in Browser.window) {
                if (u.indexOf('TB/') > -1 || u.indexOf('Taobao/') > -1 || u.indexOf('TM/') > -1) {
                    window.tbMiniGame(Laya, Laya);
                    if (!Laya["TBMiniAdapter"]) {
                        console.error("请先添加淘宝适配库,详细教程：https://ldc2.layabox.com/doc/?language=zh&nav=zh-ts-5-6-0");
                    }
                    else {
                        Laya["TBMiniAdapter"].enable();
                    }
                }
                else if (u.indexOf('AlipayMiniGame') > -1) {
                    window.aliPayMiniGame(Laya, Laya);
                    if (!Laya["ALIMiniAdapter"]) {
                        console.error("请先添加阿里小游戏适配库,详细教程：https://ldc2.layabox.com/doc/?language=zh&nav=zh-ts-5-6-0");
                    }
                    else {
                        Laya["ALIMiniAdapter"].enable();
                    }
                }
            }
            if (u.indexOf('OPPO') == -1 && u.indexOf("MiniGame") > -1 && "wx" in Browser.window) {
                if ("tt" in Browser.window) {
                    window.ttMiniGame(Laya, Laya);
                    if (!Laya["TTMiniAdapter"]) {
                        console.error("请引入字节跳动小游戏的适配库");
                    }
                    else {
                        Laya["TTMiniAdapter"].enable();
                    }
                }
                else if ("bl" in Browser.window) {
                    window.biliMiniGame(Laya, Laya);
                    if (!Laya["BLMiniAdapter"]) {
                        console.error("请引入bilibili小游戏的适配库,详细教程：https://ldc2.layabox.com/doc/?language=zh&nav=zh-ts-5-7-0");
                    }
                    else {
                        Laya["BLMiniAdapter"].enable();
                    }
                }
                else if ("qq" in Browser.window) {
                    window.qqMiniGame(Laya, Laya);
                    if (!Laya["QQMiniAdapter"]) {
                        console.error("请引入手机QQ小游戏的适配库,详细教程：https://ldc2.layabox.com/doc/?language=zh&nav=zh-ts-5-0-0");
                    }
                    else {
                        Laya["QQMiniAdapter"].enable();
                    }
                }
                else {
                    window.wxMiniGame(Laya, Laya);
                    if (!Laya["MiniAdpter"]) {
                        console.error("请先添加小游戏适配库,详细教程：https://ldc2.layabox.com/doc/?nav=zh-ts-5-0-0");
                    }
                    else {
                        Laya["MiniAdpter"].enable();
                    }
                }
            }
            if ("hbs" in Browser.window) {
                window.hwMiniGame(Laya, Laya);
                if (!Laya["HWMiniAdapter"]) {
                    console.error("请先添加小游戏适配库!");
                }
                else {
                    Laya["HWMiniAdapter"].enable();
                }
            }
            if (u.indexOf("SwanGame") > -1) {
                window.bdMiniGame(Laya, Laya);
                if (!Laya["BMiniAdapter"]) {
                    console.error("请先添加百度小游戏适配库,详细教程：https://ldc2.layabox.com/doc/?language=zh&nav=zh-ts-5-1-0");
                }
                else {
                    Laya["BMiniAdapter"].enable();
                }
            }
            if (u.indexOf('QuickGame') > -1) {
                window.miMiniGame(Laya, Laya);
                if (!Laya["KGMiniAdapter"]) {
                    console.error("请先添加小米小游戏适配库,详细教程：https://ldc2.layabox.com/doc/?language=zh&nav=zh-ts-5-2-0");
                }
                else {
                    Laya["KGMiniAdapter"].enable();
                }
            }
            if (u.indexOf('OPPO') > -1 && u.indexOf('MiniGame') > -1) {
                window.qgMiniGame(Laya, Laya);
                if (!Laya["QGMiniAdapter"]) {
                    console.error("请先添加OPPO小游戏适配库,详细教程：https://ldc2.layabox.com/doc/?language=zh&nav=zh-ts-5-3-0");
                }
                else {
                    Laya["QGMiniAdapter"].enable();
                }
            }
            if (u.indexOf('VVGame') > -1) {
                window.vvMiniGame(Laya, Laya);
                if (!Laya["VVMiniAdapter"]) {
                    console.error("请先添加VIVO小游戏适配库,详细教程：https://ldc2.layabox.com/doc/?language=zh&nav=zh-ts-5-4-0");
                }
                else {
                    Laya["VVMiniAdapter"].enable();
                }
            }
            win.trace = console.log;
            win.requestAnimationFrame = win.requestAnimationFrame || win.webkitRequestAnimationFrame || win.mozRequestAnimationFrame || win.oRequestAnimationFrame || win.msRequestAnimationFrame || function (fun) {
                return win.setTimeout(fun, 1000 / 60);
            };
            var bodyStyle = doc.body.style;
            bodyStyle.margin = 0;
            bodyStyle.overflow = 'hidden';
            bodyStyle['-webkit-user-select'] = 'none';
            bodyStyle['-webkit-tap-highlight-color'] = 'rgba(200,200,200,0)';
            var metas = doc.getElementsByTagName('meta');
            var i = 0, flag = false, content = 'width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no';
            while (i < metas.length) {
                var meta = metas[i];
                if (meta.name == 'viewport') {
                    meta.content = content;
                    flag = true;
                    break;
                }
                i++;
            }
            if (!flag) {
                meta = doc.createElement('meta');
                meta.name = 'viewport', meta.content = content;
                doc.getElementsByTagName('head')[0].appendChild(meta);
            }
            Browser.onMobile = window.conch ? true : u.indexOf("Mobile") > -1;
            Browser.onIOS = !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/);
            Browser.onIPhone = u.indexOf("iPhone") > -1;
            Browser.onMac = u.indexOf("Mac OS X") > -1;
            Browser.onIPad = u.indexOf("iPad") > -1 || (platform === 'MacIntel' && maxTouchPoints > 1);
            Browser.onAndroid = u.indexOf('Android') > -1 || u.indexOf('Adr') > -1;
            Browser.onWP = u.indexOf("Windows Phone") > -1;
            Browser.onQQBrowser = u.indexOf("QQBrowser") > -1;
            Browser.onMQQBrowser = u.indexOf("MQQBrowser") > -1 || (u.indexOf("Mobile") > -1 && u.indexOf("QQ") > -1);
            Browser.onIE = !!win.ActiveXObject || "ActiveXObject" in win;
            Browser.onWeiXin = u.indexOf('MicroMessenger') > -1;
            Browser.onSafari = u.indexOf("Safari") > -1;
            Browser.onChrome = u.indexOf("Chrome") > -1;
            Browser.onPC = !Browser.onMobile;
            Browser.onFirefox = u.indexOf('Firefox') > -1;
            Browser.onEdge = u.indexOf('Edge') > -1;
            Browser.onMiniGame = u.indexOf('MiniGame') > -1;
            Browser.onBDMiniGame = u.indexOf('SwanGame') > -1;
            Browser.onLayaRuntime = !!window.conch;
            if (u.indexOf('OPPO') > -1 && u.indexOf('MiniGame') > -1) {
                Browser.onQGMiniGame = true;
                Browser.onMiniGame = false;
            }
            else if ("qq" in Browser.window && u.indexOf('MiniGame') > -1) {
                Browser.onQQMiniGame = true;
                Browser.onMiniGame = false;
            }
            else if ("bl" in Browser.window && u.indexOf('MiniGame') > -1) {
                Browser.onBLMiniGame = true;
                Browser.onMiniGame = false;
            }
            else if ("tt" in Browser.window && u.indexOf('MiniGame') > -1) {
                Browser.onTTMiniGame = true;
                Browser.onMiniGame = false;
            }
            Browser.onHWMiniGame = "hbs" in Browser.window;
            Browser.onVVMiniGame = u.indexOf('VVGame') > -1;
            Browser.onKGMiniGame = u.indexOf('QuickGame') > -1;
            if (u.indexOf('AlipayMiniGame') > -1) {
                Browser.onAlipayMiniGame = true;
                Browser.onMiniGame = false;
            }
            if (u.indexOf('TB/') > -1 || u.indexOf('Taobao/') > -1 || u.indexOf('TM/') > -1) {
                Browser.onTBMiniGame = true;
            }
            if (Browser.onAndroid || Browser.onIOS) {
                if (platform && (platform.indexOf("Win") != -1 || platform.indexOf("Mac") != -1))
                    Browser.platform = Browser.PLATFORM_PC;
                else if (Browser.onAndroid)
                    Browser.platform = Browser.PLATFORM_ANDROID;
                else
                    Browser.platform = Browser.PLATFORM_IOS;
            }
            else
                Browser.platform = Browser.PLATFORM_PC;
            return win;
        }
        static get _isMiniGame() {
            return Browser.onMiniGame || Browser.onBDMiniGame || Browser.onQGMiniGame || Browser.onKGMiniGame || Browser.onVVMiniGame || Browser.onAlipayMiniGame || Browser.onQQMiniGame || Browser.onBLMiniGame || Browser.onTTMiniGame || Browser.onHWMiniGame || Browser.onTBMiniGame || (Browser.window && Browser.window.isWXMiMi);
        }
        static createElement(type) {
            Browser.__init__();
            return Browser._document.createElement(type);
        }
        static getElementById(type) {
            Browser.__init__();
            return Browser._document.getElementById(type);
        }
        static removeElement(ele) {
            if (ele && ele.parentNode)
                ele.parentNode.removeChild(ele);
        }
        static now() {
            return Date.now();
        }
        static get clientWidth() {
            Browser.__init__();
            return Browser._clientWidth || Browser._window.innerWidth || Browser._document.body.clientWidth;
        }
        static set clientWidth(value) {
            Browser._clientWidth = value;
        }
        static get clientHeight() {
            Browser.__init__();
            return Browser._clientHeight || Browser._window.innerHeight || Browser._document.body.clientHeight || Browser._document.documentElement.clientHeight;
        }
        static set clientHeight(value) {
            Browser._clientHeight = value;
        }
        static get width() {
            Browser.__init__();
            return ((ILaya.stage && ILaya.stage.canvasRotation) ? Browser.clientHeight : Browser.clientWidth) * Browser.pixelRatio;
        }
        static get height() {
            Browser.__init__();
            return ((ILaya.stage && ILaya.stage.canvasRotation) ? Browser.clientWidth : Browser.clientHeight) * Browser.pixelRatio;
        }
        static get pixelRatio() {
            if (Browser._pixelRatio < 0) {
                Browser.__init__();
                if (Browser.userAgent.indexOf("Mozilla/6.0(Linux; Android 6.0; HUAWEI NXT-AL10 Build/HUAWEINXT-AL10)") > -1)
                    Browser._pixelRatio = 2;
                else {
                    Browser._pixelRatio = (Browser._window.devicePixelRatio || 1);
                    if (Browser._pixelRatio < 1)
                        Browser._pixelRatio = 1;
                }
            }
            return Browser._pixelRatio;
        }
        static get container() {
            if (!Browser._container) {
                Browser.__init__();
                Browser._container = Browser.createElement("div");
                Browser._container.id = "layaContainer";
                Browser._document.body.appendChild(Browser._container);
            }
            return Browser._container;
        }
        static set container(value) {
            Browser._container = value;
        }
        static get window() {
            return Browser._window || Browser.__init__();
        }
        static get document() {
            Browser.__init__();
            return Browser._document;
        }
        static getQueryString(name) {
            if (Browser.onMiniGame)
                return null;
            if (!window.location || !window.location.search)
                return null;
            var reg = new RegExp("(^|&)" + name + "=([^&]*)(&|$)");
            var r = window.location.search.substring(1).match(reg);
            if (r != null)
                return unescape(r[2]);
            return null;
        }
    }
    Browser.PLATFORM_PC = 0;
    Browser.PLATFORM_ANDROID = 1;
    Browser.PLATFORM_IOS = 2;
    Browser._pixelRatio = -1;
    Browser.mainCanvas = null;
    Browser.hanzi = new RegExp("^[\u4E00-\u9FA5]$");
    Browser.fontMap = {};
    Browser.measureText = function (txt, font) {
        let isChinese = Browser.hanzi.test(txt);
        if (isChinese && Browser.fontMap[font]) {
            return Browser.fontMap[font];
        }
        let ctx = Browser.context;
        ctx.font = font;
        let r = ctx.measureText(txt);
        if (isChinese)
            Browser.fontMap[font] = r;
        return r;
    };

    class CharRender_Canvas extends ICharRender {
        constructor(maxw, maxh, scalefont = true, useImageData = true, showdbg = false) {
            super();
            this.ctx = null;
            this.lastScaleX = 1.0;
            this.lastScaleY = 1.0;
            this.maxTexW = 0;
            this.maxTexH = 0;
            this.scaleFontSize = true;
            this.showDbgInfo = false;
            this.supportImageData = true;
            this.maxTexW = maxw;
            this.maxTexH = maxh;
            this.scaleFontSize = scalefont;
            this.supportImageData = useImageData;
            this.showDbgInfo = showdbg;
            if (!CharRender_Canvas.canvas) {
                CharRender_Canvas.canvas = Browser.createElement('canvas');
                CharRender_Canvas.canvas.width = 1024;
                CharRender_Canvas.canvas.height = 512;
                CharRender_Canvas.canvas.style.left = "-10000px";
                CharRender_Canvas.canvas.style.position = "absolute";
                document.body.appendChild(CharRender_Canvas.canvas);
                this.ctx = CharRender_Canvas.canvas.getContext('2d', { willReadFrequently: true });
            }
        }
        get canvasWidth() {
            return CharRender_Canvas.canvas.width;
        }
        set canvasWidth(w) {
            if (CharRender_Canvas.canvas.width == w)
                return;
            CharRender_Canvas.canvas.width = w;
            if (w > 2048) {
                console.warn("画文字设置的宽度太大，超过2048了");
            }
            this.ctx.setTransform(1, 0, 0, 1, 0, 0);
            this.ctx.scale(this.lastScaleX, this.lastScaleY);
        }
        getWidth(font, str) {
            if (!this.ctx)
                return 0;
            if (this.ctx._lastFont != font) {
                this.ctx.font = font;
                this.ctx._lastFont = font;
            }
            return this.ctx.measureText(str).width;
        }
        scale(sx, sy) {
            if (!this.supportImageData) {
                this.lastScaleX = sx;
                this.lastScaleY = sy;
                return;
            }
            if (this.lastScaleX != sx || this.lastScaleY != sy) {
                this.ctx.setTransform(sx, 0, 0, sy, 0, 0);
                this.lastScaleX = sx;
                this.lastScaleY = sy;
            }
        }
        getCharBmp(char, font, lineWidth, colStr, strokeColStr, cri, margin_left, margin_top, margin_right, margin_bottom, rect = null) {
            if (!this.supportImageData)
                return this.getCharCanvas(char, font, lineWidth, colStr, strokeColStr, cri, margin_left, margin_top, margin_right, margin_bottom);
            var ctx = this.ctx;
            var sz = this.fontsz;
            if (ctx.font != font) {
                ctx.font = font;
                ctx._lastFont = font;
            }
            cri.width = ctx.measureText(char).width;
            var w = cri.width * this.lastScaleX;
            var h = cri.height * this.lastScaleY;
            w += (margin_left + margin_right) * this.lastScaleX;
            h += (margin_top + margin_bottom) * this.lastScaleY;
            w = Math.ceil(w);
            h = Math.ceil(h);
            w = Math.min(w, CharRender_Canvas.canvas.width);
            h = Math.min(h, CharRender_Canvas.canvas.height);
            var clearW = w + lineWidth * 2 + 1;
            var clearH = h + lineWidth * 2 + 1;
            if (rect) {
                clearW = Math.max(clearW, rect[0] + rect[2] + 1);
                clearH = Math.max(clearH, rect[1] + rect[3] + 1);
            }
            ctx.clearRect(0, 0, clearW / this.lastScaleX + 1, clearH / this.lastScaleY + 1);
            ctx.save();
            ctx.textBaseline = "middle";
            if (lineWidth > 0) {
                ctx.strokeStyle = strokeColStr;
                ctx.lineWidth = lineWidth;
                ctx.strokeText(char, margin_left, margin_top + sz / 2);
            }
            if (colStr) {
                ctx.fillStyle = colStr;
                ctx.fillText(char, margin_left, margin_top + sz / 2);
            }
            if (this.showDbgInfo) {
                ctx.strokeStyle = '#ff0000';
                ctx.strokeRect(1, 1, w - 2, h - 2);
                ctx.strokeStyle = '#00ff00';
                ctx.strokeRect(margin_left, margin_top, cri.width, cri.height);
            }
            if (rect) {
                if (rect[2] == -1)
                    rect[2] = Math.ceil((cri.width + lineWidth * 2) * this.lastScaleX);
                if (rect[2] <= 0)
                    rect[2] = 1;
            }
            var imgdt = rect ? (ctx.getImageData(rect[0], rect[1], rect[2], rect[3] + 1)) : (ctx.getImageData(0, 0, w, h + 1));
            ctx.restore();
            cri.bmpWidth = imgdt.width;
            cri.bmpHeight = imgdt.height;
            return imgdt;
        }
        getCharCanvas(char, font, lineWidth, colStr, strokeColStr, cri, margin_left, margin_top, margin_right, margin_bottom) {
            var ctx = this.ctx;
            if (ctx.font != font) {
                ctx.font = font;
                ctx._lastFont = font;
            }
            cri.width = ctx.measureText(char).width;
            var w = cri.width * this.lastScaleX;
            var h = cri.height * this.lastScaleY;
            w += (margin_left + margin_right) * this.lastScaleX;
            h += ((margin_top + margin_bottom) * this.lastScaleY + 1);
            w = Math.min(w, this.maxTexW);
            h = Math.min(h, this.maxTexH);
            CharRender_Canvas.canvas.width = Math.min(w + 1, this.maxTexW);
            CharRender_Canvas.canvas.height = Math.min(h + 1, this.maxTexH);
            ctx.font = font;
            ctx.clearRect(0, 0, w + 1 + lineWidth, h + 1 + lineWidth);
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.save();
            if (this.scaleFontSize) {
                ctx.scale(this.lastScaleX, this.lastScaleY);
            }
            ctx.translate(margin_left, margin_top);
            ctx.textAlign = "left";
            var sz = this.fontsz;
            ctx.textBaseline = "middle";
            if (lineWidth > 0) {
                ctx.strokeStyle = strokeColStr;
                ctx.fillStyle = colStr;
                ctx.lineWidth = lineWidth;
                if (ctx.fillAndStrokeText) {
                    ctx.fillAndStrokeText(char, 0, sz / 2);
                }
                else {
                    ctx.strokeText(char, 0, sz / 2);
                    ctx.fillText(char, 0, sz / 2);
                }
            }
            else if (colStr) {
                ctx.fillStyle = colStr;
                ctx.fillText(char, 0, sz / 2);
            }
            if (this.showDbgInfo) {
                ctx.strokeStyle = '#ff0000';
                ctx.strokeRect(0, 0, w, h);
                ctx.strokeStyle = '#00ff00';
                ctx.strokeRect(0, 0, cri.width, cri.height);
            }
            ctx.restore();
            cri.bmpWidth = CharRender_Canvas.canvas.width;
            cri.bmpHeight = CharRender_Canvas.canvas.height;
            return CharRender_Canvas.canvas;
        }
    }
    CharRender_Canvas.canvas = null;

    class CharRender_Native extends ICharRender {
        constructor() {
            super();
            this.lastFont = '';
            this.lastScaleX = 1.0;
            this.lastScaleY = 1.0;
        }
        getWidth(font, str) {
            if (!window.conchTextCanvas)
                return 0;
            window.conchTextCanvas.font = font;
            this.lastFont = font;
            return window.conchTextCanvas.measureText(str).width;
        }
        scale(sx, sy) {
            this.lastScaleX = sx;
            this.lastScaleY = sy;
        }
        getCharBmp(char, font, lineWidth, colStr, strokeColStr, size, margin_left, margin_top, margin_right, margin_bottom, rect = null) {
            if (!window.conchTextCanvas)
                return null;
            window.conchTextCanvas.font = font;
            this.lastFont = font;
            size.width = window.conchTextCanvas.measureText(char).width;
            size.height;
            window.conchTextCanvas.scale && window.conchTextCanvas.scale(this.lastScaleX, this.lastScaleY);
            var c1 = ColorUtils.create(strokeColStr);
            var nStrokeColor = c1.numColor;
            var c2 = ColorUtils.create(colStr);
            var nTextColor = c2.numColor;
            var textInfo = window.conchTextCanvas.getTextBitmapData(char, nTextColor, lineWidth > 2 ? 2 : lineWidth, nStrokeColor);
            size.bmpWidth = textInfo.width;
            size.bmpHeight = textInfo.height;
            return textInfo;
        }
    }

    class TextRender {
        constructor() {
            this.fontSizeInfo = {};
            this.mapFont = {};
            this.fontID = 0;
            this.fontScaleX = 1.0;
            this.fontScaleY = 1.0;
            this._curStrPos = 0;
            this.textAtlases = [];
            this.isoTextures = [];
            this.lastFont = null;
            this.fontSizeW = 0;
            this.fontSizeH = 0;
            this.fontSizeOffX = 0;
            this.fontSizeOffY = 0;
            this.renderPerChar = true;
            this.tmpAtlasPos = new Point();
            this.textureMem = 0;
            var bugIOS = false;
            var miniadp = ILaya.Laya['MiniAdpter'];
            if (miniadp && miniadp.systemInfo && miniadp.systemInfo.system) {
                bugIOS = miniadp.systemInfo.system.toLowerCase() === 'ios 10.1.1';
            }
            if ((ILaya.Browser.onMiniGame || ILaya.Browser.onTTMiniGame || ILaya.Browser.onBLMiniGame || ILaya.Browser.onAlipayMiniGame || ILaya.Browser.onTBMiniGame) && !bugIOS)
                TextRender.isWan1Wan = true;
            this.charRender = LayaEnv.isConch ? (new CharRender_Native()) : (new CharRender_Canvas(2048, 2048, TextRender.scaleFontWithCtx, !TextRender.isWan1Wan, false));
            TextRender.textRenderInst = this;
            ILaya.Laya['textRender'] = this;
            TextRender.atlasWidth2 = TextRender.atlasWidth * TextRender.atlasWidth;
        }
        setFont(font) {
            if (this.lastFont == font)
                return;
            this.lastFont = font;
            var fontsz = this.getFontSizeInfo(font._family);
            var offx = fontsz >> 24;
            var offy = (fontsz >> 16) & 0xff;
            var fw = (fontsz >> 8) & 0xff;
            var fh = fontsz & 0xff;
            var k = font._size / TextRender.standardFontSize;
            this.fontSizeOffX = Math.ceil(offx * k);
            this.fontSizeOffY = Math.ceil(offy * k);
            this.fontSizeW = Math.ceil(fw * k);
            this.fontSizeH = Math.ceil(fh * k);
            if (font._font.indexOf('italic') >= 0) {
                this.fontStr = font._font.replace('italic', '');
            }
            else {
                this.fontStr = font._font;
            }
        }
        getNextChar(str) {
            var len = str.length;
            var start = this._curStrPos;
            if (!str.substring)
                return null;
            if (start >= len)
                return null;
            var i = start;
            var state = 0;
            for (; i < len; i++) {
                var c = str.charCodeAt(i);
                if ((c >>> 11) == 0x1b) {
                    if (state == 1)
                        break;
                    state = 1;
                    i++;
                }
                else if (c === 0xfe0e || c === 0xfe0f) ;
                else if (c == 0x200d) {
                    state = 2;
                }
                else {
                    if (state == 0)
                        state = 1;
                    else if (state == 1)
                        break;
                    else ;
                }
            }
            this._curStrPos = i;
            return str.substring(start, i);
        }
        filltext(ctx, data, x, y, fontStr, color, strokeColor, lineWidth, textAlign, underLine = 0) {
            if (data.length <= 0)
                return;
            var font = FontInfo.Parse(fontStr);
            var nTextAlign = 0;
            switch (textAlign) {
                case 'center':
                    nTextAlign = Const.ENUM_TEXTALIGN_CENTER;
                    break;
                case 'right':
                    nTextAlign = Const.ENUM_TEXTALIGN_RIGHT;
                    break;
            }
            this._fast_filltext(ctx, data, null, x, y, font, color, strokeColor, lineWidth, nTextAlign, underLine);
        }
        fillWords(ctx, data, x, y, fontStr, color, strokeColor, lineWidth) {
            if (!data)
                return;
            if (data.length <= 0)
                return;
            var font = typeof (fontStr) === 'string' ? FontInfo.Parse(fontStr) : fontStr;
            this._fast_filltext(ctx, null, data, x, y, font, color, strokeColor, lineWidth, 0, 0);
        }
        _fast_filltext(ctx, data, htmlchars, x, y, font, color, strokeColor, lineWidth, textAlign, underLine = 0) {
            if (data && !(data.length >= 1))
                return;
            if (htmlchars && htmlchars.length < 1)
                return;
            if (lineWidth < 0)
                lineWidth = 0;
            this.setFont(font);
            this.fontScaleX = this.fontScaleY = 1.0;
            if (TextRender.scaleFontWithCtx) {
                var sx = 1;
                var sy = 1;
                if (!LayaEnv.isConch || (window.conchTextCanvas.scale)) {
                    sx = ctx.getMatScaleX();
                    sy = ctx.getMatScaleY();
                }
                if (sx < 1e-4 || sy < 1e-1)
                    return;
                if (sx > 1)
                    this.fontScaleX = sx;
                if (sy > 1)
                    this.fontScaleY = sy;
            }
            font._italic && (ctx._italicDeg = 13);
            var wt = data;
            var isWT = !htmlchars && (data instanceof WordText);
            var str = data && data.toString();
            var isHtmlChar = !!htmlchars;
            var sameTexData = isWT ? wt.pageChars : [];
            var strWidth = 0;
            if (isWT) {
                str = wt._text;
                strWidth = wt.width;
                if (strWidth < 0) {
                    strWidth = wt.width = this.charRender.getWidth(this.fontStr, str);
                }
            }
            else {
                strWidth = str ? this.charRender.getWidth(this.fontStr, str) : 0;
            }
            switch (textAlign) {
                case Const.ENUM_TEXTALIGN_CENTER:
                    x -= strWidth / 2;
                    break;
                case Const.ENUM_TEXTALIGN_RIGHT:
                    x -= strWidth;
                    break;
            }
            if (wt && sameTexData) {
                if (this.hasFreedText(sameTexData)) {
                    sameTexData = wt.pageChars = [];
                }
            }
            var ri = null;
            var splitTex = this.renderPerChar = (!isWT) || TextRender.forceSplitRender || isHtmlChar || (isWT && wt.splitRender);
            if (!sameTexData || sameTexData.length < 1) {
                if (isWT) {
                    wt.scalex = this.fontScaleX;
                    wt.scaley = this.fontScaleY;
                }
                if (splitTex) {
                    var stx = 0;
                    var sty = 0;
                    this._curStrPos = 0;
                    var curstr;
                    while (true) {
                        if (htmlchars) {
                            var chc = htmlchars[this._curStrPos++];
                            if (chc) {
                                curstr = chc.char;
                                stx = chc.x;
                                sty = chc.y;
                            }
                            else {
                                curstr = null;
                            }
                        }
                        else {
                            curstr = this.getNextChar(str);
                        }
                        if (!curstr)
                            break;
                        ri = this.getCharRenderInfo(curstr, font, color, strokeColor, lineWidth, false);
                        if (!ri) {
                            break;
                        }
                        if (ri.isSpace) ;
                        else {
                            var add = sameTexData[ri.tex.id];
                            if (!add) {
                                var o1 = { texgen: ri.tex.genID, tex: ri.tex, words: new Array() };
                                sameTexData[ri.tex.id] = o1;
                                add = o1.words;
                            }
                            else {
                                add = add.words;
                            }
                            add.push({ ri: ri, x: stx, y: sty, w: ri.bmpWidth / this.fontScaleX, h: ri.bmpHeight / this.fontScaleY });
                            stx += ri.width;
                        }
                    }
                }
                else {
                    var margin = LayaEnv.isConch ? 0 : (font._size / 3 | 0);
                    var isotex = TextRender.noAtlas || (strWidth + margin + margin) * this.fontScaleX > TextRender.atlasWidth;
                    ri = this.getCharRenderInfo(str, font, color, strokeColor, lineWidth, isotex);
                    sameTexData[0] = { texgen: ri.tex.genID, tex: ri.tex, words: [{ ri: ri, x: 0, y: 0, w: ri.bmpWidth / this.fontScaleX, h: ri.bmpHeight / this.fontScaleY }] };
                }
            }
            this._drawResortedWords(ctx, x, y, sameTexData);
            ctx._italicDeg = 0;
        }
        _drawResortedWords(ctx, startx, starty, samePagesData) {
            var isLastRender = ctx._charSubmitCache ? ctx._charSubmitCache._enable : false;
            var mat = ctx._curMat;
            for (var id in samePagesData) {
                var dt = samePagesData[id];
                if (!dt)
                    continue;
                var pri = dt.words;
                var pisz = pri.length;
                if (pisz <= 0)
                    continue;
                var tex = samePagesData[id].tex;
                for (var j = 0; j < pisz; j++) {
                    var riSaved = pri[j];
                    var ri = riSaved.ri;
                    if (ri.isSpace)
                        continue;
                    ri.touch();
                    ctx.drawTexAlign = true;
                    if (LayaEnv.isConch) {
                        ctx._drawTextureM(tex.texture, startx + riSaved.x - ri.orix, starty + riSaved.y - ri.oriy, riSaved.w, riSaved.h, null, 1.0, ri.uv);
                    }
                    else {
                        let t = tex;
                        ctx._inner_drawTexture(t.texture, t.id, startx + riSaved.x - ri.orix, starty + riSaved.y - ri.oriy, riSaved.w, riSaved.h, mat, ri.uv, 1.0, isLastRender);
                    }
                    if (ctx.touches) {
                        ctx.touches.push(ri);
                    }
                }
            }
        }
        hasFreedText(txts) {
            for (let i in txts) {
                var pri = txts[i];
                if (!pri)
                    continue;
                var tex = pri.tex;
                if (tex.destroyed || tex.genID != pri.texgen) {
                    return true;
                }
            }
            return false;
        }
        getCharRenderInfo(str, font, color, strokeColor, lineWidth, isoTexture = false) {
            var fid = this.mapFont[font._family];
            if (fid == undefined) {
                this.mapFont[font._family] = fid = this.fontID++;
            }
            var key = str + '_' + fid + '_' + font._size + '_' + color;
            if (lineWidth > 0)
                key += '_' + strokeColor + lineWidth;
            if (font._bold)
                key += 'P';
            if (this.fontScaleX != 1 || this.fontScaleY != 1) {
                key += (this.fontScaleX * 20 | 0) + '_' + (this.fontScaleY * 20 | 0);
            }
            var i = 0;
            var sz = this.textAtlases.length;
            var ri;
            var atlas;
            if (!isoTexture) {
                for (i = 0; i < sz; i++) {
                    atlas = this.textAtlases[i];
                    ri = atlas.charMaps[key];
                    if (ri) {
                        ri.touch();
                        return ri;
                    }
                }
            }
            ri = new CharRenderInfo();
            this.charRender.scale(this.fontScaleX, this.fontScaleY);
            ri.char = str;
            ri.height = font._size;
            var margin = LayaEnv.isConch ? 0 : (font._size / 3 | 0);
            var imgdt = null;
            if (!lineWidth) {
                lineWidth = 0;
            }
            var w1 = Math.ceil((this.charRender.getWidth(this.fontStr, str) + 2 * lineWidth) * this.fontScaleX);
            if (w1 > this.charRender.canvasWidth) {
                this.charRender.canvasWidth = Math.min(2048, w1 + margin * 2);
            }
            if (isoTexture) {
                this.charRender.fontsz = font._size;
                imgdt = this.charRender.getCharBmp(str, this.fontStr, lineWidth, color, strokeColor, ri, margin, margin, margin, margin, null);
                if (imgdt) {
                    var tex = TextTexture.getTextTexture(imgdt.width, imgdt.height);
                    tex.addChar(imgdt, 0, 0, ri.uv);
                    ri.tex = tex;
                    ri.orix = margin;
                    ri.oriy = margin;
                    tex.ri = ri;
                    this.isoTextures.push(tex);
                }
            }
            else {
                var len = str.length;
                var lineExt = lineWidth * 1;
                var fw = Math.ceil((this.fontSizeW + lineExt * 2) * this.fontScaleX);
                var fh = Math.ceil((this.fontSizeH + lineExt * 2) * this.fontScaleY);
                TextRender.imgdtRect[0] = ((margin - this.fontSizeOffX - lineExt) * this.fontScaleX) | 0;
                TextRender.imgdtRect[1] = ((margin - this.fontSizeOffY - lineExt) * this.fontScaleY) | 0;
                if (this.renderPerChar || len == 1) {
                    TextRender.imgdtRect[2] = Math.max(w1, fw);
                    TextRender.imgdtRect[3] = Math.max(w1, fh);
                }
                else {
                    TextRender.imgdtRect[2] = -1;
                    TextRender.imgdtRect[3] = fh;
                }
                this.charRender.fontsz = font._size;
                imgdt = this.charRender.getCharBmp(str, this.fontStr, lineWidth, color, strokeColor, ri, margin, margin, margin, margin, TextRender.imgdtRect);
                if (imgdt) {
                    atlas = this.addBmpData(imgdt, ri);
                    if (TextRender.isWan1Wan) {
                        ri.orix = margin;
                        ri.oriy = margin;
                    }
                    else {
                        ri.orix = (this.fontSizeOffX + lineExt);
                        ri.oriy = (this.fontSizeOffY + lineExt);
                    }
                    atlas.charMaps[key] = ri;
                }
            }
            return ri;
        }
        addBmpData(data, ri) {
            var w = data.width;
            var h = data.height;
            var sz = this.textAtlases.length;
            var atlas;
            var find = false;
            for (var i = 0; i < sz; i++) {
                atlas = this.textAtlases[i];
                find = atlas.getAEmpty(w, h, this.tmpAtlasPos);
                if (find) {
                    break;
                }
            }
            if (!find) {
                atlas = new TextAtlas();
                this.textAtlases.push(atlas);
                find = atlas.getAEmpty(w, h, this.tmpAtlasPos);
                if (!find) {
                    throw 'err1';
                }
                this.cleanAtlases();
            }
            if (find) {
                atlas.texture.addChar(data, this.tmpAtlasPos.x, this.tmpAtlasPos.y, ri.uv);
                ri.tex = atlas.texture;
            }
            return atlas;
        }
        GC() {
            var i = 0;
            var sz = this.textAtlases.length;
            var dt = 0;
            var destroyDt = TextRender.destroyAtlasDt;
            var totalUsedRate = 0;
            var totalUsedRateAtlas = 0;
            var curloop = RenderInfo.loopCount;
            var maxWasteRateID = -1;
            var maxWasteRate = 0;
            var tex = null;
            var curatlas = null;
            for (; i < sz; i++) {
                curatlas = this.textAtlases[i];
                tex = curatlas.texture;
                if (tex) {
                    totalUsedRate += tex.curUsedCovRate;
                    totalUsedRateAtlas += tex.curUsedCovRateAtlas;
                    var waste = curatlas.usedRate - tex.curUsedCovRateAtlas;
                    if (maxWasteRate < waste) {
                        maxWasteRate = waste;
                        maxWasteRateID = i;
                    }
                }
                dt = curloop - curatlas.texture.lastTouchTm;
                if (dt > destroyDt) {
                    TextRender.showLog && console.log('TextRender GC delete atlas ' + tex ? curatlas.texture.id : 'unk');
                    curatlas.destroy();
                    this.textAtlases[i] = this.textAtlases[sz - 1];
                    sz--;
                    i--;
                    maxWasteRateID = -1;
                }
            }
            this.textAtlases.length = sz;
            sz = this.isoTextures.length;
            for (i = 0; i < sz; i++) {
                tex = this.isoTextures[i];
                dt = curloop - tex.lastTouchTm;
                if (dt > TextRender.destroyUnusedTextureDt) {
                    tex.ri.deleted = true;
                    tex.ri.tex = null;
                    tex.destroy();
                    this.isoTextures[i] = this.isoTextures[sz - 1];
                    sz--;
                    i--;
                }
            }
            this.isoTextures.length = sz;
            var needGC = this.textAtlases.length > 1 && this.textAtlases.length - totalUsedRateAtlas >= 2;
            if (TextRender.atlasWidth * TextRender.atlasWidth * 4 * this.textAtlases.length > TextRender.cleanMem || needGC || TextRender.simClean) {
                TextRender.simClean = false;
                TextRender.showLog && console.log('清理使用率低的贴图。总使用率:', totalUsedRateAtlas, ':', this.textAtlases.length, '最差贴图:' + maxWasteRateID);
                if (maxWasteRateID >= 0) {
                    curatlas = this.textAtlases[maxWasteRateID];
                    curatlas.destroy();
                    this.textAtlases[maxWasteRateID] = this.textAtlases[this.textAtlases.length - 1];
                    this.textAtlases.length = this.textAtlases.length - 1;
                }
            }
            TextTexture.clean();
        }
        cleanAtlases() {
        }
        getCharBmp(c) {
        }
        checkBmpLine(data, l, sx, ex) {
            if (this.bmpData32.buffer != data.data.buffer) {
                this.bmpData32 = new Uint32Array(data.data.buffer);
            }
            var stpos = data.width * l + sx;
            for (var x = sx; x < ex; x++) {
                if (this.bmpData32[stpos++] != 0)
                    return true;
            }
            return false;
        }
        updateBbx(data, curbbx, onlyH = false) {
            var w = data.width;
            var h = data.height;
            var x = 0;
            var sy = curbbx[1];
            var ey = 0;
            var y = sy;
            if (this.checkBmpLine(data, sy, 0, w)) {
                while (true) {
                    y = (sy + ey) / 2 | 0;
                    if (y + 1 >= sy) {
                        curbbx[1] = y;
                        break;
                    }
                    if (this.checkBmpLine(data, y, 0, w)) {
                        sy = y;
                    }
                    else {
                        ey = y;
                    }
                }
            }
            if (curbbx[3] > h)
                curbbx[3] = h;
            else {
                y = sy = curbbx[3];
                ey = h;
                if (this.checkBmpLine(data, sy, 0, w)) {
                    while (true) {
                        y = (sy + ey) / 2 | 0;
                        if (y - 1 <= sy) {
                            curbbx[3] = y;
                            break;
                        }
                        if (this.checkBmpLine(data, y, 0, w)) {
                            sy = y;
                        }
                        else {
                            ey = y;
                        }
                    }
                }
            }
            if (onlyH)
                return;
            var minx = curbbx[0];
            var stpos = w * curbbx[1];
            for (y = curbbx[1]; y < curbbx[3]; y++) {
                for (x = 0; x < minx; x++) {
                    if (this.bmpData32[stpos + x] != 0) {
                        minx = x;
                        break;
                    }
                }
                stpos += w;
            }
            curbbx[0] = minx;
            var maxx = curbbx[2];
            stpos = w * curbbx[1];
            for (y = curbbx[1]; y < curbbx[3]; y++) {
                for (x = maxx; x < w; x++) {
                    if (this.bmpData32[stpos + x] != 0) {
                        maxx = x;
                        break;
                    }
                }
                stpos += w;
            }
            curbbx[2] = maxx;
        }
        getFontSizeInfo(font) {
            var finfo = this.fontSizeInfo[font];
            if (finfo != undefined)
                return finfo;
            var fontstr = 'bold ' + TextRender.standardFontSize + 'px ' + font;
            if (TextRender.isWan1Wan) {
                this.fontSizeW = this.charRender.getWidth(fontstr, '有') * 1.5;
                this.fontSizeH = TextRender.standardFontSize * 1.5;
                var szinfo = this.fontSizeW << 8 | this.fontSizeH;
                this.fontSizeInfo[font] = szinfo;
                return szinfo;
            }
            TextRender.pixelBBX[0] = TextRender.standardFontSize / 2;
            TextRender.pixelBBX[1] = TextRender.standardFontSize / 2;
            TextRender.pixelBBX[2] = TextRender.standardFontSize;
            TextRender.pixelBBX[3] = TextRender.standardFontSize;
            var orix = 16;
            var oriy = 16;
            var marginr = 16;
            var marginb = 16;
            this.charRender.scale(1, 1);
            TextRender.tmpRI.height = TextRender.standardFontSize;
            this.charRender.fontsz = TextRender.standardFontSize;
            var bmpdt = this.charRender.getCharBmp('g', fontstr, 0, 'red', null, TextRender.tmpRI, orix, oriy, marginr, marginb);
            if (LayaEnv.isConch) {
                bmpdt.data = new Uint8ClampedArray(bmpdt.data);
            }
            this.bmpData32 = new Uint32Array(bmpdt.data.buffer);
            this.updateBbx(bmpdt, TextRender.pixelBBX, false);
            bmpdt = this.charRender.getCharBmp('有', fontstr, 0, 'red', null, TextRender.tmpRI, oriy, oriy, marginr, marginb);
            if (LayaEnv.isConch) {
                bmpdt.data = new Uint8ClampedArray(bmpdt.data);
            }
            this.bmpData32 = new Uint32Array(bmpdt.data.buffer);
            if (TextRender.pixelBBX[2] < orix + TextRender.tmpRI.width)
                TextRender.pixelBBX[2] = orix + TextRender.tmpRI.width;
            this.updateBbx(bmpdt, TextRender.pixelBBX, false);
            if (LayaEnv.isConch) {
                orix = 0;
                oriy = 0;
            }
            var xoff = Math.max(orix - TextRender.pixelBBX[0], 0);
            var yoff = Math.max(oriy - TextRender.pixelBBX[1], 0);
            var bbxw = TextRender.pixelBBX[2] - TextRender.pixelBBX[0];
            var bbxh = TextRender.pixelBBX[3] - TextRender.pixelBBX[1];
            var sizeinfo = xoff << 24 | yoff << 16 | bbxw << 8 | bbxh;
            this.fontSizeInfo[font] = sizeinfo;
            return sizeinfo;
        }
        printDbgInfo() {
            console.log('图集个数:' + this.textAtlases.length + ',每个图集大小:' + TextRender.atlasWidth + 'x' + TextRender.atlasWidth, ' 用canvas:', TextRender.isWan1Wan);
            console.log('图集占用空间:' + (TextRender.atlasWidth * TextRender.atlasWidth * 4 / 1024 / 1024 * this.textAtlases.length) + 'M');
            console.log('缓存用到的字体:');
            for (var f in this.mapFont) {
                var fontsz = this.getFontSizeInfo(f);
                var offx = fontsz >> 24;
                var offy = (fontsz >> 16) & 0xff;
                var fw = (fontsz >> 8) & 0xff;
                var fh = fontsz & 0xff;
                console.log('    ' + f, ' off:', offx, offy, ' size:', fw, fh);
            }
            var num = 0;
            console.log('缓存数据:');
            var totalUsedRate = 0;
            var totalUsedRateAtlas = 0;
            this.textAtlases.forEach(function (a) {
                var id = a.texture.id;
                var dt = RenderInfo.loopCount - a.texture.lastTouchTm;
                var dtstr = dt > 0 ? ('' + dt + '帧以前') : '当前帧';
                totalUsedRate += a.texture.curUsedCovRate;
                totalUsedRateAtlas += a.texture.curUsedCovRateAtlas;
                console.log('--图集(id:' + id + ',当前使用率:' + (a.texture.curUsedCovRate * 1000 | 0) + '‰', '当前图集使用率:', (a.texture.curUsedCovRateAtlas * 100 | 0) + '%', '图集使用率:', (a.usedRate * 100 | 0), '%, 使用于:' + dtstr + ')--:');
                for (var k in a.charMaps) {
                    var ri = a.charMaps[k];
                    console.log('     off:', ri.orix, ri.oriy, ' bmp宽高:', ri.bmpWidth, ri.bmpHeight, '无效:', ri.deleted, 'touchdt:', (RenderInfo.loopCount - ri.touchTick), '位置:', ri.uv[0] * TextRender.atlasWidth | 0, ri.uv[1] * TextRender.atlasWidth | 0, '字符:', ri.char, 'key:', k);
                    num++;
                }
            });
            console.log('独立贴图文字(' + this.isoTextures.length + '个):');
            this.isoTextures.forEach(function (tex) {
                console.log('    size:', tex._texW, tex._texH, 'touch间隔:', (RenderInfo.loopCount - tex.lastTouchTm), 'char:', tex.ri.char);
            });
            console.log('总缓存:', num, '总使用率:', totalUsedRate, '总当前图集使用率:', totalUsedRateAtlas);
        }
        showAtlas(n, bgcolor, x, y, w, h) {
            if (!this.textAtlases[n]) {
                console.log('没有这个图集');
                return null;
            }
            var sp = new Sprite();
            var texttex = this.textAtlases[n].texture;
            var texture = {
                width: TextRender.atlasWidth,
                height: TextRender.atlasWidth,
                sourceWidth: TextRender.atlasWidth,
                sourceHeight: TextRender.atlasWidth,
                offsetX: 0,
                offsetY: 0,
                getIsReady: function () { return true; },
                _addReference: function () { },
                _removeReference: function () { },
                _getSource: function () { return texttex._getSource(); },
                bitmap: { id: texttex.id },
                _uv: Texture.DEF_UV
            };
            sp.size = function (w, h) {
                this.width = w;
                this.height = h;
                sp.graphics.clear();
                sp.graphics.drawRect(0, 0, sp.width, sp.height, bgcolor);
                sp.graphics.drawTexture(texture, 0, 0, sp.width, sp.height);
                return this;
            };
            sp.graphics.drawRect(0, 0, w, h, bgcolor);
            sp.graphics.drawTexture(texture, 0, 0, w, h);
            sp.pos(x, y);
            ILaya.stage.addChild(sp);
            return sp;
        }
        filltext_native(ctx, data, htmlchars, x, y, fontStr, color, strokeColor, lineWidth, textAlign, underLine = 0) {
            if (data && data.length <= 0)
                return;
            if (htmlchars && htmlchars.length < 1)
                return;
            var font = FontInfo.Parse(fontStr);
            var nTextAlign = 0;
            switch (textAlign) {
                case 'center':
                    nTextAlign = Const.ENUM_TEXTALIGN_CENTER;
                    break;
                case 'right':
                    nTextAlign = Const.ENUM_TEXTALIGN_RIGHT;
                    break;
            }
            return this._fast_filltext(ctx, data, htmlchars, x, y, font, color, strokeColor, lineWidth, nTextAlign, underLine);
        }
    }
    TextRender.useOldCharBook = false;
    TextRender.atlasWidth = 1024;
    TextRender.noAtlas = false;
    TextRender.forceSplitRender = false;
    TextRender.forceWholeRender = false;
    TextRender.scaleFontWithCtx = true;
    TextRender.standardFontSize = 32;
    TextRender.destroyAtlasDt = 10;
    TextRender.checkCleanTextureDt = 2000;
    TextRender.destroyUnusedTextureDt = 3000;
    TextRender.cleanMem = 100 * 1024 * 1024;
    TextRender.isWan1Wan = false;
    TextRender.showLog = false;
    TextRender.debugUV = false;
    TextRender.tmpRI = new CharRenderInfo();
    TextRender.pixelBBX = [0, 0, 0, 0];
    TextRender.imgdtRect = [0, 0, 0, 0];
    TextRender.simClean = false;

    class MathUtils3D {
        constructor() {
        }
        static isZero(v) {
            return Math.abs(v) < MathUtils3D.zeroTolerance;
        }
        static nearEqual(n1, n2) {
            if (MathUtils3D.isZero(n1 - n2))
                return true;
            return false;
        }
        static fastInvSqrt(value) {
            if (MathUtils3D.isZero(value))
                return value;
            return 1.0 / Math.sqrt(value);
        }
    }
    MathUtils3D.zeroTolerance = 1e-6;
    MathUtils3D.MaxValue = 3.40282347e+38;
    MathUtils3D.MinValue = -3.40282347e+38;
    MathUtils3D.Deg2Rad = Math.PI / 180;

    class Vector2 {
        constructor(x = 0, y = 0) {
            this.x = x;
            this.y = y;
        }
        setValue(x, y) {
            this.x = x;
            this.y = y;
        }
        static scale(a, b, out) {
            out.x = a.x * b;
            out.y = a.y * b;
        }
        fromArray(array, offset = 0) {
            this.x = array[offset + 0];
            this.y = array[offset + 1];
        }
        toArray() {
            return [this.x, this.y];
        }
        writeTo(array, offset = 0) {
            array[offset + 0] = this.x;
            array[offset + 1] = this.y;
        }
        cloneTo(destObject) {
            var destVector2 = destObject;
            destVector2.x = this.x;
            destVector2.y = this.y;
        }
        static dot(a, b) {
            return (a.x * b.x) + (a.y * b.y);
        }
        static normalize(s, out) {
            var x = s.x, y = s.y;
            var len = x * x + y * y;
            if (len > 0) {
                len = 1 / Math.sqrt(len);
                out.x = x * len;
                out.y = y * len;
            }
        }
        static scalarLength(a) {
            var x = a.x, y = a.y;
            return Math.sqrt(x * x + y * y);
        }
        clone() {
            var destVector2 = new Vector2();
            this.cloneTo(destVector2);
            return destVector2;
        }
        forNativeElement(nativeElements = null) {
            if (nativeElements) {
                this.elements = nativeElements;
                this.elements[0] = this.x;
                this.elements[1] = this.y;
            }
            else {
                this.elements = new Float32Array([this.x, this.y]);
            }
            Vector2.rewriteNumProperty(this, "x", 0);
            Vector2.rewriteNumProperty(this, "y", 1);
        }
        static rewriteNumProperty(proto, name, index) {
            Object["defineProperty"](proto, name, {
                "get": function () {
                    return this.elements[index];
                },
                "set": function (v) {
                    this.elements[index] = v;
                }
            });
        }
    }
    Vector2.ZERO = new Vector2(0.0, 0.0);
    Vector2.ONE = new Vector2(1.0, 1.0);

    class Vector4 {
        constructor(x = 0, y = 0, z = 0, w = 0) {
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
        }
        setValue(x, y, z, w) {
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
        }
        fromArray(arr, offset = 0) {
            this.x = arr[offset + 0];
            this.y = arr[offset + 1];
            this.z = arr[offset + 2];
            this.w = arr[offset + 3];
        }
        toArray() {
            return [this.x, this.y, this.z, this.w];
        }
        writeTo(arr, offset = 0) {
            arr[offset + 0] = this.x;
            arr[offset + 1] = this.y;
            arr[offset + 2] = this.z;
            arr[offset + 3] = this.w;
        }
        cloneTo(destObject) {
            var destVector4 = destObject;
            destVector4.x = this.x;
            destVector4.y = this.y;
            destVector4.z = this.z;
            destVector4.w = this.w;
        }
        clone() {
            var destVector4 = new Vector4();
            this.cloneTo(destVector4);
            return destVector4;
        }
        static lerp(a, b, t, out) {
            var ax = a.x, ay = a.y, az = a.z, aw = a.w;
            out.x = ax + t * (b.x - ax);
            out.y = ay + t * (b.y - ay);
            out.z = az + t * (b.z - az);
            out.w = aw + t * (b.w - aw);
        }
        static transformByM4x4(vector4, m4x4, out) {
            var vx = vector4.x;
            var vy = vector4.y;
            var vz = vector4.z;
            var vw = vector4.w;
            var me = m4x4.elements;
            out.x = vx * me[0] + vy * me[4] + vz * me[8] + vw * me[12];
            out.y = vx * me[1] + vy * me[5] + vz * me[9] + vw * me[13];
            out.z = vx * me[2] + vy * me[6] + vz * me[10] + vw * me[14];
            out.w = vx * me[3] + vy * me[7] + vz * me[11] + vw * me[15];
        }
        static equals(a, b) {
            return MathUtils3D.nearEqual(Math.abs(a.x), Math.abs(b.x)) && MathUtils3D.nearEqual(Math.abs(a.y), Math.abs(b.y)) && MathUtils3D.nearEqual(Math.abs(a.z), Math.abs(b.z)) && MathUtils3D.nearEqual(Math.abs(a.w), Math.abs(b.w));
        }
        equal(value) {
            return Vector4.equals(this, value);
        }
        length() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
        }
        lengthSquared() {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
        }
        static normalize(s, out) {
            var len = s.length();
            if (len > 0) {
                var inverse = 1.0 / len;
                out.x = s.x * inverse;
                out.y = s.y * inverse;
                out.z = s.z * inverse;
                out.w = s.w * inverse;
            }
        }
        static add(a, b, out) {
            out.x = a.x + b.x;
            out.y = a.y + b.y;
            out.z = a.z + b.z;
            out.w = a.w + b.w;
        }
        static subtract(a, b, out) {
            out.x = a.x - b.x;
            out.y = a.y - b.y;
            out.z = a.z - b.z;
            out.w = a.w - b.w;
        }
        static multiply(a, b, out) {
            out.x = a.x * b.x;
            out.y = a.y * b.y;
            out.z = a.z * b.z;
            out.w = a.w * b.w;
        }
        static scale(a, b, out) {
            out.x = a.x * b;
            out.y = a.y * b;
            out.z = a.z * b;
            out.w = a.w * b;
        }
        static Clamp(value, min, max, out) {
            var x = value.x;
            var y = value.y;
            var z = value.z;
            var w = value.w;
            var mineX = min.x;
            var mineY = min.y;
            var mineZ = min.z;
            var mineW = min.w;
            var maxeX = max.x;
            var maxeY = max.y;
            var maxeZ = max.z;
            var maxeW = max.w;
            x = (x > maxeX) ? maxeX : x;
            x = (x < mineX) ? mineX : x;
            y = (y > maxeY) ? maxeY : y;
            y = (y < mineY) ? mineY : y;
            z = (z > maxeZ) ? maxeZ : z;
            z = (z < mineZ) ? mineZ : z;
            w = (w > maxeW) ? maxeW : w;
            w = (w < mineW) ? mineW : w;
            out.x = x;
            out.y = y;
            out.z = z;
            out.w = w;
        }
        static distanceSquared(value1, value2) {
            var x = value1.x - value2.x;
            var y = value1.y - value2.y;
            var z = value1.z - value2.z;
            var w = value1.w - value2.w;
            return (x * x) + (y * y) + (z * z) + (w * w);
        }
        static distance(value1, value2) {
            var x = value1.x - value2.x;
            var y = value1.y - value2.y;
            var z = value1.z - value2.z;
            var w = value1.w - value2.w;
            return Math.sqrt((x * x) + (y * y) + (z * z) + (w * w));
        }
        static dot(a, b) {
            return (a.x * b.x) + (a.y * b.y) + (a.z * b.z) + (a.w * b.w);
        }
        static min(a, b, out) {
            out.x = Math.min(a.x, b.x);
            out.y = Math.min(a.y, b.y);
            out.z = Math.min(a.z, b.z);
            out.w = Math.min(a.w, b.w);
        }
        static max(a, b, out) {
            out.x = Math.max(a.x, b.x);
            out.y = Math.max(a.y, b.y);
            out.z = Math.max(a.z, b.z);
            out.w = Math.max(a.w, b.w);
        }
        forNativeElement(nativeElements = null) {
            if (nativeElements) {
                this.elements = nativeElements;
                this.elements[0] = this.x;
                this.elements[1] = this.y;
                this.elements[2] = this.z;
                this.elements[3] = this.w;
            }
            else {
                this.elements = new Float32Array([this.x, this.y, this.z, this.w]);
            }
            Vector2.rewriteNumProperty(this, "x", 0);
            Vector2.rewriteNumProperty(this, "y", 1);
            Vector2.rewriteNumProperty(this, "z", 2);
            Vector2.rewriteNumProperty(this, "w", 3);
        }
    }
    Vector4.ZERO = new Vector4();
    Vector4.ONE = new Vector4(1.0, 1.0, 1.0, 1.0);
    Vector4.UnitX = new Vector4(1.0, 0.0, 0.0, 0.0);
    Vector4.UnitY = new Vector4(0.0, 1.0, 0.0, 0.0);
    Vector4.UnitZ = new Vector4(0.0, 0.0, 1.0, 0.0);
    Vector4.UnitW = new Vector4(0.0, 0.0, 0.0, 1.0);
    Vector4.tempVec4 = new Vector4(0.0, 0.0, 0.0, 0.0);

    class Vector3 {
        constructor(x = 0, y = 0, z = 0) {
            this.x = x;
            this.y = y;
            this.z = z;
        }
        static distanceSquared(value1, value2) {
            var x = value1.x - value2.x;
            var y = value1.y - value2.y;
            var z = value1.z - value2.z;
            return (x * x) + (y * y) + (z * z);
        }
        static distance(value1, value2) {
            var x = value1.x - value2.x;
            var y = value1.y - value2.y;
            var z = value1.z - value2.z;
            return Math.sqrt((x * x) + (y * y) + (z * z));
        }
        static min(a, b, out) {
            out.x = Math.min(a.x, b.x);
            out.y = Math.min(a.y, b.y);
            out.z = Math.min(a.z, b.z);
        }
        static max(a, b, out) {
            out.x = Math.max(a.x, b.x);
            out.y = Math.max(a.y, b.y);
            out.z = Math.max(a.z, b.z);
        }
        static transformQuat(source, rotation, out) {
            var x = source.x, y = source.y, z = source.z, qx = rotation.x, qy = rotation.y, qz = rotation.z, qw = rotation.w, ix = qw * x + qy * z - qz * y, iy = qw * y + qz * x - qx * z, iz = qw * z + qx * y - qy * x, iw = -qx * x - qy * y - qz * z;
            out.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
            out.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
            out.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
        }
        static scalarLength(a) {
            var x = a.x, y = a.y, z = a.z;
            return Math.sqrt(x * x + y * y + z * z);
        }
        static scalarLengthSquared(a) {
            var x = a.x, y = a.y, z = a.z;
            return x * x + y * y + z * z;
        }
        static normalize(s, out) {
            var x = s.x, y = s.y, z = s.z;
            var len = x * x + y * y + z * z;
            if (len > 0) {
                len = 1 / Math.sqrt(len);
                out.x = x * len;
                out.y = y * len;
                out.z = z * len;
            }
        }
        static multiply(a, b, out) {
            out.x = a.x * b.x;
            out.y = a.y * b.y;
            out.z = a.z * b.z;
        }
        static scale(a, b, out) {
            out.x = a.x * b;
            out.y = a.y * b;
            out.z = a.z * b;
        }
        static lerp(a, b, t, out) {
            var ax = a.x, ay = a.y, az = a.z;
            out.x = ax + t * (b.x - ax);
            out.y = ay + t * (b.y - ay);
            out.z = az + t * (b.z - az);
        }
        static transformV3ToV3(vector, transform, result) {
            var intermediate = Vector3._tempVector4;
            Vector3.transformV3ToV4(vector, transform, intermediate);
            result.x = intermediate.x;
            result.y = intermediate.y;
            result.z = intermediate.z;
        }
        static transformV3ToV4(vector, transform, result) {
            var vectorX = vector.x;
            var vectorY = vector.y;
            var vectorZ = vector.z;
            var transformElem = transform.elements;
            result.x = (vectorX * transformElem[0]) + (vectorY * transformElem[4]) + (vectorZ * transformElem[8]) + transformElem[12];
            result.y = (vectorX * transformElem[1]) + (vectorY * transformElem[5]) + (vectorZ * transformElem[9]) + transformElem[13];
            result.z = (vectorX * transformElem[2]) + (vectorY * transformElem[6]) + (vectorZ * transformElem[10]) + transformElem[14];
            result.w = (vectorX * transformElem[3]) + (vectorY * transformElem[7]) + (vectorZ * transformElem[11]) + transformElem[15];
        }
        static TransformNormal(normal, transform, result) {
            var normalX = normal.x;
            var normalY = normal.y;
            var normalZ = normal.z;
            var transformElem = transform.elements;
            result.x = (normalX * transformElem[0]) + (normalY * transformElem[4]) + (normalZ * transformElem[8]);
            result.y = (normalX * transformElem[1]) + (normalY * transformElem[5]) + (normalZ * transformElem[9]);
            result.z = (normalX * transformElem[2]) + (normalY * transformElem[6]) + (normalZ * transformElem[10]);
        }
        static transformCoordinate(coordinate, transform, result) {
            var coordinateX = coordinate.x;
            var coordinateY = coordinate.y;
            var coordinateZ = coordinate.z;
            var transformElem = transform.elements;
            var w = coordinateX * transformElem[3] + coordinateY * transformElem[7] + coordinateZ * transformElem[11] + transformElem[15];
            result.x = (coordinateX * transformElem[0] + coordinateY * transformElem[4] + coordinateZ * transformElem[8] + transformElem[12]) / w;
            result.y = (coordinateX * transformElem[1] + coordinateY * transformElem[5] + coordinateZ * transformElem[9] + transformElem[13]) / w;
            result.z = (coordinateX * transformElem[2] + coordinateY * transformElem[6] + coordinateZ * transformElem[10] + transformElem[14]) / w;
        }
        static Clamp(value, min, max, out) {
            var x = value.x;
            var y = value.y;
            var z = value.z;
            var mineX = min.x;
            var mineY = min.y;
            var mineZ = min.z;
            var maxeX = max.x;
            var maxeY = max.y;
            var maxeZ = max.z;
            x = (x > maxeX) ? maxeX : x;
            x = (x < mineX) ? mineX : x;
            y = (y > maxeY) ? maxeY : y;
            y = (y < mineY) ? mineY : y;
            z = (z > maxeZ) ? maxeZ : z;
            z = (z < mineZ) ? mineZ : z;
            out.x = x;
            out.y = y;
            out.z = z;
        }
        static add(a, b, out) {
            out.x = a.x + b.x;
            out.y = a.y + b.y;
            out.z = a.z + b.z;
        }
        static subtract(a, b, o) {
            o.x = a.x - b.x;
            o.y = a.y - b.y;
            o.z = a.z - b.z;
        }
        static cross(a, b, o) {
            var ax = a.x, ay = a.y, az = a.z, bx = b.x, by = b.y, bz = b.z;
            o.x = ay * bz - az * by;
            o.y = az * bx - ax * bz;
            o.z = ax * by - ay * bx;
        }
        static dot(a, b) {
            return (a.x * b.x) + (a.y * b.y) + (a.z * b.z);
        }
        static equals(a, b) {
            return MathUtils3D.nearEqual(a.x, b.x) && MathUtils3D.nearEqual(a.y, b.y) && MathUtils3D.nearEqual(a.z, b.z);
        }
        equal(value) {
            return Vector3.equals(this, value);
        }
        setValue(x, y, z) {
            this.x = x;
            this.y = y;
            this.z = z;
            return this;
        }
        set(x, y, z) {
            this.x = x;
            this.y = y;
            this.z = z;
            return this;
        }
        fromArray(arr, offset = 0) {
            this.x = arr[offset + 0];
            this.y = arr[offset + 1];
            this.z = arr[offset + 2];
        }
        toArray() {
            return [this.x, this.y, this.z];
        }
        writeTo(arr, offset = 0) {
            arr[offset + 0] = this.x;
            arr[offset + 1] = this.y;
            arr[offset + 2] = this.z;
        }
        length() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        }
        lengthSquared() {
            return this.x * this.x + this.y * this.y + this.z * this.z;
        }
        vsub(b, out) {
            out.x = this.x - b.x;
            out.y = this.y - b.y;
            out.z = this.z - b.z;
            return out;
        }
        vadd(b, out) {
            out.x = this.x + b.x;
            out.y = this.y + b.y;
            out.z = this.z + b.z;
            return out;
        }
        scale(s, out) {
            out.x = this.x * s;
            out.y = this.y * s;
            out.z = this.z * s;
            return out;
        }
        normalize() {
            let x = this.x, y = this.y, z = this.z;
            var len = x * x + y * y + z * z;
            if (len > 0) {
                len = 1 / Math.sqrt(len);
                this.x = x * len;
                this.y = y * len;
                this.z = z * len;
            }
            return this;
        }
        dot(b) {
            return (this.x * b.x) + (this.y * b.y) + (this.z * b.z);
        }
        cross(b, o) {
            var ax = this.x, ay = this.y, az = this.z, bx = b.x, by = b.y, bz = b.z;
            o.x = ay * bz - az * by;
            o.y = az * bx - ax * bz;
            o.z = ax * by - ay * bx;
            return o;
        }
        cloneTo(destObject) {
            var destVector3 = destObject;
            destVector3.x = this.x;
            destVector3.y = this.y;
            destVector3.z = this.z;
        }
        clone() {
            var destVector3 = new Vector3();
            this.cloneTo(destVector3);
            return destVector3;
        }
        toDefault() {
            this.x = 0;
            this.y = 0;
            this.z = 0;
        }
    }
    Vector3._tempVector4 = new Vector4();
    Vector3.ZERO = new Vector3(0.0, 0.0, 0.0);
    Vector3.ONE = new Vector3(1.0, 1.0, 1.0);
    Vector3.NegativeUnitX = new Vector3(-1, 0, 0);
    Vector3.UnitX = new Vector3(1, 0, 0);
    Vector3.UnitY = new Vector3(0, 1, 0);
    Vector3.UnitZ = new Vector3(0, 0, 1);
    Vector3.ForwardRH = new Vector3(0, 0, -1);
    Vector3.ForwardLH = new Vector3(0, 0, 1);
    Vector3.Up = new Vector3(0, 1, 0);

    class Config3D {
        static setResolution(width, height) {
            Config3D.customResolution = true;
            Config3D._resoluWidth = width;
            Config3D._resoluHeight = height;
        }
    }
    Config3D.enableDynamicBatch = true;
    Config3D.enableStaticBatch = true;
    Config3D.enableUniformBufferObject = true;
    Config3D.pixelRatio = 1;
    Config3D.customResolution = false;
    Config3D.defaultCacheRTMemory = 256;
    Config3D.defaultPhysicsMemory = 16;
    Config3D.enableMultiLight = true;
    Config3D.maxLightCount = 32;
    Config3D.lightClusterCount = new Vector3(12, 12, 12);
    Config3D.useBVHCull = false;
    Config3D.BVH_max_SpatialCount = 7;
    Config3D.BVH_limit_size = 32;
    Config3D.BVH_Min_Build_nums = 10;
    Config3D._resoluWidth = -1;
    Config3D._resoluHeight = -1;
    Config3D.debugFrustumCulling = false;
    Config.isStencil = true;

    class RenderTexture extends BaseTexture {
        constructor(width, height, colorFormat, depthFormat, generateMipmap = false, multiSamples = 1, generateDepthTexture = false, sRGB = false) {
            super(width, height, colorFormat);
            this._inPool = false;
            this._isCameraTarget = false;
            this._generateDepthTexture = false;
            this._gammaSpace = sRGB;
            this._depthStencilFormat = (depthFormat == null ? exports.RenderTargetFormat.None : depthFormat);
            this._generateMipmap = generateMipmap;
            this._multiSamples = multiSamples;
            this._generateDepthTexture = generateDepthTexture;
            this._createRenderTarget();
        }
        static get currentActive() {
            return RenderTexture._currentActive;
        }
        static configRenderContextInstance(value) {
            RenderTexture._configInstance = value;
        }
        static createFromPool(width, height, colorFormat, depthFormat, mipmap = false, multiSamples = 1, depthTexture = false, sRGB = false) {
            mipmap = mipmap && (width & (width - 1)) === 0 && (height & (height - 1)) === 0;
            let n = RenderTexture._pool.length;
            for (let index = 0; index < n; index++) {
                let rt = RenderTexture._pool[index];
                if (rt.width == width && rt.height == height && rt.colorFormat == colorFormat && rt.depthStencilFormat == depthFormat && rt._generateMipmap == mipmap && rt.multiSamples == multiSamples && rt.generateDepthTexture == depthTexture && rt._gammaSpace == sRGB) {
                    rt._inPool = false;
                    let end = RenderTexture._pool[n - 1];
                    RenderTexture._pool[index] = end;
                    RenderTexture._pool.length -= 1;
                    RenderTexture._poolMemory -= (rt._renderTarget.gpuMemory / 1024 / 1024);
                    return rt;
                }
            }
            let rt = new RenderTexture(width, height, colorFormat, depthFormat, mipmap, multiSamples, depthTexture, sRGB);
            rt.lock = true;
            return rt;
        }
        static recoverToPool(rt) {
            if (rt._inPool || rt.destroyed)
                return;
            RenderTexture._pool.push(rt);
            RenderTexture._poolMemory += (rt._renderTarget.gpuMemory / 1024 / 1024);
            rt._inPool = true;
        }
        static clearPool() {
            if (RenderTexture._poolMemory < Config3D.defaultCacheRTMemory) {
                return;
            }
            for (var i in RenderTexture._pool) {
                RenderTexture._pool[i].destroy();
            }
            RenderTexture._pool = [];
            RenderTexture._poolMemory = 0;
        }
        static get bindCanvasRender() {
            return RenderTexture._bindCanvasRender;
        }
        static set bindCanvasRender(value) {
            if (value != this._bindCanvasRender)
                this._bindCanvasRender = value;
        }
        get generateDepthTexture() {
            return this._generateDepthTexture;
        }
        set generateDepthTexture(value) {
            if (value && !this._depthStencilTexture) {
                this._depthStencilTexture = new BaseTexture(this.width, this.height, this.depthStencilFormat);
                this._depthStencilTexture._dimension = exports.TextureDimension.Tex2D;
                this._depthStencilTexture._texture = LayaGL.textureContext.createRenderTextureInternal(exports.TextureDimension.Tex2D, this.width, this.height, this.depthStencilFormat, false, false);
                LayaGL.textureContext.setupRendertargetTextureAttachment(this._renderTarget, this._depthStencilTexture._texture);
            }
            this._generateDepthTexture = value;
        }
        get depthStencilTexture() {
            return this._depthStencilTexture;
        }
        get colorFormat() {
            return this._renderTarget.colorFormat;
        }
        get depthStencilFormat() {
            return this._renderTarget.depthStencilFormat;
        }
        get multiSamples() {
            return this._renderTarget._samples;
        }
        get isCube() {
            return this._renderTarget._isCube;
        }
        get samples() {
            return this._renderTarget._samples;
        }
        get generateMipmap() {
            return this._renderTarget._generateMipmap;
        }
        _createRenderTarget() {
            this._dimension = exports.TextureDimension.Tex2D;
            this._renderTarget = LayaGL.textureContext.createRenderTargetInternal(this.width, this.height, this._format, this._depthStencilFormat, this._generateMipmap, this._gammaSpace, this._multiSamples);
            this._generateMipmap = this._renderTarget._generateMipmap;
            this._texture = this._renderTarget._textures[0];
            this.generateDepthTexture = this._generateDepthTexture;
        }
        recreate(width, height, colorFormat, depthFormat, generateMipmap = false, multiSamples = 1, generateDepthTexture = false, sRGB = false) {
            this._width = width;
            this._height = height;
            this._format = colorFormat;
            this._gammaSpace = sRGB;
            this._depthStencilFormat = (depthFormat == null ? exports.RenderTargetFormat.None : depthFormat);
            this._generateMipmap = generateMipmap;
            this._multiSamples = multiSamples;
            this._generateDepthTexture = generateDepthTexture;
            this._disposeResource();
            this._createRenderTarget();
        }
        _start() {
            RenderTexture._configInstance.invertY = this._isCameraTarget;
            if (RenderTexture._currentActive != this) {
                RenderTexture._currentActive && RenderTexture._currentActive._end();
                RenderTexture._currentActive = this;
                LayaGL.textureContext.bindRenderTarget(this._renderTarget);
            }
        }
        _end() {
            RenderTexture._currentActive = null;
            LayaGL.textureContext.unbindRenderTarget(this._renderTarget);
            (this._isCameraTarget) && (RenderTexture._configInstance.invertY = false);
        }
        getData(xOffset, yOffset, width, height, out) {
            LayaGL.textureContext.readRenderTargetPixelData(this._renderTarget, xOffset, yOffset, width, height, out);
            return out;
        }
        _disposeResource() {
            var _a;
            if (RenderTexture._currentActive == this) {
                this._end();
            }
            this._renderTarget.dispose();
            this._renderTarget = null;
            (_a = this._depthStencilTexture) === null || _a === void 0 ? void 0 : _a.destroy();
            this._depthStencilTexture = null;
        }
    }
    RenderTexture._currentActive = null;
    RenderTexture._configInstance = {};
    RenderTexture._pool = [];
    RenderTexture._poolMemory = 0;

    var CONTEXT2D_FUNCTION_ID;
    (function (CONTEXT2D_FUNCTION_ID) {
        CONTEXT2D_FUNCTION_ID[CONTEXT2D_FUNCTION_ID["SIZE"] = 0] = "SIZE";
        CONTEXT2D_FUNCTION_ID[CONTEXT2D_FUNCTION_ID["CLEAR"] = 1] = "CLEAR";
        CONTEXT2D_FUNCTION_ID[CONTEXT2D_FUNCTION_ID["SAVE"] = 2] = "SAVE";
        CONTEXT2D_FUNCTION_ID[CONTEXT2D_FUNCTION_ID["TRANSFORM"] = 3] = "TRANSFORM";
        CONTEXT2D_FUNCTION_ID[CONTEXT2D_FUNCTION_ID["ALPHA"] = 4] = "ALPHA";
        CONTEXT2D_FUNCTION_ID[CONTEXT2D_FUNCTION_ID["RESTORE"] = 5] = "RESTORE";
        CONTEXT2D_FUNCTION_ID[CONTEXT2D_FUNCTION_ID["FILL_STYLE"] = 6] = "FILL_STYLE";
        CONTEXT2D_FUNCTION_ID[CONTEXT2D_FUNCTION_ID["FILL_RECT"] = 7] = "FILL_RECT";
        CONTEXT2D_FUNCTION_ID[CONTEXT2D_FUNCTION_ID["STROKE_STYLE"] = 8] = "STROKE_STYLE";
        CONTEXT2D_FUNCTION_ID[CONTEXT2D_FUNCTION_ID["LINE_WIDTH"] = 9] = "LINE_WIDTH";
        CONTEXT2D_FUNCTION_ID[CONTEXT2D_FUNCTION_ID["STROKE_RECT"] = 10] = "STROKE_RECT";
        CONTEXT2D_FUNCTION_ID[CONTEXT2D_FUNCTION_ID["FILL_WORD_TEXT"] = 11] = "FILL_WORD_TEXT";
        CONTEXT2D_FUNCTION_ID[CONTEXT2D_FUNCTION_ID["DRAW_TEXTURE_SIZE_GRID"] = 12] = "DRAW_TEXTURE_SIZE_GRID";
        CONTEXT2D_FUNCTION_ID[CONTEXT2D_FUNCTION_ID["DRAW_TEXTURE"] = 13] = "DRAW_TEXTURE";
        CONTEXT2D_FUNCTION_ID[CONTEXT2D_FUNCTION_ID["CLIP_RECT"] = 14] = "CLIP_RECT";
        CONTEXT2D_FUNCTION_ID[CONTEXT2D_FUNCTION_ID["DRAW_LINE"] = 15] = "DRAW_LINE";
        CONTEXT2D_FUNCTION_ID[CONTEXT2D_FUNCTION_ID["DRAW_LINES"] = 16] = "DRAW_LINES";
        CONTEXT2D_FUNCTION_ID[CONTEXT2D_FUNCTION_ID["SCALE"] = 17] = "SCALE";
        CONTEXT2D_FUNCTION_ID[CONTEXT2D_FUNCTION_ID["TRANSLATE"] = 18] = "TRANSLATE";
        CONTEXT2D_FUNCTION_ID[CONTEXT2D_FUNCTION_ID["ROTATE"] = 19] = "ROTATE";
        CONTEXT2D_FUNCTION_ID[CONTEXT2D_FUNCTION_ID["DRAW_CIRCLE"] = 20] = "DRAW_CIRCLE";
        CONTEXT2D_FUNCTION_ID[CONTEXT2D_FUNCTION_ID["DRAW_PIE"] = 21] = "DRAW_PIE";
        CONTEXT2D_FUNCTION_ID[CONTEXT2D_FUNCTION_ID["DRAW_POLY"] = 22] = "DRAW_POLY";
        CONTEXT2D_FUNCTION_ID[CONTEXT2D_FUNCTION_ID["DRAW_CURVES"] = 23] = "DRAW_CURVES";
        CONTEXT2D_FUNCTION_ID[CONTEXT2D_FUNCTION_ID["BEGIN_PATH"] = 24] = "BEGIN_PATH";
        CONTEXT2D_FUNCTION_ID[CONTEXT2D_FUNCTION_ID["MOVE_TO"] = 25] = "MOVE_TO";
        CONTEXT2D_FUNCTION_ID[CONTEXT2D_FUNCTION_ID["LINE_TO"] = 26] = "LINE_TO";
        CONTEXT2D_FUNCTION_ID[CONTEXT2D_FUNCTION_ID["ARC_TO"] = 27] = "ARC_TO";
        CONTEXT2D_FUNCTION_ID[CONTEXT2D_FUNCTION_ID["CLOSE_PATH"] = 28] = "CLOSE_PATH";
        CONTEXT2D_FUNCTION_ID[CONTEXT2D_FUNCTION_ID["FILL"] = 29] = "FILL";
        CONTEXT2D_FUNCTION_ID[CONTEXT2D_FUNCTION_ID["STROKE"] = 30] = "STROKE";
        CONTEXT2D_FUNCTION_ID[CONTEXT2D_FUNCTION_ID["SET_AS_BITMAP"] = 31] = "SET_AS_BITMAP";
        CONTEXT2D_FUNCTION_ID[CONTEXT2D_FUNCTION_ID["DRAW_MASKED"] = 32] = "DRAW_MASKED";
        CONTEXT2D_FUNCTION_ID[CONTEXT2D_FUNCTION_ID["DRAW_TRANGLES"] = 33] = "DRAW_TRANGLES";
        CONTEXT2D_FUNCTION_ID[CONTEXT2D_FUNCTION_ID["SET_GLOBAL_COMPOSITE_OPERTAION"] = 34] = "SET_GLOBAL_COMPOSITE_OPERTAION";
        CONTEXT2D_FUNCTION_ID[CONTEXT2D_FUNCTION_ID["FILL_WORDS"] = 35] = "FILL_WORDS";
    })(CONTEXT2D_FUNCTION_ID || (CONTEXT2D_FUNCTION_ID = {}));
    class NativeContext {
        constructor() {
            this._byteLen = 0;
            this.sprite = null;
            this._renderObject3DList = [];
            this._tmpMatrix = new Matrix();
            this._nativeObj = new window._conchContext(LayaGL.renderEngine._nativeObj);
            this._byteLen = 1024 * 512;
            this._tempRenderTexture2D = new NativeRenderTexture2D(0, 0, exports.RenderTargetFormat.R8G8B8A8, exports.RenderTargetFormat.None, false);
            this._init(false);
        }
        static __init__() {
        }
        _init(isSyncToRenderThread) {
            this._buffer = new ArrayBuffer(this._byteLen);
            this._idata = new Int32Array(this._buffer);
            this._fdata = new Float32Array(this._buffer);
            this._byteArray = new Uint8Array(this._buffer);
            var bufferConchRef = window.webglPlus.createArrayBufferRef(this._buffer, NativeContext.ARRAY_BUFFER_TYPE_CMD, isSyncToRenderThread, NativeContext.ARRAY_BUFFER_REF_REFERENCE);
            this._nativeObj.setSharedCommandBuffer(bufferConchRef);
            this._idata[0] = 1;
        }
        _need(sz) {
            if ((this._byteLen - (this._idata[0] << 2)) >= sz)
                return;
            this._nativeObj.flushCommand();
            if (sz > this._byteLen) {
                throw "too big";
            }
        }
        get lineJoin() {
            return '';
        }
        set lineJoin(value) {
        }
        get lineCap() {
            return '';
        }
        set lineCap(value) {
        }
        get miterLimit() {
            return '';
        }
        set miterLimit(value) {
        }
        clearRect(x, y, width, height) {
        }
        set isMain(value) {
            this._nativeObj.flushCommand();
            this._nativeObj.isMain = value;
        }
        get isMain() {
            this._nativeObj.flushCommand();
            return this._nativeObj.isMain;
        }
        set _targets(target) {
            if (target) {
                this._nativeObj.flushCommand();
                this._nativeObj._target = target._nativeObj;
            }
        }
        get _targets() {
            this._nativeObj.flushCommand();
            let target = this._nativeObj._target;
            if (target) {
                this._tempRenderTexture2D.width = this._nativeObj.width;
                this._tempRenderTexture2D.height = this._nativeObj.height;
                this._tempRenderTexture2D._nativeObj = target;
                this._tempRenderTexture2D._renderTarget = target._renderTarget;
                this._tempRenderTexture2D._texture = target._renderTarget._textures[0];
                return this._tempRenderTexture2D;
            }
            return null;
        }
        alpha(value) {
            this.globalAlpha *= value;
        }
        flush() {
            BufferState._curBindedBufferState && BufferState._curBindedBufferState.unBind();
            this._nativeObj.flushCommand();
            this._nativeObj.flush();
        }
        clear() {
            this.add_i(CONTEXT2D_FUNCTION_ID.CLEAR);
            this._nativeObj.flushCommand();
            this._renderObject3DList.length = 0;
        }
        destroy(keepRT = false) {
            this._nativeObj.flushCommand();
            if (this._tempRenderTexture2D._nativeObj) {
                this._tempRenderTexture2D._nativeObj._deleteRT = keepRT;
            }
            this._nativeObj.destroy(keepRT);
        }
        static set2DRenderConfig() {
            if (!NativeContext.const2DRenderCMD) {
                const cmd = NativeContext.const2DRenderCMD = LayaGL.renderEngine.createRenderStateComand();
                cmd.addCMD(exports.RenderStateType.BlendType, true);
                cmd.addCMD(exports.RenderStateType.BlendEquation, exports.BlendEquationSeparate.ADD);
                BlendMode.activeBlendFunction = null;
                cmd.addCMD(exports.RenderStateType.BlendFunc, [exports.BlendFactor.One, exports.BlendFactor.OneMinusSourceAlpha]);
                cmd.addCMD(exports.RenderStateType.DepthTest, false);
                cmd.addCMD(exports.RenderStateType.DepthMask, true);
                cmd.addCMD(exports.RenderStateType.CullFace, false);
                cmd.addCMD(exports.RenderStateType.FrontFace, exports.CullMode.Front);
            }
            NativeContext.const2DRenderCMD.applyCMD();
            RenderTexture.currentActive && RenderTexture.currentActive._end();
            window.set2DRenderConfig();
            BufferState._curBindedBufferState && BufferState._curBindedBufferState.unBind();
        }
        set globalCompositeOperation(value) {
            this.add_i_String(CONTEXT2D_FUNCTION_ID.SET_GLOBAL_COMPOSITE_OPERTAION, value);
        }
        get globalCompositeOperation() {
            this._nativeObj.flushCommand();
            return this._nativeObj.globalCompositeOperation;
        }
        set fillStyle(value) {
            var c = ColorUtils.create(value);
            this.add_ii(CONTEXT2D_FUNCTION_ID.FILL_STYLE, c.numColor);
        }
        get fillStyle() {
            this._nativeObj.flushCommand();
            return this._nativeObj.fillStyle;
        }
        set globalAlpha(value) {
            this.add_if(CONTEXT2D_FUNCTION_ID.ALPHA, value);
        }
        get globalAlpha() {
            this._nativeObj.flushCommand();
            return this._nativeObj.globalAlpha;
        }
        save() {
            this.add_i(CONTEXT2D_FUNCTION_ID.SAVE);
        }
        restore() {
            this.add_i(CONTEXT2D_FUNCTION_ID.RESTORE);
        }
        saveTransform(matrix) {
            this.add_i(CONTEXT2D_FUNCTION_ID.SAVE);
        }
        transformByMatrix(matrix, tx, ty) {
            this.add_iffffff(CONTEXT2D_FUNCTION_ID.TRANSFORM, matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx + tx, matrix.ty + ty);
        }
        restoreTransform(matrix) {
            this.add_i(CONTEXT2D_FUNCTION_ID.RESTORE);
        }
        clipRect(x, y, width, height) {
            this.add_iffff(CONTEXT2D_FUNCTION_ID.CLIP_RECT, x, y, width, height);
        }
        transform(a, b, c, d, tx, ty) {
            this.add_iffffff(CONTEXT2D_FUNCTION_ID.TRANSFORM, a, b, c, d, tx, ty);
        }
        scale(scaleX, scaleY) {
            this.add_iff(CONTEXT2D_FUNCTION_ID.SCALE, scaleX, scaleY);
        }
        drawTexture(tex, x, y, width, height) {
            if (!this.checkTexture(tex)) {
                return;
            }
            this.add_iiffffffffffff(CONTEXT2D_FUNCTION_ID.DRAW_TEXTURE, tex.bitmap._texture.id, x, y, width, height, tex.uv[0], tex.uv[1], tex.uv[2], tex.uv[3], tex.uv[4], tex.uv[5], tex.uv[6], tex.uv[7]);
        }
        drawTextureWithTransform(tex, x, y, width, height, transform, tx, ty, alpha, blendMode, colorfilter = null, uv) {
            if (!this.checkTexture(tex)) {
                return;
            }
            this.save();
            this.alpha(alpha);
            var uvs = uv || tex.uv;
            if (transform) {
                this.add_iffffff(CONTEXT2D_FUNCTION_ID.TRANSFORM, transform.a, transform.b, transform.c, transform.d, transform.tx + tx, transform.ty + ty);
                this.add_iiffffffffffff(CONTEXT2D_FUNCTION_ID.DRAW_TEXTURE, tex.bitmap._texture.id, x, y, width || tex.width, height || tex.height, uvs[0], uvs[1], uvs[2], uvs[3], uvs[4], uvs[5], uvs[6], uvs[7]);
            }
            else {
                this.add_iiffffffffffff(CONTEXT2D_FUNCTION_ID.DRAW_TEXTURE, tex.bitmap._texture.id, x + tx, y + ty, width || tex.width, height || tex.height, uvs[0], uvs[1], uvs[2], uvs[3], uvs[4], uvs[5], uvs[6], uvs[7]);
            }
            this.restore();
        }
        drawTextureWithSizeGrid(tex, tx, ty, width, height, sizeGrid, gx, gy) {
            if (!this.checkTexture(tex)) {
                return;
            }
            var uv = tex.uv; tex.bitmap.width; tex.bitmap.height;
            var top = sizeGrid[0];
            var left = sizeGrid[3];
            var right = sizeGrid[1];
            var bottom = sizeGrid[2];
            var repeat = sizeGrid[4];
            this.add_iiffffffffiffffffffff(CONTEXT2D_FUNCTION_ID.DRAW_TEXTURE_SIZE_GRID, tex.bitmap._texture.id, tx, ty, width, height, top, right, bottom, left, repeat ? 1 : 0, gx, gy, uv[0], uv[1], uv[2], uv[3], uv[4], uv[5], uv[6], uv[7]);
        }
        _drawTextureM(tex, x, y, width, height, transform, alpha, uv) {
            if (!this.checkTexture(tex)) {
                return;
            }
            this.save();
            this.alpha(alpha);
            if (transform) {
                this.add_iffffff(CONTEXT2D_FUNCTION_ID.TRANSFORM, transform.a, transform.b, transform.c, transform.d, transform.tx, transform.ty);
            }
            var uvs = uv || tex.uv;
            this.add_iiffffffffffff(CONTEXT2D_FUNCTION_ID.DRAW_TEXTURE, tex.bitmap._texture.id, x, y, width || tex.width, height || tex.height, uvs[0], uvs[1], uvs[2], uvs[3], uvs[4], uvs[5], uvs[6], uvs[7]);
            this.restore();
        }
        translate(x, y) {
            this.add_iff(CONTEXT2D_FUNCTION_ID.TRANSLATE, x, y);
        }
        _transform(mat, pivotX, pivotY) {
            this.add_iff(CONTEXT2D_FUNCTION_ID.TRANSLATE, pivotX, pivotY);
            this.add_iffffff(CONTEXT2D_FUNCTION_ID.TRANSFORM, mat.a, mat.b, mat.c, mat.d, mat.tx, mat.ty);
            this.add_iff(CONTEXT2D_FUNCTION_ID.TRANSLATE, -pivotX, -pivotY);
        }
        _rotate(angle, pivotX, pivotY) {
            this.add_iff(CONTEXT2D_FUNCTION_ID.TRANSLATE, pivotX, pivotY);
            this.add_if(CONTEXT2D_FUNCTION_ID.ROTATE, angle);
            this.add_iff(CONTEXT2D_FUNCTION_ID.TRANSLATE, -pivotX, -pivotY);
        }
        _scale(scaleX, scaleY, pivotX, pivotY) {
            this.add_iff(CONTEXT2D_FUNCTION_ID.TRANSLATE, pivotX, pivotY);
            this.add_iff(CONTEXT2D_FUNCTION_ID.SCALE, scaleX, scaleY);
            this.add_iff(CONTEXT2D_FUNCTION_ID.TRANSLATE, -pivotX, -pivotY);
        }
        _drawLine(x, y, fromX, fromY, toX, toY, lineColor, lineWidth, vid) {
            var c1 = ColorUtils.create(lineColor);
            this.add_iffffffif(CONTEXT2D_FUNCTION_ID.DRAW_LINE, x, y, fromX, fromY, toX, toY, c1.numColor, lineWidth);
        }
        _drawLines(x, y, points, lineColor, lineWidth, vid) {
            var c1 = ColorUtils.create(lineColor);
            this.add_iffif_ab(CONTEXT2D_FUNCTION_ID.DRAW_LINES, x, y, c1.numColor, lineWidth, new Float32Array(points));
        }
        _drawCircle(x, y, radius, fillColor, lineColor, lineWidth, vid) {
            var c1 = ColorUtils.create(fillColor);
            var c2 = ColorUtils.create(lineColor);
            this.add_ifffiiiif(CONTEXT2D_FUNCTION_ID.DRAW_CIRCLE, x, y, radius, fillColor ? 1 : 0, c1.numColor, lineColor ? 1 : 0, c2.numColor, lineWidth);
        }
        _drawPie(x, y, radius, startAngle, endAngle, fillColor, lineColor, lineWidth, vid) {
            var c1 = ColorUtils.create(fillColor);
            var c2 = ColorUtils.create(lineColor);
            this.add_ifffffiiiif(CONTEXT2D_FUNCTION_ID.DRAW_PIE, x, y, radius, startAngle, endAngle, fillColor ? 1 : 0, c1.numColor, lineColor ? 1 : 0, c2.numColor, lineWidth);
        }
        _drawPoly(x, y, points, fillColor, lineColor, lineWidth, isConvexPolygon, vid) {
            var c1 = ColorUtils.create(fillColor);
            var c2 = ColorUtils.create(lineColor);
            this.add_iffiiiifi_ab(CONTEXT2D_FUNCTION_ID.DRAW_POLY, x, y, fillColor ? 1 : 0, c1.numColor, lineColor ? 1 : 0, c2.numColor, lineWidth, isConvexPolygon ? 1 : 0, new Float32Array(points));
        }
        fillRect(x, y, width, height, fillColor) {
            if (fillColor != null) {
                var c = ColorUtils.create(fillColor);
                this.add_ii(CONTEXT2D_FUNCTION_ID.FILL_STYLE, c.numColor);
            }
            this.add_i(CONTEXT2D_FUNCTION_ID.SAVE);
            this.add_iffff(CONTEXT2D_FUNCTION_ID.FILL_RECT, x, y, width, height);
            this.add_i(CONTEXT2D_FUNCTION_ID.RESTORE);
        }
        drawRect(x, y, width, height, fillColor, lineColor, lineWidth) {
            if (fillColor != null) {
                var c1 = ColorUtils.create(fillColor);
                this.add_i(CONTEXT2D_FUNCTION_ID.SAVE);
                this.add_ii(CONTEXT2D_FUNCTION_ID.FILL_STYLE, c1.numColor);
                this.add_iffff(CONTEXT2D_FUNCTION_ID.FILL_RECT, x, y, width, height);
                this.add_i(CONTEXT2D_FUNCTION_ID.RESTORE);
            }
            if (lineColor != null) {
                var c2 = ColorUtils.create(lineColor);
                this.add_i(CONTEXT2D_FUNCTION_ID.SAVE);
                this.add_ii(CONTEXT2D_FUNCTION_ID.STROKE_STYLE, c2.numColor);
                this.add_if(CONTEXT2D_FUNCTION_ID.LINE_WIDTH, lineWidth);
                this.add_iffff(CONTEXT2D_FUNCTION_ID.STROKE_RECT, x, y, width, height);
                this.add_i(CONTEXT2D_FUNCTION_ID.RESTORE);
            }
        }
        _drawPath(x, y, paths, brush, pen) {
            this.add_ii(CONTEXT2D_FUNCTION_ID.BEGIN_PATH, 0);
            for (var i = 0, n = paths.length; i < n; i++) {
                var path = paths[i];
                switch (path[0]) {
                    case "moveTo":
                        this.add_iff(CONTEXT2D_FUNCTION_ID.MOVE_TO, x + path[1], y + path[2]);
                        break;
                    case "lineTo":
                        this.add_iff(CONTEXT2D_FUNCTION_ID.LINE_TO, x + path[1], y + path[2]);
                        break;
                    case "arcTo":
                        this.add_ifffff(CONTEXT2D_FUNCTION_ID.ARC_TO, x + path[1], y + path[2], x + path[3], y + path[4], path[5]);
                        break;
                    case "closePath":
                        this.add_i(CONTEXT2D_FUNCTION_ID.CLOSE_PATH);
                        break;
                }
            }
            if (brush != null) {
                var c1 = ColorUtils.create(brush.fillStyle);
                this.add_ii(CONTEXT2D_FUNCTION_ID.FILL_STYLE, c1.numColor);
                this.add_i(CONTEXT2D_FUNCTION_ID.FILL);
            }
            if (pen != null) {
                var c2 = ColorUtils.create(pen.strokeStyle);
                this.add_ii(CONTEXT2D_FUNCTION_ID.STROKE_STYLE, c2.numColor);
                this.add_if(CONTEXT2D_FUNCTION_ID.LINE_WIDTH, pen.lineWidth || 1);
                this.add_i(CONTEXT2D_FUNCTION_ID.STROKE);
            }
        }
        drawCurves(x, y, points, lineColor, lineWidth) {
            var c1 = ColorUtils.create(lineColor);
            this.add_iffif_ab(CONTEXT2D_FUNCTION_ID.DRAW_CURVES, x, y, c1.numColor, lineWidth, new Float32Array(points));
        }
        drawCanvas(canvas, x, y, width, height) {
            if (!canvas)
                return;
            this._nativeObj.flushCommand();
            if (canvas instanceof (NativeWebGLCacheAsNormalCanvas)) {
                this._nativeObj.drawCanvasNormal(canvas._nativeObj, x, y, width, height);
            }
            else {
                this._nativeObj.drawCanvasBitmap(canvas.context._nativeObj, x, y, width, height);
            }
        }
        fillText(txt, x, y, fontStr, color, align, lineWidth = 0, borderColor = "") {
            var nTextAlign = 0;
            switch (align) {
                case 'center':
                    nTextAlign = Const.ENUM_TEXTALIGN_CENTER;
                    break;
                case 'right':
                    nTextAlign = Const.ENUM_TEXTALIGN_RIGHT;
                    break;
            }
            var c1 = ColorUtils.create(color);
            var c2 = ColorUtils.create(borderColor);
            if (typeof (txt) === 'string') {
                this.add_iiiifff_String_String(CONTEXT2D_FUNCTION_ID.FILL_WORDS, c1.numColor, c2.numColor, nTextAlign, x, y, lineWidth, txt, fontStr);
            }
            else {
                this.add_iiffiifi_String(CONTEXT2D_FUNCTION_ID.FILL_WORD_TEXT, txt._nativeObj.id, x, y, c1.numColor, c2.numColor, lineWidth, nTextAlign, fontStr);
            }
        }
        drawText(text, x, y, font, color, align) {
            var nTextAlign = 0;
            switch (align) {
                case 'center':
                    nTextAlign = Const.ENUM_TEXTALIGN_CENTER;
                    break;
                case 'right':
                    nTextAlign = Const.ENUM_TEXTALIGN_RIGHT;
                    break;
            }
            var c1 = ColorUtils.create(color);
            var c2 = ColorUtils.create(null);
            if (typeof (text) === 'string') {
                this.add_iiiifff_String_String(CONTEXT2D_FUNCTION_ID.FILL_WORDS, c1.numColor, c2.numColor, nTextAlign, x, y, 0, text, font);
            }
            else {
                this.add_iiffiifi_String(CONTEXT2D_FUNCTION_ID.FILL_WORD_TEXT, text._nativeObj.id, x, y, c1.numColor, c2.numColor, 0, nTextAlign, font);
            }
        }
        fillWords(words, x, y, fontStr, color) {
            var c1 = ColorUtils.create(color);
            var c2 = ColorUtils.create(null);
            var length = words.length;
            for (var i = 0; i < length; i++) {
                this.add_iiiifff_String_String(CONTEXT2D_FUNCTION_ID.FILL_WORDS, c1.numColor, c2.numColor, 0, words[i].x + x, words[i].y + y, 0, words[i].char, fontStr);
            }
        }
        strokeWord(text, x, y, font, color, lineWidth, align) {
            var nTextAlign = 0;
            switch (align) {
                case 'center':
                    nTextAlign = Const.ENUM_TEXTALIGN_CENTER;
                    break;
                case 'right':
                    nTextAlign = Const.ENUM_TEXTALIGN_RIGHT;
                    break;
            }
            var c1 = ColorUtils.create(color);
            var c2 = ColorUtils.create(null);
            if (typeof (text) === 'string') {
                this.add_iiiifff_String_String(CONTEXT2D_FUNCTION_ID.FILL_WORDS, c1.numColor, c2.numColor, nTextAlign, x, y, lineWidth, text, font);
            }
            else {
                this.add_iiffiifi_String(CONTEXT2D_FUNCTION_ID.FILL_WORD_TEXT, text._nativeObj.id, x, y, c1.numColor, c2.numColor, lineWidth, nTextAlign, font);
            }
        }
        fillBorderText(txt, x, y, font, color, borderColor, lineWidth, align) {
            var nTextAlign = 0;
            switch (align) {
                case 'center':
                    nTextAlign = Const.ENUM_TEXTALIGN_CENTER;
                    break;
                case 'right':
                    nTextAlign = Const.ENUM_TEXTALIGN_RIGHT;
                    break;
            }
            var c1 = ColorUtils.create(color);
            var c2 = ColorUtils.create(borderColor);
            if (typeof (txt) === 'string') {
                this.add_iiiifff_String_String(CONTEXT2D_FUNCTION_ID.FILL_WORDS, c1.numColor, c2.numColor, nTextAlign, x, y, lineWidth, txt, font);
            }
            else {
                this.add_iiffiifi_String(CONTEXT2D_FUNCTION_ID.FILL_WORD_TEXT, txt._nativeObj.id, x, y, c1.numColor, c2.numColor, lineWidth, nTextAlign, font);
            }
        }
        fillBorderWords(words, x, y, font, color, borderColor, lineWidth) {
            var c1 = ColorUtils.create(color);
            var c2 = ColorUtils.create(borderColor);
            var length = words.length;
            for (var i = 0; i < length; i++) {
                this.add_iiiifff_String_String(CONTEXT2D_FUNCTION_ID.FILL_WORDS, c1.numColor, c2.numColor, 0, words[i].x + x, words[i].y + y, lineWidth, words[i].char, font);
            }
        }
        fillWords11(words, x, y, fontStr, color, strokeColor, lineWidth) {
            var c1 = ColorUtils.create(color);
            var c2 = ColorUtils.create(strokeColor);
            var font = typeof (fontStr) === 'string' ? fontStr : fontStr._font;
            var length = words.length;
            for (var i = 0; i < length; i++) {
                this.add_iiiifff_String_String(CONTEXT2D_FUNCTION_ID.FILL_WORDS, c1.numColor, c2.numColor, 0, words[i].x + x, words[i].y + y, lineWidth, words[i].char, font);
            }
        }
        filltext11(data, x, y, fontStr, color, strokeColor, lineWidth, align) {
            var nTextAlign = 0;
            switch (align) {
                case 'center':
                    nTextAlign = Const.ENUM_TEXTALIGN_CENTER;
                    break;
                case 'right':
                    nTextAlign = Const.ENUM_TEXTALIGN_RIGHT;
                    break;
            }
            var c1 = ColorUtils.create(color);
            var c2 = ColorUtils.create(strokeColor);
            if (typeof (data) === 'string') {
                this.add_iiiifff_String_String(CONTEXT2D_FUNCTION_ID.FILL_WORDS, c1.numColor, c2.numColor, nTextAlign, x, y, lineWidth, data, fontStr);
            }
            else {
                this.add_iiffiifi_String(CONTEXT2D_FUNCTION_ID.FILL_WORD_TEXT, data._nativeObj.id, x, y, c1.numColor, c2.numColor, lineWidth, nTextAlign, fontStr);
            }
        }
        _fast_filltext(data, x, y, fontObj, color, strokeColor, lineWidth, textAlign, underLine = 0) {
            var c1 = ColorUtils.create(color);
            var c2 = ColorUtils.create(strokeColor);
            if (typeof (data) === 'string') {
                this.add_iiiifff_String_String(CONTEXT2D_FUNCTION_ID.FILL_WORDS, c1.numColor, c2.numColor, textAlign, x, y, lineWidth, data, fontObj._font);
            }
            else {
                this.add_iiffiifi_String(CONTEXT2D_FUNCTION_ID.FILL_WORD_TEXT, data._nativeObj.id, x, y, c1.numColor, c2.numColor, lineWidth, textAlign, fontObj._font);
            }
        }
        drawTriangles(tex, x, y, vertices, uvs, indices, matrix, alpha, color, blendMode, colorNum = 0xffffffff) {
            if (!this.checkTexture(tex)) {
                return;
            }
            var m = matrix ? matrix : this._tmpMatrix;
            if (blendMode != null || color != null) {
                this.add_i(CONTEXT2D_FUNCTION_ID.SAVE);
                this.add_i_String(CONTEXT2D_FUNCTION_ID.SET_GLOBAL_COMPOSITE_OPERTAION, blendMode);
                this.add_iiifffffffff_ab_ab_ab(CONTEXT2D_FUNCTION_ID.DRAW_TRANGLES, tex.bitmap._texture.id, colorNum, x, y, alpha, m.a, m.b, m.c, m.d, m.tx, m.ty, (vertices instanceof Array) ? Float32Array.from(vertices) : vertices, (uvs instanceof Array) ? Float32Array.from(uvs) : uvs, (indices instanceof Array) ? Uint16Array.from(indices) : indices);
                this.add_i(CONTEXT2D_FUNCTION_ID.RESTORE);
            }
            else {
                this.add_iiifffffffff_ab_ab_ab(CONTEXT2D_FUNCTION_ID.DRAW_TRANGLES, tex.bitmap._texture.id, colorNum, x, y, alpha, m.a, m.b, m.c, m.d, m.tx, m.ty, (vertices instanceof Array) ? Float32Array.from(vertices) : vertices, (uvs instanceof Array) ? Float32Array.from(uvs) : uvs, (indices instanceof Array) ? Uint16Array.from(indices) : indices);
            }
        }
        drawMask(w, h) {
            this._nativeObj.flushCommand();
            return this._nativeObj.drawMask(w, h);
        }
        drawMasked(x, y, w, h) {
            this.add_iffff(CONTEXT2D_FUNCTION_ID.DRAW_MASKED, x, y, w, h);
        }
        drawMaskComposite(rt, x, y, w, h) {
            this._nativeObj.flushCommand();
            this._nativeObj.drawMaskComposite(rt, x, y, w, h);
        }
        set asBitmap(value) {
            this.add_ii(CONTEXT2D_FUNCTION_ID.SET_AS_BITMAP, value ? 1 : 0);
        }
        size(w, h) {
            this.add_iii(CONTEXT2D_FUNCTION_ID.SIZE, w, h);
        }
        setColorFilter(filter) {
            this._nativeObj.flushCommand();
            if (filter) {
                this._nativeObj.setColorFilter(true, filter._alpha, filter._mat);
            }
            else {
                this._nativeObj.setColorFilter(false, null, null);
            }
        }
        drawTarget(rt, x, y, width, height, matrix, shaderValue, uv = null, blend = -1) {
            this._nativeObj.flushCommand();
            return this._nativeObj.drawTarget(rt, x, y, width, height, matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx, matrix.ty, blend);
        }
        drawTargetBlurFilter(rt, x, y, width, height, strength) {
            this._nativeObj.flushCommand();
            this._nativeObj.drawTargetBlurFilter(rt, x, y, width, height, strength);
        }
        get _curMat() {
            this._nativeObj.flushCommand();
            var data = this._nativeObj._curMat;
            var mat = Matrix.create();
            mat.a = data[0];
            mat.b = data[1];
            mat.c = data[2];
            mat.d = data[3];
            mat.tx = data[4];
            mat.ty = data[5];
            return mat;
        }
        addRenderObject3D(scene3D) {
            this._renderObject3DList.push(scene3D);
            this._nativeObj.flushCommand();
            this._nativeObj.addRenderObject3D(scene3D._nativeObj);
        }
        pushRT() {
            this._nativeObj.flushCommand();
            this._nativeObj.pushRT();
        }
        popRT() {
            this._nativeObj.flushCommand();
            this._nativeObj.popRT();
        }
        useRT(rt) {
            this._nativeObj.flushCommand();
            this._nativeObj.useRT(rt);
        }
        drawFilter(out, src, x, y, width, height) {
            this._nativeObj.flushCommand();
            this._nativeObj.drawFilter(out, src, x, y, width, height);
        }
        checkTexture(tex) {
            var cs = this.sprite;
            if (!tex._getSource(function () {
                if (cs) {
                    cs.repaint();
                }
            })) {
                return false;
            }
            return true;
        }
        add_i(i) {
            this._need(4);
            this._idata[this._idata[0]++] = i;
        }
        add_ii(a, b) {
            this._need(8);
            var i = this._idata[0];
            this._idata[i++] = a;
            this._idata[i++] = b;
            this._idata[0] = i;
        }
        add_if(a, b) {
            this._need(8);
            var i = this._idata[0];
            this._idata[i++] = a;
            this._fdata[i++] = b;
            this._idata[0] = i;
        }
        add_iff(a, b, c) {
            this._need(12);
            var i = this._idata[0];
            this._idata[i++] = a;
            this._fdata[i++] = b;
            this._fdata[i++] = c;
            this._idata[0] = i;
        }
        add_iffif(a, b, c, d, e) {
            this._need(20);
            var i = this._idata[0];
            var fdata = this._fdata;
            this._idata[i++] = a;
            fdata[i++] = b;
            fdata[i++] = c;
            this._idata[i++] = d;
            fdata[i++] = e;
            this._idata[0] = i;
        }
        add_iffff(a, b, c, d, e) {
            this._need(20);
            var i = this._idata[0];
            var fdata = this._fdata;
            this._idata[i++] = a;
            fdata[i++] = b;
            fdata[i++] = c;
            fdata[i++] = d;
            fdata[i++] = e;
            this._idata[0] = i;
        }
        add_iii(a, b, c) {
            this._need(12);
            var idata = this._idata;
            var i = this._idata[0];
            idata[i++] = a;
            idata[i++] = b;
            idata[i++] = c;
            this._idata[0] = i;
        }
        add_iiffff(a, b, c, d, e, f) {
            this._need(24);
            var i = this._idata[0];
            var fdata = this._fdata;
            this._idata[i++] = a;
            this._idata[i++] = b;
            fdata[i++] = c;
            fdata[i++] = d;
            fdata[i++] = e;
            fdata[i++] = f;
            this._idata[0] = i;
        }
        add_ifffff(a, b, c, d, e, f) {
            this._need(24);
            var i = this._idata[0];
            var fdata = this._fdata;
            this._idata[i++] = a;
            fdata[i++] = b;
            fdata[i++] = c;
            fdata[i++] = d;
            fdata[i++] = e;
            fdata[i++] = f;
            this._idata[0] = i;
        }
        add_iffffff(a, b, c, d, e, f, g) {
            this._need(28);
            var i = this._idata[0];
            var fdata = this._fdata;
            this._idata[i++] = a;
            fdata[i++] = b;
            fdata[i++] = c;
            fdata[i++] = d;
            fdata[i++] = e;
            fdata[i++] = f;
            fdata[i++] = g;
            this._idata[0] = i;
        }
        add_ifffiiiif(a, b, c, d, e, f, g, h, ii) {
            this._need(36);
            var idata = this._idata;
            var i = idata[0];
            var fdata = this._fdata;
            idata[i++] = a;
            fdata[i++] = b;
            fdata[i++] = c;
            fdata[i++] = d;
            idata[i++] = e;
            idata[i++] = f;
            idata[i++] = g;
            idata[i++] = h;
            fdata[i++] = ii;
            idata[0] = i;
        }
        add_ifffffiiiif(a, b, c, d, e, f, g, h, ii, j, k) {
            this._need(44);
            var idata = this._idata;
            var i = idata[0];
            var fdata = this._fdata;
            idata[i++] = a;
            fdata[i++] = b;
            fdata[i++] = c;
            fdata[i++] = d;
            fdata[i++] = e;
            fdata[i++] = f;
            idata[i++] = g;
            idata[i++] = h;
            idata[i++] = ii;
            idata[i++] = j;
            fdata[i++] = k;
            idata[0] = i;
        }
        add_iffffffif(a, b, c, d, e, f, g, h, ii) {
            this._need(36);
            var idata = this._idata;
            var i = idata[0];
            var fdata = this._fdata;
            idata[i++] = a;
            fdata[i++] = b;
            fdata[i++] = c;
            fdata[i++] = d;
            fdata[i++] = e;
            fdata[i++] = f;
            fdata[i++] = g;
            idata[i++] = h;
            fdata[i++] = ii;
            idata[0] = i;
        }
        add_String(ab) {
            var len = ab.byteLength;
            this._need(len + 4);
            this._idata[this._idata[0]++] = len;
            if (len == 0)
                return;
            var uint8array = new Uint8Array(ab);
            this._byteArray.set(uint8array, this._idata[0] * 4);
            this._idata[0] += len / 4;
        }
        add_iffiiiifi(a, b, c, d, e, f, g, h, ii) {
            this._need(45);
            var i = this._idata[0];
            var fdata = this._fdata;
            this._idata[i++] = a;
            fdata[i++] = b;
            fdata[i++] = c;
            this._idata[i++] = d;
            this._idata[i++] = e;
            this._idata[i++] = f;
            this._idata[i++] = g;
            fdata[i++] = h;
            this._idata[i++] = ii;
            this._idata[0] = i;
        }
        add_iiffiifi(a, b, c, d, e, f, g, h) {
            this._need(32);
            var i = this._idata[0];
            var fdata = this._fdata;
            this._idata[i++] = a;
            this._idata[i++] = b;
            fdata[i++] = c;
            fdata[i++] = d;
            this._idata[i++] = e;
            this._idata[i++] = f;
            fdata[i++] = g;
            this._idata[i++] = h;
            this._idata[0] = i;
        }
        add_i_String(a, str) {
            var ab = window.conch.strTobufer(str);
            this._need(4 + ab.byteLength + 4);
            this.add_i(a);
            this.add_String(ab);
        }
        add_iiiifff(a, b, c, d, e, f, g) {
            this._need(28);
            var i = this._idata[0];
            var fdata = this._fdata;
            this._idata[i++] = a;
            this._idata[i++] = b;
            this._idata[i++] = c;
            this._idata[i++] = d;
            fdata[i++] = e;
            fdata[i++] = f;
            fdata[i++] = g;
            this._idata[0] = i;
        }
        add_iiffiifi_String(a, b, c, d, e, f, g, h, str) {
            var ab = window.conch.strTobufer(str);
            this._need(32 + ab.byteLength + 4);
            this.add_iiffiifi(a, b, c, d, e, f, g, h);
            this.add_String(ab);
        }
        add_iiiifff_String_String(a, b, c, d, e, f, g, str0, str1) {
            var ab0 = window.conch.strTobufer(str0);
            var ab1 = window.conch.strTobufer(str1);
            this._need(28 + (ab0.byteLength + 4) + (ab1.byteLength + 4));
            this.add_iiiifff(a, b, c, d, e, f, g);
            this.add_String(ab0);
            this.add_String(ab1);
        }
        add_iiffffffffffff(a, b, c, d, e, f, g, h, ii, j, k, l, m, n) {
            this._need(56);
            var idata = this._idata;
            var i = idata[0];
            var fdata = this._fdata;
            idata[i++] = a;
            idata[i++] = b;
            fdata[i++] = c;
            fdata[i++] = d;
            fdata[i++] = e;
            fdata[i++] = f;
            fdata[i++] = g;
            fdata[i++] = h;
            fdata[i++] = ii;
            fdata[i++] = j;
            fdata[i++] = k;
            fdata[i++] = l;
            fdata[i++] = m;
            fdata[i++] = n;
            idata[0] = i;
        }
        add_iiffffffffiffffffffff(a, b, c, d, e, f, g, h, ii, j, k, l, m, n, o, p, q, r, s, t, u) {
            this._need(84);
            var idata = this._idata;
            var fdata = this._fdata;
            var i = idata[0];
            idata[i++] = a;
            idata[i++] = b;
            fdata[i++] = c;
            fdata[i++] = d;
            fdata[i++] = e;
            fdata[i++] = f;
            fdata[i++] = g;
            fdata[i++] = h;
            fdata[i++] = ii;
            fdata[i++] = j;
            idata[i++] = k;
            fdata[i++] = l;
            fdata[i++] = m;
            fdata[i++] = n;
            fdata[i++] = o;
            fdata[i++] = p;
            fdata[i++] = q;
            fdata[i++] = r;
            fdata[i++] = s;
            fdata[i++] = t;
            fdata[i++] = u;
            idata[0] = i;
        }
        add_iiifffffffff(a, b, c, d, e, f, g, h, ii, j, k, l) {
            this._need(48);
            var idata = this._idata;
            var fdata = this._fdata;
            var i = idata[0];
            idata[i++] = a;
            idata[i++] = b;
            idata[i++] = c;
            fdata[i++] = d;
            fdata[i++] = e;
            fdata[i++] = f;
            fdata[i++] = g;
            fdata[i++] = h;
            fdata[i++] = ii;
            fdata[i++] = j;
            fdata[i++] = k;
            fdata[i++] = l;
            idata[0] = i;
        }
        add_iiifffffffff_ab_ab_ab(a, b, c, d, e, f, g, h, ii, j, k, l, arraybuffer0, arraybuffer1, arraybuffer2) {
            var nAlignLength0 = this.getAlignLength(arraybuffer0);
            var nAlignLength1 = this.getAlignLength(arraybuffer1);
            var nAlignLength2 = this.getAlignLength(arraybuffer2);
            this._need(48 + (nAlignLength0 + 4) + (nAlignLength1 + 4) + (nAlignLength2 + 4));
            this.add_iiifffffffff(a, b, c, d, e, f, g, h, ii, j, k, l);
            this.wab(arraybuffer0, arraybuffer0.byteLength, nAlignLength0, 0);
            this.wab(arraybuffer1, arraybuffer1.byteLength, nAlignLength1, 0);
            this.wab(arraybuffer2, arraybuffer2.byteLength, nAlignLength2, 0);
        }
        wab(arraybuffer, length, nAlignLength, offset) {
            offset = offset ? offset : 0;
            this._need(nAlignLength + 4);
            this._idata[this._idata[0]++] = length;
            var uint8array = null;
            if (arraybuffer instanceof Float32Array && offset == 0) {
                this._fdata.set(arraybuffer, this._idata[0]);
            }
            else {
                if (arraybuffer instanceof ArrayBuffer) {
                    uint8array = new Uint8Array(arraybuffer, offset, length);
                }
                else if (arraybuffer.buffer) {
                    uint8array = new Uint8Array(arraybuffer.buffer, offset + arraybuffer.byteOffset, length);
                }
                else {
                    console.log("not arraybuffer/dataview");
                    return;
                }
                this._byteArray.set(uint8array, this._idata[0] * 4);
            }
            this._idata[0] += nAlignLength / 4;
        }
        getAlignLength(data) {
            var byteLength = data.byteLength;
            return (byteLength + 3) & 0xfffffffc;
        }
        add_iif_ab(a, b, c, arraybuffer) {
            var nAlignLength = this.getAlignLength(arraybuffer);
            this._need(12 + nAlignLength + 4);
            this.add_iff(a, b, c);
            this.wab(arraybuffer, arraybuffer.byteLength, nAlignLength, 0);
        }
        add_iffif_ab(a, b, c, d, e, arraybuffer) {
            var nAlignLength = this.getAlignLength(arraybuffer);
            this._need(20 + nAlignLength + 4);
            this.add_iffif(a, b, c, d, e);
            this.wab(arraybuffer, arraybuffer.byteLength, nAlignLength, 0);
        }
        add_iffiiiifi_ab(a, b, c, d, e, f, g, h, ii, arraybuffer) {
            var nAlignLength = this.getAlignLength(arraybuffer);
            this._need(45 + nAlignLength + 4);
            this.add_iffiiiifi(a, b, c, d, e, f, g, h, ii);
            this.wab(arraybuffer, arraybuffer.byteLength, nAlignLength, 0);
        }
    }
    NativeContext.ARRAY_BUFFER_TYPE_DATA = 0;
    NativeContext.ARRAY_BUFFER_TYPE_CMD = 1;
    NativeContext.ARRAY_BUFFER_REF_REFERENCE = 0;
    NativeContext.ARRAY_BUFFER_REF_COPY = 1;
    NativeContext.ENUM_TEXTALIGN_DEFAULT = 0;
    NativeContext.ENUM_TEXTALIGN_CENTER = 1;
    NativeContext.ENUM_TEXTALIGN_RIGHT = 2;

    const defaultClipMatrix = new Matrix(Const.MAX_CLIP_SIZE, 0, 0, Const.MAX_CLIP_SIZE, 0, 0);
    class Context {
        constructor() {
            this._tmpMatrix = new Matrix();
            this._drawTexToDrawTri_Vert = new Float32Array(8);
            this._drawTexToDrawTri_Index = new Uint16Array([0, 1, 2, 0, 2, 3]);
            this._tempUV = new Float32Array(8);
            this._drawTriUseAbsMatrix = false;
            this._id = ++Context._COUNT;
            this._other = null;
            this._renderNextSubmitIndex = 0;
            this._path = null;
            this._drawCount = 1;
            this._width = Const.MAX_CLIP_SIZE;
            this._height = Const.MAX_CLIP_SIZE;
            this._renderCount = 0;
            this._submits = null;
            this._curSubmit = null;
            this._submitKey = new SubmitKey();
            this._pathMesh = null;
            this._triangleMesh = null;
            this.meshlist = [];
            this._transedPoints = new Array(8);
            this._temp4Points = new Array(8);
            this._clipRect = Context.MAXCLIPRECT;
            this._globalClipMatrix = defaultClipMatrix.clone();
            this._clipInCache = false;
            this._clipInfoID = 0;
            this._clipID_Gen = 0;
            this._lastMatScaleX = 1.0;
            this._lastMatScaleY = 1.0;
            this._lastMat_a = 1.0;
            this._lastMat_b = 0.0;
            this._lastMat_c = 0.0;
            this._lastMat_d = 1.0;
            this._nBlendType = 0;
            this._save = null;
            this._targets = null;
            this._charSubmitCache = null;
            this._saveMark = null;
            this._shader2D = new Shader2D();
            this.sprite = null;
            this._italicDeg = 0;
            this._lastTex = null;
            this._fillColor = 0;
            this._flushCnt = 0;
            this.defTexture = null;
            this._colorFiler = null;
            this.drawTexAlign = false;
            this._incache = false;
            this.isMain = false;
            this.clearColor = new Color();
            Context._contextcount++;
            Context._textRender = Context._textRender || new TextRender();
            if (!this.defTexture) {
                var defTex2d = new Texture2D(2, 2, exports.TextureFormat.R8G8B8A8, true, false, false);
                defTex2d.setPixelsData(new Uint8Array(16), false, false);
                defTex2d.lock = true;
                this.defTexture = new Texture(defTex2d);
            }
            this._lastTex = this.defTexture;
            this.clear();
        }
        static __init__() {
            Context.MAXCLIPRECT = new Rectangle(0, 0, Const.MAX_CLIP_SIZE, Const.MAX_CLIP_SIZE);
            ContextParams.DEFAULT = new ContextParams();
        }
        drawImage(...args) {
        }
        getImageData(...args) {
        }
        measureText(text) {
            return null;
        }
        setTransform(...args) {
        }
        $transform(a, b, c, d, tx, ty) {
        }
        get lineJoin() {
            return '';
        }
        set lineJoin(value) {
        }
        get lineCap() {
            return '';
        }
        set lineCap(value) {
        }
        get miterLimit() {
            return '';
        }
        set miterLimit(value) {
        }
        clearRect(x, y, width, height) {
        }
        _drawRect(x, y, width, height, style) {
            style && (this.fillStyle = style);
            this.fillRect(x, y, width, height, null);
        }
        drawTexture2(x, y, pivotX, pivotY, m, args2) {
        }
        transformByMatrix(matrix, tx, ty) {
            this.transform(matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx + tx, matrix.ty + ty);
        }
        saveTransform(matrix) {
            this.save();
        }
        restoreTransform(matrix) {
            this.restore();
        }
        drawRect(x, y, width, height, fillColor, lineColor, lineWidth) {
            var ctx = this;
            if (fillColor != null) {
                ctx.fillStyle = fillColor;
                ctx.fillRect(x, y, width, height);
            }
            if (lineColor != null) {
                ctx.strokeStyle = lineColor;
                ctx.lineWidth = lineWidth;
                ctx.strokeRect(x, y, width, height);
            }
        }
        alpha(value) {
            this.globalAlpha *= value;
        }
        _transform(mat, pivotX, pivotY) {
            this.translate(pivotX, pivotY);
            this.transform(mat.a, mat.b, mat.c, mat.d, mat.tx, mat.ty);
            this.translate(-pivotX, -pivotY);
        }
        _rotate(angle, pivotX, pivotY) {
            this.translate(pivotX, pivotY);
            this.rotate(angle);
            this.translate(-pivotX, -pivotY);
        }
        _scale(scaleX, scaleY, pivotX, pivotY) {
            this.translate(pivotX, pivotY);
            this.scale(scaleX, scaleY);
            this.translate(-pivotX, -pivotY);
        }
        _drawLine(x, y, fromX, fromY, toX, toY, lineColor, lineWidth, vid) {
            this.beginPath();
            this.strokeStyle = lineColor;
            this.lineWidth = lineWidth;
            this.moveTo(x + fromX, y + fromY);
            this.lineTo(x + toX, y + toY);
            this.stroke();
        }
        _drawLines(x, y, points, lineColor, lineWidth, vid) {
            this.beginPath();
            this.strokeStyle = lineColor;
            this.lineWidth = lineWidth;
            this.addPath(points.slice(), false, false, x, y);
            this.stroke();
        }
        drawCurves(x, y, points, lineColor, lineWidth) {
            this.beginPath();
            this.strokeStyle = lineColor;
            this.lineWidth = lineWidth;
            this.moveTo(x + points[0], y + points[1]);
            var i = 2, n = points.length;
            while (i < n) {
                this.quadraticCurveTo(x + points[i++], y + points[i++], x + points[i++], y + points[i++]);
            }
            this.stroke();
        }
        _fillAndStroke(fillColor, strokeColor, lineWidth, isConvexPolygon = false) {
            if (fillColor != null) {
                this.fillStyle = fillColor;
                this.fill();
            }
            if (strokeColor != null && lineWidth > 0) {
                this.strokeStyle = strokeColor;
                this.lineWidth = lineWidth;
                this.stroke();
            }
        }
        _drawCircle(x, y, radius, fillColor, lineColor, lineWidth, vid) {
            this.beginPath(true);
            this.arc(x, y, radius, 0, Context.PI2);
            this.closePath();
            this._fillAndStroke(fillColor, lineColor, lineWidth);
        }
        _drawPie(x, y, radius, startAngle, endAngle, fillColor, lineColor, lineWidth, vid) {
            this.beginPath();
            this.moveTo(x, y);
            this.arc(x, y, radius, startAngle, endAngle);
            this.closePath();
            this._fillAndStroke(fillColor, lineColor, lineWidth);
        }
        _drawPoly(x, y, points, fillColor, lineColor, lineWidth, isConvexPolygon, vid) {
            this.beginPath();
            this.addPath(points.slice(), true, isConvexPolygon, x, y);
            this.closePath();
            this._fillAndStroke(fillColor, lineColor, lineWidth, isConvexPolygon);
        }
        _drawPath(x, y, paths, brush, pen) {
            this.beginPath();
            for (var i = 0, n = paths.length; i < n; i++) {
                var path = paths[i];
                switch (path[0]) {
                    case "moveTo":
                        this.moveTo(x + path[1], y + path[2]);
                        break;
                    case "lineTo":
                        this.lineTo(x + path[1], y + path[2]);
                        break;
                    case "arcTo":
                        this.arcTo(x + path[1], y + path[2], x + path[3], y + path[4], path[5]);
                        break;
                    case "closePath":
                        this.closePath();
                        break;
                }
            }
            if (brush != null) {
                this.fillStyle = brush.fillStyle;
                this.fill();
            }
            if (pen != null) {
                this.strokeStyle = pen.strokeStyle;
                this.lineWidth = pen.lineWidth || 1;
                this.lineJoin = pen.lineJoin;
                this.lineCap = pen.lineCap;
                this.miterLimit = pen.miterLimit;
                this.stroke();
            }
        }
        static set2DRenderConfig() {
            if (!Context.const2DRenderCMD) {
                const cmd = Context.const2DRenderCMD = LayaGL.renderEngine.createRenderStateComand();
                cmd.addCMD(exports.RenderStateType.BlendType, true);
                cmd.addCMD(exports.RenderStateType.BlendEquation, exports.BlendEquationSeparate.ADD);
                BlendMode.activeBlendFunction = null;
                cmd.addCMD(exports.RenderStateType.BlendFunc, [exports.BlendFactor.One, exports.BlendFactor.OneMinusSourceAlpha]);
                cmd.addCMD(exports.RenderStateType.DepthTest, false);
                cmd.addCMD(exports.RenderStateType.DepthMask, true);
                cmd.addCMD(exports.RenderStateType.CullFace, false);
                cmd.addCMD(exports.RenderStateType.FrontFace, exports.CullMode.Front);
            }
            Context.const2DRenderCMD.applyCMD();
            RenderTexture.currentActive && RenderTexture.currentActive._end();
            RenderTexture2D.currentActive && RenderTexture2D.currentActive.end();
            LayaGL.renderEngine.viewport(0, 0, RenderState2D.width, RenderState2D.height);
            LayaGL.renderEngine.scissorTest(true);
            LayaGL.renderEngine.scissor(0, 0, RenderState2D.width, RenderState2D.height);
        }
        clearBG(r, g, b, a) {
            this.clearColor.r = r;
            this.clearColor.g = g;
            this.clearColor.b = b;
            this.clearColor.a = a;
            LayaGL.renderEngine.clearRenderTexture(exports.RenderClearFlag.Color, this.clearColor, 1);
        }
        _getSubmits() {
            return this._submits;
        }
        _releaseMem(keepRT = false) {
            if (!this._submits)
                return;
            this._curMat && this._curMat.destroy();
            this._curMat = null;
            this._shader2D.destroy();
            this._shader2D = null;
            this._charSubmitCache.clear();
            for (var i = 0, n = this._submits._length; i < n; i++) {
                this._submits[i].releaseRender();
            }
            this._submits.length = 0;
            this._submits._length = 0;
            this._submits = null;
            this._curSubmit = null;
            this._path = null;
            this._save = null;
            var sz;
            for (i = 0, sz = this.meshlist.length; i < sz; i++) {
                var curm = this.meshlist[i];
                curm.destroy();
            }
            this.meshlist.length = 0;
            this.sprite = null;
            if (!keepRT) {
                this._targets && (this._targets.destroy());
                this._targets = null;
            }
        }
        destroy(keepRT = false) {
            --Context._contextcount;
            this.sprite = null;
            this._releaseMem(keepRT);
            this._charSubmitCache && this._charSubmitCache.destroy();
            this._mesh.destroy();
            if (!keepRT) {
                this._targets && this._targets.destroy();
                this._targets = null;
            }
            if (this.defTexture) {
                this.defTexture.bitmap && this.defTexture.bitmap.destroy();
                this.defTexture.destroy();
            }
        }
        clear() {
            if (!this._submits) {
                this._other = ContextParams.DEFAULT;
                this._curMat = Matrix.create();
                this._charSubmitCache = new CharSubmitCache();
                this._mesh = MeshQuadTexture.getAMesh(this.isMain);
                this.meshlist.push(this._mesh);
                this._pathMesh = MeshVG.getAMesh(this.isMain);
                this.meshlist.push(this._pathMesh);
                this._triangleMesh = MeshTexture.getAMesh(this.isMain);
                this.meshlist.push(this._triangleMesh);
                this._submits = [];
                this._save = [SaveMark.Create(this)];
                this._save.length = 10;
                this._shader2D = new Shader2D();
            }
            this._submitKey.clear();
            this._mesh.clearVB();
            this._drawCount = 1;
            this._other = ContextParams.DEFAULT;
            this._other.lineWidth = this._shader2D.ALPHA = 1.0;
            this._nBlendType = 0;
            this._clipRect = Context.MAXCLIPRECT;
            this._curSubmit = SubmitBase.RENDERBASE;
            SubmitBase.RENDERBASE._ref = 0xFFFFFF;
            SubmitBase.RENDERBASE._numEle = 0;
            this._shader2D.fillStyle = this._shader2D.strokeStyle = DrawStyle.DEFAULT;
            for (let i = 0, n = this._submits._length; i < n; i++)
                this._submits[i].releaseRender();
            this._submits._length = 0;
            this._curMat.identity();
            this._other.clear();
            this._saveMark = this._save[0];
            this._save._length = 1;
        }
        size(w, h) {
            if (this._width != w || this._height != h) {
                this._width = w;
                this._height = h;
                if (this._targets) {
                    this._targets.destroy();
                    this._targets = new RenderTexture2D(w, h, exports.RenderTargetFormat.R8G8B8A8, -1);
                }
                if (this.isMain) {
                    LayaGL.renderEngine.viewport(0, 0, w, h);
                    RenderState2D.width = w;
                    RenderState2D.height = h;
                }
            }
            if (w === 0 && h === 0)
                this._releaseMem();
        }
        set asBitmap(value) {
            if (value) {
                let rt = this._targets;
                if (!this._width || !this._height)
                    throw Error("asBitmap no size!");
                if (!rt || rt.width != this._width || rt.height != this._height) {
                    if (rt) {
                        rt.destroy();
                    }
                    this._targets = new RenderTexture2D(this._width, this._height, exports.RenderTargetFormat.R8G8B8A8);
                }
            }
            else {
                this._targets && this._targets.destroy();
                this._targets = null;
            }
        }
        getMatScaleX() {
            if (this._lastMat_a == this._curMat.a && this._lastMat_b == this._curMat.b)
                return this._lastMatScaleX;
            this._lastMatScaleX = this._curMat.getScaleX();
            this._lastMat_a = this._curMat.a;
            this._lastMat_b = this._curMat.b;
            return this._lastMatScaleX;
        }
        getMatScaleY() {
            if (this._lastMat_c == this._curMat.c && this._lastMat_d == this._curMat.d)
                return this._lastMatScaleY;
            this._lastMatScaleY = this._curMat.getScaleY();
            this._lastMat_c = this._curMat.c;
            this._lastMat_d = this._curMat.d;
            return this._lastMatScaleY;
        }
        setFillColor(color) {
            this._fillColor = color;
        }
        getFillColor() {
            return this._fillColor;
        }
        set fillStyle(value) {
            if (!this._shader2D.fillStyle.equal(value)) {
                SaveBase.save(this, SaveBase.TYPE_FILESTYLE, this._shader2D, false);
                this._shader2D.fillStyle = DrawStyle.create(value);
                this._submitKey.other = -this._shader2D.fillStyle.toInt();
            }
        }
        get fillStyle() {
            return this._shader2D.fillStyle;
        }
        set globalAlpha(value) {
            value = Math.floor(value * 1000) / 1000;
            if (value != this._shader2D.ALPHA) {
                SaveBase.save(this, SaveBase.TYPE_ALPHA, this._shader2D, false);
                this._shader2D.ALPHA = value;
            }
        }
        get globalAlpha() {
            return this._shader2D.ALPHA;
        }
        set textAlign(value) {
            (this._other.textAlign === value) || (this._other = this._other.make(), SaveBase.save(this, SaveBase.TYPE_TEXTALIGN, this._other, false), this._other.textAlign = value);
        }
        get textAlign() {
            return this._other.textAlign;
        }
        set textBaseline(value) {
            (this._other.textBaseline === value) || (this._other = this._other.make(), SaveBase.save(this, SaveBase.TYPE_TEXTBASELINE, this._other, false), this._other.textBaseline = value);
        }
        get textBaseline() {
            return this._other.textBaseline;
        }
        set globalCompositeOperation(value) {
            var n = BlendMode.TOINT[value];
            n == null || (this._nBlendType === n) || (SaveBase.save(this, SaveBase.TYPE_GLOBALCOMPOSITEOPERATION, this, true), this._curSubmit = SubmitBase.RENDERBASE, this._nBlendType = n);
        }
        get globalCompositeOperation() {
            return BlendMode.NAMES[this._nBlendType];
        }
        set strokeStyle(value) {
            this._shader2D.strokeStyle.equal(value) || (SaveBase.save(this, SaveBase.TYPE_STROKESTYLE, this._shader2D, false), this._shader2D.strokeStyle = DrawStyle.create(value), this._submitKey.other = -this._shader2D.strokeStyle.toInt());
        }
        get strokeStyle() {
            return this._shader2D.strokeStyle;
        }
        translate(x, y) {
            if (x !== 0 || y !== 0) {
                SaveTranslate.save(this);
                if (this._curMat._bTransform) {
                    SaveTransform.save(this);
                    this._curMat.tx += (x * this._curMat.a + y * this._curMat.c);
                    this._curMat.ty += (x * this._curMat.b + y * this._curMat.d);
                }
                else {
                    this._curMat.tx = x;
                    this._curMat.ty = y;
                }
            }
        }
        set lineWidth(value) {
            (this._other.lineWidth === value) || (this._other = this._other.make(), SaveBase.save(this, SaveBase.TYPE_LINEWIDTH, this._other, false), this._other.lineWidth = value);
        }
        get lineWidth() {
            return this._other.lineWidth;
        }
        save() {
            this._save[this._save._length++] = SaveMark.Create(this);
        }
        restore() {
            var sz = this._save._length;
            var lastBlend = this._nBlendType;
            if (sz < 1)
                return;
            for (var i = sz - 1; i >= 0; i--) {
                var o = this._save[i];
                o.restore(this);
                if (o.isSaveMark()) {
                    this._save._length = i;
                    return;
                }
            }
            if (lastBlend != this._nBlendType) {
                this._curSubmit = SubmitBase.RENDERBASE;
            }
        }
        set font(str) {
            this._other = this._other.make();
            SaveBase.save(this, SaveBase.TYPE_FONT, this._other, false);
        }
        fillText(txt, x, y, fontStr, color, align, lineWidth = 0, borderColor = "") {
            Context._textRender.filltext(this, txt, x, y, fontStr, color, borderColor, lineWidth, align);
        }
        drawText(text, x, y, font, color, textAlign) {
            Context._textRender.filltext(this, text, x, y, font, color, null, 0, textAlign);
        }
        fillWords(words, x, y, fontStr, color) {
            Context._textRender.fillWords(this, words, x, y, fontStr, color, null, 0);
        }
        strokeWord(text, x, y, font, color, lineWidth, textAlign) {
            Context._textRender.filltext(this, text, x, y, font, null, color, lineWidth, textAlign);
        }
        fillBorderText(txt, x, y, font, color, borderColor, lineWidth, textAlign) {
            Context._textRender.filltext(this, txt, x, y, font, color, borderColor, lineWidth, textAlign);
        }
        fillBorderWords(words, x, y, font, color, borderColor, lineWidth) {
            Context._textRender.fillWords(this, words, x, y, font, color, borderColor, lineWidth);
        }
        _fast_filltext(data, x, y, fontObj, color, strokeColor, lineWidth, textAlign, underLine = 0) {
            Context._textRender._fast_filltext(this, data, null, x, y, fontObj, color, strokeColor, lineWidth, textAlign, underLine);
        }
        fillWords11(data, x, y, fontStr, color, strokeColor, lineWidth) {
            Context._textRender.fillWords(this, data, x, y, fontStr, color, strokeColor, lineWidth);
        }
        filltext11(data, x, y, fontStr, color, strokeColor, lineWidth, textAlign) {
            Context._textRender.filltext(this, data, x, y, fontStr, color, strokeColor, lineWidth, textAlign);
        }
        _fillRect(x, y, width, height, rgba) {
            var submit = this._curSubmit;
            var sameKey = submit && (submit._key.submitType === SubmitBase.KEY_DRAWTEXTURE && submit._key.blendShader === this._nBlendType);
            if (this._mesh.vertNum + 4 > Context._MAXVERTNUM) {
                this._mesh = MeshQuadTexture.getAMesh(this.isMain);
                this.meshlist.push(this._mesh);
                sameKey = false;
            }
            sameKey && (sameKey = sameKey && this.isSameClipInfo(submit));
            this.transformQuad(x, y, width, height, 0, this._curMat, this._transedPoints);
            if (!this.clipedOff(this._transedPoints)) {
                this._mesh.addQuad(this._transedPoints, Texture.NO_UV, rgba, false);
                if (!sameKey) {
                    submit = this._curSubmit = SubmitTexture.create(this, this._mesh, Value2D.create(ShaderDefines2D.TEXTURE2D, 0));
                    this._submits[this._submits._length++] = submit;
                    this._copyClipInfo(submit, this._globalClipMatrix);
                    if (!this._lastTex || this._lastTex.destroyed) {
                        submit.shaderValue.textureHost = this.defTexture;
                    }
                    else {
                        submit.shaderValue.textureHost = this._lastTex;
                    }
                    submit._key.other = (this._lastTex && this._lastTex.bitmap) ? this._lastTex.bitmap.id : -1;
                    submit._renderType = SubmitBase.TYPE_TEXTURE;
                }
                this._curSubmit._numEle += 6;
                this._mesh.indexNum += 6;
                this._mesh.vertNum += 4;
            }
        }
        fillRect(x, y, width, height, fillStyle) {
            var drawstyle = fillStyle ? DrawStyle.create(fillStyle) : this._shader2D.fillStyle;
            var rgba = this.mixRGBandAlpha(drawstyle.toInt());
            this._fillRect(x, y, width, height, rgba);
        }
        fillTexture(texture, x, y, width, height, type, offset) {
            if (!texture._getSource()) {
                this.sprite && ILaya.systemTimer.callLater(this, this._repaintSprite);
                return;
            }
            this._fillTexture(texture, texture.width, texture.height, texture.uvrect, x, y, width, height, type, offset.x, offset.y);
        }
        _fillTexture(texture, texw, texh, texuvRect, x, y, width, height, type, offsetx, offsety) {
            var submit = this._curSubmit;
            if (this._mesh.vertNum + 4 > Context._MAXVERTNUM) {
                this._mesh = MeshQuadTexture.getAMesh(this.isMain);
                this.meshlist.push(this._mesh);
            }
            var repeatx = true;
            var repeaty = true;
            switch (type) {
                case "repeat": break;
                case "repeat-x":
                    repeaty = false;
                    break;
                case "repeat-y":
                    repeatx = false;
                    break;
                case "no-repeat":
                    repeatx = repeaty = false;
                    break;
            }
            var uv = this._temp4Points;
            var stu = 0;
            var stv = 0;
            var stx = 0, sty = 0, edx = 0, edy = 0;
            if (offsetx < 0) {
                stx = x;
                stu = (-offsetx % texw) / texw;
            }
            else {
                stx = x + offsetx;
            }
            if (offsety < 0) {
                sty = y;
                stv = (-offsety % texh) / texh;
            }
            else {
                sty = y + offsety;
            }
            edx = x + width;
            edy = y + height;
            (!repeatx) && (edx = Math.min(edx, x + offsetx + texw));
            (!repeaty) && (edy = Math.min(edy, y + offsety + texh));
            if (edx < x || edy < y)
                return;
            if (stx > edx || sty > edy)
                return;
            var edu = (edx - x - offsetx) / texw;
            var edv = (edy - y - offsety) / texh;
            this.transformQuad(stx, sty, edx - stx, edy - sty, 0, this._curMat, this._transedPoints);
            uv[0] = stu;
            uv[1] = stv;
            uv[2] = edu;
            uv[3] = stv;
            uv[4] = edu;
            uv[5] = edv;
            uv[6] = stu;
            uv[7] = edv;
            if (!this.clipedOff(this._transedPoints)) {
                var rgba = this._mixRGBandAlpha(0xffffffff, this._shader2D.ALPHA);
                this._mesh.addQuad(this._transedPoints, uv, rgba, true);
                var sv = Value2D.create(ShaderDefines2D.TEXTURE2D, 0);
                sv.defines.add(ShaderDefines2D.FILLTEXTURE);
                sv.u_TexRange = texuvRect.concat();
                submit = this._curSubmit = SubmitTexture.create(this, this._mesh, sv);
                this._submits[this._submits._length++] = submit;
                this._copyClipInfo(submit, this._globalClipMatrix);
                submit.shaderValue.textureHost = texture;
                submit._renderType = SubmitBase.TYPE_TEXTURE;
                this._curSubmit._numEle += 6;
                this._mesh.indexNum += 6;
                this._mesh.vertNum += 4;
            }
            this.breakNextMerge();
        }
        setColorFilter(filter) {
            SaveBase.save(this, SaveBase.TYPE_COLORFILTER, this, true);
            this._colorFiler = filter;
            this._curSubmit = SubmitBase.RENDERBASE;
        }
        drawTexture(tex, x, y, width, height) {
            this._drawTextureM(tex, x, y, width, height, null, 1, null);
        }
        drawTextures(tex, pos, tx, ty) {
            if (!tex._getSource()) {
                this.sprite && ILaya.systemTimer.callLater(this, this._repaintSprite);
                return;
            }
            var n = pos.length / 2;
            var ipos = 0;
            var bmpid = tex.bitmap.id;
            for (var i = 0; i < n; i++) {
                this._inner_drawTexture(tex, bmpid, pos[ipos++] + tx, pos[ipos++] + ty, 0, 0, null, null, 1.0, false);
            }
        }
        _drawTextureAddSubmit(imgid, tex) {
            var submit = null;
            submit = SubmitTexture.create(this, this._mesh, Value2D.create(ShaderDefines2D.TEXTURE2D, 0));
            this._submits[this._submits._length++] = submit;
            submit.shaderValue.textureHost = tex;
            submit._key.other = imgid;
            submit._renderType = SubmitBase.TYPE_TEXTURE;
            this._curSubmit = submit;
        }
        _drawTextureM(tex, x, y, width, height, m, alpha, uv) {
            var cs = this.sprite;
            if (!tex._getSource(function () {
                if (cs) {
                    cs.repaint();
                }
            })) {
                return false;
            }
            return this._inner_drawTexture(tex, tex.bitmap.id, x, y, width, height, m, uv, alpha, false);
        }
        _drawRenderTexture(tex, x, y, width, height, m, alpha, uv) {
            return this._inner_drawTexture(tex, -1, x, y, width, height, m, uv, 1.0, false);
        }
        submitDebugger() {
            this._submits[this._submits._length++] = SubmitCMD.create([], function () { debugger; }, this);
        }
        _copyClipInfo(submit, clipInfo) {
            var cm = submit.shaderValue.clipMatDir;
            cm[0] = clipInfo.a;
            cm[1] = clipInfo.b;
            cm[2] = clipInfo.c;
            cm[3] = clipInfo.d;
            var cmp = submit.shaderValue.clipMatPos;
            cmp[0] = clipInfo.tx;
            cmp[1] = clipInfo.ty;
            submit.clipInfoID = this._clipInfoID;
            if (this._clipInCache) {
                submit.shaderValue.clipOff[0] = 1;
            }
        }
        isSameClipInfo(submit) {
            return (submit.clipInfoID === this._clipInfoID);
        }
        _useNewTex2DSubmit(tex, minVertNum) {
            if (this._mesh.vertNum + minVertNum > Context._MAXVERTNUM) {
                this._mesh = MeshQuadTexture.getAMesh(this.isMain);
                this.meshlist.push(this._mesh);
            }
            var submit = SubmitTexture.create(this, this._mesh, Value2D.create(ShaderDefines2D.TEXTURE2D, 0));
            this._submits[this._submits._length++] = this._curSubmit = submit;
            submit.shaderValue.textureHost = tex;
            this._copyClipInfo(submit, this._globalClipMatrix);
        }
        _drawTexRect(x, y, w, h, uv) {
            this.transformQuad(x, y, w, h, this._italicDeg, this._curMat, this._transedPoints);
            var ops = this._transedPoints;
            ops[0] = (ops[0] + 0.5) | 0;
            ops[1] = (ops[1] + 0.5) | 0;
            ops[2] = (ops[2] + 0.5) | 0;
            ops[3] = (ops[3] + 0.5) | 0;
            ops[4] = (ops[4] + 0.5) | 0;
            ops[5] = (ops[5] + 0.5) | 0;
            ops[6] = (ops[6] + 0.5) | 0;
            ops[7] = (ops[7] + 0.5) | 0;
            if (!this.clipedOff(this._transedPoints)) {
                this._mesh.addQuad(this._transedPoints, uv, this._fillColor, true);
                this._curSubmit._numEle += 6;
                this._mesh.indexNum += 6;
                this._mesh.vertNum += 4;
            }
        }
        drawCallOptimize(enable) {
            this._charSubmitCache.enable(enable, this);
            return enable;
        }
        _inner_drawTexture(tex, imgid, x, y, width, height, m, uv, alpha, lastRender) {
            if (width <= 0 || height <= 0) {
                return false;
            }
            var preKey = this._curSubmit._key;
            uv = uv || tex._uv;
            if (preKey.submitType === SubmitBase.KEY_TRIANGLES && preKey.other === imgid) {
                var tv = this._drawTexToDrawTri_Vert;
                tv[0] = x;
                tv[1] = y;
                tv[2] = x + width, tv[3] = y, tv[4] = x + width, tv[5] = y + height, tv[6] = x, tv[7] = y + height;
                this._drawTriUseAbsMatrix = true;
                var tuv = this._tempUV;
                tuv[0] = uv[0];
                tuv[1] = uv[1];
                tuv[2] = uv[2];
                tuv[3] = uv[3];
                tuv[4] = uv[4];
                tuv[5] = uv[5];
                tuv[6] = uv[6];
                tuv[7] = uv[7];
                this.drawTriangles(tex, 0, 0, tv, tuv, this._drawTexToDrawTri_Index, m || this._curMat, alpha, null, null);
                this._drawTriUseAbsMatrix = false;
                return true;
            }
            var mesh = this._mesh;
            var submit = this._curSubmit;
            var ops = lastRender ? this._charSubmitCache.getPos() : this._transedPoints;
            this.transformQuad(x, y, width || tex.width, height || tex.height, this._italicDeg, m || this._curMat, ops);
            if (this.drawTexAlign) {
                var round = Math.round;
                ops[0] = round(ops[0]);
                ops[1] = round(ops[1]);
                ops[2] = round(ops[2]);
                ops[3] = round(ops[3]);
                ops[4] = round(ops[4]);
                ops[5] = round(ops[5]);
                ops[6] = round(ops[6]);
                ops[7] = round(ops[7]);
                this.drawTexAlign = false;
            }
            var rgba = this._mixRGBandAlpha(0xffffffff, this._shader2D.ALPHA * alpha);
            if (lastRender) {
                this._charSubmitCache.add(this, tex, imgid, ops, uv, rgba);
                return true;
            }
            this._drawCount++;
            var sameKey = imgid >= 0 && preKey.submitType === SubmitBase.KEY_DRAWTEXTURE && preKey.other === imgid;
            sameKey && (sameKey = sameKey && this.isSameClipInfo(submit));
            this._lastTex = tex;
            if (mesh.vertNum + 4 > Context._MAXVERTNUM) {
                mesh = this._mesh = MeshQuadTexture.getAMesh(this.isMain);
                this.meshlist.push(mesh);
                sameKey = false;
            }
            {
                mesh.addQuad(ops, uv, rgba, true);
                if (!sameKey) {
                    this._submits[this._submits._length++] = this._curSubmit = submit = SubmitTexture.create(this, mesh, Value2D.create(ShaderDefines2D.TEXTURE2D, 0));
                    submit.shaderValue.textureHost = tex;
                    submit._key.other = imgid;
                    this._copyClipInfo(submit, this._globalClipMatrix);
                }
                submit._numEle += 6;
                mesh.indexNum += 6;
                mesh.vertNum += 4;
                return true;
            }
        }
        transform4Points(a, m, out) {
            var tx = m.tx;
            var ty = m.ty;
            var ma = m.a;
            var mb = m.b;
            var mc = m.c;
            var md = m.d;
            var a0 = a[0];
            var a1 = a[1];
            var a2 = a[2];
            var a3 = a[3];
            var a4 = a[4];
            var a5 = a[5];
            var a6 = a[6];
            var a7 = a[7];
            if (m._bTransform) {
                out[0] = a0 * ma + a1 * mc + tx;
                out[1] = a0 * mb + a1 * md + ty;
                out[2] = a2 * ma + a3 * mc + tx;
                out[3] = a2 * mb + a3 * md + ty;
                out[4] = a4 * ma + a5 * mc + tx;
                out[5] = a4 * mb + a5 * md + ty;
                out[6] = a6 * ma + a7 * mc + tx;
                out[7] = a6 * mb + a7 * md + ty;
            }
            else {
                out[0] = a0 + tx;
                out[1] = a1 + ty;
                out[2] = a2 + tx;
                out[3] = a3 + ty;
                out[4] = a4 + tx;
                out[5] = a5 + ty;
                out[6] = a6 + tx;
                out[7] = a7 + ty;
            }
        }
        clipedOff(pt) {
            if (this._clipRect.width <= 0 || this._clipRect.height <= 0)
                return true;
            return false;
        }
        transformQuad(x, y, w, h, italicDeg, m, out) {
            var xoff = 0;
            if (italicDeg != 0) {
                xoff = Math.tan(italicDeg * Math.PI / 180) * h;
            }
            var maxx = x + w;
            var maxy = y + h;
            var tx = m.tx;
            var ty = m.ty;
            var ma = m.a;
            var mb = m.b;
            var mc = m.c;
            var md = m.d;
            var a0 = x + xoff;
            var a1 = y;
            var a2 = maxx + xoff;
            var a3 = y;
            var a4 = maxx;
            var a5 = maxy;
            var a6 = x;
            var a7 = maxy;
            if (m._bTransform) {
                out[0] = a0 * ma + a1 * mc + tx;
                out[1] = a0 * mb + a1 * md + ty;
                out[2] = a2 * ma + a3 * mc + tx;
                out[3] = a2 * mb + a3 * md + ty;
                out[4] = a4 * ma + a5 * mc + tx;
                out[5] = a4 * mb + a5 * md + ty;
                out[6] = a6 * ma + a7 * mc + tx;
                out[7] = a6 * mb + a7 * md + ty;
            }
            else {
                out[0] = a0 + tx;
                out[1] = a1 + ty;
                out[2] = a2 + tx;
                out[3] = a3 + ty;
                out[4] = a4 + tx;
                out[5] = a5 + ty;
                out[6] = a6 + tx;
                out[7] = a7 + ty;
            }
        }
        pushRT() {
            this.addRenderObject(SubmitCMD.create(null, RenderTexture2D.pushRT, this));
        }
        popRT() {
            this.addRenderObject(SubmitCMD.create(null, RenderTexture2D.popRT, this));
            this.breakNextMerge();
        }
        useRT(rt) {
            function _use(rt) {
                if (!rt) {
                    throw 'error useRT';
                }
                else {
                    rt.start();
                    rt.clear(0, 0, 0, 0);
                }
            }
            this.addRenderObject(SubmitCMD.create([rt], _use, this));
            this.breakNextMerge();
        }
        RTRestore(rt) {
            function _restore(rt) {
                rt.restore();
            }
            this.addRenderObject(SubmitCMD.create([rt], _restore, this));
            this.breakNextMerge();
        }
        breakNextMerge() {
            this._curSubmit = SubmitBase.RENDERBASE;
        }
        _repaintSprite() {
            this.sprite && this.sprite.repaint();
        }
        drawTextureWithTransform(tex, x, y, width, height, transform, tx, ty, alpha, blendMode, colorfilter = null, uv) {
            var oldcomp;
            var curMat = this._curMat;
            if (blendMode) {
                oldcomp = this.globalCompositeOperation;
                this.globalCompositeOperation = blendMode;
            }
            var oldColorFilter = this._colorFiler;
            if (colorfilter) {
                this.setColorFilter(colorfilter);
            }
            if (!transform) {
                this._drawTextureM(tex, x + tx, y + ty, width, height, curMat, alpha, uv);
                if (blendMode) {
                    this.globalCompositeOperation = oldcomp;
                }
                if (colorfilter) {
                    this.setColorFilter(oldColorFilter);
                }
                return;
            }
            var tmpMat = this._tmpMatrix;
            tmpMat.a = transform.a;
            tmpMat.b = transform.b;
            tmpMat.c = transform.c;
            tmpMat.d = transform.d;
            tmpMat.tx = transform.tx + tx;
            tmpMat.ty = transform.ty + ty;
            tmpMat._bTransform = transform._bTransform;
            if (transform && curMat._bTransform) {
                Matrix.mul(tmpMat, curMat, tmpMat);
                transform = tmpMat;
                transform._bTransform = true;
            }
            else {
                tmpMat.tx += curMat.tx;
                tmpMat.ty += curMat.ty;
                transform = tmpMat;
            }
            this._drawTextureM(tex, x, y, width, height, transform, alpha, uv);
            if (blendMode) {
                this.globalCompositeOperation = oldcomp;
            }
            if (colorfilter) {
                this.setColorFilter(oldColorFilter);
            }
        }
        _flushToTarget(context, target) {
            RenderState2D.worldScissorTest = false;
            LayaGL.renderEngine.scissorTest(false);
            var preAlpha = RenderState2D.worldAlpha;
            var preMatrix4 = RenderState2D.worldMatrix4;
            var preMatrix = RenderState2D.worldMatrix;
            RenderState2D.worldShaderDefines;
            RenderState2D.worldMatrix = Matrix.EMPTY;
            RenderState2D.restoreTempArray();
            RenderState2D.worldMatrix4 = RenderState2D.TEMPMAT4_ARRAY;
            RenderState2D.worldAlpha = 1;
            BaseShader.activeShader = null;
            target.start();
            if (context._submits._length > 0)
                target.clear(0, 0, 0, 0);
            context._curSubmit = SubmitBase.RENDERBASE;
            context.flush();
            context.clear();
            target.restore();
            context._curSubmit = SubmitBase.RENDERBASE;
            BaseShader.activeShader = null;
            RenderState2D.worldAlpha = preAlpha;
            RenderState2D.worldMatrix4 = preMatrix4;
            RenderState2D.worldMatrix = preMatrix;
        }
        drawCanvas(canvas, x, y, width, height) {
            if (!canvas)
                return;
            var src = canvas.context;
            var submit;
            if (src._targets) {
                if (src._submits._length > 0) {
                    submit = SubmitCMD.create([src, src._targets], this._flushToTarget, this);
                    this._submits[this._submits._length++] = submit;
                }
                this._drawRenderTexture(src._targets, x, y, width, height, null, 1.0, RenderTexture2D.flipyuv);
                this._curSubmit = SubmitBase.RENDERBASE;
            }
            else {
                var canv = canvas;
                if (canv.touches) {
                    canv.touches.forEach(function (v) { v.touch(); });
                }
                submit = SubmitCanvas.create(canvas, this._shader2D.ALPHA, this._shader2D.filters);
                this._submits[this._submits._length++] = submit;
                submit._key.clear();
                var mat = submit._matrix;
                this._curMat.copyTo(mat);
                var tx = mat.tx, ty = mat.ty;
                mat.tx = mat.ty = 0;
                mat.transformPoint(Point.TEMP.setTo(x, y));
                mat.translate(Point.TEMP.x + tx, Point.TEMP.y + ty);
                Matrix.mul(canv.invMat, mat, mat);
                this._curSubmit = SubmitBase.RENDERBASE;
            }
        }
        drawTarget(rt, x, y, width, height, m, shaderValue, uv = null, blend = -1) {
            this._drawCount++;
            if (this._mesh.vertNum + 4 > Context._MAXVERTNUM) {
                this._mesh = MeshQuadTexture.getAMesh(this.isMain);
                this.meshlist.push(this._mesh);
            }
            this.transformQuad(x, y, width, height, 0, m || this._curMat, this._transedPoints);
            if (!this.clipedOff(this._transedPoints)) {
                this._mesh.addQuad(this._transedPoints, uv || Texture.DEF_UV, 0xffffffff, true);
                var submit = this._curSubmit = SubmitTarget.create(this, this._mesh, shaderValue, rt);
                submit.blendType = (blend == -1) ? this._nBlendType : blend;
                this._copyClipInfo(submit, this._globalClipMatrix);
                submit._numEle = 6;
                this._mesh.indexNum += 6;
                this._mesh.vertNum += 4;
                this._submits[this._submits._length++] = submit;
                this._curSubmit = SubmitBase.RENDERBASE;
                return true;
            }
            this._curSubmit = SubmitBase.RENDERBASE;
            return false;
        }
        drawTriangles(tex, x, y, vertices, uvs, indices, matrix, alpha, color, blendMode, colorNum = 0xffffffff) {
            if (!tex._getSource()) {
                if (this.sprite) {
                    ILaya.systemTimer.callLater(this, this._repaintSprite);
                }
                return;
            }
            var oldcomp = null;
            if (blendMode) {
                oldcomp = this.globalCompositeOperation;
                this.globalCompositeOperation = blendMode;
            }
            this._drawCount++;
            var tmpMat = this._tmpMatrix;
            var triMesh = this._triangleMesh;
            var oldColorFilter = null;
            var needRestorFilter = false;
            if (color) {
                oldColorFilter = this._colorFiler;
                this._colorFiler = color;
                this._curSubmit = SubmitBase.RENDERBASE;
                needRestorFilter = oldColorFilter != color;
            }
            var webGLImg = tex.bitmap;
            var preKey = this._curSubmit._key;
            var sameKey = preKey.submitType === SubmitBase.KEY_TRIANGLES && preKey.other === webGLImg.id && preKey.blendShader == this._nBlendType;
            if (triMesh.vertNum + vertices.length / 2 > Context._MAXVERTNUM) {
                triMesh = this._triangleMesh = MeshTexture.getAMesh(this.isMain);
                this.meshlist.push(triMesh);
                sameKey = false;
            }
            if (!sameKey) {
                var submit = this._curSubmit = SubmitTexture.create(this, triMesh, Value2D.create(ShaderDefines2D.TEXTURE2D, 0));
                submit.shaderValue.textureHost = tex;
                submit._renderType = SubmitBase.TYPE_TEXTURE;
                submit._key.submitType = SubmitBase.KEY_TRIANGLES;
                submit._key.other = webGLImg.id;
                this._copyClipInfo(submit, this._globalClipMatrix);
                this._submits[this._submits._length++] = submit;
            }
            var rgba = this._mixRGBandAlpha(colorNum, this._shader2D.ALPHA * alpha);
            if (!this._drawTriUseAbsMatrix) {
                if (!matrix) {
                    tmpMat.a = 1;
                    tmpMat.b = 0;
                    tmpMat.c = 0;
                    tmpMat.d = 1;
                    tmpMat.tx = x;
                    tmpMat.ty = y;
                }
                else {
                    tmpMat.a = matrix.a;
                    tmpMat.b = matrix.b;
                    tmpMat.c = matrix.c;
                    tmpMat.d = matrix.d;
                    tmpMat.tx = matrix.tx + x;
                    tmpMat.ty = matrix.ty + y;
                }
                Matrix.mul(tmpMat, this._curMat, tmpMat);
                triMesh.addData(vertices, uvs, indices, tmpMat || this._curMat, rgba);
            }
            else {
                triMesh.addData(vertices, uvs, indices, matrix, rgba);
            }
            this._curSubmit._numEle += indices.length;
            if (needRestorFilter) {
                this._colorFiler = oldColorFilter;
                this._curSubmit = SubmitBase.RENDERBASE;
            }
            if (blendMode) {
                this.globalCompositeOperation = oldcomp;
            }
        }
        transform(a, b, c, d, tx, ty) {
            SaveTransform.save(this);
            Matrix.mul(Matrix.TEMP.setTo(a, b, c, d, tx, ty), this._curMat, this._curMat);
            this._curMat._checkTransform();
        }
        _transformByMatrix(matrix, tx, ty) {
            matrix.setTranslate(tx, ty);
            Matrix.mul(matrix, this._curMat, this._curMat);
            matrix.setTranslate(0, 0);
            this._curMat._bTransform = true;
        }
        setTransformByMatrix(value) {
            value.copyTo(this._curMat);
        }
        rotate(angle) {
            SaveTransform.save(this);
            this._curMat.rotateEx(angle);
        }
        scale(scaleX, scaleY) {
            SaveTransform.save(this);
            this._curMat.scaleEx(scaleX, scaleY);
        }
        clipRect(x, y, width, height, escape) {
            SaveClipRect.save(this);
            if (this._clipRect == Context.MAXCLIPRECT) {
                this._clipRect = new Rectangle(x, y, width, height);
            }
            else {
                this._clipRect.width = width;
                this._clipRect.height = height;
                this._clipRect.x = x;
                this._clipRect.y = y;
            }
            this._clipID_Gen++;
            this._clipID_Gen %= 10000;
            this._clipInfoID = this._clipID_Gen;
            if (escape) {
                defaultClipMatrix.copyTo(this._globalClipMatrix);
                return;
            }
            var cm = this._globalClipMatrix;
            var minx = cm.tx;
            var miny = cm.ty;
            var maxx = minx + cm.a;
            var maxy = miny + cm.d;
            if (this._clipRect.width >= Const.MAX_CLIP_SIZE) {
                cm.a = cm.d = Const.MAX_CLIP_SIZE;
                cm.b = cm.c = cm.tx = cm.ty = 0;
            }
            else {
                if (this._curMat._bTransform) {
                    cm.tx = this._clipRect.x * this._curMat.a + this._clipRect.y * this._curMat.c + this._curMat.tx;
                    cm.ty = this._clipRect.x * this._curMat.b + this._clipRect.y * this._curMat.d + this._curMat.ty;
                    cm.a = this._clipRect.width * this._curMat.a;
                    cm.b = this._clipRect.width * this._curMat.b;
                    cm.c = this._clipRect.height * this._curMat.c;
                    cm.d = this._clipRect.height * this._curMat.d;
                }
                else {
                    cm.tx = this._clipRect.x + this._curMat.tx;
                    cm.ty = this._clipRect.y + this._curMat.ty;
                    cm.a = this._clipRect.width;
                    cm.b = cm.c = 0;
                    cm.d = this._clipRect.height;
                }
                if (this._incache) {
                    this._clipInCache = true;
                }
            }
            if (cm.a > 0 && cm.d > 0) {
                var cmaxx = cm.tx + cm.a;
                var cmaxy = cm.ty + cm.d;
                if (cmaxx <= minx || cmaxy <= miny || cm.tx >= maxx || cm.ty >= maxy) {
                    cm.a = -0.1;
                    cm.d = -0.1;
                }
                else {
                    if (cm.tx < minx) {
                        cm.a -= (minx - cm.tx);
                        cm.tx = minx;
                    }
                    if (cmaxx > maxx) {
                        cm.a -= (cmaxx - maxx);
                    }
                    if (cm.ty < miny) {
                        cm.d -= (miny - cm.ty);
                        cm.ty = miny;
                    }
                    if (cmaxy > maxy) {
                        cm.d -= (cmaxy - maxy);
                    }
                    if (cm.a <= 0)
                        cm.a = -0.1;
                    if (cm.d <= 0)
                        cm.d = -0.1;
                }
            }
        }
        addRenderObject(o) {
            this._submits[this._submits._length++] = o;
        }
        submitElement(start, end) {
            this.isMain;
            var renderList = this._submits;
            var ret = renderList._length;
            end < 0 && (end = renderList._length);
            var submit = SubmitBase.RENDERBASE;
            while (start < end) {
                this._renderNextSubmitIndex = start + 1;
                if (renderList[start] === SubmitBase.RENDERBASE) {
                    start++;
                    continue;
                }
                SubmitBase.preRender = submit;
                submit = renderList[start];
                start += submit.renderSubmit();
            }
            return ret;
        }
        flush() {
            this._clipID_Gen = 0;
            var ret = this.submitElement(0, this._submits._length);
            this._path && this._path.reset();
            SkinMeshBuffer.instance && SkinMeshBuffer.getInstance().reset();
            this._curSubmit = SubmitBase.RENDERBASE;
            for (var i = 0, sz = this.meshlist.length; i < sz; i++) {
                var curm = this.meshlist[i];
                curm.canReuse ? (curm.releaseMesh()) : (curm.destroy());
            }
            this.meshlist.length = 0;
            this._mesh = MeshQuadTexture.getAMesh(this.isMain);
            this._pathMesh = MeshVG.getAMesh(this.isMain);
            this._triangleMesh = MeshTexture.getAMesh(this.isMain);
            this.meshlist.push(this._mesh, this._pathMesh, this._triangleMesh);
            this._flushCnt++;
            if (this._flushCnt % 60 == 0 && this.isMain) {
                if (TextRender.textRenderInst) {
                    TextRender.textRenderInst.GC();
                }
            }
            return ret;
        }
        beginPath(convex = false) {
            var tPath = this._getPath();
            tPath.beginPath(convex);
        }
        closePath() {
            this._path.closePath();
        }
        addPath(points, close, convex, dx, dy) {
            let sz = points.length;
            for (let i = 0; i < sz - 1; i += 2) {
                points[i] += dx;
                points[i + 1] += dy;
            }
            if (close && sz > 5 && (points[sz - 2] != points[0] || points[sz - 1] != points[1])) {
                points.push(points[0], points[1]);
            }
            this._getPath().push(points, convex);
        }
        fill() {
            var m = this._curMat;
            var tPath = this._getPath();
            var submit = this._curSubmit;
            var sameKey = (submit._key.submitType === SubmitBase.KEY_VG && submit._key.blendShader === this._nBlendType);
            sameKey && (sameKey = sameKey && this.isSameClipInfo(submit));
            if (!sameKey) {
                this._curSubmit = this.addVGSubmit(this._pathMesh);
            }
            var rgba = this.mixRGBandAlpha(this.fillStyle.toInt());
            var curEleNum = 0;
            var idx;
            for (var i = 0, sz = tPath.paths.length; i < sz; i++) {
                var p = tPath.paths[i];
                var vertNum = p.path.length / 2;
                if (vertNum < 3 || (vertNum == 3 && !p.convex))
                    continue;
                var cpath = p.path.concat();
                var pi = 0;
                var xp, yp;
                var _x, _y;
                if (m._bTransform) {
                    for (pi = 0; pi < vertNum; pi++) {
                        xp = pi << 1;
                        yp = xp + 1;
                        _x = cpath[xp];
                        _y = cpath[yp];
                        cpath[xp] = m.a * _x + m.c * _y + m.tx;
                        cpath[yp] = m.b * _x + m.d * _y + m.ty;
                    }
                }
                else {
                    for (pi = 0; pi < vertNum; pi++) {
                        xp = pi << 1;
                        yp = xp + 1;
                        _x = cpath[xp];
                        _y = cpath[yp];
                        cpath[xp] = _x + m.tx;
                        cpath[yp] = _y + m.ty;
                    }
                }
                if (this._pathMesh.vertNum + vertNum > Context._MAXVERTNUM) {
                    this._curSubmit._numEle += curEleNum;
                    curEleNum = 0;
                    this._pathMesh = MeshVG.getAMesh(this.isMain);
                    this._curSubmit = this.addVGSubmit(this._pathMesh);
                }
                var curvert = this._pathMesh.vertNum;
                if (p.convex) {
                    var faceNum = vertNum - 2;
                    idx = new Array(faceNum * 3);
                    var idxpos = 0;
                    for (var fi = 0; fi < faceNum; fi++) {
                        idx[idxpos++] = curvert;
                        idx[idxpos++] = fi + 1 + curvert;
                        idx[idxpos++] = fi + 2 + curvert;
                    }
                }
                else {
                    idx = Earcut.earcut(cpath, null, 2);
                    if (curvert > 0) {
                        for (var ii = 0; ii < idx.length; ii++) {
                            idx[ii] += curvert;
                        }
                    }
                }
                this._pathMesh.addVertAndIBToMesh(this, cpath, rgba, idx);
                curEleNum += idx.length;
            }
            this._curSubmit._numEle += curEleNum;
        }
        addVGSubmit(mesh) {
            var submit = Submit.createShape(this, mesh, 0, Value2D.create(ShaderDefines2D.PRIMITIVE, 0));
            submit._key.submitType = SubmitBase.KEY_VG;
            this._submits[this._submits._length++] = submit;
            this._copyClipInfo(submit, this._globalClipMatrix);
            return submit;
        }
        stroke() {
            if (this.lineWidth > 0) {
                var rgba = this.mixRGBandAlpha(this.strokeStyle._color.numColor);
                var tPath = this._getPath();
                var submit = this._curSubmit;
                var sameKey = (submit._key.submitType === SubmitBase.KEY_VG && submit._key.blendShader === this._nBlendType);
                sameKey && (sameKey = sameKey && this.isSameClipInfo(submit));
                if (!sameKey) {
                    this._curSubmit = this.addVGSubmit(this._pathMesh);
                }
                var curEleNum = 0;
                for (var i = 0, sz = tPath.paths.length; i < sz; i++) {
                    var p = tPath.paths[i];
                    if (p.path.length <= 0)
                        continue;
                    var idx = [];
                    var vertex = [];
                    var maxVertexNum = p.path.length * 2;
                    if (maxVertexNum < 2)
                        continue;
                    if (this._pathMesh.vertNum + maxVertexNum > Context._MAXVERTNUM) {
                        this._curSubmit._numEle += curEleNum;
                        curEleNum = 0;
                        this._pathMesh = MeshVG.getAMesh(this.isMain);
                        this.meshlist.push(this._pathMesh);
                        this._curSubmit = this.addVGSubmit(this._pathMesh);
                    }
                    BasePoly.createLine2(p.path, idx, this.lineWidth, this._pathMesh.vertNum, vertex, p.loop);
                    var ptnum = vertex.length / 2;
                    var m = this._curMat;
                    var pi = 0;
                    var xp, yp;
                    var _x, _y;
                    if (m._bTransform) {
                        for (pi = 0; pi < ptnum; pi++) {
                            xp = pi << 1;
                            yp = xp + 1;
                            _x = vertex[xp];
                            _y = vertex[yp];
                            vertex[xp] = m.a * _x + m.c * _y + m.tx;
                            vertex[yp] = m.b * _x + m.d * _y + m.ty;
                        }
                    }
                    else {
                        for (pi = 0; pi < ptnum; pi++) {
                            xp = pi << 1;
                            yp = xp + 1;
                            _x = vertex[xp];
                            _y = vertex[yp];
                            vertex[xp] = _x + m.tx;
                            vertex[yp] = _y + m.ty;
                        }
                    }
                    this._pathMesh.addVertAndIBToMesh(this, vertex, rgba, idx);
                    curEleNum += idx.length;
                }
                this._curSubmit._numEle += curEleNum;
            }
        }
        moveTo(x, y) {
            var tPath = this._getPath();
            tPath.newPath();
            tPath._lastOriX = x;
            tPath._lastOriY = y;
            tPath.addPoint(x, y);
        }
        lineTo(x, y) {
            var tPath = this._getPath();
            if (Math.abs(x - tPath._lastOriX) < 1e-3 && Math.abs(y - tPath._lastOriY) < 1e-3)
                return;
            tPath._lastOriX = x;
            tPath._lastOriY = y;
            tPath.addPoint(x, y);
        }
        arcTo(x1, y1, x2, y2, r) {
            var i = 0;
            var x = 0, y = 0;
            var dx = this._path._lastOriX - x1;
            var dy = this._path._lastOriY - y1;
            var len1 = Math.sqrt(dx * dx + dy * dy);
            if (len1 <= 0.000001) {
                return;
            }
            var ndx = dx / len1;
            var ndy = dy / len1;
            var dx2 = x2 - x1;
            var dy2 = y2 - y1;
            var len22 = dx2 * dx2 + dy2 * dy2;
            var len2 = Math.sqrt(len22);
            if (len2 <= 0.000001) {
                return;
            }
            var ndx2 = dx2 / len2;
            var ndy2 = dy2 / len2;
            var odx = ndx + ndx2;
            var ody = ndy + ndy2;
            var olen = Math.sqrt(odx * odx + ody * ody);
            if (olen <= 0.000001) {
                return;
            }
            var nOdx = odx / olen;
            var nOdy = ody / olen;
            var alpha = Math.acos(nOdx * ndx + nOdy * ndy);
            var halfAng = Math.PI / 2 - alpha;
            len1 = r / Math.tan(halfAng);
            var ptx1 = len1 * ndx + x1;
            var pty1 = len1 * ndy + y1;
            var orilen = Math.sqrt(len1 * len1 + r * r);
            var orix = x1 + nOdx * orilen;
            var oriy = y1 + nOdy * orilen;
            var dir = ndx * ndy2 - ndy * ndx2;
            var fChgAng = 0;
            var sinx = 0.0;
            var cosx = 0.0;
            if (dir >= 0) {
                fChgAng = halfAng * 2;
                var fda = fChgAng / Context.SEGNUM;
                sinx = Math.sin(fda);
                cosx = Math.cos(fda);
            }
            else {
                fChgAng = -halfAng * 2;
                fda = fChgAng / Context.SEGNUM;
                sinx = Math.sin(fda);
                cosx = Math.cos(fda);
            }
            var lastx = this._path._lastOriX, lasty = this._path._lastOriY;
            var _x1 = ptx1, _y1 = pty1;
            if (Math.abs(_x1 - this._path._lastOriX) > 0.1 || Math.abs(_y1 - this._path._lastOriY) > 0.1) {
                x = _x1;
                y = _y1;
                lastx = _x1;
                lasty = _y1;
                this._path._lastOriX = x;
                this._path._lastOriY = y;
                this._path.addPoint(x, y);
            }
            var cvx = ptx1 - orix;
            var cvy = pty1 - oriy;
            for (i = 0; i < Context.SEGNUM; i++) {
                var cx = cvx * cosx + cvy * sinx;
                var cy = -cvx * sinx + cvy * cosx;
                x = cx + orix;
                y = cy + oriy;
                if (Math.abs(lastx - x) > 0.1 || Math.abs(lasty - y) > 0.1) {
                    this._path._lastOriX = x;
                    this._path._lastOriY = y;
                    this._path.addPoint(x, y);
                    lastx = x;
                    lasty = y;
                }
                cvx = cx;
                cvy = cy;
            }
        }
        arc(cx, cy, r, startAngle, endAngle, counterclockwise = false, b = true) {
            var a = 0, da = 0;
            var dx = 0, dy = 0, x = 0, y = 0;
            var i, ndivs;
            da = endAngle - startAngle;
            if (!counterclockwise) {
                if (Math.abs(da) >= Math.PI * 2) {
                    da = Math.PI * 2;
                }
                else {
                    while (da < 0.0) {
                        da += Math.PI * 2;
                    }
                }
            }
            else {
                if (Math.abs(da) >= Math.PI * 2) {
                    da = -Math.PI * 2;
                }
                else {
                    while (da > 0.0) {
                        da -= Math.PI * 2;
                    }
                }
            }
            var sx = this.getMatScaleX();
            var sy = this.getMatScaleY();
            var sr = r * (sx > sy ? sx : sy);
            var cl = 2 * Math.PI * sr;
            ndivs = (Math.max(cl / 10, 10)) | 0;
            var tPath = this._getPath();
            for (i = 0; i <= ndivs; i++) {
                a = startAngle + da * (i / ndivs);
                dx = Math.cos(a);
                dy = Math.sin(a);
                x = cx + dx * r;
                y = cy + dy * r;
                if (x != this._path._lastOriX || y != this._path._lastOriY) {
                    tPath.addPoint(x, y);
                }
            }
            dx = Math.cos(endAngle);
            dy = Math.sin(endAngle);
            x = cx + dx * r;
            y = cy + dy * r;
            if (x != this._path._lastOriX || y != this._path._lastOriY) {
                tPath.addPoint(x, y);
            }
        }
        quadraticCurveTo(cpx, cpy, x, y) {
            var tBezier = Bezier.I;
            var tArray = tBezier.getBezierPoints([this._path._lastOriX, this._path._lastOriY, cpx, cpy, x, y], 30, 2);
            for (var i = 0, n = tArray.length / 2; i < n; i++) {
                this.lineTo(tArray[i * 2], tArray[i * 2 + 1]);
            }
            this.lineTo(x, y);
        }
        mixRGBandAlpha(color) {
            return this._mixRGBandAlpha(color, this._shader2D.ALPHA);
        }
        _mixRGBandAlpha(color, alpha) {
            if (alpha >= 1) {
                return color;
            }
            var a = ((color & 0xff000000) >>> 24);
            if (a != 0) {
                a *= alpha;
            }
            else {
                a = alpha * 255;
            }
            return (color & 0x00ffffff) | (a << 24);
        }
        strokeRect(x, y, width, height, parameterLineWidth) {
            if (this.lineWidth > 0) {
                var rgba = this.mixRGBandAlpha(this.strokeStyle._color.numColor);
                var hw = this.lineWidth / 2;
                this._fillRect(x - hw, y - hw, width + this.lineWidth, this.lineWidth, rgba);
                this._fillRect(x - hw, y - hw + height, width + this.lineWidth, this.lineWidth, rgba);
                this._fillRect(x - hw, y + hw, this.lineWidth, height - this.lineWidth, rgba);
                this._fillRect(x - hw + width, y + hw, this.lineWidth, height - this.lineWidth, rgba);
            }
        }
        clip() {
        }
        drawParticle(x, y, pt) {
            pt.x = x;
            pt.y = y;
            this._submits[this._submits._length++] = pt;
        }
        _getPath() {
            return this._path || (this._path = new Path());
        }
        get canvas() {
            return this._canvas;
        }
        _fillTexture_h(tex, imgid, uv, oriw, orih, x, y, w) {
            if (oriw <= 0)
                console.error('_fillTexture_h error: oriw must>0');
            var stx = x;
            var num = Math.floor(w / oriw);
            var left = w % oriw;
            for (var i = 0; i < num; i++) {
                this._inner_drawTexture(tex, imgid, stx, y, oriw, orih, this._curMat, uv, 1, false);
                stx += oriw;
            }
            if (left > 0) {
                var du = uv[2] - uv[0];
                var uvr = uv[0] + du * (left / oriw);
                var tuv = Context.tmpuv1;
                tuv[0] = uv[0];
                tuv[1] = uv[1];
                tuv[2] = uvr;
                tuv[3] = uv[3];
                tuv[4] = uvr;
                tuv[5] = uv[5];
                tuv[6] = uv[6];
                tuv[7] = uv[7];
                this._inner_drawTexture(tex, imgid, stx, y, left, orih, this._curMat, tuv, 1, false);
            }
        }
        _fillTexture_v(tex, imgid, uv, oriw, orih, x, y, h) {
            if (orih <= 0)
                console.error('_fillTexture_v error: orih must>0');
            var sty = y;
            var num = Math.floor(h / orih);
            var left = h % orih;
            for (var i = 0; i < num; i++) {
                this._inner_drawTexture(tex, imgid, x, sty, oriw, orih, this._curMat, uv, 1, false);
                sty += orih;
            }
            if (left > 0) {
                var dv = uv[7] - uv[1];
                var uvb = uv[1] + dv * (left / orih);
                var tuv = Context.tmpuv1;
                tuv[0] = uv[0];
                tuv[1] = uv[1];
                tuv[2] = uv[2];
                tuv[3] = uv[3];
                tuv[4] = uv[4];
                tuv[5] = uvb;
                tuv[6] = uv[6];
                tuv[7] = uvb;
                this._inner_drawTexture(tex, imgid, x, sty, oriw, left, this._curMat, tuv, 1, false);
            }
        }
        drawTextureWithSizeGrid(tex, tx, ty, width, height, sizeGrid, gx, gy) {
            if (!tex._getSource())
                return;
            tx += gx;
            ty += gy;
            var uv = tex.uv, w = tex.bitmap.width, h = tex.bitmap.height;
            var top = sizeGrid[0];
            var left = sizeGrid[3];
            var right = sizeGrid[1];
            var bottom = sizeGrid[2];
            var repeat = sizeGrid[4];
            if (width == tex.width) {
                left = right = 0;
            }
            if (height == tex.height) {
                top = bottom = 0;
            }
            var d_top = top / h;
            var d_left = left / w;
            var d_right = right / w;
            var d_bottom = bottom / h;
            var imgid = tex.bitmap.id;
            var mat = this._curMat;
            var tuv = this._tempUV;
            var scale_x = 1;
            var scale_y = 1;
            if (left + right > width)
                scale_x = width / (left + right);
            if (top + bottom > height)
                scale_y = height / (top + bottom);
            left *= scale_x;
            right *= scale_x;
            top *= scale_y;
            bottom *= scale_y;
            var uvl = uv[0];
            var uvt = uv[1];
            var uvr = uv[4];
            var uvb = uv[5];
            var uvl_ = uvl;
            var uvt_ = uvt;
            var uvr_ = uvr;
            var uvb_ = uvb;
            if (left && top) {
                uvr_ = uvl + d_left;
                uvb_ = uvt + d_top;
                tuv[0] = uvl, tuv[1] = uvt, tuv[2] = uvr_, tuv[3] = uvt,
                    tuv[4] = uvr_, tuv[5] = uvb_, tuv[6] = uvl, tuv[7] = uvb_;
                this._inner_drawTexture(tex, imgid, tx, ty, left, top, mat, tuv, 1, false);
            }
            if (right && top) {
                uvl_ = uvr - d_right;
                uvt_ = uvt;
                uvr_ = uvr;
                uvb_ = uvt + d_top;
                tuv[0] = uvl_, tuv[1] = uvt_, tuv[2] = uvr_, tuv[3] = uvt_,
                    tuv[4] = uvr_, tuv[5] = uvb_, tuv[6] = uvl_, tuv[7] = uvb_;
                this._inner_drawTexture(tex, imgid, width - right + tx, 0 + ty, right, top, mat, tuv, 1, false);
            }
            if (left && bottom) {
                uvl_ = uvl;
                uvt_ = uvb - d_bottom;
                uvr_ = uvl + d_left;
                uvb_ = uvb;
                tuv[0] = uvl_, tuv[1] = uvt_, tuv[2] = uvr_, tuv[3] = uvt_,
                    tuv[4] = uvr_, tuv[5] = uvb_, tuv[6] = uvl_, tuv[7] = uvb_;
                this._inner_drawTexture(tex, imgid, 0 + tx, height - bottom + ty, left, bottom, mat, tuv, 1, false);
            }
            if (right && bottom) {
                uvl_ = uvr - d_right;
                uvt_ = uvb - d_bottom;
                uvr_ = uvr;
                uvb_ = uvb;
                tuv[0] = uvl_, tuv[1] = uvt_, tuv[2] = uvr_, tuv[3] = uvt_,
                    tuv[4] = uvr_, tuv[5] = uvb_, tuv[6] = uvl_, tuv[7] = uvb_;
                this._inner_drawTexture(tex, imgid, width - right + tx, height - bottom + ty, right, bottom, mat, tuv, 1, false);
            }
            if (top) {
                uvl_ = uvl + d_left;
                uvt_ = uvt;
                uvr_ = uvr - d_right;
                uvb_ = uvt + d_top;
                tuv[0] = uvl_, tuv[1] = uvt_, tuv[2] = uvr_, tuv[3] = uvt_,
                    tuv[4] = uvr_, tuv[5] = uvb_, tuv[6] = uvl_, tuv[7] = uvb_;
                if (repeat) {
                    this._fillTexture_h(tex, imgid, tuv, tex.width - left - right, top, left + tx, ty, width - left - right);
                }
                else {
                    this._inner_drawTexture(tex, imgid, left + tx, ty, width - left - right, top, mat, tuv, 1, false);
                }
            }
            if (bottom) {
                uvl_ = uvl + d_left;
                uvt_ = uvb - d_bottom;
                uvr_ = uvr - d_right;
                uvb_ = uvb;
                tuv[0] = uvl_, tuv[1] = uvt_, tuv[2] = uvr_, tuv[3] = uvt_,
                    tuv[4] = uvr_, tuv[5] = uvb_, tuv[6] = uvl_, tuv[7] = uvb_;
                if (repeat) {
                    this._fillTexture_h(tex, imgid, tuv, tex.width - left - right, bottom, left + tx, height - bottom + ty, width - left - right);
                }
                else {
                    this._inner_drawTexture(tex, imgid, left + tx, height - bottom + ty, width - left - right, bottom, mat, tuv, 1, false);
                }
            }
            if (left) {
                uvl_ = uvl;
                uvt_ = uvt + d_top;
                uvr_ = uvl + d_left;
                uvb_ = uvb - d_bottom;
                tuv[0] = uvl_, tuv[1] = uvt_, tuv[2] = uvr_, tuv[3] = uvt_,
                    tuv[4] = uvr_, tuv[5] = uvb_, tuv[6] = uvl_, tuv[7] = uvb_;
                if (repeat) {
                    this._fillTexture_v(tex, imgid, tuv, left, tex.height - top - bottom, tx, top + ty, height - top - bottom);
                }
                else {
                    this._inner_drawTexture(tex, imgid, tx, top + ty, left, height - top - bottom, mat, tuv, 1, false);
                }
            }
            if (right) {
                uvl_ = uvr - d_right;
                uvt_ = uvt + d_top;
                uvr_ = uvr;
                uvb_ = uvb - d_bottom;
                tuv[0] = uvl_, tuv[1] = uvt_, tuv[2] = uvr_, tuv[3] = uvt_,
                    tuv[4] = uvr_, tuv[5] = uvb_, tuv[6] = uvl_, tuv[7] = uvb_;
                if (repeat) {
                    this._fillTexture_v(tex, imgid, tuv, right, tex.height - top - bottom, width - right + tx, top + ty, height - top - bottom);
                }
                else {
                    this._inner_drawTexture(tex, imgid, width - right + tx, top + ty, right, height - top - bottom, mat, tuv, 1, false);
                }
            }
            uvl_ = uvl + d_left;
            uvt_ = uvt + d_top;
            uvr_ = uvr - d_right;
            uvb_ = uvb - d_bottom;
            tuv[0] = uvl_, tuv[1] = uvt_, tuv[2] = uvr_, tuv[3] = uvt_,
                tuv[4] = uvr_, tuv[5] = uvb_, tuv[6] = uvl_, tuv[7] = uvb_;
            if (repeat) {
                var tuvr = Context.tmpUVRect;
                tuvr[0] = uvl_;
                tuvr[1] = uvt_;
                tuvr[2] = uvr_ - uvl_;
                tuvr[3] = uvb_ - uvt_;
                this._fillTexture(tex, tex.width - left - right, tex.height - top - bottom, tuvr, left + tx, top + ty, width - left - right, height - top - bottom, 'repeat', 0, 0);
            }
            else {
                this._inner_drawTexture(tex, imgid, left + tx, top + ty, width - left - right, height - top - bottom, mat, tuv, 1, false);
            }
        }
        addRenderObject3D(scene3D) {
            this._curSubmit = SubmitBase.RENDERBASE;
            this.addRenderObject(scene3D);
        }
    }
    Context._SUBMITVBSIZE = 32000;
    Context._MAXVERTNUM = 65535;
    Context.MAXCLIPRECT = null;
    Context._COUNT = 0;
    Context.SEGNUM = 32;
    Context._contextcount = 0;
    Context.PI2 = 2 * Math.PI;
    Context._textRender = null;
    Context.tmpuv1 = [0, 0, 0, 0, 0, 0, 0, 0];
    Context.tmpUV = [0, 0, 0, 0, 0, 0, 0, 0];
    Context.tmpUVRect = [0, 0, 0, 0];
    class ContextParams {
        constructor() {
            this.lineWidth = 1;
        }
        clear() {
            this.lineWidth = 1;
            this.textAlign = this.textBaseline = null;
        }
        make() {
            return this === ContextParams.DEFAULT ? new ContextParams() : this;
        }
    }
    if (window.conch && !window.conchConfig.conchWebGL) {
        Context = NativeContext;
    }

    class HTMLCanvas extends Resource {
        constructor(createCanvas = false) {
            super();
            if (createCanvas)
                this._source = Browser.createElement("canvas");
            else {
                this._source = this;
            }
            this.lock = true;
        }
        get source() {
            return this._source;
        }
        get width() {
            return this._width;
        }
        set width(width) {
            this._width = width;
        }
        get height() {
            return this._height;
        }
        set height(height) {
            this._height = height;
        }
        _getSource() {
            return this._source;
        }
        clear() {
            if (this._ctx) {
                if (this._ctx.clear) {
                    this._ctx.clear();
                }
                else {
                    this._ctx.clearRect(0, 0, this._width, this._height);
                }
            }
            if (this._texture) {
                this._texture.destroy();
                this._texture = null;
            }
        }
        destroy() {
            super.destroy();
            this._setCPUMemory(0);
            this._ctx && this._ctx.destroy && this._ctx.destroy();
            this._ctx = null;
        }
        release() {
        }
        get context() {
            if (this._ctx)
                return this._ctx;
            if (this._source == this) {
                this._ctx = new Context();
            }
            else {
                this._ctx = this._source.getContext(LayaEnv.isConch ? 'layagl' : '2d');
            }
            this._ctx._canvas = this;
            return this._ctx;
        }
        _setContext(context) {
            this._ctx = context;
        }
        getContext(contextID, other = null) {
            return this.context;
        }
        getMemSize() {
            return 0;
        }
        size(w, h) {
            if (this._width != w || this._height != h || (this._source && (this._source.width != w || this._source.height != h))) {
                this._width = w;
                this._height = h;
                this._setCPUMemory(w * h * 4);
                this._ctx && this._ctx.size && this._ctx.size(w, h);
                if (this._source) {
                    this._source.height = h;
                    this._source.width = w;
                }
                if (this._texture) {
                    this._texture.destroy();
                    this._texture = null;
                }
            }
        }
        getTexture() {
            if (!this._texture) {
                var bitmap = new Texture2D(this.source.width, this.source.height, exports.TextureFormat.R8G8B8A8, true, false, false);
                bitmap.setImageData(this.source, false, false);
                this._texture = new Texture(bitmap);
            }
            return this._texture;
        }
        toBase64(type, encoderOptions) {
            if (this._source) {
                if (LayaEnv.isConch) {
                    var win = window;
                    var width = this._ctx._targets.sourceWidth;
                    var height = this._ctx._targets.sourceHeight;
                    var data = this._ctx._targets.getData(0, 0, width, height);
                    return win.conchToBase64FlipY ? win.conchToBase64FlipY(type, encoderOptions, data.buffer, width, height) : win.conchToBase64(type, encoderOptions, data.buffer, width, height);
                }
                else {
                    return this._source.toDataURL(type, encoderOptions);
                }
            }
            return null;
        }
        toBase64Async(type, encoderOptions, callBack) {
            var width = this._ctx._targets.sourceWidth;
            var height = this._ctx._targets.sourceHeight;
            this._ctx._targets.getDataAsync(0, 0, width, height, function (data) {
                let win = window;
                var base64 = win.conchToBase64FlipY ? win.conchToBase64FlipY(type, encoderOptions, data.buffer, width, height) : win.conchToBase64(type, encoderOptions, data.buffer, width, height);
                callBack(base64);
            });
        }
    }

    class BoundsStyle {
        reset() {
            if (this.bounds)
                this.bounds.recover();
            if (this.userBounds)
                this.userBounds.recover();
            this.bounds = null;
            this.userBounds = null;
            this.temBM = null;
            return this;
        }
        recover() {
            Pool.recover("BoundsStyle", this.reset());
        }
        static create() {
            return Pool.getItemByClass("BoundsStyle", BoundsStyle);
        }
    }

    class CacheStyle {
        constructor() {
            this.reset();
        }
        needBitmapCache() {
            return this.cacheForFilters || !!this.mask;
        }
        needEnableCanvasRender() {
            return this.userSetCache != "none" || this.cacheForFilters || !!this.mask;
        }
        releaseContext() {
            if (this.canvas && this.canvas.size) {
                Pool.recover("CacheCanvas", this.canvas);
                this.canvas.size(0, 0);
                try {
                    this.canvas.width = 0;
                    this.canvas.height = 0;
                }
                catch (e) {
                }
            }
            this.canvas = null;
        }
        createContext() {
            if (!this.canvas) {
                this.canvas = Pool.getItem("CacheCanvas") || new HTMLCanvas(false);
                var tx = this.canvas.context;
                if (!tx) {
                    tx = this.canvas.getContext('2d');
                }
            }
        }
        releaseFilterCache() {
            var fc = this.filterCache;
            if (fc) {
                fc.destroy();
                fc.recycle();
                this.filterCache = null;
            }
        }
        recover() {
            if (this === CacheStyle.EMPTY)
                return;
            Pool.recover("SpriteCache", this.reset());
        }
        reset() {
            this.releaseContext();
            this.releaseFilterCache();
            this.cacheAs = "none";
            this.enableCanvasRender = false;
            this.userSetCache = "none";
            this.cacheForFilters = false;
            this.staticCache = false;
            this.reCache = true;
            this.mask = null;
            this.maskParent = null;
            this.filterCache = null;
            this.filters = null;
            this.hasGlowFilter = false;
            if (this.cacheRect)
                this.cacheRect.recover();
            this.cacheRect = null;
            return this;
        }
        static create() {
            return Pool.getItemByClass("SpriteCache", CacheStyle);
        }
        _calculateCacheRect(sprite, tCacheType, x, y) {
            var _cacheStyle = sprite._cacheStyle;
            if (!_cacheStyle.cacheRect)
                _cacheStyle.cacheRect = Rectangle.create();
            var tRec;
            if (tCacheType === "bitmap") {
                tRec = sprite.getSelfBounds();
                tRec.width = tRec.width + CacheStyle.CANVAS_EXTEND_EDGE * 2;
                tRec.height = tRec.height + CacheStyle.CANVAS_EXTEND_EDGE * 2;
                tRec.x = tRec.x - sprite.pivotX;
                tRec.y = tRec.y - sprite.pivotY;
                tRec.x = tRec.x - CacheStyle.CANVAS_EXTEND_EDGE;
                tRec.y = tRec.y - CacheStyle.CANVAS_EXTEND_EDGE;
                tRec.x = Math.floor(tRec.x + x) - x;
                tRec.y = Math.floor(tRec.y + y) - y;
                tRec.width = Math.floor(tRec.width);
                tRec.height = Math.floor(tRec.height);
                _cacheStyle.cacheRect.copyFrom(tRec);
            }
            else {
                _cacheStyle.cacheRect.setTo(-sprite._style.pivotX, -sprite._style.pivotY, 1, 1);
            }
            tRec = _cacheStyle.cacheRect;
            if (sprite._style.scrollRect) {
                var scrollRect = sprite._style.scrollRect;
                tRec.x -= scrollRect.x;
                tRec.y -= scrollRect.y;
            }
            CacheStyle._scaleInfo.setTo(1, 1);
            return CacheStyle._scaleInfo;
        }
    }
    CacheStyle.EMPTY = new CacheStyle();
    CacheStyle._scaleInfo = new Point();
    CacheStyle.CANVAS_EXTEND_EDGE = 16;

    class SpriteStyle {
        constructor() {
            this.reset();
        }
        reset() {
            this.scaleX = this.scaleY = 1;
            this.skewX = this.skewY = 0;
            this.pivotX = this.pivotY = this.rotation = 0;
            this.alpha = 1;
            if (this.scrollRect)
                this.scrollRect.recover();
            this.scrollRect = null;
            if (this.viewport)
                this.viewport.recover();
            this.viewport = null;
            this.hitArea = null;
            this.dragging = null;
            this.blendMode = null;
            return this;
        }
        recover() {
            if (this === SpriteStyle.EMPTY)
                return;
            Pool.recover("SpriteStyle", this.reset());
        }
        static create() {
            return Pool.getItemByClass("SpriteStyle", SpriteStyle);
        }
    }
    SpriteStyle.EMPTY = new SpriteStyle();

    class AlphaCmd {
        static create(alpha) {
            var cmd = Pool.getItemByClass("AlphaCmd", AlphaCmd);
            cmd.alpha = alpha;
            return cmd;
        }
        recover() {
            Pool.recover("AlphaCmd", this);
        }
        run(context, gx, gy) {
            context.alpha(this.alpha);
        }
        get cmdID() {
            return AlphaCmd.ID;
        }
    }
    AlphaCmd.ID = "Alpha";

    class ClassUtils {
        static regClass(className, classDef) {
            ClassUtils._classMap[className] = classDef;
        }
        static getClass(className) {
            return ClassUtils._classMap[className];
        }
        static getInstance(className) {
            var compClass = ClassUtils.getClass(className);
            if (compClass)
                return new compClass();
            else
                console.warn("[error] Undefined class:", className);
            return null;
        }
    }
    ClassUtils._classMap = {};

    class DrawCircleCmd {
        static create(x, y, radius, fillColor, lineColor, lineWidth) {
            var cmd = Pool.getItemByClass("DrawCircleCmd", DrawCircleCmd);
            var offset = (lineWidth >= 1 && lineColor) ? lineWidth / 2 : 0;
            cmd.x = x;
            cmd.y = y;
            cmd.radius = radius - offset;
            cmd.fillColor = fillColor;
            cmd.lineColor = lineColor;
            cmd.lineWidth = lineWidth;
            return cmd;
        }
        recover() {
            this.fillColor = null;
            this.lineColor = null;
            Pool.recover("DrawCircleCmd", this);
        }
        run(context, gx, gy) {
            if (this.percent && context.sprite) {
                let w = context.sprite.width;
                let h = context.sprite.height;
                context._drawCircle(this.x * w + gx, this.y * h + gy, this.radius * w, this.fillColor, this.lineColor, this.lineWidth, 0);
            }
            else
                context._drawCircle(this.x + gx, this.y + gy, this.radius, this.fillColor, this.lineColor, this.lineWidth, 0);
        }
        get cmdID() {
            return DrawCircleCmd.ID;
        }
        getBoundPoints(sp) {
            return Rectangle._getBoundPointS(this.x - this.radius, this.y - this.radius, this.radius + this.radius, this.radius + this.radius, this.percent ? sp : null);
        }
    }
    DrawCircleCmd.ID = "DrawCircle";
    ClassUtils.regClass("DrawCircleCmd", DrawCircleCmd);

    class DrawCurvesCmd {
        static create(x, y, points, lineColor, lineWidth) {
            var cmd = Pool.getItemByClass("DrawCurvesCmd", DrawCurvesCmd);
            cmd.x = x;
            cmd.y = y;
            cmd.points = points;
            cmd.lineColor = lineColor;
            cmd.lineWidth = lineWidth;
            return cmd;
        }
        recover() {
            this.points = null;
            this.lineColor = null;
            Pool.recover("DrawCurvesCmd", this);
        }
        run(context, gx, gy) {
            if (this.points)
                context.drawCurves(this.x + gx, this.y + gy, this.points, this.lineColor, this.lineWidth);
        }
        get cmdID() {
            return DrawCurvesCmd.ID;
        }
        getBoundPoints(sp) {
            return Bezier.I.getBezierPoints(this.points);
        }
    }
    DrawCurvesCmd.ID = "DrawCurves";
    ClassUtils.regClass("DrawCurvesCmd", DrawCurvesCmd);

    class DrawImageCmd {
        static create(texture, x, y, width, height) {
            if (!width)
                width = texture.sourceWidth;
            if (!height)
                height = texture.sourceHeight;
            if (texture.bitmap) {
                var wRate = width / texture.sourceWidth;
                var hRate = height / texture.sourceHeight;
                width = texture.width * wRate;
                height = texture.height * hRate;
                x += texture.offsetX * wRate;
                y += texture.offsetY * hRate;
            }
            var cmd = Pool.getItemByClass("DrawImageCmd", DrawImageCmd);
            cmd.texture = texture;
            texture._addReference();
            cmd.x = x;
            cmd.y = y;
            cmd.width = width;
            cmd.height = height;
            return cmd;
        }
        recover() {
            this.texture && this.texture._removeReference();
            this.texture = null;
            Pool.recover("DrawImageCmd", this);
        }
        run(context, gx, gy) {
            if (this.texture)
                context.drawTexture(this.texture, this.x + gx, this.y + gy, this.width, this.height);
        }
        get cmdID() {
            return DrawImageCmd.ID;
        }
    }
    DrawImageCmd.ID = "DrawImage";

    class DrawLineCmd {
        static create(fromX, fromY, toX, toY, lineColor, lineWidth) {
            var cmd = Pool.getItemByClass("DrawLineCmd", DrawLineCmd);
            var offset = (lineWidth < 1 || lineWidth % 2 === 0) ? 0 : 0.5;
            cmd.fromX = fromX + offset;
            cmd.fromY = fromY + offset;
            cmd.toX = toX + offset;
            cmd.toY = toY + offset;
            cmd.lineColor = lineColor;
            cmd.lineWidth = lineWidth;
            return cmd;
        }
        recover() {
            Pool.recover("DrawLineCmd", this);
        }
        run(context, gx, gy) {
            if (this.percent && context.sprite) {
                let w = context.sprite.width;
                let h = context.sprite.height;
                context._drawLine(gx, gy, this.fromX * w, this.fromY * h, this.toX * w, this.toY * h, this.lineColor, this.lineWidth, 0);
            }
            else
                context._drawLine(gx, gy, this.fromX, this.fromY, this.toX, this.toY, this.lineColor, this.lineWidth, 0);
        }
        get cmdID() {
            return DrawLineCmd.ID;
        }
        getBoundPoints(sp) {
            _tempPoints$2.length = 0;
            let lineWidth;
            lineWidth = this.lineWidth * 0.5;
            let fromX = this.fromX, fromY = this.fromY, toX = this.toX, toY = this.toY;
            if (this.percent) {
                fromX *= sp.width;
                fromY *= sp.height;
                toX *= sp.width;
                toY *= sp.height;
            }
            if (fromX == toX) {
                _tempPoints$2.push(fromX + lineWidth, fromY, toX + lineWidth, toY, fromX - lineWidth, fromY, toX - lineWidth, toY);
            }
            else if (fromY == toY) {
                _tempPoints$2.push(fromX, fromY + lineWidth, toX, toY + lineWidth, fromX, fromY - lineWidth, toX, toY - lineWidth);
            }
            else {
                _tempPoints$2.push(fromX, fromY, toX, toY);
            }
            return _tempPoints$2;
        }
    }
    DrawLineCmd.ID = "DrawLine";
    const _tempPoints$2 = [];
    ClassUtils.regClass("DrawLineCmd", DrawLineCmd);

    class DrawLinesCmd {
        static create(x, y, points, lineColor, lineWidth) {
            var cmd = Pool.getItemByClass("DrawLinesCmd", DrawLinesCmd);
            var offset = (lineWidth < 1 || lineWidth % 2 === 0) ? 0 : 0.5;
            cmd.x = x + offset;
            cmd.y = y + offset;
            cmd.points = points;
            cmd.lineColor = lineColor;
            cmd.lineWidth = lineWidth;
            return cmd;
        }
        recover() {
            this.points = null;
            this.lineColor = null;
            Pool.recover("DrawLinesCmd", this);
        }
        run(context, gx, gy) {
            this.points && context._drawLines(this.x + gx, this.y + gy, this.points, this.lineColor, this.lineWidth, 0);
        }
        get cmdID() {
            return DrawLinesCmd.ID;
        }
    }
    DrawLinesCmd.ID = "DrawLines";
    ClassUtils.regClass("DrawLinesCmd", DrawLinesCmd);

    class DrawPathCmd {
        static create(x, y, paths, brush, pen) {
            var cmd = Pool.getItemByClass("DrawPathCmd", DrawPathCmd);
            cmd.x = x;
            cmd.y = y;
            cmd.paths = paths;
            cmd.brush = brush;
            cmd.pen = pen;
            return cmd;
        }
        recover() {
            this.paths = null;
            this.brush = null;
            this.pen = null;
            Pool.recover("DrawPathCmd", this);
        }
        run(context, gx, gy) {
            this.paths && context._drawPath(this.x + gx, this.y + gy, this.paths, this.brush, this.pen);
        }
        get cmdID() {
            return DrawPathCmd.ID;
        }
        getBoundPoints(sp) {
            let rst = _tempPoints$1;
            rst.length = 0;
            let paths = this.paths;
            let len = paths.length;
            for (let i = 0; i < len; i++) {
                let tCMD = paths[i];
                if (tCMD.length > 1) {
                    rst.push(tCMD[1], tCMD[2]);
                    if (tCMD.length > 3) {
                        rst.push(tCMD[3], tCMD[4]);
                    }
                }
            }
            return rst;
        }
    }
    DrawPathCmd.ID = "DrawPath";
    const _tempPoints$1 = [];
    ClassUtils.regClass("DrawPathCmd", DrawPathCmd);

    class DrawPieCmd {
        static create(x, y, radius, startAngle, endAngle, fillColor, lineColor, lineWidth) {
            var cmd = Pool.getItemByClass("DrawPieCmd", DrawPieCmd);
            var offset = (lineWidth >= 1 && lineColor) ? lineWidth / 2 : 0;
            var lineOffset = lineColor ? lineWidth : 0;
            cmd.x = x + offset;
            cmd.y = y + offset;
            cmd.radius = radius - lineOffset;
            cmd._startAngle = startAngle;
            cmd._endAngle = endAngle;
            cmd.fillColor = fillColor;
            cmd.lineColor = lineColor;
            cmd.lineWidth = lineWidth;
            return cmd;
        }
        recover() {
            this.fillColor = null;
            this.lineColor = null;
            Pool.recover("DrawPieCmd", this);
        }
        run(context, gx, gy) {
            context._drawPie(this.x + gx, this.y + gy, this.radius, this._startAngle, this._endAngle, this.fillColor, this.lineColor, this.lineWidth, 0);
        }
        get cmdID() {
            return DrawPieCmd.ID;
        }
        get startAngle() {
            return this._startAngle * 180 / Math.PI;
        }
        set startAngle(value) {
            this._startAngle = value * Math.PI / 180;
        }
        get endAngle() {
            return this._endAngle * 180 / Math.PI;
        }
        set endAngle(value) {
            this._endAngle = value * Math.PI / 180;
        }
        getBoundPoints(sp) {
            let rst = _tempPoints;
            _tempPoints.length = 0;
            let k = Math.PI / 180;
            let d1 = this.endAngle - this.startAngle;
            let x = this.x, y = this.y, radius = this.radius;
            if (d1 >= 360 || d1 <= -360) {
                rst.push(x - radius, y - radius);
                rst.push(x + radius, y - radius);
                rst.push(x + radius, y + radius);
                rst.push(x - radius, y + radius);
                return rst;
            }
            rst.push(x, y);
            var delta = d1 % 360;
            if (delta < 0)
                delta += 360;
            var end1 = this.startAngle + delta;
            var st = this.startAngle * k;
            var ed = end1 * k;
            rst.push(x + radius * Math.cos(st), y + radius * Math.sin(st));
            rst.push(x + radius * Math.cos(ed), y + radius * Math.sin(ed));
            var s1 = Math.ceil(this.startAngle / 90) * 90;
            var s2 = Math.floor(end1 / 90) * 90;
            for (var cs = s1; cs <= s2; cs += 90) {
                var csr = cs * k;
                rst.push(x + radius * Math.cos(csr), y + radius * Math.sin(csr));
            }
            return rst;
        }
    }
    DrawPieCmd.ID = "DrawPie";
    const _tempPoints = [];
    ClassUtils.regClass("DrawPieCmd", DrawPieCmd);

    class DrawPolyCmd {
        static create(x, y, points, fillColor, lineColor, lineWidth) {
            var cmd = Pool.getItemByClass("DrawPolyCmd", DrawPolyCmd);
            var tIsConvexPolygon = false;
            if (points.length > 6) {
                tIsConvexPolygon = false;
            }
            else {
                tIsConvexPolygon = true;
            }
            var offset = (lineWidth >= 1 && lineColor) ? (lineWidth % 2 === 0 ? 0 : 0.5) : 0;
            cmd.x = x + offset;
            cmd.y = y + offset;
            cmd.points = points;
            cmd.fillColor = fillColor;
            cmd.lineColor = lineColor;
            cmd.lineWidth = lineWidth;
            cmd.isConvexPolygon = tIsConvexPolygon;
            return cmd;
        }
        recover() {
            this.points = null;
            this.fillColor = null;
            this.lineColor = null;
            Pool.recover("DrawPolyCmd", this);
        }
        run(context, gx, gy) {
            this.points && context._drawPoly(this.x + gx, this.y + gy, this.points, this.fillColor, this.lineColor, this.lineWidth, this.isConvexPolygon, 0);
        }
        get cmdID() {
            return DrawPolyCmd.ID;
        }
    }
    DrawPolyCmd.ID = "DrawPoly";
    ClassUtils.regClass("DrawPolyCmd", DrawPolyCmd);

    class DrawRectCmd {
        static create(x, y, width, height, fillColor, lineColor, lineWidth, percent) {
            var cmd = Pool.getItemByClass("DrawRectCmd", DrawRectCmd);
            var offset = (lineWidth >= 1 && lineColor) ? lineWidth / 2 : 0;
            var lineOffset = lineColor ? lineWidth : 0;
            cmd.x = x + offset;
            cmd.y = y + offset;
            cmd.width = width - lineOffset;
            cmd.height = height - lineOffset;
            cmd.fillColor = fillColor;
            cmd.lineColor = lineColor;
            cmd.lineWidth = lineWidth;
            cmd.percent = percent;
            return cmd;
        }
        recover() {
            this.fillColor = null;
            this.lineColor = null;
            Pool.recover("DrawRectCmd", this);
        }
        run(context, gx, gy) {
            if (this.percent && context.sprite) {
                let w = context.sprite.width;
                let h = context.sprite.height;
                context.drawRect(this.x * w + gx, this.y * h + gy, this.width * w, this.height * h, this.fillColor, this.lineColor, this.lineWidth);
            }
            else
                context.drawRect(this.x + gx, this.y + gy, this.width, this.height, this.fillColor, this.lineColor, this.lineWidth);
        }
        get cmdID() {
            return DrawRectCmd.ID;
        }
        getBoundPoints(sp) {
            return Rectangle._getBoundPointS(this.x, this.y, this.width, this.height, this.percent ? sp : null);
        }
    }
    DrawRectCmd.ID = "DrawRect";
    ClassUtils.regClass("DrawRectCmd", DrawRectCmd);

    class DrawTextureCmd {
        constructor() {
            this.colorFlt = null;
            this.uv = null;
        }
        static create(texture, x, y, width, height, matrix, alpha, color, blendMode, uv) {
            if (!width)
                width = texture.sourceWidth;
            if (!height)
                height = texture.sourceHeight;
            let wRate = width / texture.sourceWidth;
            let hRate = height / texture.sourceHeight;
            width = texture.width * wRate;
            height = texture.height * hRate;
            x += texture.offsetX * wRate;
            y += texture.offsetY * hRate;
            var cmd = Pool.getItemByClass("DrawTextureCmd", DrawTextureCmd);
            cmd.texture = texture;
            texture._addReference();
            cmd.x = x;
            cmd.y = y;
            cmd.width = width;
            cmd.height = height;
            cmd.matrix = matrix;
            cmd.alpha = alpha;
            cmd.color = color;
            cmd.blendMode = blendMode;
            cmd.uv = uv || null;
            if (color) {
                cmd.colorFlt = new ColorFilter();
                cmd.colorFlt.setColor(color);
            }
            else
                cmd.colorFlt = null;
            return cmd;
        }
        recover() {
            this.texture && this.texture._removeReference();
            this.texture = null;
            this.matrix = null;
            Pool.recover("DrawTextureCmd", this);
        }
        run(context, gx, gy) {
            this.texture && context.drawTextureWithTransform(this.texture, this.x, this.y, this.width, this.height, this.matrix, gx, gy, this.alpha, this.blendMode, this.colorFlt, this.uv);
        }
        get cmdID() {
            return DrawTextureCmd.ID;
        }
    }
    DrawTextureCmd.ID = "DrawTexture";

    class FillTextureCmd {
        static create(texture, x, y, width, height, type, offset) {
            var cmd = Pool.getItemByClass("FillTextureCmd", FillTextureCmd);
            cmd.texture = texture;
            cmd.x = x;
            cmd.y = y;
            cmd.width = width;
            cmd.height = height;
            cmd.type = type;
            cmd.offset = offset;
            return cmd;
        }
        recover() {
            this.texture = null;
            this.offset = null;
            Pool.recover("FillTextureCmd", this);
        }
        run(context, gx, gy) {
            if (this.texture) {
                if (this.percent && context.sprite) {
                    let w = context.sprite.width;
                    let h = context.sprite.height;
                    context.fillTexture(this.texture, this.x * w + gx, this.y * h + gy, this.width * w, this.height * h, this.type, this.offset || Point.EMPTY);
                }
                else
                    context.fillTexture(this.texture, this.x + gx, this.y + gy, this.width, this.height, this.type, this.offset || Point.EMPTY);
            }
        }
        get cmdID() {
            return FillTextureCmd.ID;
        }
        getBoundPoints(sp) {
            if (this.width && this.height)
                return Rectangle._getBoundPointS(this.x, this.y, this.width, this.height, this.percent ? sp : null);
            else
                return Rectangle._getBoundPointS(this.x, this.y, this.texture.width, this.texture.height);
        }
    }
    FillTextureCmd.ID = "FillTexture";
    ClassUtils.regClass("FillTextureCmd", FillTextureCmd);

    class RestoreCmd {
        static create() {
            var cmd = Pool.getItemByClass("RestoreCmd", RestoreCmd);
            return cmd;
        }
        recover() {
            Pool.recover("RestoreCmd", this);
        }
        run(context, gx, gy) {
            context.restore();
        }
        get cmdID() {
            return RestoreCmd.ID;
        }
    }
    RestoreCmd.ID = "Restore";

    class RotateCmd {
        static create(angle, pivotX, pivotY) {
            var cmd = Pool.getItemByClass("RotateCmd", RotateCmd);
            cmd.angle = angle;
            cmd.pivotX = pivotX;
            cmd.pivotY = pivotY;
            return cmd;
        }
        recover() {
            Pool.recover("RotateCmd", this);
        }
        run(context, gx, gy) {
            context._rotate(this.angle, this.pivotX + gx, this.pivotY + gy);
        }
        get cmdID() {
            return RotateCmd.ID;
        }
    }
    RotateCmd.ID = "Rotate";

    class ScaleCmd {
        static create(scaleX, scaleY, pivotX, pivotY) {
            var cmd = Pool.getItemByClass("ScaleCmd", ScaleCmd);
            cmd.scaleX = scaleX;
            cmd.scaleY = scaleY;
            cmd.pivotX = pivotX;
            cmd.pivotY = pivotY;
            return cmd;
        }
        recover() {
            Pool.recover("ScaleCmd", this);
        }
        run(context, gx, gy) {
            context._scale(this.scaleX, this.scaleY, this.pivotX + gx, this.pivotY + gy);
        }
        get cmdID() {
            return ScaleCmd.ID;
        }
    }
    ScaleCmd.ID = "Scale";

    class TransformCmd {
        static create(matrix, pivotX, pivotY) {
            var cmd = Pool.getItemByClass("TransformCmd", TransformCmd);
            cmd.matrix = matrix;
            cmd.pivotX = pivotX;
            cmd.pivotY = pivotY;
            return cmd;
        }
        recover() {
            this.matrix = null;
            Pool.recover("TransformCmd", this);
        }
        run(context, gx, gy) {
            context._transform(this.matrix, this.pivotX + gx, this.pivotY + gy);
        }
        get cmdID() {
            return TransformCmd.ID;
        }
    }
    TransformCmd.ID = "Transform";

    class TranslateCmd {
        static create(tx, ty) {
            var cmd = Pool.getItemByClass("TranslateCmd", TranslateCmd);
            cmd.tx = tx;
            cmd.ty = ty;
            return cmd;
        }
        recover() {
            Pool.recover("TranslateCmd", this);
        }
        run(context, gx, gy) {
            context.translate(this.tx, this.ty);
        }
        get cmdID() {
            return TranslateCmd.ID;
        }
    }
    TranslateCmd.ID = "Translate";

    class DrawTrianglesCmd {
        static create(texture, x, y, vertices, uvs, indices, matrix, alpha, color, blendMode, colorNum) {
            var cmd = Pool.getItemByClass("DrawTrianglesCmd", DrawTrianglesCmd);
            cmd.texture = texture;
            cmd.x = x;
            cmd.y = y;
            cmd.vertices = vertices;
            cmd.uvs = uvs;
            cmd.indices = indices;
            cmd.matrix = matrix;
            cmd.alpha = alpha;
            if (color) {
                cmd.color = new ColorFilter();
                var c = ColorUtils.create(color).arrColor;
                cmd.color.color(c[0] * 255, c[1] * 255, c[2] * 255, c[3] * 255);
            }
            cmd.blendMode = blendMode;
            cmd.colorNum = colorNum;
            return cmd;
        }
        recover() {
            this.texture = null;
            this.vertices = null;
            this.uvs = null;
            this.indices = null;
            this.matrix = null;
            Pool.recover("DrawTrianglesCmd", this);
        }
        run(context, gx, gy) {
            context.drawTriangles(this.texture, this.x + gx, this.y + gy, this.vertices, this.uvs, this.indices, this.matrix, this.alpha, this.color, this.blendMode, this.colorNum);
        }
        get cmdID() {
            return DrawTrianglesCmd.ID;
        }
        getBoundPoints(sp) {
            let vert = this.vertices;
            var vnum = vert.length;
            if (vnum < 2)
                return [];
            var minx = vert[0];
            var miny = vert[1];
            var maxx = minx;
            var maxy = miny;
            for (var i = 2; i < vnum;) {
                var cx = vert[i++];
                var cy = vert[i++];
                if (minx > cx)
                    minx = cx;
                if (miny > cy)
                    miny = cy;
                if (maxx < cx)
                    maxx = cx;
                if (maxy < cy)
                    maxy = cy;
            }
            return [minx, miny, maxx, miny, maxx, maxy, minx, maxy];
        }
    }
    DrawTrianglesCmd.ID = "DrawTriangles";
    ClassUtils.regClass("DrawTrianglesCmd", DrawTrianglesCmd);

    class Draw9GridTextureCmd {
        static create(texture, x, y, width, height, sizeGrid, percent) {
            let cmd = Pool.getItemByClass("Draw9GridTextureCmd", Draw9GridTextureCmd);
            cmd.texture = texture;
            texture._addReference();
            cmd.x = x;
            cmd.y = y;
            cmd.width = width;
            cmd.height = height;
            cmd.sizeGrid = sizeGrid;
            cmd.percent = percent;
            return cmd;
        }
        recover() {
            this.texture._removeReference();
            Pool.recover("Draw9GridTextureCmd", this);
        }
        run(context, gx, gy) {
            if (this.texture) {
                if (this.percent && context.sprite) {
                    let w = context.sprite.width;
                    let h = context.sprite.height;
                    context.drawTextureWithSizeGrid(this.texture, this.x * w, this.y * h, this.width * w, this.height * h, this.sizeGrid || EMPTY_SIZE_GRID, gx, gy);
                }
                else
                    context.drawTextureWithSizeGrid(this.texture, this.x, this.y, this.width, this.height, this.sizeGrid || EMPTY_SIZE_GRID, gx, gy);
            }
        }
        get cmdID() {
            return Draw9GridTextureCmd.ID;
        }
        getBoundPoints(sp) {
            let minx = this.x;
            let miny = this.y;
            let maxx = this.width;
            let maxy = this.height;
            if (this.percent) {
                minx *= sp.width;
                miny *= sp.height;
                maxx *= sp.width;
                maxy *= sp.height;
            }
            return [minx, miny, maxx, miny, maxx, maxy, minx, maxy];
        }
    }
    Draw9GridTextureCmd.ID = "Draw9GridTexture";
    const EMPTY_SIZE_GRID = [0, 0, 0, 0, 0];
    ClassUtils.regClass("Draw9GridTextureCmd", Draw9GridTextureCmd);

    class SaveCmd {
        static create() {
            var cmd = Pool.getItemByClass("SaveCmd", SaveCmd);
            return cmd;
        }
        recover() {
            Pool.recover("SaveCmd", this);
        }
        run(context, gx, gy) {
            context.save();
        }
        get cmdID() {
            return SaveCmd.ID;
        }
    }
    SaveCmd.ID = "Save";

    const _tempMatrix = new Matrix();
    const _initMatrix = new Matrix();
    const _tempMatrixArrays = [];
    class GraphicsBounds {
        constructor() {
            this._cacheBoundsType = false;
        }
        destroy() {
            this._graphics = null;
            this._cacheBoundsType = false;
            if (this._temp)
                this._temp.length = 0;
            if (this._rstBoundPoints)
                this._rstBoundPoints.length = 0;
            if (this._bounds)
                this._bounds.recover();
            this._bounds = null;
            Pool.recover("GraphicsBounds", this);
        }
        static create() {
            return Pool.getItemByClass("GraphicsBounds", GraphicsBounds);
        }
        reset() {
            this._temp && (this._temp.length = 0);
        }
        getBounds(realSize = false) {
            if (!this._bounds || !this._temp || this._temp.length < 1 || realSize != this._cacheBoundsType) {
                this._bounds = Rectangle._getWrapRec(this.getBoundPoints(realSize), this._bounds);
            }
            this._cacheBoundsType = realSize;
            return this._bounds;
        }
        getBoundPoints(realSize = false) {
            if (!this._temp || this._temp.length < 1 || realSize != this._cacheBoundsType)
                this._temp = this._getCmdPoints(realSize);
            this._cacheBoundsType = realSize;
            return this._rstBoundPoints = Utils.copyArray(this._rstBoundPoints, this._temp);
        }
        _getCmdPoints(realSize = false) {
            let cmds = this._graphics.cmds;
            let sp = this._graphics._sp;
            let rst;
            rst = this._temp || (this._temp = []);
            rst.length = 0;
            if (cmds.length == 0)
                return rst;
            let matrixs = _tempMatrixArrays;
            matrixs.length = 0;
            let tMatrix = _initMatrix;
            tMatrix.identity();
            let tempMatrix = _tempMatrix;
            for (let i = 0, n = cmds.length; i < n; i++) {
                let cmd = cmds[i];
                switch (cmd.cmdID) {
                    case AlphaCmd.ID:
                    case SaveCmd.ID:
                        matrixs.push(tMatrix);
                        tMatrix = tMatrix.clone();
                        break;
                    case RestoreCmd.ID:
                        tMatrix = matrixs.pop();
                        break;
                    case ScaleCmd.ID:
                        tempMatrix.identity();
                        tempMatrix.translate(-cmd.pivotX, -cmd.pivotY);
                        tempMatrix.scale(cmd.scaleX, cmd.scaleY);
                        tempMatrix.translate(cmd.pivotX, cmd.pivotY);
                        this._switchMatrix(tMatrix, tempMatrix);
                        break;
                    case RotateCmd.ID:
                        tempMatrix.identity();
                        tempMatrix.translate(-cmd.pivotX, -cmd.pivotY);
                        tempMatrix.rotate(cmd.angle);
                        tempMatrix.translate(cmd.pivotX, cmd.pivotY);
                        this._switchMatrix(tMatrix, tempMatrix);
                        break;
                    case TranslateCmd.ID:
                        tempMatrix.identity();
                        tempMatrix.translate(cmd.tx, cmd.ty);
                        this._switchMatrix(tMatrix, tempMatrix);
                        break;
                    case TransformCmd.ID:
                        tempMatrix.identity();
                        tempMatrix.translate(-cmd.pivotX, -cmd.pivotY);
                        tempMatrix.concat(cmd.matrix);
                        tempMatrix.translate(cmd.pivotX, cmd.pivotY);
                        this._switchMatrix(tMatrix, tempMatrix);
                        break;
                    case DrawImageCmd.ID:
                    case FillTextureCmd.ID:
                        addPointArrToRst(rst, Rectangle._getBoundPointS(cmd.x, cmd.y, cmd.width, cmd.height), tMatrix);
                        break;
                    case DrawTextureCmd.ID:
                        tMatrix.copyTo(tempMatrix);
                        if (cmd.matrix)
                            tempMatrix.concat(cmd.matrix);
                        addPointArrToRst(rst, Rectangle._getBoundPointS(cmd.x, cmd.y, cmd.width, cmd.height), tempMatrix);
                        break;
                    case DrawRectCmd.ID:
                        addPointArrToRst(rst, cmd.getBoundPoints(sp), tMatrix);
                        break;
                    case DrawCircleCmd.ID:
                        addPointArrToRst(rst, cmd.getBoundPoints(sp), tMatrix);
                        break;
                    case DrawLineCmd.ID:
                        addPointArrToRst(rst, cmd.getBoundPoints(sp), tMatrix);
                        break;
                    case DrawCurvesCmd.ID:
                        addPointArrToRst(rst, cmd.getBoundPoints(sp), tMatrix, cmd.x, cmd.y);
                        break;
                    case DrawLinesCmd.ID:
                    case DrawPolyCmd.ID:
                        addPointArrToRst(rst, cmd.points, tMatrix, cmd.x, cmd.y);
                        break;
                    case DrawPathCmd.ID:
                        addPointArrToRst(rst, cmd.getBoundPoints(sp), tMatrix, cmd.x, cmd.y);
                        break;
                    case DrawPieCmd.ID:
                        addPointArrToRst(rst, cmd.getBoundPoints(sp), tMatrix);
                        break;
                    case DrawTrianglesCmd.ID:
                        addPointArrToRst(rst, cmd.getBoundPoints(sp), tMatrix);
                        break;
                    case Draw9GridTextureCmd.ID:
                        addPointArrToRst(rst, cmd.getBoundPoints(sp), tMatrix);
                        break;
                }
            }
            if (rst.length > 200) {
                rst = Utils.copyArray(rst, Rectangle._getWrapRec(rst)._getBoundPoints());
            }
            else if (rst.length > 8)
                rst = GrahamScan.scanPList(rst);
            return rst;
        }
        _switchMatrix(tMatix, tempMatrix) {
            tempMatrix.concat(tMatix);
            tempMatrix.copyTo(tMatix);
        }
    }
    function addPointArrToRst(rst, points, matrix, dx = 0, dy = 0) {
        let len = points.length;
        for (let i = 0; i < len; i += 2) {
            addPointToRst(rst, points[i] + dx, points[i + 1] + dy, matrix);
        }
    }
    function addPointToRst(rst, x, y, matrix) {
        var _tempPoint = Point.TEMP;
        _tempPoint.setTo(x ? x : 0, y ? y : 0);
        matrix.transformPoint(_tempPoint);
        rst.push(_tempPoint.x, _tempPoint.y);
    }

    class ClipRectCmd {
        static create(x, y, width, height) {
            var cmd = Pool.getItemByClass("ClipRectCmd", ClipRectCmd);
            cmd.x = x;
            cmd.y = y;
            cmd.width = width;
            cmd.height = height;
            return cmd;
        }
        recover() {
            Pool.recover("ClipRectCmd", this);
        }
        run(context, gx, gy) {
            context.clipRect(this.x + gx, this.y + gy, this.width, this.height);
        }
        get cmdID() {
            return ClipRectCmd.ID;
        }
    }
    ClipRectCmd.ID = "ClipRect";

    class DrawTexturesCmd {
        static create(texture, pos) {
            var cmd = Pool.getItemByClass("DrawTexturesCmd", DrawTexturesCmd);
            cmd.texture = texture;
            texture._addReference();
            cmd.pos = pos;
            return cmd;
        }
        recover() {
            this.texture._removeReference();
            this.texture = null;
            this.pos = null;
            Pool.recover("DrawTexturesCmd", this);
        }
        run(context, gx, gy) {
            context.drawTextures(this.texture, this.pos, gx, gy);
        }
        get cmdID() {
            return DrawTexturesCmd.ID;
        }
    }
    DrawTexturesCmd.ID = "DrawTextures";

    class FillTextCmd {
        constructor() {
            this._textIsWorldText = false;
            this._fontColor = 0xffffffff;
            this._strokeColor = 0;
            this._fontObj = FillTextCmd._defFontObj;
            this._nTexAlign = 0;
        }
        static create(text, words, x, y, font, color, textAlign, lineWidth, borderColor) {
            var cmd = Pool.getItemByClass("FillTextCmd", FillTextCmd);
            cmd.text = text;
            cmd._textIsWorldText = text instanceof WordText;
            cmd._words = words;
            cmd.x = x;
            cmd.y = y;
            cmd.font = font;
            cmd.color = color;
            cmd.textAlign = textAlign;
            cmd._lineWidth = lineWidth;
            cmd._borderColor = borderColor;
            return cmd;
        }
        recover() {
            Pool.recover("FillTextCmd", this);
        }
        run(context, gx, gy) {
            if (ILaya.stage.isGlobalRepaint()) {
                this._textIsWorldText && this._text.cleanCache();
            }
            if (this._words) {
                context.fillWords11(this._words, this.x + gx, this.y + gy, this._fontObj, this._color, this._borderColor, this._lineWidth);
            }
            else {
                if (this._textIsWorldText) {
                    context._fast_filltext(this._text, this.x + gx, this.y + gy, this._fontObj, this._color, this._borderColor, this._lineWidth, this._nTexAlign, 0);
                }
                else {
                    context.filltext11(this._text, this.x + gx, this.y + gy, this.font, this.color, this._borderColor, this._lineWidth, this._textAlign);
                }
            }
        }
        get cmdID() {
            return FillTextCmd.ID;
        }
        get text() {
            return this._text;
        }
        set text(value) {
            this._text = value;
            this._textIsWorldText = value instanceof WordText;
            this._textIsWorldText && this._text.cleanCache();
        }
        get font() {
            return this._font;
        }
        set font(value) {
            this._font = value;
            this._fontObj = FontInfo.Parse(value);
            this._textIsWorldText && this._text.cleanCache();
        }
        get color() {
            return this._color;
        }
        set color(value) {
            this._color = value;
            this._fontColor = ColorUtils.create(value).numColor;
            this._textIsWorldText && this._text.cleanCache();
        }
        get textAlign() {
            return this._textAlign;
        }
        set textAlign(value) {
            this._textAlign = value;
            switch (value) {
                case 'center':
                    this._nTexAlign = Const.ENUM_TEXTALIGN_CENTER;
                    break;
                case 'right':
                    this._nTexAlign = Const.ENUM_TEXTALIGN_RIGHT;
                    break;
                default:
                    this._nTexAlign = Const.ENUM_TEXTALIGN_DEFAULT;
            }
            this._textIsWorldText && this._text.cleanCache();
        }
    }
    FillTextCmd.ID = "FillText";
    FillTextCmd._defFontObj = new FontInfo(null);

    class CacheManger {
        constructor() {
        }
        static regCacheByFunction(disposeFunction, getCacheListFunction) {
            CacheManger.unRegCacheByFunction(disposeFunction, getCacheListFunction);
            var cache;
            cache = { tryDispose: disposeFunction, getCacheList: getCacheListFunction };
            CacheManger._cacheList.push(cache);
        }
        static unRegCacheByFunction(disposeFunction, getCacheListFunction) {
            var i, len;
            len = CacheManger._cacheList.length;
            for (i = 0; i < len; i++) {
                if (CacheManger._cacheList[i].tryDispose == disposeFunction && CacheManger._cacheList[i].getCacheList == getCacheListFunction) {
                    CacheManger._cacheList.splice(i, 1);
                    return;
                }
            }
        }
        static forceDispose() {
            var i, len = CacheManger._cacheList.length;
            for (i = 0; i < len; i++) {
                CacheManger._cacheList[i].tryDispose(true);
            }
        }
        static beginCheck(waitTime = 15000) {
            ILaya.systemTimer.loop(waitTime, null, CacheManger._checkLoop);
        }
        static stopCheck() {
            ILaya.systemTimer.clear(null, CacheManger._checkLoop);
        }
        static _checkLoop() {
            var cacheList = CacheManger._cacheList;
            if (cacheList.length < 1)
                return;
            var tTime = ILaya.Browser.now();
            var count;
            var len;
            len = count = cacheList.length;
            while (count > 0) {
                CacheManger._index++;
                CacheManger._index = CacheManger._index % len;
                cacheList[CacheManger._index].tryDispose(false);
                if (ILaya.Browser.now() - tTime > CacheManger.loopTimeLimit)
                    break;
                count--;
            }
        }
    }
    CacheManger.loopTimeLimit = 2;
    CacheManger._cacheList = [];
    CacheManger._index = 0;

    class VectorGraphManager {
        constructor() {
            this.useDic = {};
            this.shapeDic = {};
            this.shapeLineDic = {};
            this._id = 0;
            this._checkKey = false;
            this._freeIdArray = [];
            CacheManger.regCacheByFunction(this.startDispose.bind(this), this.getCacheList.bind(this));
        }
        static getInstance() {
            return VectorGraphManager.instance = VectorGraphManager.instance || new VectorGraphManager();
        }
        getId() {
            return this._id++;
        }
        addShape(id, shape) {
            this.shapeDic[id] = shape;
            if (!this.useDic[id]) {
                this.useDic[id] = true;
            }
        }
        addLine(id, Line) {
            this.shapeLineDic[id] = Line;
            if (!this.shapeLineDic[id]) {
                this.shapeLineDic[id] = true;
            }
        }
        getShape(id) {
            if (this._checkKey) {
                if (this.useDic[id] != null) {
                    this.useDic[id] = true;
                }
            }
        }
        deleteShape(id) {
            if (this.shapeDic[id]) {
                this.shapeDic[id] = null;
                delete this.shapeDic[id];
            }
            if (this.shapeLineDic[id]) {
                this.shapeLineDic[id] = null;
                delete this.shapeLineDic[id];
            }
            if (this.useDic[id] != null) {
                delete this.useDic[id];
            }
        }
        getCacheList() {
            var str;
            var list = [];
            for (str in this.shapeDic) {
                list.push(this.shapeDic[str]);
            }
            for (str in this.shapeLineDic) {
                list.push(this.shapeLineDic[str]);
            }
            return list;
        }
        startDispose(key) {
            var str;
            for (str in this.useDic) {
                this.useDic[str] = false;
            }
            this._checkKey = true;
        }
        endDispose() {
            if (this._checkKey) {
                var str;
                for (str in this.useDic) {
                    if (!this.useDic[str]) {
                        this.deleteShape(str);
                    }
                }
                this._checkKey = false;
            }
        }
    }

    class Graphics {
        constructor() {
            this._sp = null;
            this._render = this._renderEmpty;
            this._cmds = [];
            this._vectorgraphArray = null;
            this._graphicBounds = null;
            this._createData();
        }
        _createData() {
        }
        _clearData() {
        }
        _destroyData() {
        }
        destroy() {
            this.clear(true);
            if (this._graphicBounds)
                this._graphicBounds.destroy();
            this._graphicBounds = null;
            this._vectorgraphArray = null;
            if (this._sp) {
                this._sp._renderType = 0;
                this._sp._setRenderType(0);
                this._sp = null;
            }
            this._destroyData();
        }
        clear(recoverCmds = true) {
            if (recoverCmds) {
                for (let i = 0, len = this._cmds.length; i < len; i++) {
                    this._cmds[i].recover();
                }
            }
            this._cmds.length = 0;
            this._render = this._renderEmpty;
            this._clearData();
            if (this._sp) {
                this._sp._renderType &= ~SpriteConst.GRAPHICS;
                this._sp._setRenderType(this._sp._renderType);
            }
            this._repaint();
            if (this._vectorgraphArray) {
                for (let i = 0, len = this._vectorgraphArray.length; i < len; i++) {
                    VectorGraphManager.getInstance().deleteShape(this._vectorgraphArray[i]);
                }
                this._vectorgraphArray.length = 0;
            }
        }
        _clearBoundsCache() {
            if (this._graphicBounds)
                this._graphicBounds.reset();
        }
        _initGraphicBounds() {
            if (!this._graphicBounds) {
                this._graphicBounds = GraphicsBounds.create();
                this._graphicBounds._graphics = this;
            }
        }
        _repaint() {
            this._clearBoundsCache();
            this._sp && this._sp.repaint();
        }
        _isOnlyOne() {
            return this._cmds.length === 1;
        }
        get cmds() {
            return this._cmds;
        }
        set cmds(value) {
            if (this._sp) {
                this._sp._renderType |= SpriteConst.GRAPHICS;
                this._sp._setRenderType(this._sp._renderType);
            }
            this._cmds = value;
            let len = value.length;
            this._render = len === 0 ? this._renderEmpty : (len === 1 ? this._renderOne : this._renderAll);
            this._repaint();
        }
        addCmd(cmd) {
            if (cmd == null) {
                console.warn("null cmd");
                return;
            }
            if (this._sp) {
                this._sp._renderType |= SpriteConst.GRAPHICS;
                this._sp._setRenderType(this._sp._renderType);
            }
            this._cmds.push(cmd);
            if (this._cmds.length == 1)
                this._render = this._renderOne;
            else
                this._render = this._renderAll;
            this._repaint();
            return cmd;
        }
        removeCmd(cmd) {
            let i = this.cmds.indexOf(cmd);
            if (i != -1) {
                this._cmds.splice(i, 1);
                if (this._sp) {
                    this._sp._renderType |= SpriteConst.GRAPHICS;
                    this._sp._setRenderType(this._sp._renderType);
                }
                let len = this._cmds.length;
                this._render = len === 0 ? this._renderEmpty : (len === 1 ? this._renderOne : this._renderAll);
                this._repaint();
            }
        }
        getBounds(realSize = false) {
            this._initGraphicBounds();
            return this._graphicBounds.getBounds(realSize);
        }
        getBoundPoints(realSize = false) {
            this._initGraphicBounds();
            return this._graphicBounds.getBoundPoints(realSize);
        }
        drawImage(texture, x = 0, y = 0, width = 0, height = 0) {
            if (!texture)
                return null;
            if (!texture.bitmap)
                return null;
            return this.addCmd(DrawImageCmd.create(texture, x, y, width, height));
        }
        drawTexture(texture, x = 0, y = 0, width = 0, height = 0, matrix = null, alpha = 1, color = null, blendMode = null, uv) {
            if (!texture || alpha < 0.01)
                return null;
            if (!texture.bitmap)
                return null;
            return this.addCmd(DrawTextureCmd.create(texture, x, y, width, height, matrix, alpha, color, blendMode, uv));
        }
        drawTextures(texture, pos) {
            if (!texture)
                return null;
            return this.addCmd(DrawTexturesCmd.create(texture, pos));
        }
        drawTriangles(texture, x, y, vertices, uvs, indices, matrix = null, alpha = 1, color = null, blendMode = null, colorNum = 0xffffffff) {
            return this.addCmd(DrawTrianglesCmd.create(texture, x, y, vertices, uvs, indices, matrix, alpha, color, blendMode, colorNum));
        }
        fillTexture(texture, x, y, width = 0, height = 0, type = "repeat", offset = null) {
            if (texture && texture.bitmap)
                return this.addCmd(FillTextureCmd.create(texture, x, y, width, height, type, offset || Point.EMPTY));
            else
                return null;
        }
        clipRect(x, y, width, height) {
            return this.addCmd(ClipRectCmd.create(x, y, width, height));
        }
        fillText(text, x, y, font, color, textAlign) {
            return this.addCmd(FillTextCmd.create(text, null, x, y, font || Config.defaultFontStr(), color, textAlign, 0, ""));
        }
        fillBorderText(text, x, y, font, fillColor, textAlign, lineWidth, borderColor) {
            return this.addCmd(FillTextCmd.create(text, null, x, y, font || Config.defaultFontStr(), fillColor, textAlign, lineWidth, borderColor));
        }
        fillWords(words, x, y, font, color) {
            return this.addCmd(FillTextCmd.create(null, words, x, y, font || Config.defaultFontStr(), color, '', 0, null));
        }
        fillBorderWords(words, x, y, font, fillColor, borderColor, lineWidth) {
            return this.addCmd(FillTextCmd.create(null, words, x, y, font || Config.defaultFontStr(), fillColor, "", lineWidth, borderColor));
        }
        strokeText(text, x, y, font, color, lineWidth, textAlign) {
            return this.addCmd(FillTextCmd.create(text, null, x, y, font || Config.defaultFontStr(), null, textAlign, lineWidth, color));
        }
        alpha(alpha) {
            return this.addCmd(AlphaCmd.create(alpha));
        }
        transform(matrix, pivotX = 0, pivotY = 0) {
            return this.addCmd(TransformCmd.create(matrix, pivotX, pivotY));
        }
        rotate(angle, pivotX = 0, pivotY = 0) {
            return this.addCmd(RotateCmd.create(angle, pivotX, pivotY));
        }
        scale(scaleX, scaleY, pivotX = 0, pivotY = 0) {
            return this.addCmd(ScaleCmd.create(scaleX, scaleY, pivotX, pivotY));
        }
        translate(tx, ty) {
            return this.addCmd(TranslateCmd.create(tx, ty));
        }
        save() {
            return this.addCmd(SaveCmd.create());
        }
        restore() {
            return this.addCmd(RestoreCmd.create());
        }
        replaceText(text) {
            this._repaint();
            var cmds = this._cmds;
            for (let i = cmds.length - 1; i > -1; i--) {
                if (this._isTextCmd(cmds[i])) {
                    cmds[i].text = text;
                    return true;
                }
            }
            return false;
        }
        _isTextCmd(cmd) {
            var cmdID = cmd.cmdID;
            return cmdID == FillTextCmd.ID;
        }
        replaceTextColor(color) {
            this._repaint();
            let cmds = this._cmds;
            for (let i = cmds.length - 1; i > -1; i--) {
                if (this._isTextCmd(cmds[i])) {
                    this._setTextCmdColor(cmds[i], color);
                }
            }
        }
        _setTextCmdColor(cmdO, color) {
            var cmdID = cmdO.cmdID;
            switch (cmdID) {
                case FillTextCmd.ID:
                    cmdO.color = color;
                    break;
            }
        }
        loadImage(url, x = 0, y = 0, width = 0, height = 0, complete = null) {
            let tex = ILaya.loader.getRes(url);
            if (tex) {
                this.drawImage(tex, x, y, width, height);
                complete && complete.call(this._sp);
            }
            else {
                ILaya.loader.load(url).then((tex) => {
                    this.drawImage(tex, x, y, width, height);
                    complete && complete.call(this._sp);
                });
            }
        }
        _renderEmpty(sprite, context, x, y) {
        }
        _renderAll(sprite, context, x, y) {
            context.sprite = sprite;
            var cmds = this._cmds;
            for (let i = 0, n = cmds.length; i < n; i++) {
                cmds[i].run(context, x, y);
            }
        }
        _renderOne(sprite, context, x, y) {
            context.sprite = sprite;
            this._cmds[0].run(context, x, y);
        }
        drawLine(fromX, fromY, toX, toY, lineColor, lineWidth = 1) {
            return this.addCmd(DrawLineCmd.create(fromX, fromY, toX, toY, lineColor, lineWidth));
        }
        drawLines(x, y, points, lineColor, lineWidth = 1) {
            if (!points || points.length < 4)
                return null;
            return this.addCmd(DrawLinesCmd.create(x, y, points, lineColor, lineWidth));
        }
        drawCurves(x, y, points, lineColor, lineWidth = 1) {
            return this.addCmd(DrawCurvesCmd.create(x, y, points, lineColor, lineWidth));
        }
        drawRect(x, y, width, height, fillColor, lineColor = null, lineWidth = 1, percent) {
            return this.addCmd(DrawRectCmd.create(x, y, width, height, fillColor, lineColor, lineWidth, percent));
        }
        drawCircle(x, y, radius, fillColor, lineColor = null, lineWidth = 1) {
            return this.addCmd(DrawCircleCmd.create(x, y, radius, fillColor, lineColor, lineWidth));
        }
        drawPie(x, y, radius, startAngle, endAngle, fillColor, lineColor = null, lineWidth = 1) {
            return this.addCmd(DrawPieCmd.create(x, y, radius, Utils.toRadian(startAngle), Utils.toRadian(endAngle), fillColor, lineColor, lineWidth));
        }
        drawPoly(x, y, points, fillColor, lineColor = null, lineWidth = 1) {
            return this.addCmd(DrawPolyCmd.create(x, y, points, fillColor, lineColor, lineWidth));
        }
        drawPath(x, y, paths, brush = null, pen = null) {
            return this.addCmd(DrawPathCmd.create(x, y, paths, brush, pen));
        }
        draw9Grid(texture, x = 0, y = 0, width = 0, height = 0, sizeGrid) {
            this.addCmd(Draw9GridTextureCmd.create(texture, x, y, width, height, sizeGrid));
        }
    }

    const ARRAY_EMPTY = [];
    class Node extends EventDispatcher {
        constructor() {
            super();
            this._bits = 0;
            this._hideFlags = 0;
            this._children = ARRAY_EMPTY;
            this._extUIChild = ARRAY_EMPTY;
            this._parent = null;
            this._destroyed = false;
            this.name = "";
            this._initialize();
        }
        get url() {
            return this._url;
        }
        set url(path) {
            this._url = path;
        }
        get hideFlags() {
            return this._hideFlags;
        }
        set hideFlags(value) {
            this._hideFlags = value;
        }
        get is3D() {
            return this._is3D;
        }
        get destroyed() {
            return this._destroyed;
        }
        _initialize() {
            this._extra = {};
        }
        _setBit(type, value) {
            if (type === NodeFlags.DISPLAY) {
                var preValue = this._getBit(type);
                if (preValue != value)
                    this._updateDisplayedInstage();
            }
            if (value)
                this._bits |= type;
            else
                this._bits &= ~type;
        }
        _getBit(type) {
            return (this._bits & type) != 0;
        }
        _setUpNoticeChain() {
            if (this._getBit(NodeFlags.DISPLAY))
                this._setBitUp(NodeFlags.DISPLAY);
        }
        _setBitUp(type) {
            var ele = this;
            ele._setBit(type, true);
            ele = ele._parent;
            while (ele) {
                if (ele._getBit(type))
                    return;
                ele._setBit(type, true);
                ele = ele._parent;
            }
        }
        onStartListeningToType(type) {
            if (type === Event.DISPLAY || type === Event.UNDISPLAY) {
                if (!this._getBit(NodeFlags.DISPLAY))
                    this._setBitUp(NodeFlags.DISPLAY);
            }
        }
        hasHideFlag(flag) {
            return (this._hideFlags & flag) != 0;
        }
        destroy(destroyChild = true) {
            this._destroyed = true;
            this.destroyAllComponent();
            this._parent && this._parent.removeChild(this);
            if (this._children) {
                if (destroyChild)
                    this.destroyChildren();
                else
                    this.removeChildren();
            }
            this.onDestroy();
            this._children = null;
            this.offAll();
        }
        onDestroy() {
        }
        destroyChildren() {
            if (this._children) {
                for (let i = 0, n = this._children.length; i < n; i++) {
                    this._children[0] && this._children[0].destroy(true);
                }
            }
        }
        addChild(node) {
            if (!node || this._destroyed || node === this)
                return node;
            if (node._zOrder)
                this._setBit(NodeFlags.HAS_ZORDER, true);
            if (node._parent === this) {
                var index = this.getChildIndex(node);
                if (index !== this._children.length - 1) {
                    this._children.splice(index, 1);
                    this._children.push(node);
                    this._childChanged();
                }
            }
            else {
                node._parent && node._parent.removeChild(node);
                this._children === ARRAY_EMPTY && (this._children = []);
                this._children.push(node);
                node._setParent(this);
            }
            return node;
        }
        addInputChild(node) {
            if (this._extUIChild == ARRAY_EMPTY) {
                this._extUIChild = [node];
            }
            else {
                if (this._extUIChild.indexOf(node) >= 0) {
                    return null;
                }
                this._extUIChild.push(node);
            }
            return null;
        }
        removeInputChild(node) {
            var idx = this._extUIChild.indexOf(node);
            if (idx >= 0) {
                this._extUIChild.splice(idx, 1);
            }
        }
        addChildren(...args) {
            var i = 0, n = args.length;
            while (i < n) {
                this.addChild(args[i++]);
            }
        }
        addChildAt(node, index) {
            if (!node || this._destroyed || node === this)
                return node;
            if (node._zOrder)
                this._setBit(NodeFlags.HAS_ZORDER, true);
            if (index >= 0 && index <= this._children.length) {
                if (node._parent === this) {
                    var oldIndex = this.getChildIndex(node);
                    this._children.splice(oldIndex, 1);
                    this._children.splice(index, 0, node);
                    this._childChanged();
                }
                else {
                    node._parent && node._parent.removeChild(node);
                    this._children === ARRAY_EMPTY && (this._children = []);
                    this._children.splice(index, 0, node);
                    node._setParent(this);
                }
                return node;
            }
            else {
                throw new Error("appendChildAt:The index is out of bounds");
            }
        }
        getChildIndex(node) {
            return this._children.indexOf(node);
        }
        getChildByName(name) {
            for (let child of this._children) {
                if (child && child.name === name)
                    return child;
            }
            return null;
        }
        getChildAt(index) {
            return this._children[index] || null;
        }
        setChildIndex(node, index) {
            var childs = this._children;
            if (index < 0 || index >= childs.length) {
                throw new Error("setChildIndex:The index is out of bounds.");
            }
            var oldIndex = this.getChildIndex(node);
            if (oldIndex < 0)
                throw new Error("setChildIndex:node is must child of this object.");
            childs.splice(oldIndex, 1);
            childs.splice(index, 0, node);
            this._childChanged();
            return node;
        }
        _childChanged(child = null) {
        }
        removeChild(node) {
            if (!this._children)
                return node;
            var index = this._children.indexOf(node);
            return this.removeChildAt(index);
        }
        removeSelf() {
            this._parent && this._parent.removeChild(this);
            return this;
        }
        removeChildByName(name) {
            var node = this.getChildByName(name);
            node && this.removeChild(node);
            return node;
        }
        removeChildAt(index) {
            var node = this.getChildAt(index);
            if (node) {
                this._children.splice(index, 1);
                node._setParent(null);
            }
            return node;
        }
        removeChildren(beginIndex = 0, endIndex = 0x7fffffff) {
            if (this._children && this._children.length > 0) {
                var childs = this._children;
                if (beginIndex === 0 && endIndex >= childs.length - 1) {
                    var arr = childs;
                    this._children = ARRAY_EMPTY;
                }
                else {
                    arr = childs.splice(beginIndex, endIndex - beginIndex + 1);
                }
                for (var i = 0, n = arr.length; i < n; i++) {
                    arr[i]._setParent(null);
                }
            }
            return this;
        }
        replaceChild(newNode, oldNode) {
            var index = this._children.indexOf(oldNode);
            if (index > -1) {
                this._children.splice(index, 1, newNode);
                oldNode._setParent(null);
                newNode._setParent(this);
                return newNode;
            }
            return null;
        }
        get numChildren() {
            return this._children ? this._children.length : 0;
        }
        get parent() {
            return this._parent;
        }
        isAncestorOf(node) {
            let p = node.parent;
            while (p) {
                if (p == this)
                    return true;
                p = p.parent;
            }
            return false;
        }
        ;
        _setParent(value) {
            if (this._parent !== value) {
                if (value) {
                    this._parent = value;
                    this._onAdded();
                    this.event(Event.ADDED);
                    if (this._getBit(NodeFlags.DISPLAY)) {
                        this._setUpNoticeChain();
                        value.displayedInStage && this._displayChild(this, true);
                    }
                    value._childChanged(this);
                }
                else {
                    this._onRemoved();
                    this.event(Event.REMOVED);
                    let p = this._parent;
                    if (this._getBit(NodeFlags.DISPLAY))
                        this._displayChild(this, false);
                    this._parent = value;
                    p._childChanged(this);
                }
            }
        }
        get displayedInStage() {
            if (this._getBit(NodeFlags.DISPLAY))
                return this._getBit(NodeFlags.DISPLAYED_INSTAGE);
            this._setBitUp(NodeFlags.DISPLAY);
            return this._getBit(NodeFlags.DISPLAYED_INSTAGE);
        }
        _updateDisplayedInstage() {
            var ele;
            ele = this;
            var stage = ILaya.stage;
            var displayedInStage = false;
            while (ele) {
                if (ele._getBit(NodeFlags.DISPLAY)) {
                    displayedInStage = ele._getBit(NodeFlags.DISPLAYED_INSTAGE);
                    break;
                }
                if (ele === stage || ele._getBit(NodeFlags.DISPLAYED_INSTAGE)) {
                    displayedInStage = true;
                    break;
                }
                ele = ele._parent;
            }
            this._setBit(NodeFlags.DISPLAYED_INSTAGE, displayedInStage);
        }
        _setDisplay(value) {
            if (this._getBit(NodeFlags.DISPLAYED_INSTAGE) !== value) {
                this._setBit(NodeFlags.DISPLAYED_INSTAGE, value);
                if (value)
                    this.event(Event.DISPLAY);
                else
                    this.event(Event.UNDISPLAY);
            }
        }
        _displayChild(node, display) {
            var childs = node._children;
            if (childs) {
                for (var i = 0, n = childs.length; i < n; i++) {
                    var child = childs[i];
                    if (!child)
                        continue;
                    if (!child._getBit(NodeFlags.DISPLAY))
                        continue;
                    if (child._children.length > 0) {
                        this._displayChild(child, display);
                    }
                    else {
                        child._setDisplay(display);
                    }
                }
            }
            node._setDisplay(display);
        }
        contains(node) {
            if (node === this)
                return true;
            while (node) {
                if (node._parent === this)
                    return true;
                node = node._parent;
            }
            return false;
        }
        timerLoop(delay, caller, method, args = null, coverBefore = true, jumpFrame = false) {
            this.timer.loop(delay, caller, method, args, coverBefore, jumpFrame);
        }
        timerOnce(delay, caller, method, args = null, coverBefore = true) {
            this.timer._create(false, false, delay, caller, method, args, coverBefore);
        }
        frameLoop(delay, caller, method, args = null, coverBefore = true) {
            this.timer._create(true, true, delay, caller, method, args, coverBefore);
        }
        frameOnce(delay, caller, method, args = null, coverBefore = true) {
            this.timer._create(true, false, delay, caller, method, args, coverBefore);
        }
        clearTimer(caller, method) {
            this.timer.clear(caller, method);
        }
        callLater(method, args = null) {
            this.timer.callLater(this, method, args);
        }
        runCallLater(method) {
            this.timer.runCallLater(this, method);
        }
        get scene() {
            return this._scene;
        }
        get active() {
            return !this._getBit(NodeFlags.NOT_READY) && !this._getBit(NodeFlags.NOT_ACTIVE);
        }
        set active(value) {
            value = !!value;
            if (!this._getBit(NodeFlags.NOT_ACTIVE) !== value) {
                if (this._activeChangeScripts && this._activeChangeScripts.length !== 0) {
                    if (value)
                        throw "Node: can't set the main inActive node active in hierarchy,if the operate is in main inActive node or it's children script's onDisable Event.";
                    else
                        throw "Node: can't set the main active node inActive in hierarchy,if the operate is in main active node or it's children script's onEnable Event.";
                }
                else {
                    this._setBit(NodeFlags.NOT_ACTIVE, !value);
                    if (this._parent) {
                        if (this._parent.activeInHierarchy) {
                            this._processActive(value, true);
                        }
                    }
                }
            }
        }
        get activeInHierarchy() {
            return this._getBit(NodeFlags.ACTIVE_INHIERARCHY);
        }
        _onActive() {
            Stat.spriteCount++;
        }
        _onInActive() {
            Stat.spriteCount--;
        }
        _onActiveInScene() {
        }
        _onInActiveInScene() {
        }
        onAwake() {
        }
        onEnable() {
        }
        onDisable() {
        }
        _parse(data, spriteMap) {
        }
        _setBelongScene(scene) {
            if (!this._scene || this.scene != scene) {
                this._scene = scene;
                this._onActiveInScene();
                for (let i = 0, n = this._children.length; i < n; i++)
                    this._children[i]._setBelongScene(scene);
            }
        }
        _setUnBelongScene() {
            if (this._scene !== this) {
                this._onInActiveInScene();
                this._scene = null;
                for (let i = 0, n = this._children.length; i < n; i++)
                    this._children[i]._setUnBelongScene();
            }
        }
        _processActive(active, fromSetter) {
            (this._activeChangeScripts) || (this._activeChangeScripts = []);
            let arr = this._activeChangeScripts;
            if (active)
                this._activeHierarchy(arr, fromSetter);
            else
                this._inActiveHierarchy(arr, fromSetter);
            for (let i = 0, n = arr.length; i < n; i++) {
                let comp = arr[i];
                comp.owner && comp._setActive(active);
            }
            arr.length = 0;
        }
        _activeHierarchy(activeChangeScripts, fromSetter) {
            this._setBit(NodeFlags.ACTIVE_INHIERARCHY, true);
            if (this._components) {
                for (let i = 0, n = this._components.length; i < n; i++) {
                    let comp = this._components[i];
                    if (comp._isScript())
                        (comp._enabled) && (activeChangeScripts.push(comp));
                    else
                        comp._setActive(true);
                }
            }
            this._onActive();
            for (let i = 0, n = this._children.length; i < n; i++) {
                let child = this._children[i];
                (!child._getBit(NodeFlags.NOT_ACTIVE) && !child._getBit(NodeFlags.NOT_READY)) && (child._activeHierarchy(activeChangeScripts, fromSetter));
            }
            if (!this._getBit(NodeFlags.AWAKED)) {
                this._setBit(NodeFlags.AWAKED, true);
                this.onAwake();
            }
            this.onEnable();
        }
        _inActiveHierarchy(activeChangeScripts, fromSetter) {
            this._onInActive();
            if (this._components) {
                for (let i = 0, n = this._components.length; i < n; i++) {
                    let comp = this._components[i];
                    if (comp._isScript())
                        comp._enabled && (activeChangeScripts.push(comp));
                    else
                        comp._setActive(false);
                }
            }
            this._setBit(NodeFlags.ACTIVE_INHIERARCHY, false);
            for (let i = 0, n = this._children.length; i < n; i++) {
                let child = this._children[i];
                (child && !child._getBit(NodeFlags.NOT_ACTIVE)) && (child._inActiveHierarchy(activeChangeScripts, fromSetter));
            }
            this.onDisable();
        }
        _onAdded() {
            if (this._activeChangeScripts && this._activeChangeScripts.length !== 0) {
                throw "Node: can't set the main inActive node active in hierarchy,if the operate is in main inActive node or it's children script's onDisable Event.";
            }
            else {
                let parentScene = this._parent.scene;
                parentScene && this._setBelongScene(parentScene);
                (this._parent.activeInHierarchy && this.active) && this._processActive(true);
            }
        }
        _onRemoved() {
            if (this._activeChangeScripts && this._activeChangeScripts.length !== 0) {
                throw "Node: can't set the main active node inActive in hierarchy,if the operate is in main active node or it's children script's onEnable Event.";
            }
            else {
                (this._parent.activeInHierarchy && this.active) && this._processActive(false);
                this._parent.scene && this._setUnBelongScene();
            }
        }
        _addComponentInstance(comp) {
            var _a;
            if (!this._components)
                this._components = [];
            this._components.push(comp);
            comp._setOwner(this);
            if (this.activeInHierarchy)
                comp._setActive(true);
            (_a = this._componentsChanged) === null || _a === void 0 ? void 0 : _a.call(this, comp, 0);
        }
        _destroyComponent(comp) {
            var _a;
            if (!this._components)
                return;
            let i = this._components.indexOf(comp);
            if (i != -1) {
                this._components.splice(i, 1);
                comp._destroy();
                (_a = this._componentsChanged) === null || _a === void 0 ? void 0 : _a.call(this, comp, 1);
            }
        }
        destroyAllComponent() {
            var _a;
            if (!this._components)
                return;
            for (let i = 0, n = this._components.length; i < n; i++) {
                let item = this._components[i];
                item && !item.destroyed && item._destroy();
            }
            this._components.length = 0;
            (_a = this._componentsChanged) === null || _a === void 0 ? void 0 : _a.call(this, null, 2);
        }
        _cloneTo(destObject, srcRoot, dstRoot) {
            var destNode = destObject;
            if (this._components) {
                for (let i = 0, n = this._components.length; i < n; i++) {
                    var destComponent = destNode.addComponent(this._components[i].constructor);
                    this._components[i]._cloneTo(destComponent);
                }
            }
        }
        addComponentInstance(component) {
            if (component.owner)
                throw "Node:the component has belong to other node.";
            if (component._singleton && this.getComponent(component.constructor))
                throw "Node:the component is singleton, can't add the second one.";
            this._addComponentInstance(component);
            return component;
        }
        addComponent(componentType) {
            let comp = Pool.createByClass(componentType);
            if (!comp) {
                throw componentType.toString() + "组件不存在";
            }
            if (comp._singleton && this.getComponent(componentType))
                throw "无法实例" + componentType + "组件" + "，" + componentType + "组件已存在！";
            this._addComponentInstance(comp);
            return comp;
        }
        getComponent(componentType) {
            if (this._components) {
                for (let i = 0, n = this._components.length; i < n; i++) {
                    let comp = this._components[i];
                    if (comp instanceof componentType)
                        return comp;
                }
            }
            return null;
        }
        get components() {
            return this._components || ARRAY_EMPTY;
        }
        getComponents(componentType) {
            var arr;
            if (this._components) {
                for (let i = 0, n = this._components.length; i < n; i++) {
                    let comp = this._components[i];
                    if (comp instanceof componentType) {
                        arr = arr || [];
                        arr.push(comp);
                    }
                }
            }
            return arr;
        }
        get timer() {
            return this._scene ? this._scene.timer : ILaya.timer;
        }
        onAfterDeserialize() { }
    }

    const HALF_PI = Math.PI * 0.5;
    const PI2 = Math.PI * 2;
    class Ease {
        static linearNone(t, b, c, d) {
            return c * t / d + b;
        }
        static linearIn(t, b, c, d) {
            return c * t / d + b;
        }
        static linearInOut(t, b, c, d) {
            return c * t / d + b;
        }
        static linearOut(t, b, c, d) {
            return c * t / d + b;
        }
        static bounceIn(t, b, c, d) {
            return c - Ease.bounceOut(d - t, 0, c, d) + b;
        }
        static bounceInOut(t, b, c, d) {
            if (t < d * 0.5)
                return Ease.bounceIn(t * 2, 0, c, d) * .5 + b;
            else
                return Ease.bounceOut(t * 2 - d, 0, c, d) * .5 + c * .5 + b;
        }
        static bounceOut(t, b, c, d) {
            if ((t /= d) < (1 / 2.75))
                return c * (7.5625 * t * t) + b;
            else if (t < (2 / 2.75))
                return c * (7.5625 * (t -= (1.5 / 2.75)) * t + .75) + b;
            else if (t < (2.5 / 2.75))
                return c * (7.5625 * (t -= (2.25 / 2.75)) * t + .9375) + b;
            else
                return c * (7.5625 * (t -= (2.625 / 2.75)) * t + .984375) + b;
        }
        static backIn(t, b, c, d, s = 1.70158) {
            return c * (t /= d) * t * ((s + 1) * t - s) + b;
        }
        static backInOut(t, b, c, d, s = 1.70158) {
            if ((t /= d * 0.5) < 1)
                return c * 0.5 * (t * t * (((s *= (1.525)) + 1) * t - s)) + b;
            return c / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2) + b;
        }
        static backOut(t, b, c, d, s = 1.70158) {
            return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
        }
        static elasticIn(t, b, c, d, a = 0, p = 0) {
            var s;
            if (t == 0)
                return b;
            if ((t /= d) == 1)
                return b + c;
            if (!p)
                p = d * .3;
            if (!a || (c > 0 && a < c) || (c < 0 && a < -c)) {
                a = c;
                s = p / 4;
            }
            else
                s = p / PI2 * Math.asin(c / a);
            return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * PI2 / p)) + b;
        }
        static elasticInOut(t, b, c, d, a = 0, p = 0) {
            var s;
            if (t == 0)
                return b;
            if ((t /= d * 0.5) == 2)
                return b + c;
            if (!p)
                p = d * (.3 * 1.5);
            if (!a || (c > 0 && a < c) || (c < 0 && a < -c)) {
                a = c;
                s = p / 4;
            }
            else
                s = p / PI2 * Math.asin(c / a);
            if (t < 1)
                return -.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * PI2 / p)) + b;
            return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - s) * PI2 / p) * .5 + c + b;
        }
        static elasticOut(t, b, c, d, a = 0, p = 0) {
            var s;
            if (t == 0)
                return b;
            if ((t /= d) == 1)
                return b + c;
            if (!p)
                p = d * .3;
            if (!a || (c > 0 && a < c) || (c < 0 && a < -c)) {
                a = c;
                s = p / 4;
            }
            else
                s = p / PI2 * Math.asin(c / a);
            return (a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * PI2 / p) + c + b);
        }
        static strongIn(t, b, c, d) {
            return c * (t /= d) * t * t * t * t + b;
        }
        static strongInOut(t, b, c, d) {
            if ((t /= d * 0.5) < 1)
                return c * 0.5 * t * t * t * t * t + b;
            return c * 0.5 * ((t -= 2) * t * t * t * t + 2) + b;
        }
        static strongOut(t, b, c, d) {
            return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
        }
        static sineInOut(t, b, c, d) {
            return -c * 0.5 * (Math.cos(Math.PI * t / d) - 1) + b;
        }
        static sineIn(t, b, c, d) {
            return -c * Math.cos(t / d * HALF_PI) + c + b;
        }
        static sineOut(t, b, c, d) {
            return c * Math.sin(t / d * HALF_PI) + b;
        }
        static quintIn(t, b, c, d) {
            return c * (t /= d) * t * t * t * t + b;
        }
        static quintInOut(t, b, c, d) {
            if ((t /= d * 0.5) < 1)
                return c * 0.5 * t * t * t * t * t + b;
            return c * 0.5 * ((t -= 2) * t * t * t * t + 2) + b;
        }
        static quintOut(t, b, c, d) {
            return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
        }
        static quartIn(t, b, c, d) {
            return c * (t /= d) * t * t * t + b;
        }
        static quartInOut(t, b, c, d) {
            if ((t /= d * 0.5) < 1)
                return c * 0.5 * t * t * t * t + b;
            return -c * 0.5 * ((t -= 2) * t * t * t - 2) + b;
        }
        static quartOut(t, b, c, d) {
            return -c * ((t = t / d - 1) * t * t * t - 1) + b;
        }
        static cubicIn(t, b, c, d) {
            return c * (t /= d) * t * t + b;
        }
        static cubicInOut(t, b, c, d) {
            if ((t /= d * 0.5) < 1)
                return c * 0.5 * t * t * t + b;
            return c * 0.5 * ((t -= 2) * t * t + 2) + b;
        }
        static cubicOut(t, b, c, d) {
            return c * ((t = t / d - 1) * t * t + 1) + b;
        }
        static quadIn(t, b, c, d) {
            return c * (t /= d) * t + b;
        }
        static quadInOut(t, b, c, d) {
            if ((t /= d * 0.5) < 1)
                return c * 0.5 * t * t + b;
            return -c * 0.5 * ((--t) * (t - 2) - 1) + b;
        }
        static quadOut(t, b, c, d) {
            return -c * (t /= d) * (t - 2) + b;
        }
        static expoIn(t, b, c, d) {
            return (t == 0) ? b : c * Math.pow(2, 10 * (t / d - 1)) + b - c * 0.001;
        }
        static expoInOut(t, b, c, d) {
            if (t == 0)
                return b;
            if (t == d)
                return b + c;
            if ((t /= d * 0.5) < 1)
                return c * 0.5 * Math.pow(2, 10 * (t - 1)) + b;
            return c * 0.5 * (-Math.pow(2, -10 * --t) + 2) + b;
        }
        static expoOut(t, b, c, d) {
            return (t == d) ? b + c : c * (-Math.pow(2, -10 * t / d) + 1) + b;
        }
        static circIn(t, b, c, d) {
            return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b;
        }
        static circInOut(t, b, c, d) {
            if ((t /= d * 0.5) < 1)
                return -c * 0.5 * (Math.sqrt(1 - t * t) - 1) + b;
            return c * 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;
        }
        static circOut(t, b, c, d) {
            return c * Math.sqrt(1 - (t = t / d - 1) * t) + b;
        }
    }

    class Handler {
        constructor(caller = null, method = null, args = null, once = false) {
            this.once = false;
            this._id = 0;
            this.setTo(caller, method, args, once);
        }
        setTo(caller, method, args, once = false) {
            this._id = Handler._gid++;
            this.caller = caller;
            this.method = method;
            this.args = args;
            this.once = once;
            return this;
        }
        run() {
            if (this.method == null)
                return null;
            var id = this._id;
            var result = this.method.apply(this.caller, this.args);
            this._id === id && this.once && this.recover();
            return result;
        }
        runWith(data) {
            if (this.method == null)
                return null;
            var id = this._id;
            if (data == null)
                var result = this.method.apply(this.caller, this.args);
            else if (!this.args && !data.unshift)
                result = this.method.call(this.caller, data);
            else if (this.args)
                result = this.method.apply(this.caller, this.args.concat(data));
            else
                result = this.method.apply(this.caller, data);
            this._id === id && this.once && this.recover();
            return result;
        }
        clear() {
            this.caller = null;
            this.method = null;
            this.args = null;
            return this;
        }
        recover() {
            if (this._id > 0) {
                this._id = 0;
                Handler._pool.push(this.clear());
            }
        }
        static create(caller, method, args = null, once = true) {
            if (Handler._pool.length)
                return Handler._pool.pop().setTo(caller, method, args, once);
            return new Handler(caller, method, args, once);
        }
    }
    Handler._pool = [];
    Handler._gid = 1;

    class Tween {
        constructor() {
            this.gid = 0;
            this.repeat = 1;
            this._count = 0;
        }
        static to(target, props, duration, ease = null, complete = null, delay = 0, coverBefore = false, autoRecover = true) {
            return Pool.getItemByClass("tween", Tween)._create(target, props, duration, ease, complete, delay, coverBefore, true, autoRecover, true);
        }
        static from(target, props, duration, ease = null, complete = null, delay = 0, coverBefore = false, autoRecover = true) {
            return Pool.getItemByClass("tween", Tween)._create(target, props, duration, ease, complete, delay, coverBefore, false, autoRecover, true);
        }
        to(target, props, duration, ease = null, complete = null, delay = 0, coverBefore = false) {
            return this._create(target, props, duration, ease, complete, delay, coverBefore, true, false, true);
        }
        from(target, props, duration, ease = null, complete = null, delay = 0, coverBefore = false) {
            return this._create(target, props, duration, ease, complete, delay, coverBefore, false, false, true);
        }
        _create(target, props, duration, ease, complete, delay, coverBefore, isTo, usePool, runNow) {
            if (!target)
                throw new Error("Tween:target is null");
            this._target = target;
            this._duration = duration;
            this._ease = ease || props.ease || Tween.easeNone;
            this._complete = complete || props.complete;
            this._delay = delay;
            this._props = [];
            this._usedTimer = 0;
            this._startTimer = Browser.now();
            this._usedPool = usePool;
            this._delayParam = null;
            this.update = props.update;
            var gid = (target.$_GID || (target.$_GID = Utils.getGID()));
            if (!Tween.tweenMap[gid]) {
                Tween.tweenMap[gid] = [this];
            }
            else {
                if (coverBefore)
                    Tween.clearTween(target);
                Tween.tweenMap[gid].push(this);
            }
            if (runNow) {
                if (delay <= 0)
                    this.firstStart(target, props, isTo);
                else {
                    this._delayParam = [target, props, isTo];
                    ILaya.timer.once(delay, this, this.firstStart, this._delayParam);
                }
            }
            else {
                this._initProps(target, props, isTo);
            }
            return this;
        }
        firstStart(target, props, isTo) {
            this._delayParam = null;
            if (target.destroyed) {
                this.clear();
                return;
            }
            this._initProps(target, props, isTo);
            this._beginLoop();
        }
        _initProps(target, props, isTo) {
            for (var p in props) {
                if (typeof (target[p]) == 'number') {
                    var start = isTo ? target[p] : props[p];
                    var end = isTo ? props[p] : target[p];
                    this._props.push([p, start, end - start]);
                    if (!isTo)
                        target[p] = start;
                }
            }
        }
        _beginLoop() {
            ILaya.timer.frameLoop(1, this, this._doEase);
        }
        _doEase() {
            this._updateEase(Browser.now());
        }
        _updateEase(time) {
            var target = this._target;
            if (!target)
                return;
            if (target.destroyed)
                return Tween.clearTween(target);
            var usedTimer = this._usedTimer = time - this._startTimer - this._delay;
            if (usedTimer < 0)
                return;
            if (usedTimer >= this._duration)
                return this.complete();
            var ratio = usedTimer > 0 ? this._ease(usedTimer, 0, 1, this._duration) : 0;
            var props = this._props;
            for (var i = 0, n = props.length; i < n; i++) {
                var prop = props[i];
                target[prop[0]] = prop[1] + (ratio * prop[2]);
            }
            if (this.update)
                this.update.run();
        }
        set progress(v) {
            var uTime = v * this._duration;
            this._startTimer = Browser.now() - this._delay - uTime;
        }
        complete() {
            if (!this._target)
                return;
            ILaya.timer.runTimer(this, this.firstStart);
            var target = this._target;
            var props = this._props;
            var handler = this._complete;
            for (var i = 0, n = props.length; i < n; i++) {
                var prop = props[i];
                target[prop[0]] = prop[1] + prop[2];
            }
            if (this.update)
                this.update.run();
            this._count++;
            if (this.repeat != 0 && this._count >= this.repeat) {
                this.clear();
                handler && handler.run();
            }
            else {
                this.restart();
            }
        }
        pause() {
            ILaya.timer.clear(this, this._beginLoop);
            ILaya.timer.clear(this, this._doEase);
            ILaya.timer.clear(this, this.firstStart);
            var time = Browser.now();
            var dTime;
            dTime = time - this._startTimer - this._delay;
            if (dTime < 0) {
                this._usedTimer = dTime;
            }
        }
        setStartTime(startTime) {
            this._startTimer = startTime;
        }
        static clearAll(target) {
            if (!target || !target.$_GID)
                return;
            var tweens = Tween.tweenMap[target.$_GID];
            if (tweens) {
                for (var i = 0, n = tweens.length; i < n; i++) {
                    tweens[i]._clear();
                }
                tweens.length = 0;
            }
        }
        static clear(tween) {
            tween.clear();
        }
        static clearTween(target) {
            Tween.clearAll(target);
        }
        clear() {
            if (this._target) {
                this._remove();
                this._clear();
            }
        }
        _clear() {
            this.pause();
            ILaya.timer.clear(this, this.firstStart);
            this._complete = null;
            this._target = null;
            this._ease = null;
            this._props = null;
            this._delayParam = null;
            this.repeat = 1;
            if (this._usedPool) {
                this.update = null;
                Pool.recover("tween", this);
            }
        }
        recover() {
            this._usedPool = true;
            this._clear();
        }
        _remove() {
            var tweens = Tween.tweenMap[this._target.$_GID];
            if (tweens) {
                for (var i = 0, n = tweens.length; i < n; i++) {
                    if (tweens[i] === this) {
                        tweens.splice(i, 1);
                        break;
                    }
                }
            }
        }
        restart() {
            this.pause();
            this._usedTimer = 0;
            this._startTimer = Browser.now();
            if (this._delayParam) {
                ILaya.timer.once(this._delay, this, this.firstStart, this._delayParam);
                return;
            }
            var props = this._props;
            for (var i = 0, n = props.length; i < n; i++) {
                var prop = props[i];
                this._target[prop[0]] = prop[1];
            }
            ILaya.timer.once(this._delay, this, this._beginLoop);
        }
        resume() {
            if (this._usedTimer >= this._duration)
                return;
            this._startTimer = Browser.now() - this._usedTimer - this._delay;
            if (this._delayParam) {
                if (this._usedTimer < 0) {
                    ILaya.timer.once(-this._usedTimer, this, this.firstStart, this._delayParam);
                }
                else {
                    this.firstStart.apply(this, this._delayParam);
                }
            }
            else {
                this._beginLoop();
            }
        }
        static easeNone(t, b, c, d) {
            return c * t / d + b;
        }
    }
    Tween.tweenMap = [];

    class Dragging {
        constructor() {
            this.ratio = 0.92;
            this.maxOffset = 60;
            this._dragging = false;
            this._clickOnly = true;
        }
        start(target, area, hasInertia, elasticDistance, elasticBackTime, data, ratio = 0.92) {
            this.clearTimer();
            this.target = target;
            this.area = area;
            this.hasInertia = hasInertia;
            this.elasticDistance = area ? elasticDistance : 0;
            this.elasticBackTime = elasticBackTime;
            this.data = data;
            this.ratio = ratio;
            this._parent = target.parent;
            this._clickOnly = true;
            this._dragging = true;
            this._elasticRateX = this._elasticRateY = 1;
            this._lastX = this._parent.mouseX;
            this._lastY = this._parent.mouseY;
            ILaya.stage.on(Event.MOUSE_UP, this, this.onStageMouseUp);
            ILaya.stage.on(Event.MOUSE_OUT, this, this.onStageMouseUp);
            ILaya.systemTimer.frameLoop(1, this, this.loop);
        }
        clearTimer() {
            ILaya.systemTimer.clear(this, this.loop);
            ILaya.systemTimer.clear(this, this.tweenMove);
            if (this._tween) {
                this._tween.recover();
                this._tween = null;
            }
        }
        stop() {
            if (this._dragging) {
                ILaya.stage.off(Event.MOUSE_UP, this, this.onStageMouseUp);
                ILaya.stage.off(Event.MOUSE_OUT, this, this.onStageMouseUp);
                this._dragging = false;
                this.target && this.area && this.backToArea();
                this.clear();
            }
        }
        loop() {
            var point = this._parent.getMousePoint();
            var mouseX = point.x;
            var mouseY = point.y;
            var offsetX = mouseX - this._lastX;
            var offsetY = mouseY - this._lastY;
            if (this._clickOnly) {
                if (Math.abs(offsetX * ILaya.stage._canvasTransform.getScaleX()) > 1 || Math.abs(offsetY * ILaya.stage._canvasTransform.getScaleY()) > 1) {
                    this._clickOnly = false;
                    this._offsets || (this._offsets = []);
                    this._offsets.length = 0;
                    this.target.event(Event.DRAG_START, this.data);
                }
                else
                    return;
            }
            else {
                this._offsets.push(offsetX, offsetY);
            }
            if (offsetX === 0 && offsetY === 0)
                return;
            this._lastX = mouseX;
            this._lastY = mouseY;
            this.target.x += offsetX * this._elasticRateX;
            this.target.y += offsetY * this._elasticRateY;
            this.area && this.checkArea();
            this.target.event(Event.DRAG_MOVE, this.data);
        }
        checkArea() {
            if (this.elasticDistance <= 0) {
                this.backToArea();
            }
            else {
                if (this.target._x < this.area.x) {
                    var offsetX = this.area.x - this.target._x;
                }
                else if (this.target._x > this.area.x + this.area.width) {
                    offsetX = this.target._x - this.area.x - this.area.width;
                }
                else {
                    offsetX = 0;
                }
                this._elasticRateX = Math.max(0, 1 - (offsetX / this.elasticDistance));
                if (this.target._y < this.area.y) {
                    var offsetY = this.area.y - this.target.y;
                }
                else if (this.target._y > this.area.y + this.area.height) {
                    offsetY = this.target._y - this.area.y - this.area.height;
                }
                else {
                    offsetY = 0;
                }
                this._elasticRateY = Math.max(0, 1 - (offsetY / this.elasticDistance));
            }
        }
        backToArea() {
            this.target.x = Math.min(Math.max(this.target._x, this.area.x), this.area.x + this.area.width);
            this.target.y = Math.min(Math.max(this.target._y, this.area.y), this.area.y + this.area.height);
        }
        onStageMouseUp(e) {
            ILaya.stage.off(Event.MOUSE_UP, this, this.onStageMouseUp);
            ILaya.stage.off(Event.MOUSE_OUT, this, this.onStageMouseUp);
            ILaya.systemTimer.clear(this, this.loop);
            if (this._clickOnly || !this.target)
                return;
            if (this.hasInertia) {
                if (this._offsets.length < 1) {
                    this._offsets.push(this._parent.mouseX - this._lastX, this._parent.mouseY - this._lastY);
                }
                this._offsetX = this._offsetY = 0;
                var len = this._offsets.length;
                var n = Math.min(len, 6);
                var m = this._offsets.length - n;
                for (var i = len - 1; i > m; i--) {
                    this._offsetY += this._offsets[i--];
                    this._offsetX += this._offsets[i];
                }
                this._offsetX = this._offsetX / n * 2;
                this._offsetY = this._offsetY / n * 2;
                if (Math.abs(this._offsetX) > this.maxOffset)
                    this._offsetX = this._offsetX > 0 ? this.maxOffset : -this.maxOffset;
                if (Math.abs(this._offsetY) > this.maxOffset)
                    this._offsetY = this._offsetY > 0 ? this.maxOffset : -this.maxOffset;
                ILaya.systemTimer.frameLoop(1, this, this.tweenMove);
            }
            else if (this.elasticDistance > 0) {
                this.checkElastic();
            }
            else {
                this.clear();
            }
        }
        checkElastic() {
            var tx = NaN;
            var ty = NaN;
            if (this.target.x < this.area.x)
                tx = this.area.x;
            else if (this.target._x > this.area.x + this.area.width)
                tx = this.area.x + this.area.width;
            if (this.target.y < this.area.y)
                ty = this.area.y;
            else if (this.target._y > this.area.y + this.area.height)
                ty = this.area.y + this.area.height;
            if (!isNaN(tx) || !isNaN(ty)) {
                var obj = {};
                if (!isNaN(tx))
                    obj.x = tx;
                if (!isNaN(ty))
                    obj.y = ty;
                this._tween = Tween.to(this.target, obj, this.elasticBackTime, Ease.sineOut, Handler.create(this, this.clear), 0, false, false);
            }
            else {
                this.clear();
            }
        }
        tweenMove() {
            this._offsetX *= this.ratio * this._elasticRateX;
            this._offsetY *= this.ratio * this._elasticRateY;
            this.target.x += this._offsetX;
            this.target.y += this._offsetY;
            this.area && this.checkArea();
            this.target.event(Event.DRAG_MOVE, this.data);
            if ((Math.abs(this._offsetX) < 1 && Math.abs(this._offsetY) < 1) || this._elasticRateX < 0.5 || this._elasticRateY < 0.5) {
                ILaya.systemTimer.clear(this, this.tweenMove);
                if (this.elasticDistance > 0)
                    this.checkElastic();
                else
                    this.clear();
            }
        }
        clear() {
            if (this.target) {
                this.clearTimer();
                var sp = this.target;
                this.target = null;
                this._parent = null;
                sp.event(Event.DRAG_END, this.data);
            }
        }
    }

    class SpriteUtils {
        static getGlobalRecByPoints(sprite, x0, y0, x1, y1) {
            var newLTPoint;
            newLTPoint = Point.create().setTo(x0, y0);
            newLTPoint = sprite.localToGlobal(newLTPoint);
            var newRBPoint;
            newRBPoint = Point.create().setTo(x1, y1);
            newRBPoint = sprite.localToGlobal(newRBPoint);
            var rst = Rectangle._getWrapRec([newLTPoint.x, newLTPoint.y, newRBPoint.x, newRBPoint.y]);
            newLTPoint.recover();
            newRBPoint.recover();
            return rst;
        }
        static getGlobalPosAndScale(sprite) {
            return SpriteUtils.getGlobalRecByPoints(sprite, 0, 0, 1, 1);
        }
        static getTransformRelativeToWindow(coordinateSpace, x, y) {
            var stage = ILaya.stage;
            var globalTransform = SpriteUtils.getGlobalPosAndScale(coordinateSpace);
            var canvasMatrix = stage._canvasTransform.clone();
            var canvasLeft = canvasMatrix.tx;
            var canvasTop = canvasMatrix.ty;
            canvasMatrix.rotate(-Math.PI / 180 * stage.canvasDegree);
            canvasMatrix.scale(stage.clientScaleX, stage.clientScaleY);
            var perpendicular = (stage.canvasDegree % 180 != 0);
            var tx, ty;
            if (perpendicular) {
                tx = y + globalTransform.y;
                ty = x + globalTransform.x;
                tx *= canvasMatrix.d;
                ty *= canvasMatrix.a;
                if (stage.canvasDegree == 90) {
                    tx = canvasLeft - tx;
                    ty += canvasTop;
                }
                else {
                    tx += canvasLeft;
                    ty = canvasTop - ty;
                }
            }
            else {
                tx = x + globalTransform.x;
                ty = y + globalTransform.y;
                tx *= canvasMatrix.a;
                ty *= canvasMatrix.d;
                tx += canvasLeft;
                ty += canvasTop;
            }
            ty += stage['_safariOffsetY'];
            var domScaleX, domScaleY;
            if (perpendicular) {
                domScaleX = canvasMatrix.d * globalTransform.height;
                domScaleY = canvasMatrix.a * globalTransform.width;
            }
            else {
                domScaleX = canvasMatrix.a * globalTransform.width;
                domScaleY = canvasMatrix.d * globalTransform.height;
            }
            return { x: tx, y: ty, scaleX: domScaleX, scaleY: domScaleY };
        }
        static fitDOMElementInArea(dom, coordinateSpace, x, y, width, height) {
            if (!dom._fitLayaAirInitialized) {
                dom._fitLayaAirInitialized = true;
                dom.style.transformOrigin = dom.style.webKittransformOrigin = "left top";
                dom.style.position = "absolute";
            }
            var transform = SpriteUtils.getTransformRelativeToWindow(coordinateSpace, x, y);
            dom.style.transform = dom.style.webkitTransform = "scale(" + transform.scaleX + "," + transform.scaleY + ") rotate(" + (ILaya.stage.canvasDegree) + "deg)";
            dom.style.width = width + 'px';
            dom.style.height = height + 'px';
            dom.style.left = transform.x + 'px';
            dom.style.top = transform.y + 'px';
        }
        static updateOrder(array) {
            if (!array || array.length < 2)
                return false;
            var i = 1, j, len = array.length, key, c;
            while (i < len) {
                j = i;
                c = array[j];
                key = array[j]._zOrder;
                while (--j > -1) {
                    if (array[j]._zOrder > key)
                        array[j + 1] = array[j];
                    else
                        break;
                }
                array[j + 1] = c;
                i++;
            }
            return true;
        }
    }

    class Sprite extends Node {
        constructor() {
            super();
            this._x = 0;
            this._y = 0;
            this._width = 0;
            this._height = 0;
            this._visible = true;
            this._mouseState = 0;
            this._zOrder = 0;
            this._renderType = 0;
            this._transform = null;
            this._tfChanged = false;
            this._repaint = SpriteConst.REPAINT_NONE;
            this._texture = null;
            this._style = SpriteStyle.EMPTY;
            this._cacheStyle = CacheStyle.EMPTY;
            this._boundStyle = null;
            this._graphics = null;
            this._ownGraphics = false;
            this.mouseThrough = false;
            this.autoSize = false;
            this.hitTestPrior = false;
        }
        destroy(destroyChild = true) {
            super.destroy(destroyChild);
            this._style && this._style.recover();
            this._cacheStyle && this._cacheStyle.recover();
            this._boundStyle && this._boundStyle.recover();
            this._transform && this._transform.recover();
            this._style = null;
            this._cacheStyle = null;
            this._boundStyle = null;
            this._transform = null;
            this._texture && this._texture._removeReference();
            this._texture = null;
            this._graphics && this._ownGraphics && this._graphics.destroy();
            this._graphics = null;
        }
        get scene() {
            return this._scene;
        }
        updateZOrder() {
            SpriteUtils.updateOrder(this._children) && this.repaint();
        }
        _getBoundsStyle() {
            if (!this._boundStyle)
                this._boundStyle = BoundsStyle.create();
            return this._boundStyle;
        }
        _setCustomRender() {
        }
        set customRenderEnable(b) {
            if (b) {
                this._renderType |= SpriteConst.CUSTOM;
                this._setRenderType(this._renderType);
                this._setCustomRender();
            }
        }
        get cacheAs() {
            return this._cacheStyle.userSetCache;
        }
        _setCacheAs(value) {
        }
        set cacheAs(value) {
            if (value === this._cacheStyle.userSetCache)
                return;
            this._getCacheStyle().userSetCache = value;
            if (this.mask && value === 'normal')
                return;
            this._setCacheAs(value);
            this._checkCanvasEnable();
            this.repaint();
        }
        _checkCanvasEnable() {
            var tEnable = this._cacheStyle.needEnableCanvasRender();
            this._getCacheStyle().enableCanvasRender = tEnable;
            if (tEnable) {
                if (this._cacheStyle.needBitmapCache()) {
                    this._cacheStyle.cacheAs = "bitmap";
                }
                else {
                    this._cacheStyle.cacheAs = this._cacheStyle.userSetCache;
                }
                this._cacheStyle.reCache = true;
                this._renderType |= SpriteConst.CANVAS;
            }
            else {
                this._cacheStyle.cacheAs = "none";
                this._cacheStyle.releaseContext();
                this._renderType &= ~SpriteConst.CANVAS;
            }
            this._setCacheAs(this._cacheStyle.cacheAs);
            this._setRenderType(this._renderType);
        }
        get staticCache() {
            return this._cacheStyle.staticCache;
        }
        set staticCache(value) {
            this._getCacheStyle().staticCache = value;
            if (!value)
                this.reCache();
        }
        reCache() {
            this._cacheStyle.reCache = true;
            this._repaint |= SpriteConst.REPAINT_CACHE;
        }
        getRepaint() {
            return this._repaint;
        }
        _setX(value) {
            this._x = value;
        }
        _setY(value) {
            this._y = value;
        }
        _setWidth(texture, value) {
        }
        _setHeight(texture, value) {
        }
        get x() {
            return this._x;
        }
        set x(value) {
            if (this._destroyed)
                return;
            if (this._x !== value) {
                this._setX(value);
                this.parentRepaint(SpriteConst.REPAINT_CACHE);
                var p = this._cacheStyle.maskParent;
                if (p) {
                    p.repaint(SpriteConst.REPAINT_CACHE);
                }
            }
        }
        get y() {
            return this._y;
        }
        set y(value) {
            if (this._destroyed)
                return;
            if (this._y !== value) {
                this._setY(value);
                this.parentRepaint(SpriteConst.REPAINT_CACHE);
                var p = this._cacheStyle.maskParent;
                if (p) {
                    p.repaint(SpriteConst.REPAINT_CACHE);
                }
            }
        }
        get width() {
            return this.get_width();
        }
        set width(value) {
            this.set_width(value);
        }
        set_width(value) {
            if (this._width !== value) {
                this._width = 0 == value ? 0.0000001 : value;
                this._setWidth(this.texture, value);
                this._setTranformChange();
            }
        }
        get_width() {
            if (!this.autoSize)
                return 0.0000001 == this._width ? 0 : (this._width ? this._width : (this.texture ? this.texture.width : 0));
            if (this.texture)
                return this.texture.width;
            if (!this._graphics && this._children.length === 0)
                return 0;
            return this.getSelfBounds().width;
        }
        get height() {
            return this.get_height();
        }
        set height(value) {
            this.set_height(value);
        }
        set_height(value) {
            if (this._height !== value) {
                this._height = 0 == value ? 0.0000001 : value;
                this._setHeight(this.texture, value);
                this._setTranformChange();
            }
        }
        get_height() {
            if (!this.autoSize)
                return 0.0000001 == this._height ? 0 : (this._height ? this._height : (this.texture ? this.texture.height : 0));
            if (this.texture)
                return this.texture.height;
            if (!this._graphics && this._children.length === 0)
                return 0;
            return this.getSelfBounds().height;
        }
        get displayWidth() {
            return this.width * this.scaleX;
        }
        get displayHeight() {
            return this.height * this.scaleY;
        }
        setSelfBounds(bound) {
            this._getBoundsStyle().userBounds = bound;
        }
        getBounds() {
            return this._getBoundsStyle().bounds = Rectangle._getWrapRec(this._boundPointsToParent());
        }
        getSelfBounds() {
            if (this._boundStyle && this._boundStyle.userBounds)
                return this._boundStyle.userBounds;
            if (!this._graphics && this._children.length === 0 && !this._texture)
                return Rectangle.TEMP.setTo(0, 0, this.width, this.height);
            return this._getBoundsStyle().bounds = Rectangle._getWrapRec(this._getBoundPointsM(false));
        }
        _boundPointsToParent(ifRotate = false) {
            var pX = 0, pY = 0;
            if (this._style) {
                pX = this.pivotX;
                pY = this.pivotY;
                ifRotate = ifRotate || (this._style.rotation !== 0);
                if (this._style.scrollRect) {
                    pX += this._style.scrollRect.x;
                    pY += this._style.scrollRect.y;
                }
            }
            var pList = this._getBoundPointsM(ifRotate);
            if (!pList || pList.length < 1)
                return pList;
            if (pList.length != 8) {
                pList = ifRotate ? GrahamScan.scanPList(pList) : Rectangle._getWrapRec(pList, Rectangle.TEMP)._getBoundPoints();
            }
            if (!this.transform) {
                Utils.transPointList(pList, this._x - pX, this._y - pY);
                return pList;
            }
            var tPoint = Point.TEMP;
            var i, len = pList.length;
            for (i = 0; i < len; i += 2) {
                tPoint.x = pList[i];
                tPoint.y = pList[i + 1];
                this.toParentPoint(tPoint);
                pList[i] = tPoint.x;
                pList[i + 1] = tPoint.y;
            }
            return pList;
        }
        getGraphicBounds(realSize = false) {
            if (!this._graphics)
                return Rectangle.TEMP.setTo(0, 0, 0, 0);
            return this._graphics.getBounds(realSize);
        }
        _getBoundPointsM(ifRotate = false) {
            if (this._boundStyle && this._boundStyle.userBounds)
                return this._boundStyle.userBounds._getBoundPoints();
            if (!this._boundStyle)
                this._getBoundsStyle();
            let rst = this._boundStyle.temBM;
            if (!rst)
                rst = this._boundStyle.temBM = [];
            if (this._style.scrollRect) {
                rst.length = 0;
                var rec = Rectangle.TEMP;
                rec.copyFrom(this._style.scrollRect);
                rst.push(...rec._getBoundPoints());
                return rst;
            }
            var pList;
            if (this._graphics) {
                pList = this._graphics.getBoundPoints();
            }
            else {
                rst.length = 0;
                pList = rst;
            }
            if (this._texture) {
                rec = Rectangle.TEMP;
                rec.setTo(0, 0, this.width || this._texture.width, this.height || this._texture.height);
                pList.push(...rec._getBoundPoints());
            }
            let child;
            let cList;
            let __childs;
            __childs = this._children;
            for (let i = 0, n = __childs.length; i < n; i++) {
                child = __childs[i];
                if (child instanceof Sprite && child._visible === true) {
                    cList = child._boundPointsToParent(ifRotate);
                    if (cList) {
                        if (pList)
                            pList.push(...cList);
                        else
                            pList = cList;
                    }
                }
            }
            return pList;
        }
        _getCacheStyle() {
            this._cacheStyle === CacheStyle.EMPTY && (this._cacheStyle = CacheStyle.create());
            return this._cacheStyle;
        }
        getStyle() {
            this._style === SpriteStyle.EMPTY && (this._style = SpriteStyle.create());
            return this._style;
        }
        setStyle(value) {
            this._style = value;
        }
        get scaleX() {
            return this._style.scaleX;
        }
        set scaleX(value) {
            this.set_scaleX(value);
        }
        _setScaleX(value) {
            this._style.scaleX = value;
        }
        get scaleY() {
            return this._style.scaleY;
        }
        set scaleY(value) {
            this.set_scaleY(value);
        }
        _setScaleY(value) {
            this._style.scaleY = value;
        }
        set_scaleX(value) {
            var style = this.getStyle();
            if (style.scaleX !== value) {
                this._setScaleX(value);
                this._setTranformChange();
            }
        }
        get_scaleX() {
            return this._style.scaleX;
        }
        set_scaleY(value) {
            var style = this.getStyle();
            if (style.scaleY !== value) {
                this._setScaleY(value);
                this._setTranformChange();
            }
        }
        get_scaleY() {
            return this._style.scaleY;
        }
        get rotation() {
            return this._style.rotation;
        }
        set rotation(value) {
            var style = this.getStyle();
            if (style.rotation !== value) {
                this._setRotation(value);
                this._setTranformChange();
            }
        }
        _setRotation(value) {
            this._style.rotation = value;
        }
        get skewX() {
            return this._style.skewX;
        }
        set skewX(value) {
            var style = this.getStyle();
            if (style.skewX !== value) {
                this._setSkewX(value);
                this._setTranformChange();
            }
        }
        _setSkewX(value) {
            this._style.skewX = value;
        }
        get skewY() {
            return this._style.skewY;
        }
        set skewY(value) {
            var style = this.getStyle();
            if (style.skewY !== value) {
                this._setSkewY(value);
                this._setTranformChange();
            }
        }
        _setSkewY(value) {
            this._style.skewY = value;
        }
        _createTransform() {
            return Matrix.create();
        }
        _adjustTransform() {
            this._tfChanged = false;
            var style = this._style;
            var sx = style.scaleX, sy = style.scaleY;
            var sskx = style.skewX;
            var ssky = style.skewY;
            var rot = style.rotation;
            var m = this._transform || (this._transform = this._createTransform());
            if (rot || sx !== 1 || sy !== 1 || sskx !== 0 || ssky !== 0) {
                m._bTransform = true;
                var skx = (rot - sskx) * 0.0174532922222222;
                var sky = (rot + ssky) * 0.0174532922222222;
                var cx = Math.cos(sky);
                var ssx = Math.sin(sky);
                var cy = Math.sin(skx);
                var ssy = Math.cos(skx);
                m.a = sx * cx;
                m.b = sx * ssx;
                m.c = -sy * cy;
                m.d = sy * ssy;
                m.tx = m.ty = 0;
            }
            else {
                m.identity();
                this._renderType &= ~SpriteConst.TRANSFORM;
                this._setRenderType(this._renderType);
            }
            return m;
        }
        _setTransform(value) {
        }
        get transform() {
            return this._tfChanged ? this._adjustTransform() : this._transform;
        }
        set transform(value) {
            this.set_transform(value);
        }
        get_transform() {
            return this._tfChanged ? this._adjustTransform() : this._transform;
        }
        set_transform(value) {
            this._tfChanged = false;
            var m = this._transform || (this._transform = this._createTransform());
            value.copyTo(m);
            this._setTransform(m);
            if (value) {
                this._x = m.tx;
                this._y = m.ty;
                m.tx = m.ty = 0;
            }
            if (value)
                this._renderType |= SpriteConst.TRANSFORM;
            else {
                this._renderType &= ~SpriteConst.TRANSFORM;
            }
            this._setRenderType(this._renderType);
            this.parentRepaint();
        }
        _setPivotX(value) {
            var style = this.getStyle();
            style.pivotX = value;
        }
        _getPivotX() {
            return this._style.pivotX;
        }
        _setPivotY(value) {
            var style = this.getStyle();
            style.pivotY = value;
        }
        _getPivotY() {
            return this._style.pivotY;
        }
        get pivotX() {
            return this._getPivotX();
        }
        set pivotX(value) {
            this._setPivotX(value);
            this.repaint();
        }
        get pivotY() {
            return this._getPivotY();
        }
        set pivotY(value) {
            this._setPivotY(value);
            this.repaint();
        }
        _setAlpha(value) {
            if (this._style.alpha !== value) {
                var style = this.getStyle();
                style.alpha = value;
                if (value !== 1)
                    this._renderType |= SpriteConst.ALPHA;
                else
                    this._renderType &= ~SpriteConst.ALPHA;
                this._setRenderType(this._renderType);
                this.parentRepaint();
            }
        }
        _getAlpha() {
            return this._style.alpha;
        }
        get alpha() {
            return this._getAlpha();
        }
        set alpha(value) {
            value = value < 0 ? 0 : (value > 1 ? 1 : value);
            this._setAlpha(value);
        }
        get visible() {
            return this.get_visible();
        }
        set visible(value) {
            this.set_visible(value);
        }
        get_visible() {
            return this._visible;
        }
        set_visible(value) {
            if (this._visible !== value) {
                this._visible = value;
                this.parentRepaint(SpriteConst.REPAINT_ALL);
            }
        }
        _setBlendMode(value) {
        }
        get blendMode() {
            return this._style.blendMode;
        }
        set blendMode(value) {
            this._setBlendMode(value);
            this.getStyle().blendMode = value;
            if (value && value != "source-over")
                this._renderType |= SpriteConst.BLEND;
            else
                this._renderType &= ~SpriteConst.BLEND;
            this._setRenderType(this._renderType);
            this.parentRepaint();
        }
        get graphics() {
            if (!this._graphics) {
                this.graphics = new Graphics();
                this._ownGraphics = true;
            }
            return this._graphics;
        }
        _setGraphics(value) {
        }
        set graphics(value) {
            if (this._graphics)
                this._graphics._sp = null;
            this._graphics = value;
            if (value) {
                this._setGraphics(value);
                this._renderType |= SpriteConst.GRAPHICS;
                value._sp = this;
            }
            else {
                this._renderType &= ~SpriteConst.GRAPHICS;
            }
            this._setRenderType(this._renderType);
            this.repaint();
        }
        get scrollRect() {
            return this._style.scrollRect;
        }
        _setScrollRect(value) {
        }
        set scrollRect(value) {
            this.getStyle().scrollRect = value;
            this._setScrollRect(value);
            if (value) {
                this._renderType |= SpriteConst.CLIP;
            }
            else {
                this._renderType &= ~SpriteConst.CLIP;
            }
            this._setRenderType(this._renderType);
            this.repaint();
        }
        pos(x, y, speedMode = false) {
            if (this._x !== x || this._y !== y) {
                if (this._destroyed)
                    return this;
                if (speedMode) {
                    this._setX(x);
                    this._setY(y);
                    this.parentRepaint(SpriteConst.REPAINT_CACHE);
                    var p = this._cacheStyle.maskParent;
                    if (p) {
                        p.repaint(SpriteConst.REPAINT_CACHE);
                    }
                }
                else {
                    this.x = x;
                    this.y = y;
                }
            }
            return this;
        }
        pivot(x, y) {
            this.pivotX = x;
            this.pivotY = y;
            return this;
        }
        size(width, height) {
            this.width = width;
            this.height = height;
            return this;
        }
        scale(scaleX, scaleY, speedMode = false) {
            var style = this.getStyle();
            if (style.scaleX != scaleX || style.scaleY != scaleY) {
                if (this._destroyed)
                    return this;
                if (speedMode) {
                    this._setScaleX(scaleX);
                    this._setScaleY(scaleY);
                    this._setTranformChange();
                }
                else {
                    this.scaleX = scaleX;
                    this.scaleY = scaleY;
                }
            }
            return this;
        }
        skew(skewX, skewY) {
            this.skewX = skewX;
            this.skewY = skewY;
            return this;
        }
        render(ctx, x, y) {
            RenderSprite.renders[this._renderType]._fun(this, ctx, x + this._x, y + this._y);
            this._repaint = 0;
        }
        drawToCanvas(canvasWidth, canvasHeight, offsetX, offsetY) {
            return Sprite.drawToCanvas(this, this._renderType, canvasWidth, canvasHeight, offsetX, offsetY);
        }
        drawToTexture(canvasWidth, canvasHeight, offsetX, offsetY, rt = null, invertY = false) {
            RenderState2D.InvertY = invertY;
            let res = Sprite.drawToTexture(this, this._renderType, canvasWidth, canvasHeight, offsetX, offsetY, rt);
            RenderState2D.InvertY = false;
            return res;
        }
        drawToTexture3D(offx, offy, tex) {
            throw 'not implement';
        }
        static drawToCanvas(sprite, _renderType, canvasWidth, canvasHeight, offsetX, offsetY) {
            offsetX -= sprite.x;
            offsetY -= sprite.y;
            offsetX |= 0;
            offsetY |= 0;
            canvasWidth |= 0;
            canvasHeight |= 0;
            var ctx = new Context();
            ctx.size(canvasWidth, canvasHeight);
            ctx.asBitmap = true;
            ctx._targets.start();
            ctx._targets.clear(0, 0, 0, 0);
            RenderSprite.renders[_renderType]._fun(sprite, ctx, offsetX, offsetY);
            ctx.flush();
            ctx._targets.end();
            ctx._targets.restore();
            var dt = ctx._targets.getData(0, 0, canvasWidth, canvasHeight);
            ctx.destroy();
            var imgdata = new ImageData(canvasWidth, canvasHeight);
            var lineLen = canvasWidth * 4;
            var dst = imgdata.data;
            var y = canvasHeight - 1;
            var off = y * lineLen;
            var srcoff = 0;
            for (; y >= 0; y--) {
                dst.set(dt.subarray(srcoff, srcoff + lineLen), off);
                off -= lineLen;
                srcoff += lineLen;
            }
            var canv = new HTMLCanvas(true);
            canv.size(canvasWidth, canvasHeight);
            var ctx2d = canv.getContext('2d');
            ctx2d.putImageData(imgdata, 0, 0);
            return canv;
        }
        static drawToTexture(sprite, _renderType, canvasWidth, canvasHeight, offsetX, offsetY, rt = null) {
            if (!Sprite.drawtocanvCtx) {
                Sprite.drawtocanvCtx = new Context();
            }
            offsetX -= sprite.x;
            offsetY -= sprite.y;
            offsetX |= 0;
            offsetY |= 0;
            canvasWidth |= 0;
            canvasHeight |= 0;
            var ctx = rt ? Sprite.drawtocanvCtx : new Context();
            ctx.clear();
            ctx.size(canvasWidth, canvasHeight);
            if (rt) {
                ctx._targets = rt;
            }
            else {
                ctx.asBitmap = true;
            }
            let texRT;
            if (ctx._targets) {
                ctx._targets.start();
                let color = RenderTexture2D._clearColor;
                ctx._targets.clear(color.r, color.g, color.b, color.a);
                ctx._drawingToTexture = true;
                RenderSprite.renders[_renderType]._fun(sprite, ctx, offsetX, offsetY);
                ctx._drawingToTexture = false;
                ctx.flush();
                ctx._targets.end();
                ctx._targets.restore();
                if (!rt)
                    texRT = ctx._targets;
                ctx._targets = null;
            }
            if (!rt) {
                var rtex = new Texture(ctx._targets ? ctx._targets : texRT, Texture.INV_UV);
                ctx.destroy(true);
                return rtex;
            }
            sprite._repaint = 0;
            return rt;
        }
        customRender(context, x, y) {
            this._repaint = SpriteConst.REPAINT_ALL;
        }
        _applyFilters() {
        }
        get filters() {
            return this._cacheStyle.filters;
        }
        set filters(value) {
            value && value.length === 0 && (value = null);
            this._getCacheStyle().filters = value ? value.slice() : null;
            if (value)
                this._renderType |= SpriteConst.FILTERS;
            else
                this._renderType &= ~SpriteConst.FILTERS;
            this._setRenderType(this._renderType);
            if (value && value.length > 0) {
                if (!this._getBit(NodeFlags.DISPLAY))
                    this._setBitUp(NodeFlags.DISPLAY);
                if (!(value.length == 1 && (value[0] instanceof ColorFilter))) {
                    this._getCacheStyle().cacheForFilters = true;
                    this._checkCanvasEnable();
                }
            }
            else {
                if (this._cacheStyle.cacheForFilters) {
                    this._cacheStyle.cacheForFilters = false;
                    this._checkCanvasEnable();
                }
            }
            this._getCacheStyle().hasGlowFilter = this._isHaveGlowFilter();
            this.repaint();
        }
        _isHaveGlowFilter() {
            var i, len;
            if (this.filters) {
                for (i = 0; i < this.filters.length; i++) {
                    if (this.filters[i].type == Filter.GLOW) {
                        return true;
                    }
                }
            }
            for (i = 0, len = this._children.length; i < len; i++) {
                if (this._children[i]._isHaveGlowFilter()) {
                    return true;
                }
            }
            return false;
        }
        localToGlobal(point, createNewPoint = false, globalNode = null) {
            if (createNewPoint === true) {
                point = new Point(point.x, point.y);
            }
            var ele = this;
            globalNode = globalNode || ILaya.stage;
            while (ele && !ele._destroyed) {
                if (ele == globalNode)
                    break;
                point = ele.toParentPoint(point);
                ele = ele.parent;
            }
            return point;
        }
        globalToLocal(point, createNewPoint = false, globalNode = null) {
            if (createNewPoint) {
                point = new Point(point.x, point.y);
            }
            var ele = this;
            var list = [];
            globalNode = globalNode || ILaya.stage;
            while (ele && !ele._destroyed) {
                if (ele == globalNode)
                    break;
                list.push(ele);
                ele = ele.parent;
            }
            var i = list.length - 1;
            while (i >= 0) {
                ele = list[i];
                point = ele.fromParentPoint(point);
                i--;
            }
            return point;
        }
        toParentPoint(point) {
            if (!point)
                return point;
            point.x -= this.pivotX;
            point.y -= this.pivotY;
            if (this.transform) {
                this._transform.transformPoint(point);
            }
            point.x += this._x;
            point.y += this._y;
            var scroll = this._style.scrollRect;
            if (scroll) {
                point.x -= scroll.x;
                point.y -= scroll.y;
            }
            return point;
        }
        fromParentPoint(point) {
            if (!point)
                return point;
            point.x -= this._x;
            point.y -= this._y;
            var scroll = this._style.scrollRect;
            if (scroll) {
                point.x += scroll.x;
                point.y += scroll.y;
            }
            if (this.transform) {
                this._transform.invertTransformPoint(point);
            }
            point.x += this.pivotX;
            point.y += this.pivotY;
            return point;
        }
        onStartListeningToType(type) {
            super.onStartListeningToType(type);
            if (this._mouseState !== 1 && Event.isMouseEvent(type)) {
                this.mouseEnabled = true;
                this._setBit(NodeFlags.HAS_MOUSE, true);
                if (this._parent) {
                    this._onDisplay();
                }
            }
        }
        _onDisplay(v) {
            if (this._mouseState !== 1) {
                var ele = this;
                ele = ele.parent;
                while (ele && ele._mouseState !== 1) {
                    if (ele._getBit(NodeFlags.HAS_MOUSE))
                        break;
                    ele.mouseEnabled = true;
                    ele._setBit(NodeFlags.HAS_MOUSE, true);
                    ele = ele.parent;
                }
            }
        }
        _setParent(value) {
            super._setParent(value);
            if (value && this._getBit(NodeFlags.HAS_MOUSE)) {
                this._onDisplay();
            }
        }
        loadImage(url, complete = null) {
            if (!url) {
                this.texture = null;
                this.repaint(SpriteConst.REPAINT_ALL);
                complete && complete.run();
            }
            else {
                let tex = ILaya.loader.getRes(url);
                if (tex) {
                    this.texture = tex;
                    this.repaint(SpriteConst.REPAINT_ALL);
                    complete && complete.run();
                }
                else {
                    if (this._skinBaseUrl)
                        url = URL.formatURL(url, this._skinBaseUrl);
                    ILaya.loader.load(url).then((tex) => {
                        this.texture = tex;
                        this.repaint(SpriteConst.REPAINT_ALL);
                        complete && complete.run();
                    });
                }
            }
            return this;
        }
        static fromImage(url) {
            return new Sprite().loadImage(url);
        }
        repaint(type = SpriteConst.REPAINT_CACHE) {
            if (!(this._repaint & type)) {
                this._repaint |= type;
                this.parentRepaint(type);
            }
            if (this._cacheStyle && this._cacheStyle.maskParent) {
                this._cacheStyle.maskParent.repaint(type);
            }
        }
        _needRepaint() {
            return (this._repaint & SpriteConst.REPAINT_CACHE) && this._cacheStyle.enableCanvasRender && this._cacheStyle.reCache;
        }
        _childChanged(child = null) {
            super._childChanged(child);
            if (this._children.length)
                this._renderType |= SpriteConst.CHILDS;
            else
                this._renderType &= ~SpriteConst.CHILDS;
            this._setRenderType(this._renderType);
            if (child && this._getBit(NodeFlags.HAS_ZORDER))
                ILaya.systemTimer.callLater(this, this.updateZOrder);
            this.repaint(SpriteConst.REPAINT_ALL);
        }
        parentRepaint(type = SpriteConst.REPAINT_CACHE) {
            var p = this._parent;
            if (p && !(p._repaint & type)) {
                p._repaint |= type;
                p.parentRepaint(type);
            }
        }
        get stage() {
            return ILaya.stage;
        }
        get hitArea() {
            return this._style.hitArea;
        }
        set hitArea(value) {
            this.getStyle().hitArea = value;
        }
        _setMask(value) {
        }
        get mask() {
            return this._cacheStyle.mask;
        }
        set mask(value) {
            if (value && this.mask == value && value._cacheStyle.maskParent == this)
                return;
            if (this.mask)
                this.mask._getCacheStyle().maskParent = null;
            this._getCacheStyle().mask = value;
            this._setMask(value);
            this._checkCanvasEnable();
            if (value) {
                value._getCacheStyle().maskParent = this;
                this._renderType |= SpriteConst.MASK;
            }
            else
                this._renderType &= ~SpriteConst.MASK;
            this._setRenderType(this._renderType);
            this.repaint();
        }
        get mouseEnabled() {
            return this._mouseState > 1;
        }
        set mouseEnabled(value) {
            this._mouseState = value ? 2 : 1;
        }
        startDrag(area = null, hasInertia = false, elasticDistance = 0, elasticBackTime = 300, data = null, ratio = 0.92) {
            this._style.dragging || (this.getStyle().dragging = new Dragging());
            this._style.dragging.start(this, area, hasInertia, elasticDistance, elasticBackTime, data, ratio);
        }
        stopDrag() {
            this._style.dragging && this._style.dragging.stop();
        }
        _setDisplay(value) {
            if (!value) {
                if (this._cacheStyle) {
                    this._cacheStyle.releaseContext();
                    this._cacheStyle.releaseFilterCache();
                    if (this._cacheStyle.hasGlowFilter) {
                        this._cacheStyle.hasGlowFilter = false;
                    }
                }
            }
            super._setDisplay(value);
        }
        hitTestPoint(x, y) {
            var point = this.globalToLocal(Point.TEMP.setTo(x, y));
            x = point.x;
            y = point.y;
            var rect = this._style.hitArea ? this._style.hitArea : (this._width > 0 && this._height > 0) ? Rectangle.TEMP.setTo(0, 0, this._width, this._height) : this.getSelfBounds();
            return rect.contains(x, y);
        }
        getMousePoint() {
            return this.globalToLocal(Point.TEMP.setTo(ILaya.stage.mouseX, ILaya.stage.mouseY));
        }
        get globalScaleX() {
            var scale = 1;
            var ele = this;
            while (ele) {
                if (ele === ILaya.stage)
                    break;
                scale *= ele.scaleX;
                ele = ele.parent;
            }
            return scale;
        }
        get globalRotation() {
            var angle = 0;
            var ele = this;
            while (ele) {
                if (ele === ILaya.stage)
                    break;
                angle += ele.rotation;
                ele = ele.parent;
            }
            return angle;
        }
        get globalScaleY() {
            var scale = 1;
            var ele = this;
            while (ele) {
                if (ele === ILaya.stage)
                    break;
                scale *= ele.scaleY;
                ele = ele.parent;
            }
            return scale;
        }
        get mouseX() {
            return this.getMousePoint().x;
        }
        get mouseY() {
            return this.getMousePoint().y;
        }
        get zOrder() {
            return this._zOrder;
        }
        set zOrder(value) {
            if (this._zOrder != value) {
                this._zOrder = value;
                if (this._parent) {
                    value && this._parent._setBit(NodeFlags.HAS_ZORDER, true);
                    ILaya.systemTimer.callLater(this._parent, this.updateZOrder);
                }
            }
        }
        get texture() {
            return this._texture;
        }
        _setTexture(value) {
        }
        set texture(value) {
            if (typeof (value) == 'string') {
                this.loadImage(value);
            }
            else if (this._texture != value) {
                this._texture && this._texture._removeReference();
                this._texture = value;
                value && value._addReference();
                this._setTexture(value);
                this._setWidth(this._texture, this.width);
                this._setHeight(this._texture, this.height);
                if (value)
                    this._renderType |= SpriteConst.TEXTURE;
                else
                    this._renderType &= ~SpriteConst.TEXTURE;
                this._setRenderType(this._renderType);
                this.repaint();
            }
        }
        get viewport() {
            return this._style.viewport;
        }
        set viewport(value) {
            if (typeof (value) == 'string') {
                var recArr;
                recArr = value.split(",");
                if (recArr.length > 3) {
                    value = new Rectangle(parseFloat(recArr[0]), parseFloat(recArr[1]), parseFloat(recArr[2]), parseFloat(recArr[3]));
                }
            }
            this.getStyle().viewport = value;
        }
        _setRenderType(type) {
        }
        _setTranformChange() {
            this._tfChanged = true;
            this._renderType |= SpriteConst.TRANSFORM;
            this.parentRepaint(SpriteConst.REPAINT_CACHE);
        }
        _setBgStyleColor(x, y, width, height, fillColor) {
        }
        _setBorderStyleColor(x, y, width, height, fillColor, borderWidth) {
        }
        set drawCallOptimize(value) {
            this._setBit(NodeFlags.DRAWCALL_OPTIMIZE, value);
        }
        get drawCallOptimize() {
            return this._getBit(NodeFlags.DRAWCALL_OPTIMIZE);
        }
        onAfterDeserialize() {
            super.onAfterDeserialize();
            if (LayaEnv.isPlaying) {
                if (this._gcmds) {
                    this.graphics.cmds = this._gcmds;
                    delete this._gcmds;
                }
                if (this._filters) {
                    this.filters = this._filters;
                    delete this._filters;
                }
            }
        }
    }

    class TextStyle extends SpriteStyle {
        constructor() {
            super(...arguments);
            this.italic = false;
        }
        reset() {
            super.reset();
            this.italic = false;
            this.align = "left";
            this.wordWrap = false;
            this.leading = 0;
            this.padding = [0, 0, 0, 0];
            this.bgColor = null;
            this.borderColor = null;
            this.asPassword = false;
            this.stroke = 0;
            this.strokeColor = "#000000";
            this.bold = false;
            this.underline = false;
            this.underlineColor = null;
            this.currBitmapFont = null;
            return this;
        }
        recover() {
            if (this === TextStyle.EMPTY)
                return;
            Pool.recover("TextStyle", this.reset());
        }
        static create() {
            return Pool.getItemByClass("TextStyle", TextStyle);
        }
        render(sprite, context, x, y) {
            (this.bgColor || this.borderColor) && context.drawRect(x - this.pivotX, y - this.pivotY, sprite.width, sprite.height, this.bgColor, this.borderColor, 1);
        }
    }
    TextStyle.EMPTY = new TextStyle();

    class Text extends Sprite {
        constructor() {
            super();
            this._textWidth = 0;
            this._textHeight = 0;
            this._lines = [];
            this._lineWidths = [];
            this._startX = 0;
            this._startY = 0;
            this._charSize = {};
            this._valign = "top";
            this._fontSize = Config.defaultFontSize;
            this._font = Config.defaultFont;
            this._color = "#000000";
            this._singleCharRender = false;
            this.overflow = Text.VISIBLE;
            this._style = TextStyle.EMPTY;
        }
        getStyle() {
            this._style === TextStyle.EMPTY && (this._style = TextStyle.create());
            return this._style;
        }
        _getTextStyle() {
            if (this._style === TextStyle.EMPTY) {
                this._style = TextStyle.create();
            }
            return this._style;
        }
        static registerBitmapFont(name, bitmapFont) {
            Text._bitmapFonts || (Text._bitmapFonts = {});
            Text._bitmapFonts[name] = bitmapFont;
        }
        static unregisterBitmapFont(name, destroy = true) {
            if (Text._bitmapFonts && Text._bitmapFonts[name]) {
                var tBitmapFont = Text._bitmapFonts[name];
                if (destroy)
                    tBitmapFont.destroy();
                delete Text._bitmapFonts[name];
            }
        }
        destroy(destroyChild = true) {
            super.destroy(destroyChild);
            this._clipPoint = null;
            this._lines = null;
            this._lineWidths = null;
            this._words && this._words.forEach(function (w) {
                w.cleanCache();
            });
            this._words = null;
            this._charSize = null;
        }
        _getBoundPointsM(ifRotate = false) {
            var rec = Rectangle.TEMP;
            rec.setTo(0, 0, this.width, this.height);
            return rec._getBoundPoints();
        }
        getGraphicBounds(realSize = false) {
            var rec = Rectangle.TEMP;
            rec.setTo(0, 0, this.width, this.height);
            return rec;
        }
        get width() {
            if (this._width)
                return this._width;
            return this.textWidth + this.padding[1] + this.padding[3];
        }
        set width(value) {
            if (value != this._width) {
                super.set_width(value);
                this.isChanged = true;
                if (this.borderColor) {
                    this._setBorderStyleColor(0, 0, this.width, this.height, this.borderColor, 1);
                }
            }
        }
        _getCSSStyle() {
            return this._style;
        }
        get height() {
            if (this._height)
                return this._height;
            return this.textHeight;
        }
        set height(value) {
            if (value != this._height) {
                super.set_height(value);
                this.isChanged = true;
                if (this.borderColor) {
                    this._setBorderStyleColor(0, 0, this.width, this.height, this.borderColor, 1);
                }
            }
        }
        get textWidth() {
            this._isChanged && ILaya.systemTimer.runCallLater(this, this.typeset);
            return this._textWidth;
        }
        get textHeight() {
            this._isChanged && ILaya.systemTimer.runCallLater(this, this.typeset);
            return this._textHeight;
        }
        get text() {
            return this._text || "";
        }
        get_text() {
            return this._text || "";
        }
        set_text(value) {
            if (this._text !== value) {
                this.lang(value + "");
                this.isChanged = true;
                this.event(Event.CHANGE);
                if (this.borderColor) {
                    this._setBorderStyleColor(0, 0, this.width, this.height, this.borderColor, 1);
                }
            }
        }
        set text(value) {
            this.set_text(value);
        }
        lang(text, arg1 = null, arg2 = null, arg3 = null, arg4 = null, arg5 = null, arg6 = null, arg7 = null, arg8 = null, arg9 = null, arg10 = null) {
            text = Text.langPacks && Text.langPacks[text] ? Text.langPacks[text] : text;
            if (arguments.length < 2) {
                this._text = text;
            }
            else {
                for (var i = 0, n = arguments.length; i < n; i++) {
                    text = text.replace("{" + i + "}", arguments[i + 1]);
                }
                this._text = text;
            }
        }
        get font() {
            return this._font;
        }
        set font(value) {
            if (this._style.currBitmapFont) {
                this._getTextStyle().currBitmapFont = null;
                this.scale(1, 1);
            }
            if (Text._bitmapFonts && Text._bitmapFonts[value]) {
                this._getTextStyle().currBitmapFont = Text._bitmapFonts[value];
            }
            this._font = value;
            this.isChanged = true;
        }
        get fontSize() {
            return this._fontSize;
        }
        set fontSize(value) {
            if (this._fontSize != value) {
                this._fontSize = value;
                this.isChanged = true;
            }
        }
        get bold() {
            return this._style.bold;
        }
        set bold(value) {
            this._getTextStyle().bold = value;
            this.isChanged = true;
        }
        get color() {
            return this._color;
        }
        set color(value) {
            this.set_color(value);
        }
        get_color() {
            return this._color;
        }
        set_color(value) {
            if (this._color != value) {
                this._color = value;
                if (!this._isChanged && this._graphics) {
                    this._graphics.replaceTextColor(this.color);
                }
                else {
                    this.isChanged = true;
                }
            }
        }
        get italic() {
            return this._style.italic;
        }
        set italic(value) {
            this._getTextStyle().italic = value;
            this.isChanged = true;
        }
        get align() {
            return this._style.align;
        }
        set align(value) {
            this._getTextStyle().align = value;
            this.isChanged = true;
        }
        get valign() {
            return this._valign;
        }
        set valign(value) {
            this._valign = value;
            this.isChanged = true;
        }
        get wordWrap() {
            return this._style.wordWrap;
        }
        set wordWrap(value) {
            this._getTextStyle().wordWrap = value;
            this.isChanged = true;
        }
        get leading() {
            return this._style.leading;
        }
        set leading(value) {
            this._getTextStyle().leading = value;
            this.isChanged = true;
        }
        get padding() {
            return this._style.padding;
        }
        set padding(value) {
            if (typeof (value) == 'string') {
                var arr;
                arr = value.split(",");
                var i, len;
                len = arr.length;
                while (arr.length < 4) {
                    arr.push(0);
                }
                for (i = 0; i < len; i++) {
                    arr[i] = parseFloat(arr[i]) || 0;
                }
                value = arr;
            }
            this._getTextStyle().padding = value;
            this.isChanged = true;
        }
        get bgColor() {
            return this._style.bgColor;
        }
        set bgColor(value) {
            this.set_bgColor(value);
        }
        set_bgColor(value) {
            this._getTextStyle().bgColor = value;
            this._renderType |= SpriteConst.STYLE;
            this._setBgStyleColor(0, 0, this.width, this.height, value);
            this._setRenderType(this._renderType);
            this.isChanged = true;
        }
        get_bgColor() {
            return this._style.bgColor;
        }
        get borderColor() {
            return this._style.borderColor;
        }
        set borderColor(value) {
            this._getTextStyle().borderColor = value;
            this._renderType |= SpriteConst.STYLE;
            this._setBorderStyleColor(0, 0, this.width, this.height, value, 1);
            this._setRenderType(this._renderType);
            this.isChanged = true;
        }
        get stroke() {
            return this._style.stroke;
        }
        set stroke(value) {
            this._getTextStyle().stroke = value;
            this.isChanged = true;
        }
        get strokeColor() {
            return this._style.strokeColor;
        }
        set strokeColor(value) {
            this._getTextStyle().strokeColor = value;
            this.isChanged = true;
        }
        set isChanged(value) {
            if (this._isChanged !== value) {
                this._isChanged = value;
                value && ILaya.systemTimer.callLater(this, this.typeset);
            }
        }
        _getContextFont() {
            return (this.italic ? "italic " : "") + (this.bold ? "bold " : "") + this.fontSize + "px " + (ILaya.Browser.onIPhone ? (Config.fontFamilyMap[this.font] || this.font) : this.font);
        }
        _isPassWordMode() {
            var style = this._style;
            var password = style.asPassword;
            if (("prompt" in this) && this['prompt'] == this._text)
                password = false;
            return password;
        }
        _getPassWordTxt(txt) {
            var len = txt.length;
            var word;
            word = "";
            for (var j = len; j > 0; j--) {
                word += "●";
            }
            return word;
        }
        _renderText() {
            var padding = this.padding;
            var visibleLineCount = this._lines.length;
            if (this.overflow != Text.VISIBLE) {
                visibleLineCount = Math.min(visibleLineCount, Math.floor((this.height - padding[0] - padding[2]) / (this.leading + this._charSize.height)) + 1);
            }
            var beginLine = this.scrollY / (this._charSize.height + this.leading) | 0;
            var graphics = this.graphics;
            graphics.clear(true);
            var ctxFont = this._getContextFont();
            ILaya.Browser.context.font = ctxFont;
            var startX = padding[3];
            var textAlgin = "left";
            var lines = this._lines;
            var lineHeight = this.leading + this._charSize.height;
            var tCurrBitmapFont = this._style.currBitmapFont;
            if (tCurrBitmapFont) {
                lineHeight = this.leading + tCurrBitmapFont.getMaxHeight();
            }
            var startY = padding[0];
            if ((!tCurrBitmapFont) && this._width > 0 && this._textWidth <= this._width) {
                if (this.align == "right") {
                    textAlgin = "right";
                    startX = this._width - padding[1];
                }
                else if (this.align == "center") {
                    textAlgin = "center";
                    startX = this._width * 0.5 + padding[3] - padding[1];
                }
            }
            let bitmapScale = 1;
            if (tCurrBitmapFont && tCurrBitmapFont.autoScaleSize) {
                bitmapScale = tCurrBitmapFont.fontSize / this.fontSize;
            }
            if (this._height > 0) {
                var tempVAlign = (this._textHeight > this._height) ? "top" : this.valign;
                if (tempVAlign === "middle")
                    startY = (this._height - visibleLineCount / bitmapScale * lineHeight) * 0.5 + padding[0] - padding[2];
                else if (tempVAlign === "bottom")
                    startY = this._height - visibleLineCount / bitmapScale * lineHeight - padding[2];
            }
            if (this._clipPoint) {
                graphics.save();
                if (tCurrBitmapFont && tCurrBitmapFont.autoScaleSize) {
                    var tClipWidth;
                    var tClipHeight;
                    this._width ? tClipWidth = (this._width - padding[3] - padding[1]) : tClipWidth = this._textWidth;
                    this._height ? tClipHeight = (this._height - padding[0] - padding[2]) : tClipHeight = this._textHeight;
                    tClipWidth *= bitmapScale;
                    tClipHeight *= bitmapScale;
                    graphics.clipRect(padding[3], padding[0], tClipWidth, tClipHeight);
                }
                else {
                    graphics.clipRect(padding[3], padding[0], this._width ? (this._width - padding[3] - padding[1]) : this._textWidth, this._height ? (this._height - padding[0] - padding[2]) : this._textHeight);
                }
                this.repaint();
            }
            var style = this._style;
            var password = style.asPassword;
            if (("prompt" in this) && this['prompt'] == this._text)
                password = false;
            var x = 0, y = 0;
            var end = Math.min(this._lines.length, visibleLineCount + beginLine) || 1;
            for (var i = beginLine; i < end; i++) {
                var word = lines[i];
                var _word;
                if (password) {
                    let len = word.length;
                    word = "";
                    for (var j = len; j > 0; j--) {
                        word += "●";
                    }
                }
                if (word == null)
                    word = "";
                x = startX - (this._clipPoint ? this._clipPoint.x : 0);
                y = startY + lineHeight * i - (this._clipPoint ? this._clipPoint.y : 0);
                this.underline && this._drawUnderline(textAlgin, x, y, i);
                if (tCurrBitmapFont) {
                    var tWidth = this.width;
                    if (tCurrBitmapFont.autoScaleSize) {
                        tWidth = this.width * bitmapScale;
                        x *= bitmapScale;
                        y *= bitmapScale;
                    }
                    tCurrBitmapFont._drawText(word, this, x, y, this.align, tWidth);
                }
                else {
                    this._words || (this._words = []);
                    if (this._words.length > (i - beginLine)) {
                        _word = this._words[i - beginLine];
                    }
                    else {
                        _word = new WordText();
                        this._words.push(_word);
                    }
                    _word.setText(word);
                    _word.splitRender = this._singleCharRender;
                    style.stroke ? graphics.fillBorderText(_word, x, y, ctxFont, this.color, textAlgin, style.stroke, style.strokeColor) : graphics.fillText(_word, x, y, ctxFont, this.color, textAlgin);
                }
            }
            if (tCurrBitmapFont && tCurrBitmapFont.autoScaleSize) {
                var tScale = 1 / bitmapScale;
                this.scale(tScale, tScale);
            }
            if (this._clipPoint)
                graphics.restore();
            this._startX = startX;
            this._startY = startY;
        }
        _drawUnderline(align, x, y, lineIndex) {
            var lineWidth = this._lineWidths[lineIndex];
            switch (align) {
                case 'center':
                    x -= lineWidth / 2;
                    break;
                case 'right':
                    x -= lineWidth;
                    break;
            }
            y += this._charSize.height;
            this._graphics.drawLine(x, y, x + lineWidth, y, this.underlineColor || this.color, 1);
        }
        typeset() {
            this._isChanged = false;
            if (!this._text) {
                this._clipPoint = null;
                this._textWidth = this._textHeight = 0;
                this.graphics.clear(true);
                return;
            }
            if (LayaEnv.isConch) {
                window.conchTextCanvas.font = this._getContextFont();
            }
            else {
                ILaya.Browser.context.font = this._getContextFont();
            }
            this._lines.length = 0;
            this._lineWidths.length = 0;
            if (this._isPassWordMode()) {
                this._parseLines(this._getPassWordTxt(this._text));
            }
            else
                this._parseLines(this._text);
            this._evalTextSize();
            if (this._checkEnabledViewportOrNot())
                this._clipPoint || (this._clipPoint = new Point(0, 0));
            else
                this._clipPoint = null;
            this._renderText();
        }
        _evalTextSize() {
            var nw, nh;
            nw = Math.max.apply(this, this._lineWidths);
            let bmpFont = this._style.currBitmapFont;
            if (bmpFont) {
                let h = bmpFont.getMaxHeight();
                if (bmpFont.autoScaleSize) {
                    h = this.fontSize;
                }
                nh = this._lines.length * (h + this.leading) + this.padding[0] + this.padding[2];
            }
            else {
                nh = this._lines.length * (this._charSize.height + this.leading) + this.padding[0] + this.padding[2];
                if (this._lines.length) {
                    nh -= this.leading;
                }
            }
            if (nw != this._textWidth || nh != this._textHeight) {
                this._textWidth = nw;
                this._textHeight = nh;
            }
        }
        _checkEnabledViewportOrNot() {
            return this.overflow == Text.SCROLL && ((this._width > 0 && this._textWidth > this._width) || (this._height > 0 && this._textHeight > this._height));
        }
        changeText(text) {
            if (this._text !== text) {
                this.lang(text + "");
                if (this._graphics && this._graphics.replaceText(this._text)) ;
                else {
                    this.typeset();
                }
            }
        }
        _parseLines(text) {
            var needWordWrapOrTruncate = this.wordWrap || this.overflow == Text.HIDDEN;
            if (needWordWrapOrTruncate) {
                var wordWrapWidth = this._getWordWrapWidth();
            }
            var bitmapFont = this._style.currBitmapFont;
            if (bitmapFont) {
                this._charSize.width = bitmapFont.getMaxWidth();
                this._charSize.height = bitmapFont.getMaxHeight();
            }
            else {
                var measureResult = null;
                if (LayaEnv.isConch) {
                    measureResult = window.conchTextCanvas.measureText(Text._testWord);
                }
                else {
                    measureResult = ILaya.Browser.context.measureText(Text._testWord);
                }
                if (!measureResult)
                    measureResult = { width: 100 };
                this._charSize.width = measureResult.width;
                this._charSize.height = (measureResult.height || this.fontSize);
            }
            var lines = text.replace(/\r\n/g, "\n").split("\n");
            for (var i = 0, n = lines.length; i < n; i++) {
                var line = lines[i];
                if (needWordWrapOrTruncate)
                    this._parseLine(line, wordWrapWidth);
                else {
                    this._lineWidths.push(this._getTextWidth(line));
                    this._lines.push(line);
                }
            }
        }
        _parseLine(line, wordWrapWidth) {
            var lines = this._lines;
            var maybeIndex = 0;
            var charsWidth = 0;
            var wordWidth = 0;
            var startIndex = 0;
            charsWidth = this._getTextWidth(line);
            if (charsWidth <= wordWrapWidth) {
                lines.push(line);
                this._lineWidths.push(charsWidth);
                return;
            }
            charsWidth = this._charSize.width;
            maybeIndex = Math.floor(wordWrapWidth / charsWidth);
            (maybeIndex == 0) && (maybeIndex = 1);
            charsWidth = this._getTextWidth(line.substring(0, maybeIndex));
            wordWidth = charsWidth;
            for (var j = maybeIndex, m = line.length; j < m; j++) {
                charsWidth = this._getTextWidth(line.charAt(j));
                wordWidth += charsWidth;
                if (wordWidth > wordWrapWidth) {
                    if (this.wordWrap) {
                        var newLine = line.substring(startIndex, j);
                        var ccode = newLine.charCodeAt(newLine.length - 1);
                        if (ccode < 0x4e00 || ccode > 0x9fa5) {
                            var execResult = /(?:[^\s\!-\/])+$/.exec(newLine);
                            if (execResult) {
                                j = execResult.index + startIndex;
                                if (execResult.index == 0)
                                    j += newLine.length;
                                else
                                    newLine = line.substring(startIndex, j);
                            }
                        }
                        lines.push(newLine);
                        this._lineWidths.push(wordWidth - charsWidth);
                        startIndex = j;
                        if (j + maybeIndex < m) {
                            j += maybeIndex;
                            charsWidth = this._getTextWidth(line.substring(startIndex, j));
                            wordWidth = charsWidth;
                            j--;
                        }
                        else {
                            lines.push(line.substring(startIndex, m));
                            this._lineWidths.push(this._getTextWidth(lines[lines.length - 1]));
                            startIndex = -1;
                            break;
                        }
                    }
                    else if (this.overflow == Text.HIDDEN) {
                        lines.push(line.substring(0, j));
                        this._lineWidths.push(this._getTextWidth(lines[lines.length - 1]));
                        return;
                    }
                }
            }
            if (this.wordWrap && startIndex != -1) {
                lines.push(line.substring(startIndex, m));
                this._lineWidths.push(this._getTextWidth(lines[lines.length - 1]));
            }
        }
        _getTextWidth(text) {
            var bitmapFont = this._style.currBitmapFont;
            if (bitmapFont)
                return bitmapFont.getTextWidth(text);
            else {
                if (LayaEnv.isConch) {
                    return window.conchTextCanvas.measureText(text).width;
                }
                else {
                    let ret = ILaya.Browser.context.measureText(text) || { width: 100 };
                    return ret.width;
                }
            }
        }
        _getWordWrapWidth() {
            var p = this.padding;
            var w;
            var bitmapFont = this._style.currBitmapFont;
            if (bitmapFont && bitmapFont.autoScaleSize)
                w = this._width * (bitmapFont.fontSize / this.fontSize);
            else
                w = this._width;
            if (w <= 0) {
                w = this.wordWrap ? 100 : ILaya.Browser.width;
            }
            w <= 0 && (w = 100);
            return w - p[3] - p[1];
        }
        getCharPoint(charIndex, out = null) {
            this._isChanged && ILaya.systemTimer.runCallLater(this, this.typeset);
            var len = 0, lines = this._lines, startIndex = 0;
            for (var i = 0, n = lines.length; i < n; i++) {
                len += lines[i].length;
                if (charIndex < len) {
                    var line = i;
                    break;
                }
                startIndex = len;
            }
            var ctxFont = (this.italic ? "italic " : "") + (this.bold ? "bold " : "") + this.fontSize + "px " + this.font;
            ILaya.Browser.context.font = ctxFont;
            var width = this._getTextWidth(this._text.substring(startIndex, charIndex));
            var point = out || new Point();
            return point.setTo(this._startX + width - (this._clipPoint ? this._clipPoint.x : 0), this._startY + line * (this._charSize.height + this.leading) - (this._clipPoint ? this._clipPoint.y : 0));
        }
        set scrollX(value) {
            if (this.overflow != Text.SCROLL || (this.textWidth < this._width || !this._clipPoint))
                return;
            value = value < this.padding[3] ? this.padding[3] : value;
            var maxScrollX = this._textWidth - this._width;
            value = value > maxScrollX ? maxScrollX : value;
            this._clipPoint.x = value;
            this._renderText();
        }
        get scrollX() {
            if (!this._clipPoint)
                return 0;
            return this._clipPoint.x;
        }
        set scrollY(value) {
            if (this.overflow != Text.SCROLL || (this.textHeight < this._height || !this._clipPoint))
                return;
            value = value < this.padding[0] ? this.padding[0] : value;
            var maxScrollY = this._textHeight - this._height;
            value = value > maxScrollY ? maxScrollY : value;
            this._clipPoint.y = value;
            this._renderText();
        }
        get scrollY() {
            if (!this._clipPoint)
                return 0;
            return this._clipPoint.y;
        }
        get maxScrollX() {
            return (this.textWidth < this._width) ? 0 : this._textWidth - this._width;
        }
        get maxScrollY() {
            return (this.textHeight < this._height) ? 0 : this._textHeight - this._height;
        }
        get lines() {
            if (this._isChanged)
                this.typeset();
            return this._lines;
        }
        get underlineColor() {
            return this._style.underlineColor;
        }
        set underlineColor(value) {
            this._getTextStyle().underlineColor = value;
            if (!this._isChanged)
                this._renderText();
        }
        get underline() {
            return this._style.underline;
        }
        set underline(value) {
            this._getTextStyle().underline = value;
        }
        set singleCharRender(value) {
            this._singleCharRender = value;
        }
        get singleCharRender() {
            return this._singleCharRender;
        }
    }
    Text.VISIBLE = "visible";
    Text.SCROLL = "scroll";
    Text.HIDDEN = "hidden";
    Text._testWord = "游";
    Text.CharacterCache = true;
    Text.RightToLeft = false;

    var _isFirstTouch = true;
    const _tempPoint = new Point();
    const _tempRect = new Rectangle();
    const _rollOverChain = [];
    const _rollOutChain = [];
    const _bubbleChain = [];
    var _inst;
    class InputManager {
        constructor() {
            this._touches = [];
            this._touchPool = [];
            this._mouseTouch = new TouchInfo(this._touches);
            this._pressKeys = new Set();
            this._keyEvent = new Event();
            this._keyEvent._touches = this._touches;
        }
        static get inst() {
            return _inst;
        }
        static getTouchPos(touchId) {
            var _a, _b;
            if (touchId == null)
                return ((_a = _inst._touches[0]) === null || _a === void 0 ? void 0 : _a.pos) || Point.EMPTY;
            else
                return ((_b = _inst.getTouch(touchId)) === null || _b === void 0 ? void 0 : _b.pos) || Point.EMPTY;
        }
        static get touchTarget() {
            return _inst._touchTarget;
        }
        static get touches() {
            return _inst._touches;
        }
        static get touchCount() {
            return _inst._touches.length;
        }
        static cancelClick(touchId) {
            let touch = touchId == null ? _inst._touches[0] : _inst.getTouch(touchId);
            if (touch)
                touch.clickCancelled = true;
        }
        static hasKeyDown(key) {
            return _inst._pressKeys.has(key);
        }
        static __init__(stage, canvas) {
            let inst = _inst = new InputManager();
            inst._stage = stage;
            canvas.oncontextmenu = () => {
                return false;
            };
            canvas.addEventListener("mousedown", ev => {
                if (!Browser.onIE)
                    (ev.cancelable) && (ev.preventDefault());
                if (!inst._touchInput)
                    inst.handleMouse(ev, 0);
            }, { passive: false });
            canvas.addEventListener("mouseup", ev => {
                (ev.cancelable) && (ev.preventDefault());
                if (!inst._touchInput)
                    inst.handleMouse(ev, 1);
            }, { passive: false });
            canvas.addEventListener("mousemove", ev => {
                (ev.cancelable) && (ev.preventDefault());
                if (!inst._touchInput)
                    inst.handleMouse(ev, 2);
            }, { passive: false });
            canvas.addEventListener("mouseout", ev => {
                if (!inst._touchInput)
                    inst.handleMouse(ev, 3);
            }, { passive: false });
            canvas.addEventListener("touchstart", ev => {
                inst._touchInput = true;
                if (!_isFirstTouch && !InputManager.isTextInputting)
                    (ev.cancelable) && (ev.preventDefault());
                inst.handleTouch(ev, 0);
            }, { passive: false });
            canvas.addEventListener("touchend", ev => {
                if (!_isFirstTouch && !InputManager.isTextInputting)
                    (ev.cancelable) && (ev.preventDefault());
                _isFirstTouch = false;
                inst.handleTouch(ev, 1);
            }, { passive: false });
            canvas.addEventListener("touchmove", ev => {
                (ev.cancelable) && (ev.preventDefault());
                inst.handleTouch(ev, 2);
            }, { passive: false });
            canvas.addEventListener("touchcancel", ev => {
                (ev.cancelable) && (ev.preventDefault());
                inst.handleTouch(ev, 3);
            }, { passive: false });
            canvas.addEventListener("wheel", ev => {
                inst.handleMouse(ev, 4);
            }, { passive: false });
            canvas.addEventListener("pointerdown", ev => {
                canvas.setPointerCapture(ev.pointerId);
            });
            canvas.addEventListener("pointerup", ev => {
                canvas.releasePointerCapture(ev.pointerId);
            }, true);
            let document = Browser.document;
            document.addEventListener("keydown", ev => {
                inst.handleKeys(ev);
            }, true);
            document.addEventListener("keypress", ev => {
                inst.handleKeys(ev);
            }, true);
            document.addEventListener("keyup", ev => {
                inst.handleKeys(ev);
            }, true);
        }
        handleMouse(ev, type) {
            this._eventType = type;
            this._nativeEvent = ev;
            let touch = this._mouseTouch;
            _tempPoint.setTo(ev.pageX || ev.clientX, ev.pageY || ev.clientY);
            if (this._stage._canvasTransform)
                this._stage._canvasTransform.invertTransformPoint(_tempPoint);
            let x = InputManager.mouseX = _tempPoint.x;
            let y = InputManager.mouseY = _tempPoint.y;
            touch.event.nativeEvent = ev;
            if (type == 3 || !InputManager.mouseEventsEnabled)
                touch.target = this._touchTarget = null;
            else {
                touch.target = this._touchTarget = this.getNodeUnderPoint(x, y);
                if (x != touch.pos.x || y != touch.pos.y) {
                    this._stage._mouseMoveTime = Browser.now();
                    touch.pos.setTo(x, y);
                    touch.move();
                    if (InputManager.mouseEventsEnabled) {
                        this.bubbleEvent(Event.MOUSE_MOVE, touch.event, touch.target);
                        for (let t of touch.downTargets)
                            t.event(Event.MOUSE_DRAG, touch.event);
                    }
                }
            }
            if (touch.lastRollOver != touch.target)
                this.handleRollOver(touch);
            if (type == 0) {
                if (!touch.began) {
                    touch.begin();
                    this._touches[0] = touch;
                    if (InputManager.mouseEventsEnabled) {
                        this.handleFocus();
                        if (ev.button == 0)
                            this.bubbleEvent(Event.MOUSE_DOWN, touch.event, touch.target);
                        else
                            this.bubbleEvent(Event.RIGHT_MOUSE_DOWN, touch.event, touch.target);
                    }
                }
            }
            else if (type == 1) {
                if (touch.began) {
                    touch.end();
                    this._touches.length = 0;
                    if (InputManager.mouseEventsEnabled) {
                        if (ev.button == 0)
                            this.bubbleEvent(Event.MOUSE_UP, touch.event, touch.target);
                        else
                            this.bubbleEvent(Event.RIGHT_MOUSE_UP, touch.event, touch.target);
                        if (touch.moved) {
                            for (let t of touch.downTargets)
                                t.event(Event.MOUSE_DRAG_END, touch.event);
                        }
                        let clickTarget = touch.clickTest();
                        if (clickTarget) {
                            if (ev.button == 0) {
                                this.bubbleEvent(Event.CLICK, touch.event, clickTarget);
                                if (touch.clickCount == 2)
                                    this.bubbleEvent(Event.DOUBLE_CLICK, touch.event, clickTarget);
                            }
                            else
                                this.bubbleEvent(Event.RIGHT_CLICK, touch.event, clickTarget);
                        }
                    }
                }
            }
            else if (type == 4) {
                if (InputManager.mouseEventsEnabled) {
                    touch.event.delta = ev.deltaY * 0.025;
                    this.bubbleEvent(Event.MOUSE_WHEEL, touch.event, touch.target);
                    touch.event.delta = 0;
                }
            }
        }
        handleTouch(ev, type) {
            this._eventType = type;
            this._nativeEvent = ev;
            let touches = ev.changedTouches;
            for (let i = 0; i < touches.length; ++i) {
                let uTouch = touches[i];
                if (!InputManager.multiTouchEnabled
                    && this._touches.length > 0
                    && this._touches[0].touchId != uTouch.identifier)
                    continue;
                _tempPoint.setTo(uTouch.pageX, uTouch.pageY);
                if (this._stage._canvasTransform)
                    this._stage._canvasTransform.invertTransformPoint(_tempPoint);
                let x = InputManager.mouseX = _tempPoint.x;
                let y = InputManager.mouseY = _tempPoint.y;
                let touch = this.getTouch(uTouch.identifier, type == 0);
                if (!touch)
                    continue;
                touch.event.nativeEvent = ev;
                touch.event.touchId = touch.touchId;
                if (type == 3 || !InputManager.mouseEventsEnabled)
                    touch.target = this._touchTarget = null;
                else {
                    touch.target = this._touchTarget = this.getNodeUnderPoint(x, y);
                    this._stage._mouseMoveTime = Browser.now();
                    if (Math.abs(x - touch.pos.x) > 1.5 || Math.abs(y - touch.pos.y) > 1.5) {
                        touch.pos.setTo(x, y);
                        touch.move();
                        if (InputManager.mouseEventsEnabled) {
                            this.bubbleEvent(Event.MOUSE_MOVE, touch.event, touch.target);
                            for (let t of touch.downTargets)
                                t.event(Event.MOUSE_DRAG, touch.event);
                        }
                    }
                }
                if (touch.lastRollOver != touch.target)
                    this.handleRollOver(touch);
                if (type == 0) {
                    if (!touch.began) {
                        touch.begin();
                        if (InputManager.mouseEventsEnabled) {
                            this.handleFocus();
                            this.bubbleEvent(Event.MOUSE_DOWN, touch.event, touch.target);
                        }
                    }
                }
                else if (type == 1 || type == 3) {
                    if (touch.began) {
                        touch.end();
                        if (InputManager.mouseEventsEnabled) {
                            this.bubbleEvent(Event.MOUSE_UP, touch.event, touch.target);
                            if (touch.moved) {
                                for (let t of touch.downTargets)
                                    t.event(Event.MOUSE_DRAG_END, touch.event);
                            }
                            if (type != 3) {
                                let clickTarget = touch.clickTest();
                                if (clickTarget != null) {
                                    this.bubbleEvent(Event.CLICK, touch.event, clickTarget);
                                    if (touch.clickCount == 2)
                                        this.bubbleEvent(Event.DOUBLE_CLICK, touch.event, clickTarget);
                                }
                            }
                        }
                        touch.target = null;
                        this.handleRollOver(touch);
                        touch.reset();
                        this._touches.splice(this._touches.indexOf(touch), 1);
                        this._touchPool.push(touch);
                    }
                }
            }
        }
        getTouch(touchId, shouldCreate) {
            let touch = this._touches.find(e => e.touchId == touchId);
            if (touch || !shouldCreate)
                return touch;
            touch = this._touchPool.length > 0 ? this._touchPool.pop() : new TouchInfo(this._touches);
            touch.touchId = touchId;
            this._touches.push(touch);
            return touch;
        }
        handleFocus() {
            if (InputManager.isTextInputting
                && this._stage.focus && this._stage.focus["focus"]
                && !this._stage.focus.contains(this._touchTarget)) {
                let pre_input = this._stage.focus['_tf'] || this._stage.focus;
                let new_input = this._touchTarget['_tf'] || this._touchTarget;
                if (new_input.nativeInput && new_input.multiline == pre_input.multiline)
                    pre_input['_focusOut']();
                else
                    pre_input.focus = false;
            }
        }
        handleKeys(ev) {
            let type = ev.type;
            let keyCode = ev.keyCode;
            if (type === "keydown") {
                if (keyCode != 0)
                    this._pressKeys.add(keyCode);
                this._pressKeys.add(ev.key);
            }
            else if (type === "keyup") {
                if (keyCode != 0)
                    this._pressKeys.delete(keyCode);
                this._pressKeys.delete(ev.key);
            }
            this._keyEvent.nativeEvent = ev;
            if (InputManager.keyEventsEnabled) {
                let target = (this._stage.focus && (this._stage.focus.event != null) && this._stage.focus.displayedInStage) ? this._stage.focus : this._stage;
                let ct = target;
                while (ct) {
                    ct.event(type, this._keyEvent.setTo(type, ct, target));
                    ct = ct.parent;
                }
            }
            this._keyEvent.nativeEvent = null;
        }
        getNodeUnderPoint(x, y) {
            let target = this.getSpriteUnderPoint(this._stage, x, y);
            if (target == this._stage) {
                target = this.getSprite3DUnderPoint(x, y);
                if (!target)
                    return this._stage;
            }
            return target;
        }
        getSpriteUnderPoint(sp, x, y) {
            let editor = !LayaEnv.isPlaying;
            if (sp == this._stage) {
                _tempPoint.setTo(x, y);
                sp.fromParentPoint(_tempPoint);
                x = _tempPoint.x;
                y = _tempPoint.y;
                for (let i = sp._children.length - 1; i > -1; i--) {
                    let child = sp._children[i];
                    if (!child._is3D
                        && !child._destroyed
                        && (editor && !child.hasHideFlag(HideFlags.HideInHierarchy) || child._mouseState > 1)
                        && (child._visible || child._getBit(NodeFlags.DISABLE_VISIBILITY))) {
                        let ret = this._getSpriteUnderPoint(child, x, y, editor);
                        if (ret)
                            return ret;
                    }
                }
                return sp;
            }
            else
                return this._getSpriteUnderPoint(sp, x, y, editor);
        }
        _getSpriteUnderPoint(sp, x, y, editor) {
            _tempPoint.setTo(x, y);
            sp.fromParentPoint(_tempPoint);
            x = _tempPoint.x;
            y = _tempPoint.y;
            let scrollRect = sp._style.scrollRect;
            if (scrollRect && !sp._getBit(NodeFlags.DISABLE_INNER_CLIPPING)) {
                _tempRect.setTo(scrollRect.x, scrollRect.y, scrollRect.width, scrollRect.height);
                if (!_tempRect.contains(x, y))
                    return null;
            }
            if (!editor && sp.hitTestPrior && !sp.mouseThrough && !this.hitTest(sp, x, y, editor)) {
                return null;
            }
            for (let i = sp._children.length - 1; i > -1; i--) {
                let child = sp._children[i];
                if (!child._destroyed
                    && (editor ? (!child.hasHideFlag(HideFlags.HideInHierarchy) || child.mouseThrough) : child._mouseState > 1)
                    && (child._visible || child._getBit(NodeFlags.DISABLE_VISIBILITY)
                        && !child._getBit(NodeFlags.HIDE_BY_EDITOR))) {
                    let ret = this._getSpriteUnderPoint(child, x, y, editor);
                    if (ret)
                        return ret;
                }
            }
            for (let i = sp._extUIChild.length - 1; i >= 0; i--) {
                let child = sp._extUIChild[i];
                if (!child._destroyed
                    && (editor ? (!child.hasHideFlag(HideFlags.HideInHierarchy) || child.mouseThrough) : child._mouseState > 1)
                    && (child._visible || child._getBit(NodeFlags.DISABLE_VISIBILITY))) {
                    let ret = this._getSpriteUnderPoint(child, x, y, editor);
                    if (ret)
                        return ret;
                }
            }
            if (editor) {
                if (!sp._getBit(NodeFlags.LOCK_BY_EDITOR)
                    && !sp.hasHideFlag(HideFlags.HideInHierarchy)
                    && this.hitTest(sp, x, y, editor))
                    return sp;
            }
            else {
                if (sp.hitTestPrior && !sp.mouseThrough || this.hitTest(sp, x, y, editor))
                    return sp;
            }
            return null;
        }
        getSprite3DUnderPoint(x, y) {
            return null;
        }
        hitTest(sp, x, y, editor) {
            let isHit = false;
            if (sp.scrollRect) {
                x -= sp._style.scrollRect.x;
                y -= sp._style.scrollRect.y;
            }
            let hitArea = sp._style.hitArea;
            let mouseThrough = sp.mouseThrough;
            if (editor) {
                hitArea = null;
                mouseThrough = false;
            }
            if (hitArea) {
                return hitArea.contains(x, y, sp);
            }
            if (sp.width > 0 && sp.height > 0 || mouseThrough || hitArea) {
                if (!mouseThrough)
                    isHit = (hitArea ? hitArea : _tempRect.setTo(0, 0, sp.width, sp.height)).contains(x, y);
                else
                    isHit = sp.getGraphicBounds().contains(x, y);
            }
            return isHit;
        }
        handleRollOver(touch) {
            if (!InputManager.mouseEventsEnabled) {
                touch.lastRollOver = touch.target;
                return;
            }
            _rollOverChain.length = 0;
            _rollOutChain.length = 0;
            let ele = touch.lastRollOver;
            while (ele) {
                _rollOutChain.push(ele);
                ele = ele.parent;
            }
            touch.lastRollOver = touch.target;
            ele = touch.target;
            while (ele) {
                let i = _rollOutChain.indexOf(ele);
                if (i != -1) {
                    _rollOutChain.splice(i, _rollOutChain.length - i);
                    break;
                }
                _rollOverChain.push(ele);
                ele = ele.parent;
            }
            let cnt = _rollOutChain.length;
            if (cnt > 0) {
                for (let i = 0; i < cnt; i++) {
                    ele = _rollOutChain[i];
                    if (!ele._destroyed)
                        ele.event(Event.MOUSE_OUT, touch.event.setTo(Event.MOUSE_OUT, ele, ele));
                }
                _rollOutChain.length = 0;
            }
            cnt = _rollOverChain.length;
            if (cnt > 0) {
                for (let i = 0; i < cnt; i++) {
                    ele = _rollOverChain[i];
                    if (ele.activeInHierarchy)
                        ele.event(Event.MOUSE_OVER, touch.event.setTo(Event.MOUSE_OVER, ele, ele));
                }
                _rollOverChain.length = 0;
            }
        }
        bubbleEvent(type, ev, initiator) {
            _bubbleChain.length = 0;
            let obj = initiator;
            while (obj) {
                if (obj.activeInHierarchy)
                    _bubbleChain.push(obj);
                obj = obj.parent;
            }
            ev._stopped = false;
            for (let obj of _bubbleChain) {
                ev.setTo(type, obj, initiator);
                obj.event(type, ev);
                if (ev._stopped)
                    break;
            }
        }
    }
    InputManager.multiTouchEnabled = true;
    InputManager.mouseEventsEnabled = true;
    InputManager.keyEventsEnabled = true;
    InputManager.clickTestThreshold = 10;
    InputManager.mouseX = 0;
    InputManager.mouseY = 0;
    InputManager.isTextInputting = false;
    InputManager.isiOSWKwebView = false;
    const clickTrack = {};
    class TouchInfo {
        constructor(touches) {
            this.downPos = new Point();
            this.downTargets = [];
            this.event = new Event();
            this.event._touches = touches;
            this.pos = this.event.touchPos;
            this.reset();
        }
        begin() {
            this.began = true;
            this.clickCancelled = false;
            this.moved = false;
            this.downPos.copy(this.pos);
            this.downTargets.length = 0;
            if (this.target) {
                let ele = this.target;
                while (ele) {
                    this.downTargets.push(ele);
                    ele = ele.parent;
                }
            }
        }
        move() {
            this.moved = true;
            if (Math.abs(this.pos.x - this.downPos.x) > InputManager.clickTestThreshold
                || Math.abs(this.pos.y - this.downPos.y) > InputManager.clickTestThreshold)
                this.clickCancelled = true;
        }
        end() {
            this.began = false;
            let now = performance.now();
            let lastClick = clickTrack[this.touchId];
            if (!lastClick) {
                lastClick = { pos: new Point(), time: 0, button: 0 };
                clickTrack[this.touchId] = lastClick;
            }
            if (this.downTargets.length == 0
                || this.clickCancelled
                || Math.abs(this.pos.x - this.downPos.x) > InputManager.clickTestThreshold
                || Math.abs(this.pos.y - this.downPos.y) > InputManager.clickTestThreshold) {
                this.clickCancelled = true;
                lastClick.time = 0;
                this.clickCount = 1;
            }
            else {
                if (now - lastClick.time < 350
                    && Math.abs(this.pos.x - lastClick.pos.x) < InputManager.clickTestThreshold
                    && Math.abs(this.pos.y - lastClick.pos.y) < InputManager.clickTestThreshold
                    && lastClick.button == this.event.button) {
                    this.clickCount = 2;
                }
                else
                    this.clickCount = 1;
                lastClick.time = now;
                lastClick.pos.copy(this.pos);
                lastClick.button = this.event.button;
            }
        }
        clickTest() {
            if (this.clickCancelled) {
                this.downTargets.length = 0;
                return null;
            }
            let obj = this.downTargets[0];
            if (obj.activeInHierarchy) {
                this.downTargets.length = 0;
                return obj;
            }
            obj = this.target;
            while (obj) {
                let i = this.downTargets.indexOf(obj);
                if (i != -1 && obj.activeInHierarchy)
                    break;
                obj = obj.parent;
            }
            this.downTargets.length = 0;
            return obj;
        }
        reset() {
            this.pos.setTo(0, 0);
            this.touchId = 0;
            this.clickCount = 0;
            this.began = false;
            this.moved = false;
            this.target = null;
            this.downTargets.length = 0;
            this.lastRollOver = null;
            this.clickCancelled = false;
        }
    }

    exports.WebGLMode = void 0;
    (function (WebGLMode) {
        WebGLMode[WebGLMode["Auto"] = 0] = "Auto";
        WebGLMode[WebGLMode["WebGL2"] = 1] = "WebGL2";
        WebGLMode[WebGLMode["WebGL1"] = 2] = "WebGL1";
    })(exports.WebGLMode || (exports.WebGLMode = {}));

    class WebGL {
        static _nativeRender_enable() {
        }
        static enable() {
            return true;
        }
        static onStageResize(width, height) {
            LayaGL.renderEngine.viewport(0, 0, width, height);
            RenderState2D.width = width;
            RenderState2D.height = height;
        }
    }
    WebGL._isWebGL2 = false;
    WebGL.isNativeRender_enable = false;

    class RenderStateCommand {
        constructor() {
            this.cmdArray = new Map();
        }
        addCMD(renderstate, value) {
            this.cmdArray.set(renderstate, value);
        }
        applyCMD() {
            LayaGL.renderEngine.applyRenderStateCMD(this);
        }
        clear() {
            this.cmdArray.clear();
        }
    }

    exports.WebGLExtension = void 0;
    (function (WebGLExtension) {
        WebGLExtension[WebGLExtension["OES_vertex_array_object"] = 0] = "OES_vertex_array_object";
        WebGLExtension[WebGLExtension["ANGLE_instanced_arrays"] = 1] = "ANGLE_instanced_arrays";
        WebGLExtension[WebGLExtension["OES_texture_half_float"] = 2] = "OES_texture_half_float";
        WebGLExtension[WebGLExtension["OES_texture_half_float_linear"] = 3] = "OES_texture_half_float_linear";
        WebGLExtension[WebGLExtension["OES_texture_float"] = 4] = "OES_texture_float";
        WebGLExtension[WebGLExtension["OES_element_index_uint"] = 5] = "OES_element_index_uint";
        WebGLExtension[WebGLExtension["OES_texture_float_linear"] = 6] = "OES_texture_float_linear";
        WebGLExtension[WebGLExtension["EXT_color_buffer_half_float"] = 7] = "EXT_color_buffer_half_float";
        WebGLExtension[WebGLExtension["EXT_shader_texture_lod"] = 8] = "EXT_shader_texture_lod";
        WebGLExtension[WebGLExtension["WEBGL_depth_texture"] = 9] = "WEBGL_depth_texture";
        WebGLExtension[WebGLExtension["EXT_sRGB"] = 10] = "EXT_sRGB";
        WebGLExtension[WebGLExtension["EXT_color_buffer_float"] = 11] = "EXT_color_buffer_float";
        WebGLExtension[WebGLExtension["EXT_texture_filter_anisotropic"] = 12] = "EXT_texture_filter_anisotropic";
        WebGLExtension[WebGLExtension["WEBGL_compressed_texture_s3tc"] = 13] = "WEBGL_compressed_texture_s3tc";
        WebGLExtension[WebGLExtension["WEBGL_compressed_texture_s3tc_srgb"] = 14] = "WEBGL_compressed_texture_s3tc_srgb";
        WebGLExtension[WebGLExtension["WEBGL_compressed_texture_pvrtc"] = 15] = "WEBGL_compressed_texture_pvrtc";
        WebGLExtension[WebGLExtension["WEBGL_compressed_texture_etc1"] = 16] = "WEBGL_compressed_texture_etc1";
        WebGLExtension[WebGLExtension["WEBGL_compressed_texture_etc"] = 17] = "WEBGL_compressed_texture_etc";
        WebGLExtension[WebGLExtension["WEBGL_compressed_texture_astc"] = 18] = "WEBGL_compressed_texture_astc";
    })(exports.WebGLExtension || (exports.WebGLExtension = {}));

    class GLObject {
        constructor(engine) {
            this._destroyed = false;
            this._engine = engine;
            this._gl = this._engine.gl;
            this._id = this._engine._IDCounter++;
        }
        get destroyed() {
            return this._destroyed;
        }
        setResourceManager() {
        }
        ;
        destroy() {
            if (this._destroyed)
                return;
            this._destroyed = true;
        }
    }

    class WebGLInternalTex extends GLObject {
        constructor(engine, target, width, height, dimension, mipmap, useSRGBLoader, gammaCorrection) {
            super(engine);
            this._gpuMemory = 0;
            this._baseMipmapLevel = 0;
            this._maxMipmapLevel = 0;
            this.resource = this._gl.createTexture();
            this.width = width;
            this.height = height;
            const isPot = (value) => {
                return (value & (value - 1)) === 0;
            };
            this.isPotSize = isPot(width) && isPot(height);
            this._mipmap = mipmap && this.isPotSize;
            this._mipmapCount = this._mipmap ? Math.max(Math.ceil(Math.log2(width)) + 1, Math.ceil(Math.log2(height)) + 1) : 1;
            this.useSRGBLoad = useSRGBLoader;
            this.gammaCorrection = gammaCorrection;
            this.target = target;
            this.filterMode = exports.FilterMode.Bilinear;
            this.wrapU = exports.WrapMode.Repeat;
            this.wrapV = exports.WrapMode.Repeat;
            this.wrapW = exports.WrapMode.Repeat;
            this.anisoLevel = 4;
        }
        get mipmap() {
            return this._mipmap;
        }
        get mipmapCount() {
            return this._mipmapCount;
        }
        get gpuMemory() {
            return this._gpuMemory;
        }
        set gpuMemory(value) {
            this._engine._addStatisticsInfo(exports.RenderStatisticsInfo.GPUMemory, -this._gpuMemory);
            this._engine._addStatisticsInfo(exports.RenderStatisticsInfo.TextureMemeory, -this._gpuMemory);
            this._gpuMemory = value;
            this._engine._addStatisticsInfo(exports.RenderStatisticsInfo.GPUMemory, this._gpuMemory);
            this._engine._addStatisticsInfo(exports.RenderStatisticsInfo.TextureMemeory, this._gpuMemory);
        }
        get filterMode() {
            return this._filterMode;
        }
        set filterMode(value) {
            if (this._filterMode != value && this.resource) {
                let gl = this._gl;
                let mipmap = this.mipmap;
                let min = this.getFilteMinrParam(value, mipmap);
                this._setTexParameteri(gl.TEXTURE_MIN_FILTER, min);
                let mag = this.getFilterMagParam(value);
                this._setTexParameteri(gl.TEXTURE_MAG_FILTER, mag);
                this._filterMode = value;
            }
        }
        get wrapU() {
            return this._warpU;
        }
        set wrapU(value) {
            if (this._warpU != value && this.resource) {
                let gl = this._gl;
                let warpParam = this.getWrapParam(value);
                this._setWrapMode(gl.TEXTURE_WRAP_S, warpParam);
                this._warpU = value;
            }
        }
        get wrapV() {
            return this._warpV;
        }
        set wrapV(value) {
            if (this._warpV != value && this.resource) {
                let gl = this._gl;
                let warpParam = this.getWrapParam(value);
                this._setWrapMode(gl.TEXTURE_WRAP_T, warpParam);
                this._warpV = value;
            }
        }
        get wrapW() {
            return this._warpW;
        }
        set wrapW(value) {
            this._warpW = value;
        }
        get anisoLevel() {
            return this._anisoLevel;
        }
        set anisoLevel(value) {
            let anisoExt = this._engine._supportCapatable.getExtension(exports.WebGLExtension.EXT_texture_filter_anisotropic);
            if (anisoExt) {
                let gl = this._gl;
                let maxAnisoLevel = gl.getParameter(anisoExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
                let level = Math.max(1, Math.min(maxAnisoLevel, value));
                this._setTexParametexf(anisoExt.TEXTURE_MAX_ANISOTROPY_EXT, level);
                this._anisoLevel = level;
            }
            else {
                this._anisoLevel = 1;
            }
        }
        set baseMipmapLevel(value) {
            if (this._engine.isWebGL2) {
                this._setTexParameteri(this._gl.TEXTURE_BASE_LEVEL, value);
            }
        }
        get baseMipmapLevel() {
            return this._baseMipmapLevel;
        }
        set maxMipmapLevel(value) {
            if (this._engine.isWebGL2) {
                this._setTexParameteri(this._gl.TEXTURE_MAX_LEVEL, value);
            }
        }
        get maxMipmapLevel() {
            return this._maxMipmapLevel;
        }
        get compareMode() {
            return this._compareMode;
        }
        set compareMode(value) {
            this._compareMode = value;
        }
        _setTexParameteri(pname, param) {
            let gl = this._gl;
            let target = this.target;
            this._engine._bindTexture(target, this.resource);
            gl.texParameteri(target, pname, param);
            this._engine._bindTexture(target, null);
        }
        _setTexParametexf(pname, param) {
            let gl = this._gl;
            let target = this.target;
            this._engine._bindTexture(target, this.resource);
            gl.texParameterf(target, pname, param);
            this._engine._bindTexture(target, null);
        }
        getFilteMinrParam(filterMode, mipmap) {
            let gl = this._gl;
            switch (filterMode) {
                case exports.FilterMode.Point:
                    return mipmap ? gl.NEAREST_MIPMAP_NEAREST : gl.NEAREST;
                case exports.FilterMode.Bilinear:
                    return mipmap ? gl.LINEAR_MIPMAP_NEAREST : gl.LINEAR;
                case exports.FilterMode.Trilinear:
                    return mipmap ? gl.LINEAR_MIPMAP_LINEAR : gl.LINEAR;
                default:
                    return mipmap ? gl.LINEAR_MIPMAP_NEAREST : gl.LINEAR;
            }
        }
        getFilterMagParam(filterMode) {
            let gl = this._gl;
            switch (filterMode) {
                case exports.FilterMode.Point:
                    return gl.NEAREST;
                case exports.FilterMode.Bilinear:
                    return gl.LINEAR;
                case exports.FilterMode.Trilinear:
                    return gl.LINEAR;
                default:
                    return gl.LINEAR;
            }
        }
        getWrapParam(wrapMode) {
            let gl = this._gl;
            switch (wrapMode) {
                case exports.WrapMode.Repeat:
                    return gl.REPEAT;
                case exports.WrapMode.Clamp:
                    return gl.CLAMP_TO_EDGE;
                case exports.WrapMode.Mirrored:
                    return gl.MIRRORED_REPEAT;
                default:
                    return gl.REPEAT;
            }
        }
        _setWrapMode(pname, param) {
            let gl = this._gl;
            if (!this.isPotSize) {
                param = gl.CLAMP_TO_EDGE;
            }
            this._setTexParameteri(pname, param);
        }
        dispose() {
            let gl = this._gl;
            gl.deleteTexture(this.resource);
            this._engine._addStatisticsInfo(exports.RenderStatisticsInfo.GPUMemory, -this._gpuMemory);
            this._engine._addStatisticsInfo(exports.RenderStatisticsInfo.TextureMemeory, -this._gpuMemory);
            this._gpuMemory = 0;
        }
    }

    class WebGLInternalRT extends GLObject {
        constructor(engine, colorFormat, depthStencilFormat, isCube, generateMipmap, samples) {
            super(engine);
            this._gpuMemory = 0;
            this.colorFormat = colorFormat;
            this.depthStencilFormat = depthStencilFormat;
            this._isCube = isCube;
            this._generateMipmap = generateMipmap;
            this._samples = samples;
            this._textures = [];
            this._depthTexture = null;
            this._framebuffer = this._gl.createFramebuffer();
            if (samples > 1) {
                this._msaaFramebuffer = this._gl.createFramebuffer();
            }
        }
        get gpuMemory() {
            return this._gpuMemory;
        }
        set gpuMemory(value) {
            this._gpuMemory = value;
            this._engine._addStatisticsInfo(exports.RenderStatisticsInfo.GPUMemory, this._gpuMemory);
            this._engine._addStatisticsInfo(exports.RenderStatisticsInfo.RenderTextureMemory, this._gpuMemory);
        }
        dispose() {
            this._textures.forEach(tex => {
                tex && tex.dispose();
            });
            this._textures = null;
            this._depthTexture && this._depthTexture.dispose();
            this._depthTexture = null;
            this._framebuffer && this._gl.deleteFramebuffer(this._framebuffer);
            this._framebuffer = null;
            this._depthbuffer && this._gl.deleteRenderbuffer(this._depthbuffer);
            this._depthbuffer = null;
            this._msaaFramebuffer && this._gl.deleteFramebuffer(this._msaaFramebuffer);
            this._msaaFramebuffer = null;
            this._msaaRenderbuffer && this._gl.deleteRenderbuffer(this._msaaRenderbuffer);
            this._msaaRenderbuffer = null;
            this._engine._addStatisticsInfo(exports.RenderStatisticsInfo.GPUMemory, -this._gpuMemory);
            this._engine._addStatisticsInfo(exports.RenderStatisticsInfo.RenderTextureMemory, -this._gpuMemory);
            this._gpuMemory = 0;
        }
    }

    exports.TextureCompareMode = void 0;
    (function (TextureCompareMode) {
        TextureCompareMode[TextureCompareMode["None"] = 0] = "None";
        TextureCompareMode[TextureCompareMode["LEQUAL"] = 1] = "LEQUAL";
        TextureCompareMode[TextureCompareMode["GEQUAL"] = 2] = "GEQUAL";
        TextureCompareMode[TextureCompareMode["LESS"] = 3] = "LESS";
        TextureCompareMode[TextureCompareMode["GREATER"] = 4] = "GREATER";
        TextureCompareMode[TextureCompareMode["EQUAL"] = 5] = "EQUAL";
        TextureCompareMode[TextureCompareMode["NOTEQUAL"] = 6] = "NOTEQUAL";
        TextureCompareMode[TextureCompareMode["ALWAYS"] = 7] = "ALWAYS";
        TextureCompareMode[TextureCompareMode["NEVER"] = 8] = "NEVER";
    })(exports.TextureCompareMode || (exports.TextureCompareMode = {}));

    class GLTextureContext extends GLObject {
        constructor(engine) {
            super(engine);
            this._glParam = {
                internalFormat: 0,
                format: 0,
                type: 0,
            };
            this._sRGB = this._engine._supportCapatable.getExtension(exports.WebGLExtension.EXT_sRGB);
            this._oesTextureHalfFloat = this._engine._supportCapatable.getExtension(exports.WebGLExtension.OES_texture_half_float);
            this._compressdTextureS3tc_srgb = this._engine._supportCapatable.getExtension(exports.WebGLExtension.WEBGL_compressed_texture_s3tc_srgb);
            this._compressedTextureEtc1 = this._engine._supportCapatable.getExtension(exports.WebGLExtension.WEBGL_compressed_texture_etc1);
            this._compressedTextureS3tc = this._engine._supportCapatable.getExtension(exports.WebGLExtension.WEBGL_compressed_texture_s3tc);
            this._compressedTextureETC = this._engine._supportCapatable.getExtension(exports.WebGLExtension.WEBGL_compressed_texture_etc);
            this._compressedTextureASTC = this._engine._supportCapatable.getExtension(exports.WebGLExtension.WEBGL_compressed_texture_astc);
            this._webgl_depth_texture = this._engine._supportCapatable.getExtension(exports.WebGLExtension.WEBGL_depth_texture);
        }
        glTextureParam(format, useSRGB) {
            let gl = this._gl;
            this._glParam.internalFormat = null;
            this._glParam.format = null;
            this._glParam.type = null;
            switch (format) {
                case exports.TextureFormat.R8G8B8:
                    this._glParam.internalFormat = useSRGB ? this._sRGB.SRGB_EXT : gl.RGB;
                    this._glParam.format = this._glParam.internalFormat;
                    this._glParam.type = gl.UNSIGNED_BYTE;
                    break;
                case exports.TextureFormat.R8G8B8A8:
                    this._glParam.internalFormat = useSRGB ? this._sRGB.SRGB_ALPHA_EXT : gl.RGBA;
                    this._glParam.format = this._glParam.internalFormat;
                    this._glParam.type = gl.UNSIGNED_BYTE;
                    break;
                case exports.TextureFormat.R5G6B5:
                    this._glParam.internalFormat = gl.RGB;
                    this._glParam.format = this._glParam.internalFormat;
                    this._glParam.type = gl.UNSIGNED_SHORT_5_6_5;
                    break;
                case exports.TextureFormat.R32G32B32A32:
                    this._glParam.internalFormat = gl.RGBA;
                    this._glParam.format = this._glParam.internalFormat;
                    this._glParam.type = gl.FLOAT;
                    break;
                case exports.TextureFormat.R32G32B32:
                    this._glParam.internalFormat = gl.RGB;
                    this._glParam.format = this._glParam.internalFormat;
                    this._glParam.type = gl.FLOAT;
                    break;
                case exports.TextureFormat.R16G16B16A16:
                    this._glParam.internalFormat = gl.RGBA;
                    this._glParam.format = this._glParam.internalFormat;
                    this._glParam.type = this._oesTextureHalfFloat.HALF_FLOAT_OES;
                    break;
                case exports.TextureFormat.R16G16B16:
                    this._glParam.internalFormat = gl.RGB;
                    this._glParam.format = this._glParam.internalFormat;
                    this._glParam.type = this._oesTextureHalfFloat.HALF_FLOAT_OES;
                    break;
                case exports.TextureFormat.DXT1:
                    this._glParam.internalFormat = useSRGB ? this._compressdTextureS3tc_srgb.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT : this._compressedTextureS3tc.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                    this._glParam.format = this._glParam.internalFormat;
                    this._glParam.type = gl.UNSIGNED_BYTE;
                    break;
                case exports.TextureFormat.DXT3:
                    this._glParam.internalFormat = useSRGB ? this._compressdTextureS3tc_srgb.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT : this._compressedTextureS3tc.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                    this._glParam.format = this._glParam.internalFormat;
                    this._glParam.type = gl.UNSIGNED_BYTE;
                    break;
                case exports.TextureFormat.DXT5:
                    this._glParam.internalFormat = useSRGB ? this._compressdTextureS3tc_srgb.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT : this._compressedTextureS3tc.COMPRESSED_RGBA_S3TC_DXT5_EXT;
                    this._glParam.format = this._glParam.internalFormat;
                    this._glParam.type = gl.UNSIGNED_BYTE;
                    break;
                case exports.TextureFormat.ETC1RGB:
                    this._glParam.internalFormat = this._compressedTextureEtc1.COMPRESSED_RGB_ETC1_WEBGL;
                    this._glParam.format = this._glParam.internalFormat;
                    this._glParam.type = gl.UNSIGNED_BYTE;
                    break;
                case exports.TextureFormat.ETC2RGBA:
                    this._glParam.internalFormat = this._compressedTextureETC.COMPRESSED_RGBA8_ETC2_EAC;
                    this._glParam.format = this._glParam.internalFormat;
                    this._glParam.type = gl.UNSIGNED_BYTE;
                    break;
                case exports.TextureFormat.ETC2RGB:
                    this._glParam.internalFormat = this._compressedTextureETC.COMPRESSED_RGB8_ETC2;
                    this._glParam.format = this._glParam.internalFormat;
                    this._glParam.type = gl.UNSIGNED_BYTE;
                    break;
                case exports.TextureFormat.ETC2SRGB:
                    this._glParam.internalFormat = this._compressedTextureETC.COMPRESSED_SRGB8_ETC2;
                    this._glParam.format = this._glParam.internalFormat;
                    this._glParam.type = gl.UNSIGNED_BYTE;
                    break;
                case exports.TextureFormat.ETC2SRGB_Alpha8:
                    this._glParam.internalFormat = this._compressedTextureETC.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC;
                    this._glParam.format = this._glParam.internalFormat;
                    this._glParam.type = gl.UNSIGNED_BYTE;
                    break;
                case exports.TextureFormat.ASTC4x4:
                    this._glParam.internalFormat = this._compressedTextureASTC.COMPRESSED_RGBA_ASTC_4x4_KHR;
                    this._glParam.format = this._glParam.internalFormat;
                    this._glParam.type = gl.UNSIGNED_BYTE;
                    break;
                case exports.TextureFormat.ASTC6x6:
                    this._glParam.internalFormat = this._compressedTextureASTC.COMPRESSED_RGBA_ASTC_6x6_KHR;
                    this._glParam.format = this._glParam.internalFormat;
                    this._glParam.type = gl.UNSIGNED_BYTE;
                    break;
                case exports.TextureFormat.ASTC8x8:
                    this._glParam.internalFormat = this._compressedTextureASTC.COMPRESSED_RGBA_ASTC_8x8_KHR;
                    this._glParam.format = this._glParam.internalFormat;
                    this._glParam.type = gl.UNSIGNED_BYTE;
                    break;
                case exports.TextureFormat.ASTC10x10:
                    this._glParam.internalFormat = this._compressedTextureASTC.COMPRESSED_RGBA_ASTC_10x10_KHR;
                    this._glParam.format = this._glParam.internalFormat;
                    this._glParam.type = gl.UNSIGNED_BYTE;
                    break;
                case exports.TextureFormat.ASTC12x12:
                    this._glParam.internalFormat = this._compressedTextureASTC.COMPRESSED_RGBA_ASTC_12x12_KHR;
                    this._glParam.format = this._glParam.internalFormat;
                    this._glParam.type = gl.UNSIGNED_BYTE;
                    break;
                case exports.TextureFormat.ASTC4x4SRGB:
                    this._glParam.internalFormat = this._compressedTextureASTC.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR;
                    this._glParam.format = this._glParam.internalFormat;
                    this._glParam.type = gl.UNSIGNED_BYTE;
                    break;
                case exports.TextureFormat.ASTC6x6SRGB:
                    this._glParam.internalFormat = this._compressedTextureASTC.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR;
                    this._glParam.format = this._glParam.internalFormat;
                    this._glParam.type = gl.UNSIGNED_BYTE;
                    break;
                case exports.TextureFormat.ASTC8x8SRGB:
                    this._glParam.internalFormat = this._compressedTextureASTC.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR;
                    this._glParam.format = this._glParam.internalFormat;
                    this._glParam.type = gl.UNSIGNED_BYTE;
                    break;
                case exports.TextureFormat.ASTC10x10SRGB:
                    this._glParam.internalFormat = this._compressedTextureASTC.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR;
                    this._glParam.format = this._glParam.internalFormat;
                    this._glParam.type = gl.UNSIGNED_BYTE;
                    break;
                case exports.TextureFormat.ASTC12x12SRGB:
                    this._glParam.internalFormat = this._compressedTextureASTC.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR;
                    this._glParam.format = this._glParam.internalFormat;
                    this._glParam.type = gl.UNSIGNED_BYTE;
                    break;
                default:
                    throw "Unknown Texture Format.";
            }
            return this._glParam;
        }
        glRenderTextureParam(format, useSRGB) {
            let gl = this._gl;
            this._glParam.internalFormat = null;
            this._glParam.format = null;
            this._glParam.type = null;
            switch (format) {
                case exports.RenderTargetFormat.R8G8B8:
                    this._glParam.internalFormat = useSRGB ? this._sRGB.SRGB_EXT : gl.RGB;
                    this._glParam.format = this._glParam.internalFormat;
                    this._glParam.type = gl.UNSIGNED_BYTE;
                    break;
                case exports.RenderTargetFormat.R8G8B8A8:
                    this._glParam.internalFormat = useSRGB ? this._sRGB.SRGB_EXT : gl.RGBA;
                    this._glParam.format = this._glParam.internalFormat;
                    this._glParam.type = gl.UNSIGNED_BYTE;
                    break;
                case exports.RenderTargetFormat.R16G16B16:
                    this._glParam.internalFormat = gl.RGB;
                    this._glParam.format = this._glParam.internalFormat;
                    this._glParam.type = this._oesTextureHalfFloat.HALF_FLOAT_OES;
                    break;
                case exports.RenderTargetFormat.R16G16B16A16:
                    this._glParam.internalFormat = gl.RGBA;
                    this._glParam.format = this._glParam.internalFormat;
                    this._glParam.type = this._oesTextureHalfFloat.HALF_FLOAT_OES;
                    break;
                case exports.RenderTargetFormat.R32G32B32:
                    this._glParam.internalFormat = gl.RGB;
                    this._glParam.format = this._glParam.internalFormat;
                    this._glParam.type = gl.FLOAT;
                    break;
                case exports.RenderTargetFormat.R32G32B32A32:
                    this._glParam.internalFormat = gl.RGBA;
                    this._glParam.format = this._glParam.internalFormat;
                    this._glParam.type = gl.FLOAT;
                    break;
                case exports.RenderTargetFormat.DEPTH_16:
                    this._glParam.internalFormat = gl.DEPTH_COMPONENT;
                    this._glParam.format = this._glParam.internalFormat;
                    this._glParam.type = gl.UNSIGNED_SHORT;
                    break;
                case exports.RenderTargetFormat.DEPTHSTENCIL_24_8:
                    this._glParam.internalFormat = gl.DEPTH_STENCIL;
                    this._glParam.format = this._glParam.internalFormat;
                    this._glParam.type = this._webgl_depth_texture.UNSIGNED_INT_24_8_WEBGL;
                    break;
                case exports.RenderTargetFormat.DEPTH_32:
                    this._glParam.internalFormat = gl.DEPTH_COMPONENT;
                    this._glParam.format = this._glParam.internalFormat;
                    this._glParam.type = gl.UNSIGNED_INT;
                    break;
                case exports.RenderTargetFormat.STENCIL_8:
                default:
                    throw "render texture format wrong.";
            }
            return this._glParam;
        }
        glRenderBufferParam(format, useSRGB) {
            let gl = this._gl;
            switch (format) {
                case exports.RenderTargetFormat.DEPTH_16:
                    return { internalFormat: gl.DEPTH_COMPONENT16, attachment: gl.DEPTH_ATTACHMENT };
                case exports.RenderTargetFormat.DEPTHSTENCIL_24_8:
                    return { internalFormat: gl.DEPTH_STENCIL, attachment: gl.DEPTH_STENCIL_ATTACHMENT };
                case exports.RenderTargetFormat.DEPTH_32:
                    return { internalFormat: gl.DEPTH_STENCIL, attachment: gl.DEPTH_ATTACHMENT };
                case exports.RenderTargetFormat.STENCIL_8:
                    return { internalFormat: gl.STENCIL_INDEX8, attachment: gl.STENCIL_ATTACHMENT };
                default:
                    return null;
            }
        }
        glRenderTargetAttachment(format) {
            let gl = this._gl;
            switch (format) {
                case exports.RenderTargetFormat.DEPTH_16:
                    return gl.DEPTH_ATTACHMENT;
                case exports.RenderTargetFormat.DEPTHSTENCIL_24_8:
                    return gl.DEPTH_STENCIL_ATTACHMENT;
                case exports.RenderTargetFormat.DEPTH_32:
                    return gl.DEPTH_ATTACHMENT;
                case exports.RenderTargetFormat.STENCIL_8:
                    return gl.STENCIL_ATTACHMENT;
                case exports.RenderTargetFormat.R8G8B8:
                case exports.RenderTargetFormat.R8G8B8A8:
                case exports.RenderTargetFormat.R16G16B16:
                case exports.RenderTargetFormat.R16G16B16A16:
                case exports.RenderTargetFormat.R32G32B32:
                case exports.RenderTargetFormat.R32G32B32A32:
                    return gl.COLOR_ATTACHMENT0;
                default:
                    throw "render format.";
            }
        }
        getTarget(dimension) {
            let gl = this._gl;
            switch (dimension) {
                case exports.TextureDimension.Tex2D:
                    return gl.TEXTURE_2D;
                case exports.TextureDimension.Cube:
                    return gl.TEXTURE_CUBE_MAP;
                default:
                    throw "texture dimension wrong in WebGL1.";
            }
        }
        getFormatPixelsParams(format) {
            let formatParams = {
                channels: 0,
                bytesPerPixel: 0,
                dataTypedCons: Uint8Array,
                typedSize: 1
            };
            switch (format) {
                case exports.TextureFormat.R8G8B8A8:
                    formatParams.channels = 4;
                    formatParams.bytesPerPixel = 4;
                    formatParams.dataTypedCons = Uint8Array;
                    formatParams.typedSize = 1;
                    return formatParams;
                case exports.TextureFormat.R8G8B8:
                    formatParams.channels = 3;
                    formatParams.bytesPerPixel = 3;
                    formatParams.dataTypedCons = Uint8Array;
                    formatParams.typedSize = 1;
                    return formatParams;
                case exports.TextureFormat.R5G6B5:
                    formatParams.channels = 3;
                    formatParams.bytesPerPixel = 2;
                    formatParams.dataTypedCons = Uint16Array;
                    formatParams.typedSize = 2;
                    return formatParams;
                case exports.TextureFormat.R16G16B16:
                    formatParams.channels = 3;
                    formatParams.bytesPerPixel = 6;
                    formatParams.dataTypedCons = Uint16Array;
                    formatParams.typedSize = 2;
                    return formatParams;
                case exports.TextureFormat.R16G16B16A16:
                    formatParams.channels = 4;
                    formatParams.bytesPerPixel = 8;
                    formatParams.dataTypedCons = Uint16Array;
                    formatParams.typedSize = 2;
                    return formatParams;
                case exports.TextureFormat.R32G32B32:
                    formatParams.channels = 3;
                    formatParams.bytesPerPixel = 12;
                    formatParams.dataTypedCons = Float32Array;
                    formatParams.typedSize = 4;
                    return formatParams;
                case exports.TextureFormat.R32G32B32A32:
                    formatParams.channels = 4;
                    formatParams.bytesPerPixel = 16;
                    formatParams.dataTypedCons = Float32Array;
                    formatParams.typedSize = 4;
                    return formatParams;
                default:
                    return formatParams;
            }
        }
        getGLtexMemory(tex) {
            let gl = this._gl;
            let channels = 0;
            let singlebyte = 0;
            let bytelength = 0;
            let srgb = this._sRGB ? this._sRGB.SRGB_EXT : gl.RGB;
            let srgb_alpha = this._sRGB ? this._sRGB.SRGB_ALPHA_EXT : gl.RGBA;
            switch (tex.internalFormat) {
                case srgb:
                case gl.RGB:
                    channels = 3;
                    break;
                case srgb_alpha:
                case gl.RGBA:
                    channels = 4;
                    break;
                default:
                    channels = 0;
                    break;
            }
            switch (tex.type) {
                case gl.UNSIGNED_BYTE:
                    singlebyte = 1;
                    break;
                case gl.UNSIGNED_SHORT_5_6_5:
                    singlebyte = 2 / 3;
                    break;
                case gl.FLOAT:
                    singlebyte = 4;
                    break;
                case this._oesTextureHalfFloat.HALF_FLOAT_OES:
                    singlebyte = 2;
                    break;
                default:
                    singlebyte = 0;
                    break;
            }
            bytelength = channels * singlebyte * tex.width * tex.height;
            if (tex.mipmap) {
                bytelength *= 1.333;
            }
            if (tex.target == gl.TEXTURE_CUBE_MAP)
                bytelength *= 6;
            else if (tex.target == gl.TEXTURE_2D)
                bytelength *= 1;
            return bytelength;
        }
        getGLRTTexMemory(width, height, colorFormat, depthStencilFormat, generateMipmap, multiSamples, cube) {
            let getpixelbyte = (rtFormat) => {
                let pixelByte = 0;
                switch (rtFormat) {
                    case exports.RenderTargetFormat.R8G8B8:
                        pixelByte = 3;
                        break;
                    case exports.RenderTargetFormat.R8G8B8A8:
                        pixelByte = 4;
                        break;
                    case exports.RenderTargetFormat.R16G16B16A16:
                        pixelByte = 8;
                        break;
                    case exports.RenderTargetFormat.R32G32B32:
                        pixelByte = 12;
                        break;
                    case exports.RenderTargetFormat.R32G32B32A32:
                        pixelByte = 16;
                        break;
                    case exports.RenderTargetFormat.R16G16B16:
                        pixelByte = 6;
                        break;
                    case exports.RenderTargetFormat.DEPTH_16:
                        pixelByte = 2;
                        break;
                    case exports.RenderTargetFormat.STENCIL_8:
                        pixelByte = 1;
                        break;
                    case exports.RenderTargetFormat.DEPTHSTENCIL_24_8:
                        pixelByte = 4;
                        break;
                    case exports.RenderTargetFormat.DEPTH_32:
                        pixelByte = 4;
                        break;
                }
                return pixelByte;
            };
            let colorPixelbyte = getpixelbyte(colorFormat);
            let depthPixelbyte = getpixelbyte(depthStencilFormat);
            if (multiSamples > 1)
                colorPixelbyte *= 2;
            if (cube)
                colorPixelbyte *= 6;
            if (generateMipmap)
                colorPixelbyte *= 1.333;
            let colorMemory = colorPixelbyte * width * height;
            let depthMemory = depthPixelbyte * width * height;
            return colorMemory + depthMemory;
        }
        supportSRGB(format, mipmap) {
            switch (format) {
                case exports.TextureFormat.R8G8B8:
                case exports.TextureFormat.R8G8B8A8:
                    return this._engine.getCapable(exports.RenderCapable.Texture_SRGB) && !mipmap;
                case exports.TextureFormat.DXT1:
                case exports.TextureFormat.DXT3:
                case exports.TextureFormat.DXT5:
                    return this._engine.getCapable(exports.RenderCapable.COMPRESS_TEXTURE_S3TC_SRGB) && !mipmap;
                default:
                    return false;
            }
        }
        supportGenerateMipmap(format) {
            switch (format) {
                case exports.RenderTargetFormat.DEPTH_16:
                case exports.RenderTargetFormat.DEPTHSTENCIL_24_8:
                case exports.RenderTargetFormat.DEPTH_32:
                case exports.RenderTargetFormat.STENCIL_8:
                    return false;
                default:
                    return true;
            }
        }
        isSRGBFormat(format) {
            switch (format) {
                case exports.TextureFormat.ETC2SRGB:
                case exports.TextureFormat.ETC2SRGB_Alpha8:
                case exports.TextureFormat.ASTC4x4SRGB:
                case exports.TextureFormat.ASTC6x6SRGB:
                case exports.TextureFormat.ASTC8x8SRGB:
                case exports.TextureFormat.ASTC10x10SRGB:
                case exports.TextureFormat.ASTC12x12SRGB:
                    return true;
                default:
                    return false;
            }
        }
        createTextureInternal(dimension, width, height, format, gengerateMipmap, sRGB) {
            let useSRGBExt = this.isSRGBFormat(format) || (sRGB && this.supportSRGB(format, gengerateMipmap));
            let gammaCorrection = 1.0;
            if (!useSRGBExt && sRGB) {
                gammaCorrection = 2.2;
            }
            let target = this.getTarget(dimension);
            let internalTex = new WebGLInternalTex(this._engine, target, width, height, dimension, gengerateMipmap, useSRGBExt, gammaCorrection);
            let glParam = this.glTextureParam(format, useSRGBExt);
            internalTex.internalFormat = glParam.internalFormat;
            internalTex.format = glParam.format;
            internalTex.type = glParam.type;
            return internalTex;
        }
        setTextureImageData(texture, source, premultiplyAlpha, invertY) {
            if (texture.width != source.width || texture.height != source.height) {
                console.warn("setTextureImageData: size not match");
            }
            let target = texture.target;
            let internalFormat = texture.internalFormat;
            let format = texture.format;
            let type = texture.type;
            texture.width;
            texture.height;
            let gl = texture._gl;
            premultiplyAlpha && gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
            invertY && gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
            this._engine._bindTexture(texture.target, texture.resource);
            gl.texImage2D(target, 0, internalFormat, format, type, source);
            texture.gpuMemory = this.getGLtexMemory(texture);
            if (texture.mipmap) {
                gl.generateMipmap(texture.target);
            }
            this._engine._bindTexture(texture.target, null);
            premultiplyAlpha && gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
            invertY && gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
        }
        setTexturebySubImageData(texture, source, x, y, premultiplyAlpha, invertY) {
            let target = texture.target;
            texture.internalFormat;
            let format = texture.format;
            let type = texture.type;
            source.width;
            source.height;
            let gl = texture._gl;
            premultiplyAlpha && gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
            invertY && gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
            this._engine._bindTexture(texture.target, texture.resource);
            gl.texSubImage2D(target, 0, x, y, format, type, source);
            texture.gpuMemory = this.getGLtexMemory(texture);
            if (texture.mipmap) {
                gl.generateMipmap(texture.target);
            }
            this._engine._bindTexture(texture.target, null);
            premultiplyAlpha && gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
            invertY && gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
        }
        initVideoTextureData(texture) {
            let target = texture.target;
            texture.internalFormat;
            let format = texture.format;
            let type = texture.type;
            let width = texture.width;
            let height = texture.height;
            let gl = texture._gl;
            this._engine._bindTexture(texture.target, texture.resource);
            gl.texImage2D(target, 0, texture.internalFormat, width, height, 0, format, type, null);
            texture.gpuMemory = this.getGLtexMemory(texture);
            if (texture.mipmap) {
                gl.generateMipmap(texture.target);
            }
            this._engine._bindTexture(texture.target, null);
        }
        setTexturePixelsData(texture, source, premultiplyAlpha, invertY) {
            let target = texture.target;
            let internalFormat = texture.internalFormat;
            let format = texture.format;
            let type = texture.type;
            let width = texture.width;
            let height = texture.height;
            let fourSize = width % 4 == 0 && height % 4 == 0;
            let gl = texture._gl;
            premultiplyAlpha && gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
            invertY && gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
            fourSize || gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
            this._engine._bindTexture(texture.target, texture.resource);
            gl.texImage2D(target, 0, internalFormat, width, height, 0, format, type, source);
            texture.gpuMemory = this.getGLtexMemory(texture);
            if (texture.mipmap) {
                gl.generateMipmap(texture.target);
            }
            this._engine._bindTexture(texture.target, null);
            premultiplyAlpha && gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
            invertY && gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
            fourSize || gl.pixelStorei(gl.UNPACK_ALIGNMENT, 4);
        }
        setTextureSubPixelsData(texture, source, mipmapLevel, generateMipmap, xOffset, yOffset, width, height, premultiplyAlpha, invertY) {
            generateMipmap = generateMipmap && mipmapLevel == 0;
            let target = texture.target;
            texture.internalFormat;
            let format = texture.format;
            let type = texture.type;
            let fourSize = width % 4 == 0 && height % 4 == 0;
            let gl = texture._gl;
            premultiplyAlpha && gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
            invertY && gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
            fourSize || gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
            this._engine._bindTexture(texture.target, texture.resource);
            gl.texSubImage2D(target, mipmapLevel, xOffset, yOffset, width, height, format, type, source);
            if (texture.mipmap && generateMipmap) {
                gl.generateMipmap(texture.target);
            }
            this._engine._bindTexture(texture.target, null);
            premultiplyAlpha && gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
            invertY && gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
            fourSize || gl.pixelStorei(gl.UNPACK_ALIGNMENT, 4);
        }
        setTextureDDSData(texture, ddsInfo) {
            let target = texture.target;
            let internalFormat = texture.internalFormat;
            texture.format;
            texture.type;
            let width = texture.width;
            let height = texture.height;
            let source = ddsInfo.source;
            let dataOffset = ddsInfo.dataOffset;
            let bpp = ddsInfo.bpp;
            let blockBytes = ddsInfo.blockBytes;
            let mipmapCount = ddsInfo.mipmapCount;
            let fourSize = width % 4 == 0 && height % 4 == 0;
            let gl = texture._gl;
            fourSize || gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
            this._engine._bindTexture(texture.target, texture.resource);
            let mipmapWidth = width;
            let mipmapHeight = height;
            let memory = 0;
            for (let index = 0; index < mipmapCount; index++) {
                let dataLength = Math.max(4, mipmapWidth) / 4 * Math.max(4, mipmapHeight) / 4 * blockBytes;
                let sourceData = new Uint8Array(source, dataOffset, dataLength);
                gl.compressedTexImage2D(target, index, internalFormat, mipmapWidth, mipmapHeight, 0, sourceData);
                memory += sourceData.length;
                dataOffset += bpp ? (mipmapWidth * mipmapHeight * (bpp / 8)) : dataLength;
                mipmapWidth *= 0.5;
                mipmapHeight *= 0.5;
                mipmapWidth = Math.max(1.0, mipmapWidth);
                mipmapHeight = Math.max(1.0, mipmapHeight);
            }
            texture.gpuMemory = memory;
            this._engine._bindTexture(texture.target, null);
            fourSize || gl.pixelStorei(gl.UNPACK_ALIGNMENT, 4);
        }
        setTextureKTXData(texture, ktxInfo) {
            let source = ktxInfo.source;
            let compressed = ktxInfo.compress;
            let target = texture.target;
            let internalFormat = texture.internalFormat;
            let format = texture.format;
            let type = texture.type;
            texture.mipmapCount;
            let width = texture.width;
            let height = texture.height;
            let fourSize = width % 4 == 0 && height % 4 == 0;
            let gl = texture._gl;
            fourSize || gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
            this._engine._bindTexture(texture.target, texture.resource);
            let mipmapWidth = width;
            let mipmapHeight = height;
            let dataOffset = ktxInfo.headerOffset + ktxInfo.bytesOfKeyValueData;
            let memory = 0;
            for (let index = 0; index < ktxInfo.mipmapCount; index++) {
                let imageSize = new Int32Array(source, dataOffset, 1)[0];
                dataOffset += 4;
                let sourceData = new Uint8Array(source, dataOffset, imageSize);
                compressed && gl.compressedTexImage2D(target, index, internalFormat, mipmapWidth, mipmapHeight, 0, sourceData);
                !compressed && gl.texImage2D(target, index, internalFormat, mipmapWidth, mipmapHeight, 0, format, type, sourceData);
                memory += sourceData.length;
                dataOffset += imageSize;
                dataOffset += 3 - ((imageSize + 3) % 4);
                mipmapWidth = Math.max(1, mipmapWidth * 0.5);
                mipmapHeight = Math.max(1, mipmapHeight * 0.5);
            }
            texture.gpuMemory = memory;
            this._engine._bindTexture(texture.target, null);
            fourSize || gl.pixelStorei(gl.UNPACK_ALIGNMENT, 4);
        }
        setTextureHDRData(texture, hdrInfo) {
            let hdrPixelData = hdrInfo.readScanLine();
            this.setTexturePixelsData(texture, hdrPixelData, false, false);
        }
        setCubeImageData(texture, sources, premultiplyAlpha, invertY) {
            let gl = texture._gl;
            const cubeFace = [
                gl.TEXTURE_CUBE_MAP_POSITIVE_Z,
                gl.TEXTURE_CUBE_MAP_NEGATIVE_Z,
                gl.TEXTURE_CUBE_MAP_POSITIVE_X,
                gl.TEXTURE_CUBE_MAP_NEGATIVE_X,
                gl.TEXTURE_CUBE_MAP_POSITIVE_Y,
                gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,
            ];
            let internalFormat = texture.internalFormat;
            let format = texture.format;
            let type = texture.type;
            texture.width;
            texture.height;
            premultiplyAlpha && gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
            invertY && gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
            this._engine._bindTexture(texture.target, texture.resource);
            for (let index = 0; index < cubeFace.length; index++) {
                let target = cubeFace[index];
                gl.texImage2D(target, 0, internalFormat, format, type, sources[index]);
            }
            if (texture.mipmap) {
                gl.generateMipmap(texture.target);
            }
            this._engine._bindTexture(texture.target, null);
            texture.gpuMemory = this.getGLtexMemory(texture);
            premultiplyAlpha && gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
            invertY && gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
        }
        setCubePixelsData(texture, source, premultiplyAlpha, invertY) {
            let gl = texture._gl;
            const cubeFace = [
                gl.TEXTURE_CUBE_MAP_POSITIVE_Z,
                gl.TEXTURE_CUBE_MAP_NEGATIVE_Z,
                gl.TEXTURE_CUBE_MAP_POSITIVE_X,
                gl.TEXTURE_CUBE_MAP_NEGATIVE_X,
                gl.TEXTURE_CUBE_MAP_POSITIVE_Y,
                gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,
            ];
            texture.target;
            let internalFormat = texture.internalFormat;
            let format = texture.format;
            let type = texture.type;
            let width = texture.width;
            let height = texture.height;
            let fourSize = width % 4 == 0;
            premultiplyAlpha && gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
            invertY && gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
            fourSize || gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
            this._engine._bindTexture(texture.target, texture.resource);
            if (source) {
                for (let index = 0; index < cubeFace.length; index++) {
                    let t = cubeFace[index];
                    gl.texImage2D(t, 0, internalFormat, width, height, 0, format, type, source[index]);
                }
                if (texture.mipmap) {
                    gl.generateMipmap(texture.target);
                }
            }
            else {
                for (let index = 0; index < cubeFace.length; index++) {
                    let t = cubeFace[index];
                    gl.texImage2D(t, 0, internalFormat, width, height, 0, format, type, null);
                }
                if (texture.mipmap) {
                    gl.generateMipmap(texture.target);
                }
            }
            this._engine._bindTexture(texture.target, null);
            texture.gpuMemory = this.getGLtexMemory(texture);
            premultiplyAlpha && gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
            invertY && gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
            fourSize || gl.pixelStorei(gl.UNPACK_ALIGNMENT, 4);
        }
        setCubeSubPixelData(texture, source, mipmapLevel, generateMipmap, xOffset, yOffset, width, height, premultiplyAlpha, invertY) {
            generateMipmap = generateMipmap && mipmapLevel == 0;
            let gl = texture._gl;
            const cubeFace = [
                gl.TEXTURE_CUBE_MAP_POSITIVE_Z,
                gl.TEXTURE_CUBE_MAP_NEGATIVE_Z,
                gl.TEXTURE_CUBE_MAP_POSITIVE_X,
                gl.TEXTURE_CUBE_MAP_NEGATIVE_X,
                gl.TEXTURE_CUBE_MAP_POSITIVE_Y,
                gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,
            ];
            texture.target;
            texture.internalFormat;
            let format = texture.format;
            let type = texture.type;
            let fourSize = width % 4 == 0;
            premultiplyAlpha && gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
            invertY && gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
            fourSize || gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
            this._engine._bindTexture(texture.target, texture.resource);
            for (let index = 0; index < cubeFace.length; index++) {
                let target = cubeFace[index];
                gl.texSubImage2D(target, mipmapLevel, xOffset, yOffset, width, height, format, type, source[index]);
            }
            if (texture.mipmap && generateMipmap) {
                gl.generateMipmap(texture.target);
            }
            this._engine._bindTexture(texture.target, null);
            premultiplyAlpha && gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
            invertY && gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
            fourSize || gl.pixelStorei(gl.UNPACK_ALIGNMENT, 4);
        }
        setCubeDDSData(texture, ddsInfo) {
            let internalFormat = texture.internalFormat;
            let format = texture.format;
            let type = texture.type;
            let width = texture.width;
            let height = texture.height;
            let source = ddsInfo.source;
            let dataOffset = ddsInfo.dataOffset;
            let bpp = ddsInfo.bpp;
            let blockBytes = ddsInfo.blockBytes;
            let mipmapCount = ddsInfo.mipmapCount;
            let fourSize = width % 4 == 0 && height % 4 == 0;
            fourSize = true;
            let gl = texture._gl;
            fourSize || gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
            this._engine._bindTexture(texture.target, texture.resource);
            const cubeFace = [
                gl.TEXTURE_CUBE_MAP_POSITIVE_X,
                gl.TEXTURE_CUBE_MAP_NEGATIVE_X,
                gl.TEXTURE_CUBE_MAP_POSITIVE_Y,
                gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,
                gl.TEXTURE_CUBE_MAP_POSITIVE_Z,
                gl.TEXTURE_CUBE_MAP_NEGATIVE_Z,
            ];
            let formatParams = this.getFormatPixelsParams(ddsInfo.format);
            let channelsByte = formatParams.bytesPerPixel / formatParams.channels;
            let dataTypeConstur = ddsInfo.format == exports.TextureFormat.R32G32B32A32 ? Float32Array : Uint16Array;
            let memory = 0;
            if (!ddsInfo.compressed) {
                for (let face = 0; face < 6; face++) {
                    let target = cubeFace[face];
                    let mipmapWidth = width;
                    let mipmapHeight = height;
                    for (let index = 0; index < mipmapCount; index++) {
                        let dataLength = mipmapWidth * mipmapHeight * formatParams.channels;
                        let sourceData = new dataTypeConstur(source, dataOffset, dataLength);
                        gl.texImage2D(target, index, internalFormat, mipmapWidth, mipmapHeight, 0, format, type, sourceData);
                        memory += sourceData.byteLength;
                        dataOffset += dataLength * channelsByte;
                        mipmapWidth *= 0.5;
                        mipmapHeight *= 0.5;
                        mipmapWidth = Math.max(1.0, mipmapWidth);
                        mipmapHeight = Math.max(1.0, mipmapHeight);
                    }
                }
            }
            else {
                for (let face = 0; face < 6; face++) {
                    let target = cubeFace[face];
                    let mipmapWidth = width;
                    let mipmapHeight = height;
                    for (let index = 0; index < mipmapCount; index++) {
                        let dataLength = Math.max(4, mipmapWidth) / 4 * Math.max(4, mipmapHeight) / 4 * blockBytes;
                        let sourceData = new Uint8Array(source, dataOffset, dataLength);
                        (texture.mipmap || index == 0) && gl.compressedTexImage2D(target, index, internalFormat, mipmapWidth, mipmapHeight, 0, sourceData);
                        memory += sourceData.byteLength;
                        dataOffset += bpp ? (mipmapWidth * mipmapHeight * (bpp / 8)) : dataLength;
                        mipmapWidth *= 0.5;
                        mipmapHeight *= 0.5;
                        mipmapWidth = Math.max(1.0, mipmapWidth);
                        mipmapHeight = Math.max(1.0, mipmapHeight);
                    }
                }
            }
            texture.gpuMemory = memory;
            this._engine._bindTexture(texture.target, null);
            fourSize || gl.pixelStorei(gl.UNPACK_ALIGNMENT, 4);
        }
        setCubeKTXData(texture, ktxInfo) {
            let source = ktxInfo.source;
            let compressed = ktxInfo.compress;
            let internalFormat = texture.internalFormat;
            let format = texture.format;
            let type = texture.type;
            ktxInfo.mipmapCount;
            let width = texture.width;
            let height = texture.height;
            let fourSize = width % 4 == 0 && height % 4 == 0;
            let gl = texture._gl;
            const cubeFace = [
                gl.TEXTURE_CUBE_MAP_POSITIVE_X,
                gl.TEXTURE_CUBE_MAP_NEGATIVE_X,
                gl.TEXTURE_CUBE_MAP_POSITIVE_Y,
                gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,
                gl.TEXTURE_CUBE_MAP_POSITIVE_Z,
                gl.TEXTURE_CUBE_MAP_NEGATIVE_Z,
            ];
            fourSize || gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
            this._engine._bindTexture(texture.target, texture.resource);
            let mipmapWidth = width;
            let mipmapHeight = height;
            let dataOffset = ktxInfo.headerOffset + ktxInfo.bytesOfKeyValueData;
            let memory = 0;
            for (let index = 0; index < ktxInfo.mipmapCount; index++) {
                let imageSize = new Int32Array(source, dataOffset, 1)[0];
                dataOffset += 4;
                for (let face = 0; face < 6; face++) {
                    let target = cubeFace[face];
                    if (compressed) {
                        let sourceData = new Uint8Array(source, dataOffset, imageSize);
                        gl.compressedTexImage2D(target, index, internalFormat, mipmapWidth, mipmapHeight, 0, sourceData);
                        memory += sourceData.byteLength;
                    }
                    else {
                        let pixelParams = this.getFormatPixelsParams(ktxInfo.format);
                        let typedSize = imageSize / pixelParams.typedSize;
                        let sourceData = new pixelParams.dataTypedCons(source, dataOffset, typedSize);
                        gl.texImage2D(target, index, internalFormat, mipmapWidth, mipmapHeight, 0, format, type, sourceData);
                        memory += sourceData.byteLength;
                    }
                    dataOffset += imageSize;
                    dataOffset += 3 - ((imageSize + 3) % 4);
                }
                mipmapWidth = Math.max(1, mipmapWidth * 0.5);
                mipmapHeight = Math.max(1, mipmapHeight * 0.5);
            }
            this._engine._bindTexture(texture.target, null);
            texture.gpuMemory = memory;
            fourSize || gl.pixelStorei(gl.UNPACK_ALIGNMENT, 4);
        }
        setTextureCompareMode(texture, compareMode) {
            return exports.TextureCompareMode.None;
        }
        bindRenderTarget(renderTarget, faceIndex = 0) {
            let gl = this._gl;
            let framebuffer = renderTarget._framebuffer;
            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
            if (renderTarget._isCube) {
                let texture = renderTarget._textures[0];
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, texture.resource, 0);
            }
        }
        bindoutScreenTarget() {
            let gl = this._gl;
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        }
        unbindRenderTarget(renderTarget) {
            let gl = renderTarget._gl;
            if (renderTarget._generateMipmap) {
                renderTarget._textures.forEach(tex => {
                    let target = tex.target;
                    this._engine._bindTexture(target, tex.resource);
                    gl.generateMipmap(target);
                    this._engine._bindTexture(target, null);
                });
            }
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        }
        createRenderTextureInternal(dimension, width, height, format, generateMipmap, sRGB) {
            let useSRGBExt = false;
            generateMipmap = generateMipmap && this.supportGenerateMipmap(format);
            let gammaCorrection = 1.0;
            if (sRGB) {
                gammaCorrection = 2.2;
            }
            let target = this.getTarget(dimension);
            let internalTex = new WebGLInternalTex(this._engine, target, width, height, dimension, generateMipmap, useSRGBExt, gammaCorrection);
            let glParam = this.glRenderTextureParam(format, useSRGBExt);
            internalTex.internalFormat = glParam.internalFormat;
            internalTex.format = glParam.format;
            internalTex.type = glParam.type;
            let internalFormat = internalTex.internalFormat;
            let glFormat = internalTex.format;
            let type = internalTex.type;
            let gl = internalTex._gl;
            this._engine._bindTexture(internalTex.target, internalTex.resource);
            gl.texImage2D(target, 0, internalFormat, width, height, 0, glFormat, type, null);
            this._engine._bindTexture(internalTex.target, null);
            if (format == exports.RenderTargetFormat.DEPTH_16 || format == exports.RenderTargetFormat.DEPTH_32 || format == exports.RenderTargetFormat.DEPTHSTENCIL_24_8) {
                internalTex.filterMode = exports.FilterMode.Point;
            }
            return internalTex;
        }
        createRenderTextureCubeInternal(dimension, size, format, generateMipmap, sRGB) {
            let useSRGBExt = false;
            generateMipmap = generateMipmap && this.supportGenerateMipmap(format);
            let gammaCorrection = 1.0;
            if (sRGB) {
                gammaCorrection = 2.2;
            }
            let target = this.getTarget(dimension);
            let internalTex = new WebGLInternalTex(this._engine, target, size, size, dimension, generateMipmap, useSRGBExt, gammaCorrection);
            let glParam = this.glRenderTextureParam(format, useSRGBExt);
            internalTex.internalFormat = glParam.internalFormat;
            internalTex.format = glParam.format;
            internalTex.type = glParam.type;
            let internalFormat = internalTex.internalFormat;
            let glFormat = internalTex.format;
            let type = internalTex.type;
            let gl = internalTex._gl;
            const cubeFace = [
                gl.TEXTURE_CUBE_MAP_POSITIVE_Z,
                gl.TEXTURE_CUBE_MAP_NEGATIVE_Z,
                gl.TEXTURE_CUBE_MAP_POSITIVE_X,
                gl.TEXTURE_CUBE_MAP_NEGATIVE_X,
                gl.TEXTURE_CUBE_MAP_POSITIVE_Y,
                gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,
            ];
            this._engine._bindTexture(internalTex.target, internalTex.resource);
            for (let index = 0; index < cubeFace.length; index++) {
                let target = cubeFace[index];
                gl.texImage2D(target, 0, internalFormat, size, size, 0, glFormat, type, null);
            }
            this._engine._bindTexture(internalTex.target, null);
            if (format == exports.RenderTargetFormat.DEPTH_16 || format == exports.RenderTargetFormat.DEPTH_32 || format == exports.RenderTargetFormat.DEPTHSTENCIL_24_8) {
                internalTex.filterMode = exports.FilterMode.Point;
            }
            return internalTex;
        }
        createRenderTargetInternal(width, height, colorFormat, depthStencilFormat, generateMipmap, sRGB, multiSamples) {
            multiSamples = 1;
            let texture = this.createRenderTextureInternal(exports.TextureDimension.Tex2D, width, height, colorFormat, generateMipmap, sRGB);
            let renderTarget = new WebGLInternalRT(this._engine, colorFormat, depthStencilFormat, false, texture.mipmap, multiSamples);
            renderTarget.gpuMemory = this.getGLRTTexMemory(width, height, colorFormat, depthStencilFormat, generateMipmap, multiSamples, false);
            renderTarget.colorFormat = colorFormat;
            renderTarget.depthStencilFormat = depthStencilFormat;
            renderTarget._textures.push(texture);
            let framebuffer = renderTarget._framebuffer;
            let gl = renderTarget._gl;
            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
            let colorAttachment = this.glRenderTargetAttachment(colorFormat);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, colorAttachment, gl.TEXTURE_2D, texture.resource, 0);
            let depthBufferParam = this.glRenderBufferParam(depthStencilFormat, false);
            if (depthBufferParam) {
                let depthbuffer = this.createRenderbuffer(width, height, depthBufferParam.internalFormat, renderTarget._samples);
                renderTarget._depthbuffer = depthbuffer;
                gl.framebufferRenderbuffer(gl.FRAMEBUFFER, depthBufferParam.attachment, gl.RENDERBUFFER, depthbuffer);
            }
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            return renderTarget;
        }
        createRenderTargetCubeInternal(size, colorFormat, depthStencilFormat, generateMipmap, sRGB, multiSamples) {
            multiSamples = 1;
            let texture = this.createRenderTextureCubeInternal(exports.TextureDimension.Cube, size, colorFormat, generateMipmap, sRGB);
            let renderTarget = new WebGLInternalRT(this._engine, colorFormat, depthStencilFormat, true, texture.mipmap, multiSamples);
            renderTarget.gpuMemory = this.getGLRTTexMemory(size, size, colorFormat, depthStencilFormat, generateMipmap, multiSamples, true);
            renderTarget._textures.push(texture);
            let framebuffer = renderTarget._framebuffer;
            let gl = renderTarget._gl;
            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
            let depthBufferParam = this.glRenderBufferParam(depthStencilFormat, false);
            if (depthBufferParam) {
                let depthbuffer = this.createRenderbuffer(size, size, depthBufferParam.internalFormat, renderTarget._samples);
                renderTarget._depthbuffer = depthbuffer;
                gl.framebufferRenderbuffer(gl.FRAMEBUFFER, depthBufferParam.attachment, gl.RENDERBUFFER, depthbuffer);
            }
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            return renderTarget;
        }
        createRenderbuffer(width, height, internalFormat, samples) {
            let gl = this._gl;
            let renderbuffer = gl.createRenderbuffer();
            gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);
            gl.renderbufferStorage(gl.RENDERBUFFER, internalFormat, width, height);
            gl.bindRenderbuffer(gl.RENDERBUFFER, null);
            return renderbuffer;
        }
        setupRendertargetTextureAttachment(renderTarget, texture) {
            let gl = renderTarget._gl;
            renderTarget._depthTexture = texture;
            let depthbuffer = renderTarget._depthbuffer;
            depthbuffer && gl.deleteRenderbuffer(depthbuffer);
            renderTarget._depthbuffer = null;
            let attachment = this.glRenderTargetAttachment(renderTarget.depthStencilFormat);
            let framebuffer = renderTarget._framebuffer;
            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, gl.TEXTURE_2D, texture.resource, 0);
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        }
        readRenderTargetPixelData(renderTarget, xOffset, yOffset, width, height, out) {
            let gl = renderTarget._gl;
            this.bindRenderTarget(renderTarget);
            let frameState = gl.checkFramebufferStatus(gl.FRAMEBUFFER) == gl.FRAMEBUFFER_COMPLETE;
            if (!frameState) {
                this.unbindRenderTarget(renderTarget);
                return null;
            }
            switch (renderTarget.colorFormat) {
                case exports.RenderTargetFormat.R8G8B8:
                    gl.readPixels(xOffset, yOffset, width, height, gl.RGB, gl.UNSIGNED_BYTE, out);
                    break;
                case exports.RenderTargetFormat.R8G8B8A8:
                    gl.readPixels(xOffset, yOffset, width, height, gl.RGBA, gl.UNSIGNED_BYTE, out);
                    break;
                case exports.RenderTargetFormat.R16G16B16:
                    gl.readPixels(xOffset, yOffset, width, height, gl.RGB, gl.FLOAT, out);
                    break;
                case exports.RenderTargetFormat.R16G16B16A16:
                    gl.readPixels(xOffset, yOffset, width, height, gl.RGBA, gl.FLOAT, out);
                    break;
                case exports.RenderTargetFormat.R32G32B32:
                    gl.readPixels(xOffset, yOffset, width, height, gl.RGB, gl.FLOAT, out);
                    break;
                case exports.RenderTargetFormat.R32G32B32A32:
                    gl.readPixels(xOffset, yOffset, width, height, gl.RGBA, gl.FLOAT, out);
                    break;
            }
            this.unbindRenderTarget(renderTarget);
            return out;
        }
        updateVideoTexture(texture, video, premultiplyAlpha, invertY) {
            let gl = texture._gl;
            let target = texture.target;
            let internalFormat = texture.internalFormat;
            let format = texture.format;
            let type = texture.type;
            texture.width;
            texture.height;
            premultiplyAlpha && gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
            invertY && gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
            gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
            this._engine._bindTexture(texture.target, texture.resource);
            gl.texImage2D(target, 0, internalFormat, format, type, video);
            this._engine._bindTexture(texture.target, null);
            premultiplyAlpha && gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
            invertY && gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
            gl.pixelStorei(gl.UNPACK_ALIGNMENT, 4);
        }
        getRenderTextureData(internalTex, x, y, width, height) {
            if (internalTex.colorFormat == exports.RenderTargetFormat.None)
                return null;
            let gl = internalTex._gl;
            gl.bindFramebuffer(gl.FRAMEBUFFER, internalTex._framebuffer);
            var canRead = (gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE);
            if (!canRead) {
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                return null;
            }
            let size = width * height;
            let format, type;
            var pixels;
            switch (internalTex.colorFormat) {
                case exports.RenderTargetFormat.R8G8B8:
                    format = gl.RGB;
                    type = gl.UNSIGNED_BYTE;
                    pixels = new Uint8Array(size * 3);
                    break;
                case exports.RenderTargetFormat.R8G8B8A8:
                    format = gl.RGBA;
                    type = gl.UNSIGNED_BYTE;
                    pixels = new Uint8Array(size * 4);
                    break;
                case exports.RenderTargetFormat.R16G16B16:
                    format = gl.RGB;
                    type = gl.UNSIGNED_SHORT_4_4_4_4;
                    pixels = new Uint16Array(size * 3);
                    break;
                case exports.RenderTargetFormat.R16G16B16A16:
                    format = gl.RGBA;
                    type = gl.UNSIGNED_SHORT_4_4_4_4;
                    pixels = new Uint16Array(size * 4);
                    break;
                case exports.RenderTargetFormat.R32G32B32:
                    format = gl.RGB;
                    type = gl.FLOAT;
                    pixels = new Float32Array(size * 3);
                    break;
                case exports.RenderTargetFormat.R32G32B32A32:
                    format = gl.RGBA;
                    type = gl.FLOAT;
                    pixels = new Float32Array(size * 4);
                    break;
                default:
                    return null;
            }
            gl.readPixels(x, y, width, height, format, type, pixels);
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            return pixels;
        }
    }

    class GL2TextureContext extends GLTextureContext {
        constructor(engine) {
            super(engine);
        }
        getTarget(dimension) {
            let target = -1;
            switch (dimension) {
                case exports.TextureDimension.Cube:
                    target = this._gl.TEXTURE_CUBE_MAP;
                    break;
                case exports.TextureDimension.Tex2D:
                    target = this._gl.TEXTURE_2D;
                    break;
                case exports.TextureDimension.Texture2DArray:
                    target = this._gl.TEXTURE_2D_ARRAY;
                    break;
                case exports.TextureDimension.Tex3D:
                    target = this._gl.TEXTURE_3D;
                    break;
                default:
                    throw "Unknow Texture Target";
            }
            return target;
        }
        glTextureParam(format, useSRGB) {
            let gl = this._gl;
            this._glParam.internalFormat = null;
            this._glParam.format = null;
            this._glParam.type = null;
            switch (format) {
                case exports.TextureFormat.R8G8B8:
                    this._glParam.internalFormat = useSRGB ? gl.SRGB8 : gl.RGB8;
                    this._glParam.format = gl.RGB;
                    this._glParam.type = gl.UNSIGNED_BYTE;
                    break;
                case exports.TextureFormat.R8G8B8A8:
                    this._glParam.internalFormat = useSRGB ? gl.SRGB8_ALPHA8 : gl.RGBA8;
                    this._glParam.format = gl.RGBA;
                    this._glParam.type = gl.UNSIGNED_BYTE;
                    break;
                case exports.TextureFormat.R5G6B5:
                    this._glParam.internalFormat = gl.RGB565;
                    this._glParam.format = gl.RGB;
                    this._glParam.type = gl.UNSIGNED_SHORT_5_6_5;
                    break;
                case exports.TextureFormat.R32G32B32A32:
                    this._glParam.internalFormat = gl.RGBA32F;
                    this._glParam.format = gl.RGBA;
                    this._glParam.type = gl.FLOAT;
                    break;
                case exports.TextureFormat.R32G32B32:
                    this._glParam.internalFormat = gl.RGB32F;
                    this._glParam.format = gl.RGB;
                    this._glParam.type = gl.FLOAT;
                    break;
                case exports.TextureFormat.R16G16B16:
                    this._glParam.internalFormat = gl.RGB16F;
                    this._glParam.format = gl.RGB;
                    this._glParam.type = gl.HALF_FLOAT;
                    break;
                case exports.TextureFormat.R16G16B16A16:
                    this._glParam.internalFormat = gl.RGBA16F;
                    this._glParam.format = gl.RGBA;
                    this._glParam.type = gl.HALF_FLOAT;
                    break;
                case exports.TextureFormat.DXT1:
                    this._glParam.internalFormat = useSRGB ? this._compressdTextureS3tc_srgb.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT : this._compressedTextureS3tc.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                    break;
                case exports.TextureFormat.DXT3:
                    this._glParam.internalFormat = useSRGB ? this._compressdTextureS3tc_srgb.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT : this._compressedTextureS3tc.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                    break;
                case exports.TextureFormat.DXT5:
                    this._glParam.internalFormat = useSRGB ? this._compressdTextureS3tc_srgb.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT : this._compressedTextureS3tc.COMPRESSED_RGBA_S3TC_DXT5_EXT;
                    break;
                case exports.TextureFormat.ETC1RGB:
                    this._glParam.internalFormat = this._compressedTextureEtc1.COMPRESSED_RGB_ETC1_WEBGL;
                    break;
                case exports.TextureFormat.ETC2RGBA:
                    this._glParam.internalFormat = this._compressedTextureETC.COMPRESSED_RGBA8_ETC2_EAC;
                    break;
                case exports.TextureFormat.ETC2RGB:
                    this._glParam.internalFormat = this._compressedTextureETC.COMPRESSED_RGB8_ETC2;
                    break;
                case exports.TextureFormat.ETC2SRGB:
                    this._glParam.internalFormat = this._compressedTextureETC.COMPRESSED_SRGB8_ETC2;
                    break;
                case exports.TextureFormat.ETC2SRGB_Alpha8:
                    this._glParam.internalFormat = this._compressedTextureETC.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC;
                    break;
                case exports.TextureFormat.ASTC4x4:
                    this._glParam.internalFormat = this._compressedTextureASTC.COMPRESSED_RGBA_ASTC_4x4_KHR;
                    break;
                case exports.TextureFormat.ASTC6x6:
                    this._glParam.internalFormat = this._compressedTextureASTC.COMPRESSED_RGBA_ASTC_6x6_KHR;
                    break;
                case exports.TextureFormat.ASTC8x8:
                    this._glParam.internalFormat = this._compressedTextureASTC.COMPRESSED_RGBA_ASTC_8x8_KHR;
                    break;
                case exports.TextureFormat.ASTC10x10:
                    this._glParam.internalFormat = this._compressedTextureASTC.COMPRESSED_RGBA_ASTC_10x10_KHR;
                    break;
                case exports.TextureFormat.ASTC12x12:
                    this._glParam.internalFormat = this._compressedTextureASTC.COMPRESSED_RGBA_ASTC_12x12_KHR;
                    break;
                case exports.TextureFormat.ASTC4x4SRGB:
                    this._glParam.internalFormat = this._compressedTextureASTC.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR;
                    break;
                case exports.TextureFormat.ASTC6x6SRGB:
                    this._glParam.internalFormat = this._compressedTextureASTC.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR;
                    break;
                case exports.TextureFormat.ASTC8x8SRGB:
                    this._glParam.internalFormat = this._compressedTextureASTC.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR;
                    break;
                case exports.TextureFormat.ASTC10x10SRGB:
                    this._glParam.internalFormat = this._compressedTextureASTC.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR;
                    break;
                case exports.TextureFormat.ASTC12x12SRGB:
                    this._glParam.internalFormat = this._compressedTextureASTC.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR;
                    break;
                default:
                    throw "Unknown Texture Format.";
            }
            return this._glParam;
        }
        glRenderBufferParam(format, useSRGB) {
            let gl = this._gl;
            switch (format) {
                case exports.RenderTargetFormat.DEPTH_16:
                    return { internalFormat: gl.DEPTH_COMPONENT16, attachment: gl.DEPTH_ATTACHMENT };
                case exports.RenderTargetFormat.DEPTHSTENCIL_24_8:
                    return { internalFormat: gl.DEPTH24_STENCIL8, attachment: gl.DEPTH_STENCIL_ATTACHMENT };
                case exports.RenderTargetFormat.DEPTH_32:
                    return { internalFormat: gl.DEPTH_COMPONENT32F, attachment: gl.DEPTH_ATTACHMENT };
                case exports.RenderTargetFormat.STENCIL_8:
                    return { internalFormat: gl.STENCIL_INDEX8, attachment: gl.STENCIL_ATTACHMENT };
                case exports.RenderTargetFormat.R8G8B8:
                    return { internalFormat: useSRGB ? gl.SRGB8 : gl.RGB8, attachment: gl.COLOR_ATTACHMENT0 };
                case exports.RenderTargetFormat.R8G8B8A8:
                    return { internalFormat: useSRGB ? gl.SRGB8_ALPHA8 : gl.RGBA8, attachment: gl.COLOR_ATTACHMENT0 };
                case exports.RenderTargetFormat.R16G16B16:
                    return { internalFormat: gl.RGB16F, attachment: gl.COLOR_ATTACHMENT0 };
                case exports.RenderTargetFormat.R16G16B16A16:
                    return { internalFormat: gl.RGBA16F, attachment: gl.COLOR_ATTACHMENT0 };
                case exports.RenderTargetFormat.R32G32B32:
                    return { internalFormat: gl.RGB32F, attachment: gl.COLOR_ATTACHMENT0 };
                case exports.RenderTargetFormat.R32G32B32A32:
                    return { internalFormat: gl.RGBA32F, attachment: gl.COLOR_ATTACHMENT0 };
                default:
                    return null;
            }
        }
        glRenderTextureParam(format, useSRGB) {
            let gl = this._gl;
            this._glParam.internalFormat = null;
            this._glParam.format = null;
            this._glParam.type = null;
            switch (format) {
                case exports.RenderTargetFormat.R8G8B8:
                    this._glParam.internalFormat = useSRGB ? gl.SRGB8 : gl.RGB8;
                    this._glParam.format = gl.RGB;
                    this._glParam.type = gl.UNSIGNED_BYTE;
                    break;
                case exports.RenderTargetFormat.R8G8B8A8:
                    this._glParam.internalFormat = useSRGB ? gl.SRGB8_ALPHA8 : gl.RGBA8;
                    this._glParam.format = gl.RGBA;
                    this._glParam.type = gl.UNSIGNED_BYTE;
                    break;
                case exports.RenderTargetFormat.R16G16B16:
                    this._glParam.internalFormat = gl.RGB16F;
                    this._glParam.format = gl.RGB;
                    this._glParam.type = gl.HALF_FLOAT;
                    break;
                case exports.RenderTargetFormat.R16G16B16A16:
                    this._glParam.internalFormat = gl.RGBA16F;
                    this._glParam.format = gl.RGBA;
                    this._glParam.type = gl.HALF_FLOAT;
                    break;
                case exports.RenderTargetFormat.R32G32B32:
                    this._glParam.internalFormat = gl.RGB32F;
                    this._glParam.format = gl.RGB;
                    this._glParam.type = gl.FLOAT;
                    break;
                case exports.RenderTargetFormat.R32G32B32A32:
                    this._glParam.internalFormat = gl.RGBA32F;
                    this._glParam.format = gl.RGBA;
                    this._glParam.type = gl.FLOAT;
                    break;
                case exports.RenderTargetFormat.DEPTH_16:
                    this._glParam.internalFormat = gl.DEPTH_COMPONENT16;
                    this._glParam.format = gl.DEPTH_COMPONENT;
                    this._glParam.type = gl.UNSIGNED_INT;
                    break;
                case exports.RenderTargetFormat.DEPTHSTENCIL_24_8:
                    this._glParam.internalFormat = gl.DEPTH24_STENCIL8;
                    this._glParam.format = this._glParam.internalFormat;
                    this._glParam.type = gl.UNSIGNED_INT_24_8;
                    break;
                case exports.RenderTargetFormat.DEPTH_32:
                    this._glParam.internalFormat = gl.DEPTH_COMPONENT32F;
                    this._glParam.format = this._glParam.internalFormat;
                    this._glParam.type = gl.UNSIGNED_INT;
                    break;
                case exports.RenderTargetFormat.STENCIL_8:
                    break;
                default:
                    throw "depht texture format wrong.";
            }
            return this._glParam;
        }
        getGLtexMemory(tex) {
            let gl = this._gl;
            let channels = 0;
            let singlebyte = 0;
            let bytelength = 0;
            switch (tex.internalFormat) {
                case gl.SRGB8:
                case gl.RGB8:
                case gl.RGB565:
                case gl.RGB32F:
                case gl.RGB16F:
                    channels = 3;
                    break;
                case gl.SRGB8_ALPHA8:
                case gl.RGBA8:
                case gl.RGBA32F:
                case gl.RGBA16F:
                    channels = 4;
                    break;
                default:
                    channels = 0;
                    break;
            }
            switch (tex.type) {
                case gl.UNSIGNED_BYTE:
                    singlebyte = 1;
                    break;
                case gl.UNSIGNED_SHORT_5_6_5:
                    singlebyte = 2 / 3;
                    break;
                case gl.FLOAT:
                    singlebyte = 4;
                    break;
                case gl.HALF_FLOAT:
                    singlebyte = 2;
                    break;
                default:
                    singlebyte = 0;
                    break;
            }
            bytelength = channels * singlebyte * tex.width * tex.height;
            if (tex.mipmap) {
                bytelength *= 1.333;
            }
            if (tex.target == gl.TEXTURE_CUBE_MAP)
                bytelength *= 6;
            else if (tex.target == gl.TEXTURE_2D)
                bytelength *= 1;
            return bytelength;
        }
        supportSRGB(format, mipmap) {
            switch (format) {
                case exports.TextureFormat.R8G8B8:
                    return this._engine.getCapable(exports.RenderCapable.Texture_SRGB) && !mipmap;
                case exports.TextureFormat.R8G8B8A8:
                    return this._engine.getCapable(exports.RenderCapable.Texture_SRGB);
                case exports.TextureFormat.DXT1:
                case exports.TextureFormat.DXT3:
                case exports.TextureFormat.DXT5:
                    return this._engine.getCapable(exports.RenderCapable.COMPRESS_TEXTURE_S3TC_SRGB) && !mipmap;
                default:
                    return false;
            }
        }
        setTextureImageData(texture, source, premultiplyAlpha, invertY) {
            if (texture.width != source.width || texture.height != source.height) {
                console.warn("setTextureImageData: size not match");
            }
            let target = texture.target;
            let internalFormat = texture.internalFormat;
            let format = texture.format;
            let type = texture.type;
            let width = texture.width;
            let height = texture.height;
            let mipmapCount = texture.mipmapCount;
            let gl = this._gl;
            premultiplyAlpha && gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
            invertY && gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
            this._engine._bindTexture(texture.target, texture.resource);
            gl.texStorage2D(target, mipmapCount, internalFormat, width, height);
            gl.texSubImage2D(target, 0, 0, 0, width, height, format, type, source);
            texture.gpuMemory = this.getGLtexMemory(texture);
            if (texture.mipmap) {
                gl.generateMipmap(texture.target);
            }
            this._engine._bindTexture(texture.target, null);
            premultiplyAlpha && gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
            invertY && gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
        }
        setTexturebySubImageData(texture, source, x, y, premultiplyAlpha, invertY) {
            let target = texture.target;
            let internalFormat = texture.internalFormat;
            let format = texture.format;
            let type = texture.type;
            texture.width;
            texture.height;
            let mipmapCount = texture.mipmapCount;
            let gl = this._gl;
            premultiplyAlpha && gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
            invertY && gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
            this._engine._bindTexture(texture.target, texture.resource);
            gl.texStorage2D(target, mipmapCount, internalFormat, source.width, source.height);
            gl.texSubImage2D(target, 0, x, y, source.width, source.height, format, type, source);
            texture.gpuMemory = this.getGLtexMemory(texture);
            if (texture.mipmap) {
                gl.generateMipmap(texture.target);
            }
            this._engine._bindTexture(texture.target, null);
            premultiplyAlpha && gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
            invertY && gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
        }
        setTexturePixelsData(texture, source, premultiplyAlpha, invertY) {
            let target = texture.target;
            let internalFormat = texture.internalFormat;
            let format = texture.format;
            let type = texture.type;
            let width = texture.width;
            let height = texture.height;
            let mipmapCount = texture.mipmapCount;
            let fourSize = width % 4 == 0 && height % 4 == 0;
            let gl = this._gl;
            premultiplyAlpha && gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
            invertY && gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
            fourSize || gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
            this._engine._bindTexture(texture.target, texture.resource);
            gl.texStorage2D(target, mipmapCount, internalFormat, width, height);
            texture.gpuMemory = this.getGLtexMemory(texture);
            if (source) {
                gl.texSubImage2D(target, 0, 0, 0, width, height, format, type, source);
                if (texture.mipmap) {
                    gl.generateMipmap(texture.target);
                }
            }
            this._engine._bindTexture(texture.target, null);
            premultiplyAlpha && gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
            invertY && gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
            fourSize || gl.pixelStorei(gl.UNPACK_ALIGNMENT, 4);
        }
        setTextureHDRData(texture, hdrInfo) {
            let sourceData = hdrInfo.readScanLine();
            this.setTexturePixelsData(texture, sourceData, false, false);
        }
        setTextureKTXData(texture, ktxInfo) {
            let target = texture.target;
            let internalFormat = texture.internalFormat;
            let format = texture.format;
            let type = texture.type;
            texture.mipmapCount;
            let width = texture.width;
            let height = texture.height;
            let source = ktxInfo.source;
            let compressed = ktxInfo.compress;
            let fourSize = width % 4 == 0 && height % 4 == 0;
            let gl = this._gl;
            fourSize || gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
            this._engine._bindTexture(texture.target, texture.resource);
            if (!compressed) {
                gl.texStorage2D(target, ktxInfo.mipmapCount, internalFormat, width, height);
            }
            let mipmapWidth = width;
            let mipmapHeight = height;
            let dataOffset = ktxInfo.headerOffset + ktxInfo.bytesOfKeyValueData;
            let memory = 0;
            for (let index = 0; index < ktxInfo.mipmapCount; index++) {
                let imageSize = new Int32Array(source, dataOffset, 1)[0];
                dataOffset += 4;
                if (compressed) {
                    let sourceData = new Uint8Array(source, dataOffset, imageSize);
                    gl.compressedTexImage2D(target, index, internalFormat, mipmapWidth, mipmapHeight, 0, sourceData);
                    memory += sourceData.length;
                }
                else {
                    let pixelParams = this.getFormatPixelsParams(ktxInfo.format);
                    let typedSize = imageSize / pixelParams.typedSize;
                    let sourceData = new pixelParams.dataTypedCons(source, dataOffset, typedSize);
                    gl.texSubImage2D(target, index, 0, 0, mipmapWidth, mipmapHeight, format, type, sourceData);
                    memory += sourceData.length;
                }
                dataOffset += imageSize;
                dataOffset += 3 - ((imageSize + 3) % 4);
                mipmapWidth = Math.max(1, mipmapWidth * 0.5);
                mipmapHeight = Math.max(1, mipmapHeight * 0.5);
            }
            this._engine._bindTexture(texture.target, null);
            texture.gpuMemory = memory;
            fourSize || gl.pixelStorei(gl.UNPACK_ALIGNMENT, 4);
        }
        setCubeImageData(texture, sources, premultiplyAlpha, invertY) {
            let gl = this._gl;
            const cubeFace = [
                gl.TEXTURE_CUBE_MAP_POSITIVE_Z,
                gl.TEXTURE_CUBE_MAP_NEGATIVE_Z,
                gl.TEXTURE_CUBE_MAP_POSITIVE_X,
                gl.TEXTURE_CUBE_MAP_NEGATIVE_X,
                gl.TEXTURE_CUBE_MAP_POSITIVE_Y,
                gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,
            ];
            let target = texture.target;
            let internalFormat = texture.internalFormat;
            let format = texture.format;
            let type = texture.type;
            let width = texture.width;
            let height = texture.height;
            let mipmapCount = texture.mipmapCount;
            premultiplyAlpha && gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
            invertY && gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
            this._engine._bindTexture(texture.target, texture.resource);
            gl.texStorage2D(target, mipmapCount, internalFormat, width, height);
            texture.gpuMemory = this.getGLtexMemory(texture);
            for (let index = 0; index < cubeFace.length; index++) {
                let t = cubeFace[index];
                gl.texSubImage2D(t, 0, 0, 0, format, type, sources[index]);
            }
            if (texture.mipmap) {
                gl.generateMipmap(texture.target);
            }
            this._engine._bindTexture(texture.target, null);
            premultiplyAlpha && gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
            invertY && gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
        }
        setCubePixelsData(texture, source, premultiplyAlpha, invertY) {
            let gl = this._gl;
            const cubeFace = [
                gl.TEXTURE_CUBE_MAP_POSITIVE_Z,
                gl.TEXTURE_CUBE_MAP_NEGATIVE_Z,
                gl.TEXTURE_CUBE_MAP_POSITIVE_X,
                gl.TEXTURE_CUBE_MAP_NEGATIVE_X,
                gl.TEXTURE_CUBE_MAP_POSITIVE_Y,
                gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,
            ];
            let target = texture.target;
            let internalFormat = texture.internalFormat;
            let format = texture.format;
            let type = texture.type;
            let width = texture.width;
            let height = texture.height;
            let mipmapCount = texture.mipmapCount;
            let fourSize = width % 4 == 0;
            premultiplyAlpha && gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
            invertY && gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
            fourSize || gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
            this._engine._bindTexture(texture.target, texture.resource);
            gl.texStorage2D(target, mipmapCount, internalFormat, width, height);
            if (source) {
                for (let index = 0; index < cubeFace.length; index++) {
                    let t = cubeFace[index];
                    gl.texSubImage2D(t, 0, 0, 0, width, height, format, type, source[index]);
                }
                if (texture.mipmap) {
                    gl.generateMipmap(texture.target);
                }
            }
            this._engine._bindTexture(texture.target, null);
            texture.gpuMemory = this.getGLtexMemory(texture);
            premultiplyAlpha && gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
            invertY && gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
            fourSize || gl.pixelStorei(gl.UNPACK_ALIGNMENT, 4);
        }
        setCubeKTXData(texture, ktxInfo) {
            let gl = this._gl;
            const cubeFace = [
                gl.TEXTURE_CUBE_MAP_POSITIVE_X,
                gl.TEXTURE_CUBE_MAP_NEGATIVE_X,
                gl.TEXTURE_CUBE_MAP_POSITIVE_Y,
                gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,
                gl.TEXTURE_CUBE_MAP_POSITIVE_Z,
                gl.TEXTURE_CUBE_MAP_NEGATIVE_Z,
            ];
            let target = texture.target;
            let internalFormat = texture.internalFormat;
            let format = texture.format;
            let type = texture.type;
            texture.mipmapCount;
            let width = texture.width;
            let height = texture.height;
            let source = ktxInfo.source;
            let compressed = ktxInfo.compress;
            let mipmapWidth = width;
            let mipmapHeight = height;
            let dataOffset = ktxInfo.headerOffset + ktxInfo.bytesOfKeyValueData;
            let fourSize = width % 4 == 0 && height % 4 == 0;
            fourSize || gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
            this._engine._bindTexture(texture.target, texture.resource);
            if (!compressed) {
                gl.texStorage2D(target, ktxInfo.mipmapCount, internalFormat, width, height);
            }
            let memory = 0;
            for (let index = 0; index < ktxInfo.mipmapCount; index++) {
                let imageSize = new Int32Array(source, dataOffset, 1)[0];
                dataOffset += 4;
                for (let face = 0; face < 6; face++) {
                    let t = cubeFace[face];
                    if (compressed) {
                        let sourceData = new Uint8Array(source, dataOffset, imageSize);
                        gl.compressedTexImage2D(t, index, internalFormat, mipmapWidth, mipmapHeight, 0, sourceData);
                        memory += sourceData.byteLength;
                    }
                    else {
                        let pixelParams = this.getFormatPixelsParams(ktxInfo.format);
                        let typedSize = imageSize / pixelParams.typedSize;
                        let sourceData = new pixelParams.dataTypedCons(source, dataOffset, typedSize);
                        gl.texSubImage2D(t, index, 0, 0, mipmapWidth, mipmapHeight, format, type, sourceData);
                        memory += sourceData.byteLength;
                    }
                    dataOffset += imageSize;
                    dataOffset += 3 - ((imageSize + 3) % 4);
                }
                mipmapWidth = Math.max(1, mipmapWidth * 0.5);
                mipmapHeight = Math.max(1, mipmapHeight * 0.5);
            }
            texture.gpuMemory = memory;
            this._engine._bindTexture(texture.target, null);
            fourSize || gl.pixelStorei(gl.UNPACK_ALIGNMENT, 4);
        }
        getCubeKTXRGBMData(texture, ktxInfo) {
            let gl = this._gl;
            const cubeFace = [
                gl.TEXTURE_CUBE_MAP_POSITIVE_X,
                gl.TEXTURE_CUBE_MAP_NEGATIVE_X,
                gl.TEXTURE_CUBE_MAP_POSITIVE_Y,
                gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,
                gl.TEXTURE_CUBE_MAP_POSITIVE_Z,
                gl.TEXTURE_CUBE_MAP_NEGATIVE_Z,
            ];
            let target = texture.target;
            let internalFormat = texture.internalFormat;
            let format = texture.format;
            let type = texture.type;
            texture.mipmapCount;
            let width = texture.width;
            let height = texture.height;
            let source = ktxInfo.source;
            let compressed = ktxInfo.compress;
            let mipmapWidth = width;
            let mipmapHeight = height;
            let dataOffset = ktxInfo.headerOffset + ktxInfo.bytesOfKeyValueData;
            let fourSize = width % 4 == 0 && height % 4 == 0;
            fourSize || gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
            this._engine._bindTexture(texture.target, texture.resource);
            if (!compressed) {
                gl.texStorage2D(target, ktxInfo.mipmapCount, internalFormat, width, height);
            }
            let memory = 0;
            for (let index = 0; index < ktxInfo.mipmapCount; index++) {
                let imageSize = new Int32Array(source, dataOffset, 1)[0];
                dataOffset += 4;
                for (let face = 0; face < 6; face++) {
                    let t = cubeFace[face];
                    let pixelParams = this.getFormatPixelsParams(ktxInfo.format);
                    let typedSize = imageSize / pixelParams.typedSize;
                    let sourceData = new pixelParams.dataTypedCons(source, dataOffset, typedSize);
                    gl.texSubImage2D(t, index, 0, 0, mipmapWidth, mipmapHeight, format, type, sourceData);
                    memory += sourceData.byteLength;
                }
                dataOffset += imageSize;
                dataOffset += 3 - ((imageSize + 3) % 4);
            }
            mipmapWidth = Math.max(1, mipmapWidth * 0.5);
            mipmapHeight = Math.max(1, mipmapHeight * 0.5);
            texture.gpuMemory = memory;
            this._engine._bindTexture(texture.target, null);
            fourSize || gl.pixelStorei(gl.UNPACK_ALIGNMENT, 4);
        }
        setTextureCompareMode(texture, compareMode) {
            let gl = this._gl;
            switch (compareMode) {
                case exports.TextureCompareMode.LEQUAL:
                    texture._setTexParameteri(gl.TEXTURE_COMPARE_FUNC, gl.LEQUAL);
                    texture._setTexParameteri(gl.TEXTURE_COMPARE_MODE, gl.COMPARE_REF_TO_TEXTURE);
                    break;
                case exports.TextureCompareMode.GEQUAL:
                    texture._setTexParameteri(gl.TEXTURE_COMPARE_FUNC, gl.GEQUAL);
                    texture._setTexParameteri(gl.TEXTURE_COMPARE_MODE, gl.COMPARE_REF_TO_TEXTURE);
                    break;
                case exports.TextureCompareMode.LESS:
                    texture._setTexParameteri(gl.TEXTURE_COMPARE_FUNC, gl.LESS);
                    texture._setTexParameteri(gl.TEXTURE_COMPARE_MODE, gl.COMPARE_REF_TO_TEXTURE);
                    break;
                case exports.TextureCompareMode.GREATER:
                    texture._setTexParameteri(gl.TEXTURE_COMPARE_FUNC, gl.GREATER);
                    texture._setTexParameteri(gl.TEXTURE_COMPARE_MODE, gl.COMPARE_REF_TO_TEXTURE);
                    break;
                case exports.TextureCompareMode.EQUAL:
                    texture._setTexParameteri(gl.TEXTURE_COMPARE_FUNC, gl.EQUAL);
                    texture._setTexParameteri(gl.TEXTURE_COMPARE_MODE, gl.COMPARE_REF_TO_TEXTURE);
                    break;
                case exports.TextureCompareMode.NOTEQUAL:
                    texture._setTexParameteri(gl.TEXTURE_COMPARE_FUNC, gl.NOTEQUAL);
                    texture._setTexParameteri(gl.TEXTURE_COMPARE_MODE, gl.COMPARE_REF_TO_TEXTURE);
                    break;
                case exports.TextureCompareMode.ALWAYS:
                    texture._setTexParameteri(gl.TEXTURE_COMPARE_FUNC, gl.ALWAYS);
                    texture._setTexParameteri(gl.TEXTURE_COMPARE_MODE, gl.COMPARE_REF_TO_TEXTURE);
                    break;
                case exports.TextureCompareMode.NEVER:
                    texture._setTexParameteri(gl.TEXTURE_COMPARE_FUNC, gl.NEVER);
                    texture._setTexParameteri(gl.TEXTURE_COMPARE_MODE, gl.COMPARE_REF_TO_TEXTURE);
                    break;
                case exports.TextureCompareMode.None:
                default:
                    texture._setTexParameteri(gl.TEXTURE_COMPARE_FUNC, gl.LEQUAL);
                    texture._setTexParameteri(gl.TEXTURE_COMPARE_MODE, gl.NONE);
                    break;
            }
            return compareMode;
        }
        createRenderbuffer(width, height, internalFormat, samples) {
            let gl = this._gl;
            let renderbuffer = gl.createRenderbuffer();
            gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);
            if (samples > 1) {
                gl.renderbufferStorageMultisample(gl.RENDERBUFFER, samples, internalFormat, width, height);
            }
            else {
                gl.renderbufferStorage(gl.RENDERBUFFER, internalFormat, width, height);
            }
            gl.bindRenderbuffer(gl.RENDERBUFFER, null);
            return renderbuffer;
        }
        createRenderTextureInternal(dimension, width, height, format, generateMipmap, sRGB) {
            generateMipmap = generateMipmap && this.supportGenerateMipmap(format);
            let useSRGBExt = this.isSRGBFormat(format) || (sRGB && this.supportSRGB(format, generateMipmap));
            let gammaCorrection = 1.0;
            if (!useSRGBExt && sRGB) {
                gammaCorrection = 2.2;
            }
            let target = this.getTarget(dimension);
            let internalTex = new WebGLInternalTex(this._engine, target, width, height, dimension, generateMipmap, useSRGBExt, gammaCorrection);
            let glParam = this.glRenderTextureParam(format, useSRGBExt);
            internalTex.internalFormat = glParam.internalFormat;
            internalTex.format = glParam.format;
            internalTex.type = glParam.type;
            let internalFormat = internalTex.internalFormat;
            internalTex.format;
            internalTex.type;
            let gl = internalTex._gl;
            this._engine._bindTexture(internalTex.target, internalTex.resource);
            gl.texStorage2D(target, internalTex.mipmapCount, internalFormat, width, height);
            this._engine._bindTexture(internalTex.target, null);
            if (format == exports.RenderTargetFormat.DEPTH_16 || format == exports.RenderTargetFormat.DEPTH_32 || format == exports.RenderTargetFormat.DEPTHSTENCIL_24_8) {
                internalTex.filterMode = exports.FilterMode.Point;
            }
            return internalTex;
        }
        createRenderTargetInternal(width, height, colorFormat, depthStencilFormat, generateMipmap, sRGB, multiSamples) {
            let texture = this.createRenderTextureInternal(exports.TextureDimension.Tex2D, width, height, colorFormat, generateMipmap, sRGB);
            let renderTarget = new WebGLInternalRT(this._engine, colorFormat, depthStencilFormat, false, texture.mipmap, multiSamples);
            renderTarget.gpuMemory = this.getGLRTTexMemory(width, height, colorFormat, depthStencilFormat, generateMipmap, multiSamples, false);
            renderTarget._textures.push(texture);
            let gl = renderTarget._gl;
            if (renderTarget._samples > 1) {
                let msaaFramebuffer = renderTarget._msaaFramebuffer;
                let renderbufferParam = this.glRenderBufferParam(colorFormat, sRGB);
                let msaaRenderbuffer = renderTarget._msaaRenderbuffer = this.createRenderbuffer(width, height, renderbufferParam.internalFormat, renderTarget._samples);
                gl.bindFramebuffer(gl.FRAMEBUFFER, msaaFramebuffer);
                gl.framebufferRenderbuffer(gl.FRAMEBUFFER, renderbufferParam.attachment, gl.RENDERBUFFER, msaaRenderbuffer);
                let depthBufferParam = this.glRenderBufferParam(depthStencilFormat, false);
                if (depthBufferParam) {
                    let depthbuffer = this.createRenderbuffer(width, height, depthBufferParam.internalFormat, renderTarget._samples);
                    renderTarget._depthbuffer = depthbuffer;
                    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, depthBufferParam.attachment, gl.RENDERBUFFER, depthbuffer);
                }
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                let framebuffer = renderTarget._framebuffer;
                gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
                let colorAttachment = this.glRenderTargetAttachment(colorFormat);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, colorAttachment, gl.TEXTURE_2D, texture.resource, 0);
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            }
            else {
                let framebuffer = renderTarget._framebuffer;
                gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
                let colorAttachment = this.glRenderTargetAttachment(colorFormat);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, colorAttachment, gl.TEXTURE_2D, texture.resource, 0);
                let depthBufferParam = this.glRenderBufferParam(depthStencilFormat, false);
                if (depthBufferParam) {
                    let depthbuffer = this.createRenderbuffer(width, height, depthBufferParam.internalFormat, renderTarget._samples);
                    renderTarget._depthbuffer = depthbuffer;
                    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, depthBufferParam.attachment, gl.RENDERBUFFER, depthbuffer);
                }
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            }
            return renderTarget;
        }
        createRenderTargetCubeInternal(size, colorFormat, depthStencilFormat, generateMipmap, sRGB, multiSamples) {
            let texture = this.createRenderTextureCubeInternal(exports.TextureDimension.Cube, size, colorFormat, generateMipmap, sRGB);
            let renderTarget = new WebGLInternalRT(this._engine, colorFormat, depthStencilFormat, true, texture.mipmap, multiSamples);
            renderTarget.gpuMemory = this.getGLRTTexMemory(size, size, colorFormat, depthStencilFormat, generateMipmap, multiSamples, true);
            renderTarget.colorFormat = colorFormat;
            renderTarget.depthStencilFormat = depthStencilFormat;
            renderTarget._textures.push(texture);
            let gl = renderTarget._gl;
            if (renderTarget._samples > 1) {
                let msaaFramebuffer = renderTarget._msaaFramebuffer;
                let renderbufferParam = this.glRenderBufferParam(colorFormat, false);
                let msaaRenderbuffer = renderTarget._msaaRenderbuffer = this.createRenderbuffer(size, size, renderbufferParam.internalFormat, renderTarget._samples);
                gl.bindFramebuffer(gl.FRAMEBUFFER, msaaFramebuffer);
                gl.framebufferRenderbuffer(gl.FRAMEBUFFER, renderbufferParam.attachment, gl.RENDERBUFFER, msaaRenderbuffer);
                let depthBufferParam = this.glRenderBufferParam(depthStencilFormat, false);
                if (depthBufferParam) {
                    let depthbuffer = this.createRenderbuffer(size, size, depthBufferParam.internalFormat, renderTarget._samples);
                    renderTarget._depthbuffer = depthbuffer;
                    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, depthBufferParam.attachment, gl.RENDERBUFFER, depthbuffer);
                }
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            }
            else {
                let framebuffer = renderTarget._framebuffer;
                gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
                let depthBufferParam = this.glRenderBufferParam(depthStencilFormat, false);
                if (depthBufferParam) {
                    let depthbuffer = this.createRenderbuffer(size, size, depthBufferParam.internalFormat, renderTarget._samples);
                    renderTarget._depthbuffer = depthbuffer;
                    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, depthBufferParam.attachment, gl.RENDERBUFFER, depthbuffer);
                }
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            }
            return renderTarget;
        }
        createRenderTextureCubeInternal(dimension, size, format, generateMipmap, sRGB) {
            generateMipmap = generateMipmap && this.supportGenerateMipmap(format);
            let useSRGBExt = this.isSRGBFormat(format) || (sRGB && this.supportSRGB(format, generateMipmap));
            let gammaCorrection = 1.0;
            if (!useSRGBExt && sRGB) {
                gammaCorrection = 2.2;
            }
            let target = this.getTarget(dimension);
            let internalTex = new WebGLInternalTex(this._engine, target, size, size, dimension, generateMipmap, useSRGBExt, gammaCorrection);
            let glParam = this.glRenderTextureParam(format, useSRGBExt);
            internalTex.internalFormat = glParam.internalFormat;
            internalTex.format = glParam.format;
            internalTex.type = glParam.type;
            let internalFormat = internalTex.internalFormat;
            internalTex.format;
            internalTex.type;
            let gl = internalTex._gl;
            this._engine._bindTexture(internalTex.target, internalTex.resource);
            gl.texStorage2D(target, internalTex.mipmapCount, internalFormat, size, size);
            this._engine._bindTexture(internalTex.target, null);
            return internalTex;
        }
        bindRenderTarget(renderTarget, faceIndex = 0) {
            let gl = renderTarget._gl;
            if (renderTarget._isCube) {
                let framebuffer = renderTarget._framebuffer;
                gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
                let texture = renderTarget._textures[0];
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, texture.resource, 0);
            }
            if (renderTarget._samples > 1) {
                gl.bindFramebuffer(gl.FRAMEBUFFER, renderTarget._msaaFramebuffer);
            }
            else {
                let framebuffer = renderTarget._framebuffer;
                gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
            }
        }
        unbindRenderTarget(renderTarget) {
            let gl = renderTarget._gl;
            if (renderTarget._samples > 1) {
                gl.bindFramebuffer(gl.READ_FRAMEBUFFER, renderTarget._msaaFramebuffer);
                gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, renderTarget._framebuffer);
                let texture = renderTarget._textures[0];
                let biltMask = gl.COLOR_BUFFER_BIT;
                if (renderTarget._depthTexture) {
                    biltMask |= gl.DEPTH_BUFFER_BIT;
                }
                gl.blitFramebuffer(0, 0, texture.width, texture.height, 0, 0, texture.width, texture.height, biltMask, gl.NEAREST);
            }
            if (renderTarget._generateMipmap) {
                renderTarget._textures.forEach(tex => {
                    let target = tex.target;
                    this._engine._bindTexture(target, tex.resource);
                    gl.generateMipmap(target);
                    this._engine._bindTexture(target, null);
                });
            }
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        }
    }

    class GLBuffer extends GLObject {
        constructor(engine, targetType, bufferUsageType) {
            super(engine);
            this._byteLength = 0;
            this._glTargetType = targetType;
            this._glBufferUsageType = bufferUsageType;
            this._getGLTarget(this._glTargetType);
            this._getGLUsage(this._glBufferUsageType);
            this._glBuffer = this._gl.createBuffer();
        }
        _getGLUsage(usage) {
            switch (usage) {
                case exports.BufferUsage.Static:
                    this._glUsage = this._gl.STATIC_DRAW;
                    break;
                case exports.BufferUsage.Dynamic:
                    this._glUsage = this._gl.DYNAMIC_DRAW;
                    break;
                case exports.BufferUsage.Stream:
                    this._glUsage = this._gl.STREAM_DRAW;
                    break;
                default:
                    console.error("usage is not standard");
                    break;
            }
        }
        _getGLTarget(target) {
            switch (target) {
                case exports.BufferTargetType.ARRAY_BUFFER:
                    this._glTarget = this._gl.ARRAY_BUFFER;
                    break;
                case exports.BufferTargetType.UNIFORM_BUFFER:
                    this._glTarget = this._gl.UNIFORM_BUFFER;
                    break;
                case exports.BufferTargetType.ELEMENT_ARRAY_BUFFER:
                    this._glTarget = this._gl.ELEMENT_ARRAY_BUFFER;
                    break;
            }
        }
        _memorychange(bytelength) {
            this._engine._addStatisticsInfo(exports.RenderStatisticsInfo.BufferMemory, bytelength);
            this._engine._addStatisticsInfo(exports.RenderStatisticsInfo.GPUMemory, bytelength);
        }
        bindBuffer() {
            if (this._engine._getbindBuffer(this._glTargetType) != this) {
                this._gl.bindBuffer(this._glTarget, this._glBuffer);
                this._engine._setbindBuffer(this._glTargetType, this);
                return true;
            }
            return false;
        }
        unbindBuffer() {
            if (this._engine._getbindBuffer(this._glTargetType) == this) {
                this._gl.bindBuffer(this._glTarget, null);
                this._engine._setbindBuffer(this._glTargetType, null);
            }
        }
        orphanStorage() {
            this.bindBuffer();
            this.setDataLength(this._byteLength);
        }
        setDataLength(srcData) {
            let gl = this._gl;
            this.bindBuffer();
            this._memorychange(-this._byteLength);
            this._byteLength = srcData;
            gl.bufferData(this._glTarget, this._byteLength, this._glUsage);
            this.unbindBuffer();
            this._memorychange(this._byteLength);
        }
        setData(srcData, offset) {
            let gl = this._gl;
            this.bindBuffer();
            gl.bufferSubData(this._glTarget, offset, srcData);
            this.unbindBuffer();
        }
        setDataEx(srcData, offset, length) {
            let gl = this._gl;
            this.bindBuffer();
            gl.bufferSubData(this._glTarget, offset, srcData, 0, length);
            this.unbindBuffer();
        }
        bindBufferBase(glPointer) {
            if (this._engine._getBindUBOBuffer(glPointer) != this) {
                const gl = this._gl;
                gl.bindBufferBase(this._glTarget, glPointer, this._glBuffer);
                this._engine._setBindUBOBuffer(glPointer, this);
            }
        }
        bindBufferRange(glPointer, offset, byteCount) {
            const gl = this._gl;
            gl.bindBufferRange(this._glTarget, glPointer, this._glBuffer, offset, byteCount);
        }
        resizeBuffer(dataLength) {
            this.bindBuffer();
            const gl = this._gl;
            this._byteLength = dataLength;
            gl.bufferData(this._glTarget, this._byteLength, this._glUsage);
        }
        destroy() {
            super.destroy();
            const gl = this._gl;
            gl.deleteBuffer(this._glBuffer);
            this._memorychange(-this._byteLength);
            this._byteLength = 0;
            this._engine = null;
            this._glBuffer = null;
            this._glTarget = null;
            this._glUsage = null;
            this._gl = null;
        }
    }

    class VertexArrayObject {
        constructor() {
        }
    }
    (function () {
        var glErrorShadow = {};
        function error(msg) {
            if (window.console && window.console.error) {
                window.console.error(msg);
            }
        }
        function log(msg) {
            if (window.console && window.console.log) {
                window.console.log(msg);
            }
        }
        function synthesizeGLError(err, opt_msg) {
            glErrorShadow[err] = true;
            if (opt_msg !== undefined) {
                error(opt_msg);
            }
        }
        function wrapGLError(gl) {
            var f = gl.getError;
            gl.getError = function () {
                var err;
                do {
                    err = f.apply(gl);
                    if (err != gl.NO_ERROR) {
                        glErrorShadow[err] = true;
                    }
                } while (err != gl.NO_ERROR);
                for (var err1 in glErrorShadow) {
                    if (glErrorShadow[err1]) {
                        delete glErrorShadow[err1];
                        return parseInt(err1);
                    }
                }
                return gl.NO_ERROR;
            };
        }
        var WebGLVertexArrayObjectOES = function WebGLVertexArrayObjectOES(ext) {
            var gl = ext.gl;
            this.ext = ext;
            this.isAlive = true;
            this.hasBeenBound = false;
            this.elementArrayBuffer = null;
            this.attribs = new Array(ext.maxVertexAttribs);
            for (var n = 0; n < this.attribs.length; n++) {
                var attrib = new WebGLVertexArrayObjectOES.VertexAttrib(gl);
                this.attribs[n] = attrib;
            }
            this.maxAttrib = 0;
        };
        WebGLVertexArrayObjectOES.VertexAttrib = function VertexAttrib(gl) {
            this.enabled = false;
            this.buffer = null;
            this.size = 4;
            this.type = gl.FLOAT;
            this.normalized = false;
            this.stride = 16;
            this.offset = 0;
            this.cached = "";
            this.recache();
        };
        WebGLVertexArrayObjectOES.VertexAttrib.prototype.recache = function recache() {
            this.cached = [this.size, this.type, this.normalized, this.stride, this.offset].join(":");
        };
        var OESVertexArrayObject = function OESVertexArrayObject(gl) {
            var self = this;
            this.gl = gl;
            wrapGLError(gl);
            var original = this.original = {
                getParameter: gl.getParameter,
                enableVertexAttribArray: gl.enableVertexAttribArray,
                disableVertexAttribArray: gl.disableVertexAttribArray,
                bindBuffer: gl.bindBuffer,
                getVertexAttrib: gl.getVertexAttrib,
                vertexAttribPointer: gl.vertexAttribPointer
            };
            gl.getParameter = function getParameter(pname) {
                if (pname == self.VERTEX_ARRAY_BINDING_OES) {
                    if (self.currentVertexArrayObject == self.defaultVertexArrayObject) {
                        return null;
                    }
                    else {
                        return self.currentVertexArrayObject;
                    }
                }
                return original.getParameter.apply(this, arguments);
            };
            gl.enableVertexAttribArray = function enableVertexAttribArray(index) {
                var vao = self.currentVertexArrayObject;
                vao.maxAttrib = Math.max(vao.maxAttrib, index);
                var attrib = vao.attribs[index];
                attrib.enabled = true;
                return original.enableVertexAttribArray.apply(this, arguments);
            };
            gl.disableVertexAttribArray = function disableVertexAttribArray(index) {
                var vao = self.currentVertexArrayObject;
                vao.maxAttrib = Math.max(vao.maxAttrib, index);
                var attrib = vao.attribs[index];
                attrib.enabled = false;
                return original.disableVertexAttribArray.apply(this, arguments);
            };
            gl.bindBuffer = function bindBuffer(target, buffer) {
                switch (target) {
                    case gl.ARRAY_BUFFER:
                        self.currentArrayBuffer = buffer;
                        break;
                    case gl.ELEMENT_ARRAY_BUFFER:
                        self.currentVertexArrayObject.elementArrayBuffer = buffer;
                        break;
                }
                return original.bindBuffer.apply(this, arguments);
            };
            gl.getVertexAttrib = function getVertexAttrib(index, pname) {
                var vao = self.currentVertexArrayObject;
                var attrib = vao.attribs[index];
                switch (pname) {
                    case gl.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING:
                        return attrib.buffer;
                    case gl.VERTEX_ATTRIB_ARRAY_ENABLED:
                        return attrib.enabled;
                    case gl.VERTEX_ATTRIB_ARRAY_SIZE:
                        return attrib.size;
                    case gl.VERTEX_ATTRIB_ARRAY_STRIDE:
                        return attrib.stride;
                    case gl.VERTEX_ATTRIB_ARRAY_TYPE:
                        return attrib.type;
                    case gl.VERTEX_ATTRIB_ARRAY_NORMALIZED:
                        return attrib.normalized;
                    default:
                        return original.getVertexAttrib.apply(this, arguments);
                }
            };
            gl.vertexAttribPointer = function vertexAttribPointer(indx, size, type, normalized, stride, offset) {
                var vao = self.currentVertexArrayObject;
                vao.maxAttrib = Math.max(vao.maxAttrib, indx);
                var attrib = vao.attribs[indx];
                attrib.buffer = self.currentArrayBuffer;
                attrib.size = size;
                attrib.type = type;
                attrib.normalized = normalized;
                attrib.stride = stride;
                attrib.offset = offset;
                attrib.recache();
                return original.vertexAttribPointer.apply(this, arguments);
            };
            if (gl.instrumentExtension) {
                gl.instrumentExtension(this, "OES_vertex_array_object");
            }
            gl.canvas.addEventListener('webglcontextrestored', function () {
                log("OESVertexArrayObject emulation library context restored");
                self.reset_();
            }, true);
            this.reset_();
        };
        OESVertexArrayObject.prototype.VERTEX_ARRAY_BINDING_OES = 0x85B5;
        OESVertexArrayObject.prototype.reset_ = function reset_() {
            var contextWasLost = this.vertexArrayObjects !== undefined;
            if (contextWasLost) {
                for (var ii = 0; ii < this.vertexArrayObjects.length; ++ii) {
                    this.vertexArrayObjects.isAlive = false;
                }
            }
            var gl = this.gl;
            this.maxVertexAttribs = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
            this.defaultVertexArrayObject = new WebGLVertexArrayObjectOES(this);
            this.currentVertexArrayObject = null;
            this.currentArrayBuffer = null;
            this.vertexArrayObjects = [this.defaultVertexArrayObject];
            this.bindVertexArrayOES(null);
        };
        OESVertexArrayObject.prototype.createVertexArrayOES = function createVertexArrayOES() {
            var arrayObject = new WebGLVertexArrayObjectOES(this);
            this.vertexArrayObjects.push(arrayObject);
            return arrayObject;
        };
        OESVertexArrayObject.prototype.deleteVertexArrayOES = function deleteVertexArrayOES(arrayObject) {
            arrayObject.isAlive = false;
            this.vertexArrayObjects.splice(this.vertexArrayObjects.indexOf(arrayObject), 1);
            if (this.currentVertexArrayObject == arrayObject) {
                this.bindVertexArrayOES(null);
            }
        };
        OESVertexArrayObject.prototype.isVertexArrayOES = function isVertexArrayOES(arrayObject) {
            if (arrayObject && arrayObject instanceof WebGLVertexArrayObjectOES) {
                if (arrayObject.hasBeenBound && arrayObject.ext == this) {
                    return true;
                }
            }
            return false;
        };
        OESVertexArrayObject.prototype.bindVertexArrayOES = function bindVertexArrayOES(arrayObject) {
            var gl = this.gl;
            if (arrayObject && !arrayObject.isAlive) {
                synthesizeGLError(gl.INVALID_OPERATION, "bindVertexArrayOES: attempt to bind deleted arrayObject");
                return;
            }
            var original = this.original;
            var oldVAO = this.currentVertexArrayObject;
            this.currentVertexArrayObject = arrayObject || this.defaultVertexArrayObject;
            this.currentVertexArrayObject.hasBeenBound = true;
            var newVAO = this.currentVertexArrayObject;
            if (oldVAO == newVAO) {
                return;
            }
            if (!oldVAO || newVAO.elementArrayBuffer != oldVAO.elementArrayBuffer) {
                original.bindBuffer.call(gl, gl.ELEMENT_ARRAY_BUFFER, newVAO.elementArrayBuffer);
            }
            var currentBinding = this.currentArrayBuffer;
            var maxAttrib = Math.max(oldVAO ? oldVAO.maxAttrib : 0, newVAO.maxAttrib);
            for (var n = 0; n <= maxAttrib; n++) {
                var attrib = newVAO.attribs[n];
                var oldAttrib = oldVAO ? oldVAO.attribs[n] : null;
                if (!oldVAO || attrib.enabled != oldAttrib.enabled) {
                    if (attrib.enabled) {
                        original.enableVertexAttribArray.call(gl, n);
                    }
                    else {
                        original.disableVertexAttribArray.call(gl, n);
                    }
                }
                if (attrib.enabled) {
                    var bufferChanged = false;
                    if (!oldVAO || attrib.buffer != oldAttrib.buffer) {
                        if (currentBinding != attrib.buffer) {
                            original.bindBuffer.call(gl, gl.ARRAY_BUFFER, attrib.buffer);
                            currentBinding = attrib.buffer;
                        }
                        bufferChanged = true;
                    }
                    if (bufferChanged || attrib.cached != oldAttrib.cached) {
                        original.vertexAttribPointer.call(gl, n, attrib.size, attrib.type, attrib.normalized, attrib.stride, attrib.offset);
                    }
                }
            }
            if (this.currentArrayBuffer != currentBinding) {
                original.bindBuffer.call(gl, gl.ARRAY_BUFFER, this.currentArrayBuffer);
            }
        };
        window._setupVertexArrayObject = function (gl) {
            var original_getSupportedExtensions = gl.getSupportedExtensions;
            gl.getSupportedExtensions = function getSupportedExtensions() {
                var list = original_getSupportedExtensions.call(this) || [];
                if (list.indexOf("OES_vertex_array_object") < 0) {
                    list.push("OES_vertex_array_object");
                }
                return list;
            };
            var original_getExtension = gl.getExtension;
            gl.getExtension = function getExtension(name) {
                var ext = original_getExtension.call(this, name);
                if (ext) {
                    return ext;
                }
                if (name !== "OES_vertex_array_object") {
                    return null;
                }
                if (!this.__OESVertexArrayObject) {
                    console.log("Setup OES_vertex_array_object polyfill");
                    this.__OESVertexArrayObject = new OESVertexArrayObject(this);
                }
                return this.__OESVertexArrayObject;
            };
        };
    }());

    class GlCapable {
        constructor(glEngine) {
            this._extentionVendorPrefixes = ["", "WEBKIT_", "MOZ_"];
            this._gl = glEngine.gl;
            this.initExtension(glEngine.isWebGL2);
            this.initCapable(glEngine.isWebGL2);
        }
        initCapable(isWebgl2) {
            this._capabilityMap = new Map();
            let value = isWebgl2 || !!(this.getExtension(exports.WebGLExtension.OES_element_index_uint));
            this._capabilityMap.set(exports.RenderCapable.Element_Index_Uint32, value);
            value = isWebgl2 || !!(this.getExtension(exports.WebGLExtension.OES_texture_float));
            this._capabilityMap.set(exports.RenderCapable.TextureFormat_R32G32B32A32, value);
            value = isWebgl2 || !!(this.getExtension(exports.WebGLExtension.OES_texture_half_float));
            this._capabilityMap.set(exports.RenderCapable.TextureFormat_R16G16B16A16, value);
            value = !!(this.getExtension(exports.WebGLExtension.EXT_texture_filter_anisotropic));
            this._capabilityMap.set(exports.RenderCapable.Texture_anisotropic, value);
            if (isWebgl2) {
                value = !!this.getExtension(exports.WebGLExtension.EXT_color_buffer_float);
            }
            else {
                value = (!!this.getExtension(exports.WebGLExtension.OES_texture_half_float)) && (!!this.getExtension(exports.WebGLExtension.OES_texture_half_float_linear));
            }
            this._capabilityMap.set(exports.RenderCapable.RenderTextureFormat_R16G16B16A16, value);
            value = isWebgl2 || (!!this.getExtension(exports.WebGLExtension.WEBGL_depth_texture));
            this._capabilityMap.set(exports.RenderCapable.RenderTextureFormat_Depth, value);
            value = isWebgl2;
            this._capabilityMap.set(exports.RenderCapable.RenderTextureFormat_ShadowMap, value);
            value = isWebgl2 || (!!this.getExtension(exports.WebGLExtension.OES_vertex_array_object));
            this._capabilityMap.set(exports.RenderCapable.Vertex_VAO, value);
            value = (isWebgl2 || (!!this.getExtension(exports.WebGLExtension.ANGLE_instanced_arrays)));
            this._capabilityMap.set(exports.RenderCapable.DrawElement_Instance, value);
            value = (isWebgl2) || (!!this.getExtension(exports.WebGLExtension.EXT_shader_texture_lod));
            this._capabilityMap.set(exports.RenderCapable.Shader_TextureLod, value);
            value = (!!this.getExtension(exports.WebGLExtension.WEBGL_compressed_texture_s3tc));
            this._capabilityMap.set(exports.RenderCapable.COMPRESS_TEXTURE_S3TC, value);
            value = (!!this.getExtension(exports.WebGLExtension.WEBGL_compressed_texture_s3tc_srgb));
            this._capabilityMap.set(exports.RenderCapable.COMPRESS_TEXTURE_S3TC_SRGB, value);
            value = (!!this.getExtension(exports.WebGLExtension.WEBGL_compressed_texture_pvrtc));
            this._capabilityMap.set(exports.RenderCapable.COMPRESS_TEXTURE_PVRTC, value);
            value = (!!this.getExtension(exports.WebGLExtension.WEBGL_compressed_texture_etc1));
            this._capabilityMap.set(exports.RenderCapable.COMPRESS_TEXTURE_ETC1, value);
            value = (!!this.getExtension(exports.WebGLExtension.WEBGL_compressed_texture_etc));
            this._capabilityMap.set(exports.RenderCapable.COMPRESS_TEXTURE_ETC, value);
            value = (!!this.getExtension(exports.WebGLExtension.WEBGL_compressed_texture_astc));
            this._capabilityMap.set(exports.RenderCapable.COMPRESS_TEXTURE_ASTC, value);
            value = (isWebgl2) || (!!this.getExtension(exports.WebGLExtension.EXT_sRGB));
            this._capabilityMap.set(exports.RenderCapable.Texture_SRGB, value);
            value = isWebgl2;
            this._capabilityMap.set(exports.RenderCapable.MSAA, value);
            this._capabilityMap.set(exports.RenderCapable.UnifromBufferObject, value);
            this._capabilityMap.set(exports.RenderCapable.GRAPHICS_API_GLES3, value);
        }
        initExtension(isWebgl2) {
            this._extensionMap = new Map();
            const setExtensionMap = (extension, value, map) => {
                value && map.set(extension, value);
            };
            const _extTextureFilterAnisotropic = this._getExtension("EXT_texture_filter_anisotropic");
            setExtensionMap(exports.WebGLExtension.EXT_texture_filter_anisotropic, _extTextureFilterAnisotropic, this._extensionMap);
            const _compressedTextureS3tc = this._getExtension("WEBGL_compressed_texture_s3tc");
            setExtensionMap(exports.WebGLExtension.WEBGL_compressed_texture_s3tc, _compressedTextureS3tc, this._extensionMap);
            const _compressdTextureS3tc_srgb = this._getExtension("WEBGL_compressed_texture_s3tc_srgb");
            setExtensionMap(exports.WebGLExtension.WEBGL_compressed_texture_s3tc_srgb, _compressdTextureS3tc_srgb, this._extensionMap);
            const _compressedTexturePvrtc = this._getExtension("WEBGL_compressed_texture_pvrtc");
            setExtensionMap(exports.WebGLExtension.WEBGL_compressed_texture_pvrtc, _compressedTexturePvrtc, this._extensionMap);
            const _compressedTextureEtc1 = this._getExtension("WEBGL_compressed_texture_etc1");
            setExtensionMap(exports.WebGLExtension.WEBGL_compressed_texture_etc1, _compressedTextureEtc1, this._extensionMap);
            const _compressedTextureETC = this._getExtension("WEBGL_compressed_texture_etc");
            setExtensionMap(exports.WebGLExtension.WEBGL_compressed_texture_etc, _compressedTextureETC, this._extensionMap);
            const _compressedTextureASTC = this._getExtension("WEBGL_compressed_texture_astc");
            setExtensionMap(exports.WebGLExtension.WEBGL_compressed_texture_astc, _compressedTextureASTC, this._extensionMap);
            const _oesTextureFloatLinear = this._getExtension("OES_texture_float_linear");
            setExtensionMap(exports.WebGLExtension.OES_texture_float_linear, _oesTextureFloatLinear, this._extensionMap);
            if (isWebgl2) {
                const _extColorBufferFloat = this._getExtension("EXT_color_buffer_float");
                setExtensionMap(exports.WebGLExtension.EXT_color_buffer_float, _extColorBufferFloat, this._extensionMap);
                const _extColorBufferHalfFloat = this._getExtension("EXT_color_buffer_half_float");
                setExtensionMap(exports.WebGLExtension.EXT_color_buffer_half_float, _extColorBufferHalfFloat, this._extensionMap);
            }
            else {
                if (window._setupVertexArrayObject)
                    window._setupVertexArrayObject(this._gl);
                const _vaoExt = this._getExtension("OES_vertex_array_object");
                setExtensionMap(exports.WebGLExtension.OES_vertex_array_object, _vaoExt, this._extensionMap);
                const _angleInstancedArrays = this._getExtension("ANGLE_instanced_arrays");
                setExtensionMap(exports.WebGLExtension.ANGLE_instanced_arrays, _angleInstancedArrays, this._extensionMap);
                const _oesTextureHalfFloat = this._getExtension("OES_texture_half_float");
                setExtensionMap(exports.WebGLExtension.OES_texture_half_float, _oesTextureHalfFloat, this._extensionMap);
                const _oesTextureHalfFloatLinear = this._getExtension("OES_texture_half_float_linear");
                setExtensionMap(exports.WebGLExtension.OES_texture_half_float_linear, _oesTextureHalfFloatLinear, this._extensionMap);
                const _oesTextureFloat = this._getExtension("OES_texture_float");
                setExtensionMap(exports.WebGLExtension.OES_texture_float, _oesTextureFloat, this._extensionMap);
                const _oes_element_index_uint = this._getExtension("OES_element_index_uint");
                setExtensionMap(exports.WebGLExtension.OES_element_index_uint, _oes_element_index_uint, this._extensionMap);
                const _extShaderTextureLod = this._getExtension("EXT_shader_texture_lod");
                setExtensionMap(exports.WebGLExtension.EXT_shader_texture_lod, _extShaderTextureLod, this._extensionMap);
                const _webgl_depth_texture = this._getExtension("WEBGL_depth_texture");
                setExtensionMap(exports.WebGLExtension.WEBGL_depth_texture, _webgl_depth_texture, this._extensionMap);
                const _sRGB = this._getExtension("EXT_sRGB");
                setExtensionMap(exports.WebGLExtension.EXT_sRGB, _sRGB, this._extensionMap);
            }
        }
        getCapable(type) {
            return this._capabilityMap.get(type);
        }
        getExtension(type) {
            if (this._extensionMap.has(type))
                return this._extensionMap.get(type);
            else
                return null;
        }
        _getExtension(name) {
            const prefixes = this._extentionVendorPrefixes;
            for (const k in prefixes) {
                var ext = this._gl.getExtension(prefixes[k] + name);
                if (ext)
                    return ext;
            }
            return null;
        }
    }

    class GLParams {
        constructor(engine) {
            this._engine = engine;
            this._gl = this._engine.gl;
            this._initParams();
        }
        _initParams() {
            const gl = this._gl;
            this._glParamsData = new Map();
            this._glParamsData.set(exports.RenderParams.Max_Active_Texture_Count, gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS));
            const maxVertexUniform = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
            const maxFragUniform = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
            this._glParamsData.set(exports.RenderParams.Max_Uniform_Count, Math.min(maxVertexUniform, maxFragUniform));
            this._glParamsData.set(exports.RenderParams.MAX_Texture_Size, gl.getParameter(gl.MAX_TEXTURE_SIZE));
            this._glParamsData.set(exports.RenderParams.MAX_Texture_Image_Uint, gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS));
            if (this._engine.getCapable(exports.RenderCapable.Texture_anisotropic)) {
                const anisoExt = this._engine._supportCapatable.getExtension(exports.WebGLExtension.EXT_texture_filter_anisotropic);
                this._glParamsData.set(exports.RenderParams.Max_AnisoLevel_Count, gl.getParameter(anisoExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
            }
            if (this._engine.isWebGL2)
                this._glParamsData.set(exports.RenderParams.SHADER_CAPAILITY_LEVEL, 35);
            else
                this._glParamsData.set(exports.RenderParams.SHADER_CAPAILITY_LEVEL, 30);
            this._glParamsData.set(exports.RenderParams.FLOAT, gl.FLOAT);
            this._glParamsData.set(exports.RenderParams.UNSIGNED_BYTE, gl.UNSIGNED_BYTE);
            this._glParamsData.set(exports.RenderParams.UNSIGNED_SHORT, gl.UNSIGNED_SHORT);
            this._glParamsData.set(exports.RenderParams.BYTE, gl.BYTE);
        }
        getParams(params) {
            return this._glParamsData.get(params);
        }
    }

    class GLRender2DContext extends GLObject {
        constructor(engine) {
            super(engine);
        }
        activeTexture(textureID) {
            if (this._engine._activedTextureID !== textureID) {
                this._gl.activeTexture(textureID);
                this._engine._activedTextureID = textureID;
            }
        }
        bindTexture(target, texture) {
            this._engine._bindTexture(target, texture);
        }
        bindUseProgram(webglProgram) {
            if (this.cacheShaderProgram == webglProgram)
                return false;
            this._gl.useProgram(webglProgram);
            this._engine._glUseProgram = null;
            return true;
        }
    }

    exports.DrawType = void 0;
    (function (DrawType) {
        DrawType[DrawType["DrawArray"] = 0] = "DrawArray";
        DrawType[DrawType["DrawArrayInstance"] = 1] = "DrawArrayInstance";
        DrawType[DrawType["DrawElement"] = 2] = "DrawElement";
        DrawType[DrawType["DrawElementInstance"] = 3] = "DrawElementInstance";
    })(exports.DrawType || (exports.DrawType = {}));

    class GLRenderDrawContext extends GLObject {
        constructor(engine) {
            super(engine);
            if (!this._engine.isWebGL2) {
                this._angleInstancedArrays = this._engine._supportCapatable.getExtension(exports.WebGLExtension.ANGLE_instanced_arrays);
            }
        }
        getMeshTopology(mode) {
            switch (mode) {
                case exports.MeshTopology.Points:
                    return this._gl.POINTS;
                case exports.MeshTopology.Lines:
                    return this._gl.LINES;
                case exports.MeshTopology.LineLoop:
                    return this._gl.LINE_LOOP;
                case exports.MeshTopology.LineStrip:
                    return this._gl.LINE_STRIP;
                case exports.MeshTopology.Triangles:
                    return this._gl.TRIANGLES;
                case exports.MeshTopology.TriangleStrip:
                    return this._gl.TRIANGLE_STRIP;
                case exports.MeshTopology.TriangleFan:
                    return this._gl.TRIANGLE_FAN;
            }
        }
        getIndexType(type) {
            switch (type) {
                case exports.IndexFormat.UInt8:
                    return this._gl.UNSIGNED_BYTE;
                case exports.IndexFormat.UInt16:
                    return this._gl.UNSIGNED_SHORT;
                case exports.IndexFormat.UInt32:
                    return this._gl.UNSIGNED_INT;
            }
        }
        drawElementsInstanced(mode, count, type, offset, instanceCount) {
            const glmode = this.getMeshTopology(mode);
            const gltype = this.getIndexType(type);
            if (this._engine.isWebGL2)
                this._gl.drawElementsInstanced(glmode, count, gltype, offset, instanceCount);
            else
                this._angleInstancedArrays.drawElementsInstancedANGLE(glmode, count, gltype, offset, instanceCount);
            this._engine._addStatisticsInfo(exports.RenderStatisticsInfo.DrawCall, 1);
            this._engine._addStatisticsInfo(exports.RenderStatisticsInfo.InstanceDrawCall, 1);
            this._engine._addStatisticsInfo(exports.RenderStatisticsInfo.Triangle, count / 3 * instanceCount);
        }
        drawArraysInstanced(mode, first, count, instanceCount) {
            const glmode = this.getMeshTopology(mode);
            if (this._engine.isWebGL2)
                this._gl.drawArraysInstanced(glmode, first, count, instanceCount);
            else
                this._angleInstancedArrays.drawArraysInstancedANGLE(glmode, first, count, instanceCount);
            this._engine._addStatisticsInfo(exports.RenderStatisticsInfo.DrawCall, 1);
            this._engine._addStatisticsInfo(exports.RenderStatisticsInfo.InstanceDrawCall, 1);
            this._engine._addStatisticsInfo(exports.RenderStatisticsInfo.Triangle, (count - 2) * instanceCount);
        }
        drawArrays(mode, first, count) {
            const glmode = this.getMeshTopology(mode);
            this._gl.drawArrays(glmode, first, count);
            this._engine._addStatisticsInfo(exports.RenderStatisticsInfo.DrawCall, 1);
            this._engine._addStatisticsInfo(exports.RenderStatisticsInfo.Triangle, (count - 2));
        }
        drawElements(mode, count, type, offset) {
            const glmode = this.getMeshTopology(mode);
            const gltype = this.getIndexType(type);
            this._gl.drawElements(glmode, count, gltype, offset);
            this._engine._addStatisticsInfo(exports.RenderStatisticsInfo.DrawCall, 1);
            this._engine._addStatisticsInfo(exports.RenderStatisticsInfo.Triangle, count / 3);
        }
        drawGeometryElement(geometryElement) {
            geometryElement.bufferState.bind();
            let element = geometryElement.drawParams.elements;
            let length = geometryElement.drawParams.length;
            switch (geometryElement.drawType) {
                case exports.DrawType.DrawArray:
                    for (let i = 0; i < length; i += 2) {
                        this.drawArrays(geometryElement.mode, element[i], element[i + 1]);
                    }
                    break;
                case exports.DrawType.DrawElement:
                    for (let i = 0; i < length; i += 2) {
                        this.drawElements(geometryElement.mode, element[i + 1], geometryElement.indexFormat, element[i]);
                    }
                    break;
                case exports.DrawType.DrawArrayInstance:
                    for (let i = 0; i < length; i += 2) {
                        this.drawArraysInstanced(geometryElement.mode, element[i], element[i + 1], geometryElement.instanceCount);
                    }
                    break;
                case exports.DrawType.DrawElementInstance:
                    for (let i = 0; i < length; i += 2) {
                        this.drawElementsInstanced(geometryElement.mode, element[i + 1], geometryElement.indexFormat, element[i], geometryElement.instanceCount);
                    }
                    break;
            }
        }
    }

    exports.CompareFunction = void 0;
    (function (CompareFunction) {
        CompareFunction[CompareFunction["Never"] = 0] = "Never";
        CompareFunction[CompareFunction["Less"] = 1] = "Less";
        CompareFunction[CompareFunction["Equal"] = 2] = "Equal";
        CompareFunction[CompareFunction["LessEqual"] = 3] = "LessEqual";
        CompareFunction[CompareFunction["Greater"] = 4] = "Greater";
        CompareFunction[CompareFunction["NotEqual"] = 5] = "NotEqual";
        CompareFunction[CompareFunction["GreaterEqual"] = 6] = "GreaterEqual";
        CompareFunction[CompareFunction["Always"] = 7] = "Always";
    })(exports.CompareFunction || (exports.CompareFunction = {}));

    exports.StencilOperation = void 0;
    (function (StencilOperation) {
        StencilOperation[StencilOperation["Keep"] = 0] = "Keep";
        StencilOperation[StencilOperation["Zero"] = 1] = "Zero";
        StencilOperation[StencilOperation["Replace"] = 2] = "Replace";
        StencilOperation[StencilOperation["IncrementSaturate"] = 3] = "IncrementSaturate";
        StencilOperation[StencilOperation["DecrementSaturate"] = 4] = "DecrementSaturate";
        StencilOperation[StencilOperation["Invert"] = 5] = "Invert";
        StencilOperation[StencilOperation["IncrementWrap"] = 6] = "IncrementWrap";
        StencilOperation[StencilOperation["DecrementWrap"] = 7] = "DecrementWrap";
    })(exports.StencilOperation || (exports.StencilOperation = {}));

    class GLRenderState {
        constructor(engine) {
            this._depthTest = true;
            this._depthMask = true;
            this._stencilTest = false;
            this._blend = false;
            this._cullFace = false;
            this._engine = engine;
            this._gl = this._engine.gl;
            this._initState();
        }
        _initState() {
            const gl = this._gl;
            this.setDepthFunc(gl.LESS);
            this.setBlendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
            this._blendEquation = gl.FUNC_ADD;
            this._sFactor = gl.ONE;
            this._dFactor = gl.ZERO;
            this._sFactorAlpha = gl.ONE;
            this._dFactorAlpha = gl.ONE;
        }
        _getBlendFactor(factor) {
            const gl = this._gl;
            switch (factor) {
                case exports.BlendFactor.Zero:
                    return gl.ZERO;
                case exports.BlendFactor.One:
                    return gl.ONE;
                case exports.BlendFactor.SourceColor:
                    return gl.SRC_COLOR;
                case exports.BlendFactor.OneMinusSourceColor:
                    return gl.ONE_MINUS_SRC_COLOR;
                case exports.BlendFactor.DestinationColor:
                    return gl.DST_COLOR;
                case exports.BlendFactor.OneMinusDestinationColor:
                    return gl.ONE_MINUS_DST_COLOR;
                case exports.BlendFactor.SourceAlpha:
                    return gl.SRC_ALPHA;
                case exports.BlendFactor.OneMinusSourceAlpha:
                    return gl.ONE_MINUS_SRC_ALPHA;
                case exports.BlendFactor.DestinationAlpha:
                    return gl.DST_ALPHA;
                case exports.BlendFactor.OneMinusDestinationAlpha:
                    return gl.ONE_MINUS_DST_ALPHA;
                case exports.BlendFactor.SourceAlphaSaturate:
                    return gl.SRC_ALPHA_SATURATE;
                case exports.BlendFactor.BlendColor:
                    return gl.CONSTANT_COLOR;
                case exports.BlendFactor.OneMinusBlendColor:
                    return gl.ONE_MINUS_CONSTANT_COLOR;
            }
        }
        _getBlendOperation(factor) {
            const gl = this._gl;
            switch (factor) {
                case exports.BlendEquationSeparate.ADD:
                    return gl.FUNC_ADD;
                case exports.BlendEquationSeparate.SUBTRACT:
                    return gl.FUNC_SUBTRACT;
                case exports.BlendEquationSeparate.REVERSE_SUBTRACT:
                    return gl.FUNC_REVERSE_SUBTRACT;
                default:
                    throw "Unknow type";
            }
        }
        _getGLCompareFunction(compareFunction) {
            const gl = this._gl;
            switch (compareFunction) {
                case exports.CompareFunction.Never:
                    return gl.NEVER;
                case exports.CompareFunction.Less:
                    return gl.LESS;
                case exports.CompareFunction.Equal:
                    return gl.EQUAL;
                case exports.CompareFunction.LessEqual:
                    return gl.LEQUAL;
                case exports.CompareFunction.Greater:
                    return gl.GREATER;
                case exports.CompareFunction.NotEqual:
                    return gl.NOTEQUAL;
                case exports.CompareFunction.GreaterEqual:
                    return gl.GEQUAL;
                case exports.CompareFunction.Always:
                    return gl.ALWAYS;
            }
        }
        _getGLStencilOperation(compareFunction) {
            const gl = this._gl;
            switch (compareFunction) {
                case exports.StencilOperation.Keep:
                    return gl.KEEP;
                case exports.StencilOperation.Zero:
                    return gl.ZERO;
                case exports.StencilOperation.Replace:
                    return gl.REPLACE;
                case exports.StencilOperation.IncrementSaturate:
                    return gl.INCR;
                case exports.StencilOperation.DecrementSaturate:
                    return gl.DECR;
                case exports.StencilOperation.Invert:
                    return gl.INVERT;
                case exports.StencilOperation.IncrementWrap:
                    return gl.INCR_WRAP;
                case exports.StencilOperation.DecrementWrap:
                    return gl.DECR_WRAP;
            }
        }
        _getGLFrontfaceFactor(cullmode) {
            if (cullmode == exports.CullMode.Front)
                return this._gl.CCW;
            else
                return this._gl.CW;
        }
        setDepthTest(value) {
            value !== this._depthTest && (this._depthTest = value, value ? this._gl.enable(this._gl.DEPTH_TEST) : this._gl.disable(this._gl.DEPTH_TEST));
        }
        setDepthMask(value) {
            value !== this._depthMask && (this._depthMask = value, this._gl.depthMask(value));
        }
        setDepthFunc(value) {
            value !== this._depthFunc && (this._depthFunc = value, this._gl.depthFunc(value));
        }
        setStencilTest(value) {
            value !== this._stencilTest && (this._stencilTest = value, value ? this._gl.enable(this._gl.STENCIL_TEST) : this._gl.disable(this._gl.STENCIL_TEST));
        }
        setStencilMask(value) {
            value !== this._stencilMask && (this._stencilMask = value, value ? this._gl.stencilMask(0xff) : this._gl.stencilMask(0x00));
        }
        setStencilFunc(fun, ref) {
            if (fun != this._stencilFunc || ref != this._stencilRef) {
                this._stencilFunc = fun;
                this._stencilRef = ref;
                this._gl.stencilFunc(fun, ref, 0xff);
            }
        }
        setstencilOp(fail, zfail, zpass) {
            if (this._stencilOp_fail != fail || this._stencilOp_zfail != zfail || this._stencilOp_zpass != zpass) {
                this._stencilOp_fail = fail;
                this._stencilOp_zfail = zfail;
                this._stencilOp_zpass = zpass;
                this._gl.stencilOp(fail, zfail, zpass);
            }
        }
        setBlend(value) {
            value !== this._blend && (this._blend = value, value ? this._gl.enable(this._gl.BLEND) : this._gl.disable(this._gl.BLEND));
        }
        setBlendEquation(blendEquation) {
            if (blendEquation !== this._blendEquation) {
                this._blendEquation = blendEquation;
                this._blendEquationRGB = this._blendEquationAlpha = null;
                this._gl.blendEquation(blendEquation);
            }
        }
        setBlendEquationSeparate(blendEquationRGB, blendEquationAlpha) {
            if (blendEquationRGB !== this._blendEquationRGB || blendEquationAlpha !== this._blendEquationAlpha) {
                this._blendEquationRGB = blendEquationRGB;
                this._blendEquationAlpha = blendEquationAlpha;
                this._blendEquation = null;
                this._gl.blendEquationSeparate(blendEquationRGB, blendEquationAlpha);
            }
        }
        setBlendFunc(sFactor, dFactor, force = false) {
            if (force || sFactor !== this._sFactor || dFactor !== this._dFactor) {
                this._sFactor = sFactor;
                this._dFactor = dFactor;
                this._sFactorRGB = null;
                this._dFactorRGB = null;
                this._sFactorAlpha = null;
                this._dFactorAlpha = null;
                this._gl.blendFunc(sFactor, dFactor);
            }
        }
        setBlendFuncSeperate(srcRGB, dstRGB, srcAlpha, dstAlpha) {
            if (srcRGB !== this._sFactorRGB || dstRGB !== this._dFactorRGB || srcAlpha !== this._sFactorAlpha || dstAlpha !== this._dFactorAlpha) {
                this._sFactorRGB = srcRGB;
                this._dFactorRGB = dstRGB;
                this._sFactorAlpha = srcAlpha;
                this._dFactorAlpha = dstAlpha;
                this._sFactor = null;
                this._dFactor = null;
                this._gl.blendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha);
            }
        }
        setCullFace(value) {
            value !== this._cullFace && (this._cullFace = value, value ? this._gl.enable(this._gl.CULL_FACE) : this._gl.disable(this._gl.CULL_FACE));
        }
        setFrontFace(value) {
            value !== this._frontFace && (this._frontFace = value, this._gl.frontFace(value));
        }
        applyRenderStateCommand(cmd) {
            let cmdArray = cmd.cmdArray;
            cmdArray.forEach((value, key) => {
                switch (key) {
                    case exports.RenderStateType.DepthTest:
                        this.setDepthTest(value);
                        break;
                    case exports.RenderStateType.DepthMask:
                        this.setDepthMask(value);
                        break;
                    case exports.RenderStateType.DepthFunc:
                        this.setDepthFunc(this._getGLCompareFunction(value));
                        break;
                    case exports.RenderStateType.StencilTest:
                        this.setStencilTest(value);
                        break;
                    case exports.RenderStateType.StencilMask:
                        this.setStencilMask(value);
                        break;
                    case exports.RenderStateType.StencilFunc:
                        this.setStencilFunc(this._getGLCompareFunction(value[0]), value[1]);
                        break;
                    case exports.RenderStateType.StencilOp:
                        this.setstencilOp(this._getGLStencilOperation(value[0]), this._getGLStencilOperation(value[1]), this._getGLStencilOperation(value[2]));
                        break;
                    case exports.RenderStateType.BlendType:
                        this.setBlend(value != exports.BlendType.BLEND_DISABLE);
                        break;
                    case exports.RenderStateType.BlendEquation:
                        this.setBlendEquation(this._getBlendOperation(value));
                        break;
                    case exports.RenderStateType.BlendEquationSeparate:
                        this.setBlendEquationSeparate(this._getBlendOperation(value[0]), this._getBlendOperation(value[1]));
                        break;
                    case exports.RenderStateType.BlendFunc:
                        this.setBlendFunc(this._getBlendFactor(value[0]), this._getBlendFactor(value[1]));
                        break;
                    case exports.RenderStateType.BlendFuncSeperate:
                        this.setBlendFuncSeperate(this._getBlendFactor(value[0]), this._getBlendFactor(value[1]), this._getBlendFactor(value[2]), this._getBlendFactor(value[3]));
                        break;
                    case exports.RenderStateType.CullFace:
                        this.setCullFace(value);
                        break;
                    case exports.RenderStateType.FrontFace:
                        this.setFrontFace(this._getGLFrontfaceFactor(value));
                        break;
                    default:
                        throw "unknow type of renderStateType";
                }
            });
        }
    }

    class ShaderVariable {
        constructor() {
            this.textureID = -1;
        }
    }

    class GLShaderInstance extends GLObject {
        constructor(engine, vs, ps, attributeMap) {
            super(engine);
            this._complete = true;
            this._vs = vs;
            this._ps = ps;
            this._attributeMap = attributeMap;
            this._uniformMap = [];
            this._create();
        }
        _create() {
            const gl = this._gl;
            this._program = gl.createProgram();
            this._vshader = this._createShader(gl, this._vs, gl.VERTEX_SHADER);
            this._pshader = this._createShader(gl, this._ps, gl.FRAGMENT_SHADER);
            gl.attachShader(this._program, this._vshader);
            gl.attachShader(this._program, this._pshader);
            for (var k in this._attributeMap)
                gl.bindAttribLocation(this._program, this._attributeMap[k][0], k);
            gl.linkProgram(this._program);
            const bo = gl.getProgramParameter(this._program, gl.LINK_STATUS);
            if (!bo) {
                var info = gl.getProgramInfoLog(this._program);
                console.error(new Error('Could not compile WebGL program. \n\n' + info));
                this._complete = false;
                return;
            }
            const nUniformNum = gl.getProgramParameter(this._program, gl.ACTIVE_UNIFORMS);
            this.useProgram();
            this._curActTexIndex = 0;
            let one, i;
            for (i = 0; i < nUniformNum; i++) {
                var uniformData = gl.getActiveUniform(this._program, i);
                var uniName = uniformData.name;
                let location = gl.getUniformLocation(this._program, uniName);
                if (!location && location != 0)
                    continue;
                one = new ShaderVariable();
                one.location = location;
                if (uniName.indexOf('[0]') > 0) {
                    one.name = uniName = uniName.substr(0, uniName.length - 3);
                    one.isArray = true;
                }
                else {
                    one.name = uniName;
                    one.isArray = false;
                }
                one.type = uniformData.type;
                this._addShaderUnifiormFun(one);
                this._uniformMap.push(one);
                one.dataOffset = this._engine.propertyNameToID(uniName);
            }
            if (this._engine.isWebGL2) {
                this._uniformObjectMap = {};
                var nUniformBlock = gl.getProgramParameter(this._program, gl.ACTIVE_UNIFORM_BLOCKS);
                for (i = 0; i < nUniformBlock; i++) {
                    let gl2 = gl;
                    var uniformBlockName = gl2.getActiveUniformBlockName(this._program, i);
                    one = new ShaderVariable();
                    one.name = uniformBlockName;
                    one.isArray = false;
                    one.type = gl.UNIFORM_BUFFER;
                    one.dataOffset = this._engine.propertyNameToID(uniformBlockName);
                    let location = one.location = gl2.getUniformBlockIndex(this._program, uniformBlockName);
                    gl2.uniformBlockBinding(this._program, location, this._engine.getUBOPointer(uniformBlockName));
                    this._uniformObjectMap[one.name] = one;
                    this._uniformMap.push(one);
                    this._addShaderUnifiormFun(one);
                }
            }
        }
        _legalUBObyteLength(bytelength) {
            return Math.ceil(bytelength / 16) * 16;
        }
        _createShader(gl, str, type) {
            var shader = gl.createShader(type);
            gl.shaderSource(shader, str);
            gl.compileShader(shader);
            if (this._engine._isShaderDebugMode && !gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                if (!LayaEnv.isPlaying) {
                    console.warn(gl.getShaderInfoLog(shader));
                }
                else {
                    console.error(gl.getShaderInfoLog(shader));
                }
            }
            return shader;
        }
        _addShaderUnifiormFun(one) {
            var gl = this._gl;
            one.caller = this;
            var isArray = one.isArray;
            switch (one.type) {
                case gl.BOOL:
                    one.fun = this._uniform1i;
                    one.uploadedValue = new Array(1);
                    break;
                case gl.INT:
                    one.fun = isArray ? this._uniform1iv : this._uniform1i;
                    one.uploadedValue = new Array(1);
                    break;
                case gl.FLOAT:
                    one.fun = isArray ? this._uniform1fv : this._uniform1f;
                    one.uploadedValue = new Array(1);
                    break;
                case gl.FLOAT_VEC2:
                    one.fun = isArray ? this._uniform_vec2v : this._uniform_vec2;
                    one.uploadedValue = new Array(2);
                    break;
                case gl.FLOAT_VEC3:
                    one.fun = isArray ? this._uniform_vec3v : this._uniform_vec3;
                    one.uploadedValue = new Array(3);
                    break;
                case gl.FLOAT_VEC4:
                    one.fun = isArray ? this._uniform_vec4v : this._uniform_vec4;
                    one.uploadedValue = new Array(4);
                    break;
                case gl.FLOAT_MAT2:
                    one.fun = this._uniformMatrix2fv;
                    break;
                case gl.FLOAT_MAT3:
                    one.fun = this._uniformMatrix3fv;
                    break;
                case gl.FLOAT_MAT4:
                    one.fun = isArray ? this._uniformMatrix4fv : this._uniformMatrix4f;
                    break;
                case gl.SAMPLER_2D:
                case gl.SAMPLER_2D_SHADOW:
                    gl.uniform1i(one.location, this._curActTexIndex);
                    one.textureID = this._engine._glTextureIDParams[this._curActTexIndex++];
                    one.fun = this._uniform_sampler2D;
                    break;
                case 0x8b5f:
                    gl.uniform1i(one.location, this._curActTexIndex);
                    one.textureID = this._engine._glTextureIDParams[this._curActTexIndex++];
                    one.fun = this._uniform_sampler3D;
                    break;
                case gl.SAMPLER_CUBE:
                    gl.uniform1i(one.location, this._curActTexIndex);
                    one.textureID = this._engine._glTextureIDParams[this._curActTexIndex++];
                    one.fun = this._uniform_samplerCube;
                    break;
                case gl.UNIFORM_BUFFER:
                    one.fun = this._uniform_UniformBuffer;
                    break;
                default:
                    throw new Error("compile shader err!");
            }
        }
        getUniformMap() {
            return this._uniformMap;
        }
        bind() {
            return this.useProgram();
        }
        useProgram() {
            if (this._engine._glUseProgram === this)
                return false;
            this._gl.useProgram(this._program);
            this._engine._glUseProgram = this;
            return true;
        }
        _uniform1f(one, value) {
            var uploadedValue = one.uploadedValue;
            if (uploadedValue[0] !== value) {
                this._gl.uniform1f(one.location, uploadedValue[0] = value);
                return 1;
            }
            return 0;
        }
        _uniform1fv(one, value) {
            if (value.length < 4) {
                var uploadedValue = one.uploadedValue;
                if (uploadedValue[0] !== value[0] || uploadedValue[1] !== value[1] || uploadedValue[2] !== value[2] || uploadedValue[3] !== value[3]) {
                    this._gl.uniform1fv(one.location, value);
                    uploadedValue[0] = value[0];
                    uploadedValue[1] = value[1];
                    uploadedValue[2] = value[2];
                    uploadedValue[3] = value[3];
                    return 1;
                }
                return 0;
            }
            else {
                this._gl.uniform1fv(one.location, value);
                return 1;
            }
        }
        _uniform_vec2(one, v) {
            var uploadedValue = one.uploadedValue;
            if (uploadedValue[0] !== v.x || uploadedValue[1] !== v.y) {
                this._gl.uniform2f(one.location, uploadedValue[0] = v.x, uploadedValue[1] = v.y);
                return 1;
            }
            return 0;
        }
        _uniform_vec2v(one, value) {
            if (value.length < 2) {
                var uploadedValue = one.uploadedValue;
                if (uploadedValue[0] !== value[0] || uploadedValue[1] !== value[1] || uploadedValue[2] !== value[2] || uploadedValue[3] !== value[3]) {
                    this._gl.uniform2fv(one.location, value);
                    uploadedValue[0] = value[0];
                    uploadedValue[1] = value[1];
                    uploadedValue[2] = value[2];
                    uploadedValue[3] = value[3];
                    return 1;
                }
                return 0;
            }
            else {
                this._gl.uniform2fv(one.location, value);
                return 1;
            }
        }
        _uniform_vec3(one, v) {
            var uploadedValue = one.uploadedValue;
            if (uploadedValue[0] !== v.x || uploadedValue[1] !== v.y || uploadedValue[2] !== v.z) {
                this._gl.uniform3f(one.location, uploadedValue[0] = v.x, uploadedValue[1] = v.y, uploadedValue[2] = v.z);
                return 1;
            }
            return 0;
        }
        _uniform_vec3v(one, v) {
            this._gl.uniform3fv(one.location, v);
            return 1;
        }
        _uniform_vec4(one, v) {
            var uploadedValue = one.uploadedValue;
            if (uploadedValue[0] !== v.x || uploadedValue[1] !== v.y || uploadedValue[2] !== v.z || uploadedValue[3] !== v.w) {
                this._gl.uniform4f(one.location, uploadedValue[0] = v.x, uploadedValue[1] = v.y, uploadedValue[2] = v.z, uploadedValue[3] = v.w);
                return 1;
            }
            return 0;
        }
        _uniform_vec4v(one, v) {
            this._gl.uniform4fv(one.location, v);
            return 1;
        }
        _uniformMatrix2fv(one, value) {
            this._gl.uniformMatrix2fv(one.location, false, value);
            return 1;
        }
        _uniformMatrix3fv(one, value) {
            this._gl.uniformMatrix3fv(one.location, false, value);
            return 1;
        }
        _uniformMatrix4f(one, m) {
            var value = m.elements;
            this._gl.uniformMatrix4fv(one.location, false, value);
            return 1;
        }
        _uniformMatrix4fv(one, m) {
            this._gl.uniformMatrix4fv(one.location, false, m);
            return 1;
        }
        _uniform1i(one, value) {
            var uploadedValue = one.uploadedValue;
            if (uploadedValue[0] !== value) {
                this._gl.uniform1i(one.location, uploadedValue[0] = value);
                return 1;
            }
            return 0;
        }
        _uniform1iv(one, value) {
            this._gl.uniform1iv(one.location, value);
            return 1;
        }
        _uniform_ivec2(one, value) {
            var uploadedValue = one.uploadedValue;
            if (uploadedValue[0] !== value[0] || uploadedValue[1] !== value[1]) {
                this._gl.uniform2i(one.location, uploadedValue[0] = value[0], uploadedValue[1] = value[1]);
                return 1;
            }
            return 0;
        }
        _uniform_ivec2v(one, value) {
            this._gl.uniform2iv(one.location, value);
            return 1;
        }
        _uniform_vec3i(one, value) {
            var uploadedValue = one.uploadedValue;
            if (uploadedValue[0] !== value[0] || uploadedValue[1] !== value[1] || uploadedValue[2] !== value[2]) {
                this._gl.uniform3i(one.location, uploadedValue[0] = value[0], uploadedValue[1] = value[1], uploadedValue[2] = value[2]);
                return 1;
            }
            return 0;
        }
        _uniform_vec3vi(one, value) {
            this._gl.uniform3iv(one.location, value);
            return 1;
        }
        _uniform_vec4i(one, value) {
            var uploadedValue = one.uploadedValue;
            if (uploadedValue[0] !== value[0] || uploadedValue[1] !== value[1] || uploadedValue[2] !== value[2] || uploadedValue[3] !== value[3]) {
                this._gl.uniform4i(one.location, uploadedValue[0] = value[0], uploadedValue[1] = value[1], uploadedValue[2] = value[2], uploadedValue[3] = value[3]);
                return 1;
            }
            return 0;
        }
        _uniform_vec4vi(one, value) {
            this._gl.uniform4iv(one.location, value);
            return 1;
        }
        _uniform_sampler2D(one, texture) {
            var value = texture._getSource() || texture.defaultTexture._getSource();
            var gl = this._gl;
            this._bindTexture(one.textureID, gl.TEXTURE_2D, value);
            return 0;
        }
        _uniform_sampler3D(one, texture) {
            var value = texture._getSource() || texture.defaultTexture._getSource();
            this._bindTexture(one.textureID, WebGL2RenderingContext.TEXTURE_3D, value);
            return 0;
        }
        _uniform_samplerCube(one, texture) {
            var value = texture._getSource() || texture.defaultTexture._getSource();
            var gl = this._gl;
            this._bindTexture(one.textureID, gl.TEXTURE_CUBE_MAP, value);
            return 0;
        }
        _uniform_UniformBuffer(one, value) {
            value._bindUniformBufferBase();
        }
        _bindTexture(textureID, target, texture) {
            const gl = this._gl;
            if (this._engine._activedTextureID !== textureID) {
                gl.activeTexture(textureID);
                this._engine._activedTextureID = textureID;
            }
            const texID = this._engine._activedTextureID - this._gl.TEXTURE0;
            if (this._engine._activeTextures[texID] !== texture) {
                gl.bindTexture(target, texture);
                this._engine._activeTextures[texID] = texture;
            }
        }
        destroy() {
            super.destroy();
            const gl = this._gl;
            gl.deleteShader(this._vshader);
            gl.deleteShader(this._pshader);
            gl.deleteProgram(this._program);
            this._vshader = null;
            this._pshader = null;
            this._program = null;
            this._attributeMap = null;
            this._uniformMap = null;
            this._uniformObjectMap = null;
            this._gl = null;
            this._engine = null;
        }
    }

    class GLVertexState extends GLObject {
        constructor(engine) {
            super(engine);
            this._vertexDeclaration = [];
            if (!engine.isWebGL2)
                this._vaoExt = engine._supportCapatable.getExtension(exports.WebGLExtension.OES_vertex_array_object);
            this._vao = this.createVertexArray();
            this._angleInstancedArrays = this._engine._supportCapatable.getExtension(exports.WebGLExtension.ANGLE_instanced_arrays);
        }
        createVertexArray() {
            if (this._engine.isWebGL2)
                return this._gl.createVertexArray();
            else
                return this._vaoExt.createVertexArrayOES();
        }
        deleteVertexArray() {
            if (this._engine.isWebGL2)
                this._gl.deleteVertexArray(this._vao);
            else
                this._vaoExt.deleteVertexArrayOES(this._vao);
        }
        bindVertexArray() {
            if (this._engine._GLBindVertexArray == this)
                return;
            if (this._engine.isWebGL2)
                this._gl.bindVertexArray(this._vao);
            else
                this._vaoExt.bindVertexArrayOES(this._vao);
            this._engine._GLBindVertexArray = this;
        }
        unbindVertexArray() {
            if (this._engine.isWebGL2)
                this._gl.bindVertexArray(null);
            else
                this._vaoExt.bindVertexArrayOES(null);
            this._engine._GLBindVertexArray = null;
        }
        isVertexArray() {
            if (this._engine.isWebGL2)
                this._gl.isVertexArray(this._vao);
            else
                this._vaoExt.isVertexArrayOES(this._vao);
        }
        applyVertexBuffer(vertexBuffer) {
            this.clearVAO();
            this._vertexBuffers = vertexBuffer;
            if (this._engine._GLBindVertexArray == this) {
                this._vertexDeclaration.length = vertexBuffer.length;
                var i = 0;
                vertexBuffer.forEach(element => {
                    var verDec = element.vertexDeclaration;
                    this._vertexDeclaration[i++] = element.vertexDeclaration;
                    var valueData = verDec._shaderValues;
                    element.bind();
                    for (var k in valueData) {
                        var loc = parseInt(k);
                        var attribute = valueData[k];
                        this._gl.enableVertexAttribArray(loc);
                        this._gl.vertexAttribPointer(loc, attribute[0], attribute[1], !!attribute[2], attribute[3], attribute[4]);
                        if (element.instanceBuffer)
                            this.vertexAttribDivisor(loc, 1);
                    }
                });
            }
            else {
                throw "BufferState: must call bind() function first.";
            }
        }
        clearVAO() {
            for (let i = 0, n = this._vertexDeclaration.length; i < n; i++) {
                var verDec = this._vertexDeclaration[i];
                var valueData = verDec._shaderValues;
                for (var k in valueData) {
                    var loc = parseInt(k);
                    this._gl.disableVertexAttribArray(loc);
                }
            }
        }
        applyIndexBuffer(indexBuffer) {
            if (indexBuffer == null) {
                return;
            }
            if (this._engine._GLBindVertexArray == this) {
                if (this._bindedIndexBuffer !== indexBuffer) {
                    indexBuffer.bind();
                    this._bindedIndexBuffer = indexBuffer;
                }
            }
            else {
                throw "BufferState: must call bind() function first.";
            }
        }
        vertexAttribDivisor(index, divisor) {
            if (this._engine.isWebGL2)
                this._gl.vertexAttribDivisor(index, divisor);
            else
                this._angleInstancedArrays.vertexAttribDivisorANGLE(index, divisor);
        }
        destroy() {
            super.destroy();
            this._gl;
            this.deleteVertexArray();
            this._gl = null;
            this._engine = null;
        }
    }

    class WebGLEngine {
        constructor(config, webglMode = exports.WebGLMode.Auto) {
            this._propertyNameMap = {};
            this._propertyNameCounter = 0;
            this._IDCounter = 0;
            this._isShaderDebugMode = true;
            this._curUBOPointer = 0;
            this._GLUBOPointerMap = new Map();
            this._GLBindPointerUBOMap = new Map();
            this._lastClearColor = new Color;
            this._lastClearDepth = 1;
            this._GLStatisticsInfo = new Map();
            this._config = config;
            this._isWebGL2 = false;
            this._lastViewport = new Vector4(0, 0, 0, 0);
            this._lastClearColor = new Color(0, 0, 0, 0);
            this._lastScissor = new Vector4(0, 0, 0, 0);
            this._webglMode = webglMode;
            this._initStatisticsInfo();
        }
        get gl() {
            return this._gl;
        }
        get isWebGL2() {
            return this._isWebGL2;
        }
        get webglConfig() {
            return this._config;
        }
        _initStatisticsInfo() {
            this._GLStatisticsInfo.set(exports.RenderStatisticsInfo.DrawCall, 0);
            this._GLStatisticsInfo.set(exports.RenderStatisticsInfo.InstanceDrawCall, 0);
            this._GLStatisticsInfo.set(exports.RenderStatisticsInfo.Triangle, 0);
            this._GLStatisticsInfo.set(exports.RenderStatisticsInfo.UniformUpload, 0);
            this._GLStatisticsInfo.set(exports.RenderStatisticsInfo.TextureMemeory, 0);
            this._GLStatisticsInfo.set(exports.RenderStatisticsInfo.GPUMemory, 0);
            this._GLStatisticsInfo.set(exports.RenderStatisticsInfo.RenderTextureMemory, 0);
            this._GLStatisticsInfo.set(exports.RenderStatisticsInfo.BufferMemory, 0);
        }
        _addStatisticsInfo(info, value) {
            this._GLStatisticsInfo.set(info, this._GLStatisticsInfo.get(info) + value);
        }
        clearStatisticsInfo(info) {
            this._GLStatisticsInfo.set(info, 0);
        }
        getStatisticsInfo(info) {
            return this._GLStatisticsInfo.get(info);
        }
        _getBindUBOBuffer(glPointer) {
            return this._GLBindPointerUBOMap.get(glPointer);
        }
        _setBindUBOBuffer(glPointer, buffer) {
            this._GLBindPointerUBOMap.set(glPointer, buffer);
        }
        initRenderEngine(canvas) {
            let names;
            let gl;
            switch (this._webglMode) {
                case exports.WebGLMode.Auto:
                    names = ["webgl2", "experimental-webgl2", "webgl", "experimental-webgl"];
                    break;
                case exports.WebGLMode.WebGL1:
                    names = ["webgl", "experimental-webgl"];
                    break;
                case exports.WebGLMode.WebGL2:
                    names = ["webgl2", "experimental-webgl2"];
                    break;
            }
            for (var i = 0; i < names.length; i++) {
                try {
                    gl = canvas.getContext(names[i], this._config);
                }
                catch (e) {
                }
                if (gl) {
                    if (names[i] === 'webgl2' || names[i] === 'experimental-webgl2') {
                        this._isWebGL2 = true;
                    }
                    break;
                }
            }
            this._gl = gl;
            this._initBindBufferMap();
            this._supportCapatable = new GlCapable(this);
            this._GLParams = new GLParams(this);
            this._GLRenderState = new GLRenderState(this);
            this._glTextureIDParams = [gl.TEXTURE0, gl.TEXTURE1, gl.TEXTURE2, gl.TEXTURE3, gl.TEXTURE4, gl.TEXTURE5, gl.TEXTURE6, gl.TEXTURE7, gl.TEXTURE8, gl.TEXTURE9, gl.TEXTURE10, gl.TEXTURE11, gl.TEXTURE12, gl.TEXTURE13, gl.TEXTURE14, gl.TEXTURE15, gl.TEXTURE16, gl.TEXTURE17, gl.TEXTURE18, gl.TEXTURE19, gl.TEXTURE20, gl.TEXTURE21, gl.TEXTURE22, gl.TEXTURE23, gl.TEXTURE24, gl.TEXTURE25, gl.TEXTURE26, gl.TEXTURE27, gl.TEXTURE28, gl.TEXTURE29, gl.TEXTURE30, gl.TEXTURE31];
            this._activedTextureID = gl.TEXTURE0;
            this._activeTextures = [];
            this._GLTextureContext = this.isWebGL2 ? new GL2TextureContext(this) : new GLTextureContext(this);
            this._GLRenderDrawContext = new GLRenderDrawContext(this);
            this._GL2DRenderContext = new GLRender2DContext(this);
        }
        _initBindBufferMap() {
            this._GLBufferBindMap = {};
            this._GLBufferBindMap[exports.BufferTargetType.ARRAY_BUFFER] = null;
            this._GLBufferBindMap[exports.BufferTargetType.ELEMENT_ARRAY_BUFFER] = null;
            this._GLBufferBindMap[exports.BufferTargetType.UNIFORM_BUFFER] = null;
        }
        _getbindBuffer(target) {
            return this._GLBufferBindMap[target];
        }
        _setbindBuffer(target, buffer) {
            this._GLBufferBindMap[target] = buffer;
        }
        _bindTexture(target, texture) {
            const texID = this._activedTextureID - this._gl.TEXTURE0;
            if (this._activeTextures[texID] !== texture) {
                this._gl.bindTexture(target, texture);
                this._activeTextures[texID] = texture;
            }
        }
        bindTexture(texture) {
            this._bindTexture(texture._texture.target, texture._getSource());
        }
        applyRenderStateCMD(cmd) {
            this._GLRenderState.applyRenderStateCommand(cmd);
        }
        getCapable(capatableType) {
            return this._supportCapatable.getCapable(capatableType);
        }
        viewport(x, y, width, height) {
            const gl = this._gl;
            const lv = this._lastViewport;
            if (LayaEnv.isConch) {
                gl.viewport(x, y, width, height);
            }
            else if (x !== lv.x || y !== lv.y || width !== lv.z || height !== lv.w) {
                gl.viewport(x, y, width, height);
                lv.setValue(x, y, width, height);
            }
        }
        scissor(x, y, width, height) {
            const gl = this._gl;
            const lv = this._lastScissor;
            if (LayaEnv.isConch) {
                gl.scissor(x, y, width, height);
            }
            else if (x !== lv.x || y !== lv.y || width !== lv.z || height !== lv.w) {
                gl.scissor(x, y, width, height);
                lv.setValue(x, y, width, height);
            }
        }
        scissorTest(value) {
            if (value)
                this._gl.enable(this._gl.SCISSOR_TEST);
            else
                this._gl.disable(this._gl.SCISSOR_TEST);
        }
        clearRenderTexture(clearFlag, clearcolor = null, clearDepth = 1) {
            var flag;
            if (clearFlag & exports.RenderClearFlag.Color) {
                if (clearcolor && !this._lastClearColor.equal(clearcolor)) {
                    this._gl.clearColor(clearcolor.r, clearcolor.g, clearcolor.b, clearcolor.a);
                    clearcolor.cloneTo(this._lastClearColor);
                }
                flag |= this.gl.COLOR_BUFFER_BIT;
            }
            if (clearFlag & exports.RenderClearFlag.Depth) {
                if (this._lastClearDepth != clearDepth) {
                    this._gl.clearDepth(clearDepth);
                    this._lastClearDepth = clearDepth;
                }
                this._GLRenderState.setDepthMask(true);
                flag |= this._gl.DEPTH_BUFFER_BIT;
            }
            if (clearFlag & exports.RenderClearFlag.Stencil) {
                this._gl.clearStencil(0);
                this._GLRenderState.setStencilMask(true);
                flag |= this._gl.STENCIL_BUFFER_BIT;
            }
            this._gl.clear(flag);
        }
        copySubFrameBuffertoTex(texture, level, xoffset, yoffset, x, y, width, height) {
            this._bindTexture(texture._texture.target, texture._getSource());
            this._gl.copyTexSubImage2D(texture._texture.target, level, xoffset, yoffset, x, y, width, height);
        }
        colorMask(r, g, b, a) {
            this._gl.colorMask(r, g, b, a);
        }
        getParams(params) {
            return this._GLParams.getParams(params);
        }
        createBuffer(targetType, bufferUsageType) {
            return new GLBuffer(this, targetType, bufferUsageType);
        }
        createShaderInstance(vs, ps, attributeMap) {
            return new GLShaderInstance(this, vs, ps, attributeMap);
        }
        createVertexState() {
            return new GLVertexState(this);
        }
        getUBOPointer(name) {
            if (!this._GLUBOPointerMap.has(name))
                this._GLUBOPointerMap.set(name, this._curUBOPointer++);
            return this._GLUBOPointerMap.get(name);
        }
        getTextureContext() {
            return this._GLTextureContext;
        }
        getDrawContext() {
            return this._GLRenderDrawContext;
        }
        get2DRenderContext() {
            return this._GL2DRenderContext;
        }
        getCreateRenderOBJContext() {
            return this._renderOBJCreateContext;
        }
        propertyNameToID(name) {
            if (this._propertyNameMap[name] != null) {
                return this._propertyNameMap[name];
            }
            else {
                var id = this._propertyNameCounter++;
                this._propertyNameMap[name] = id;
                this._propertyNameMap[id] = name;
                return id;
            }
        }
        propertyIDToName(id) {
            return this._propertyNameMap[id];
        }
        uploadUniforms(shader, commandEncoder, shaderData, uploadUnTexture) {
            shader.bind();
            var data = shaderData._data;
            var shaderUniform = commandEncoder.getArrayData();
            var shaderCall = 0;
            for (var i = 0, n = shaderUniform.length; i < n; i++) {
                var one = shaderUniform[i];
                if (uploadUnTexture || one.textureID !== -1) {
                    var value = data[one.dataOffset];
                    if (value != null)
                        shaderCall += one.fun.call(one.caller, one, value);
                }
            }
            return shaderCall;
        }
        uploadCustomUniforms(shader, custom, index, data) {
            shader.bind();
            var shaderCall = 0;
            var one = custom[index];
            if (one && data != null)
                shaderCall += one.fun.call(one.caller, one, data);
            return shaderCall;
        }
        createRenderStateComand() {
            return new RenderStateCommand();
        }
    }

    class NativeGLObject {
        constructor(engine) {
            this._destroyed = false;
            this._engine = engine;
            this._gl = this._engine.gl;
            this._id = this._engine._IDCounter++;
        }
        get destroyed() {
            return this._destroyed;
        }
        setResourceManager() {
        }
        ;
        destroy() {
            if (this._destroyed)
                return;
            this._destroyed = true;
        }
    }

    class NativeGLTextureContext extends NativeGLObject {
        constructor(engine, native) {
            super(engine);
            this._native = native;
        }
        createTextureInternal(dimension, width, height, format, gengerateMipmap, sRGB) {
            return this._native.createTextureInternal(dimension, width, height, format, gengerateMipmap, sRGB);
        }
        setTextureImageData(texture, source, premultiplyAlpha, invertY) {
            this._native.setTextureImageData(texture, source._nativeObj.conchImgId, premultiplyAlpha, invertY);
        }
        setTexturePixelsData(texture, source, premultiplyAlpha, invertY) {
            this._native.setTexturePixelsData(texture, source, premultiplyAlpha, invertY);
        }
        initVideoTextureData(texture) {
        }
        setTextureSubPixelsData(texture, source, mipmapLevel, generateMipmap, xOffset, yOffset, width, height, premultiplyAlpha, invertY) {
            this._native.setTextureSubPixelsData(texture, source, mipmapLevel, generateMipmap, xOffset, yOffset, width, height, premultiplyAlpha, invertY);
        }
        setTexturebySubImageData(texture, source, x, y, premultiplyAlpha, invertY) {
        }
        setTextureHDRData(texture, hdrInfo) {
            let sourceData = hdrInfo.readScanLine();
            this.setTexturePixelsData(texture, sourceData, false, false);
        }
        setTextureDDSData(texture, ddsInfo) {
            throw new Error("setTextureDDSData Method not implemented.");
        }
        setTextureKTXData(texture, ktxInfo) {
            throw new Error("setTextureKTXData Method not implemented.");
        }
        setCubeImageData(texture, sources, premultiplyAlpha, invertY) {
            var images = [];
            var length = sources.length;
            for (let index = 0; index < length; index++) {
                images.push(sources[index]._nativeObj);
            }
            this._native.setCubeImageData(texture, images, premultiplyAlpha, invertY);
        }
        setCubePixelsData(texture, source, premultiplyAlpha, invertY) {
            this._native.setCubePixelsData(texture, source, premultiplyAlpha, invertY);
        }
        setCubeSubPixelData(texture, source, mipmapLevel, generateMipmap, xOffset, yOffset, width, height, premultiplyAlpha, invertY) {
            this._native.setCubeSubPixelData(texture, source, mipmapLevel, generateMipmap, xOffset, yOffset, width, height, premultiplyAlpha, invertY);
        }
        setCubeDDSData(texture, ddsInfo) {
            throw new Error("setCubeDDSData Method not implemented.");
        }
        setCubeKTXData(texture, ktxInfo) {
            throw new Error("setCubeKTXData Method not implemented.");
        }
        setTextureCompareMode(texture, compareMode) {
            return this._native.setTextureCompareMode(texture, compareMode);
        }
        bindRenderTarget(renderTarget) {
            this._native.bindRenderTarget(renderTarget);
        }
        bindoutScreenTarget() {
            this._native.bindoutScreenTarget();
        }
        unbindRenderTarget(renderTarget) {
            this._native.unbindRenderTarget(renderTarget);
        }
        createRenderTextureInternal(dimension, width, height, format, generateMipmap, sRGB) {
            return this._native.createRenderTextureInternal(dimension, width, height, format, generateMipmap, sRGB);
        }
        createRenderTargetInternal(width, height, colorFormat, depthStencilFormat, generateMipmap, sRGB, multiSamples) {
            return this._native.createRenderTargetInternal(width, height, colorFormat, depthStencilFormat ? depthStencilFormat : exports.RenderTargetFormat.None, generateMipmap, sRGB, multiSamples);
        }
        createRenderTargetCubeInternal(size, colorFormat, depthStencilFormat, generateMipmap, sRGB, multiSamples) {
            return this._native.createRenderTargetCubeInternal(size, colorFormat, depthStencilFormat, generateMipmap, sRGB, multiSamples);
        }
        createRenderTextureCubeInternal(dimension, size, format, generateMipmap, sRGB) {
            throw new Error("createRenderTextureCubeInternal Method not implemented.");
        }
        setupRendertargetTextureAttachment(renderTarget, texture) {
            this._native.setupRendertargetTextureAttachment(renderTarget, texture);
        }
        readRenderTargetPixelData(renderTarget, xOffset, yOffset, width, height, out) {
            return this._native.readRenderTargetPixelData(renderTarget, xOffset, yOffset, width, height, out);
        }
        updateVideoTexture(texture, video, premultiplyAlpha, invertY) {
            this._native.updateVideoTexture(texture, video._nativeObj.conchImgId, premultiplyAlpha, invertY);
        }
        getRenderTextureData(internalTex, x, y, width, height) {
            return this._native.getRenderTextureData(internalTex, x, y, width, height);
        }
    }

    class NativeGL2TextureContext extends NativeGLTextureContext {
        constructor(engine, native) {
            super(engine, native);
        }
    }

    class NativeGLVertexState extends NativeGLObject {
        constructor(engine) {
            super(engine);
            this._vertexDeclaration = [];
            this._nativeObj = new window.conchGLVertexState(engine._nativeObj);
            this._nativeVertexBuffers = [];
        }
        bindVertexArray() {
            this._nativeObj.bindVertexArray();
        }
        unbindVertexArray() {
            this._nativeObj.unbindVertexArray();
        }
        applyVertexBuffer(vertexBuffer) {
            this._vertexBuffers = vertexBuffer;
            this._nativeVertexBuffers.length = 0;
            vertexBuffer.forEach((element) => {
                this._nativeVertexBuffers.push(element._conchVertexBuffer3D);
            });
            this._nativeObj.applyVertexBuffer(this._nativeVertexBuffers);
        }
        applyIndexBuffer(indexBuffer) {
            if (indexBuffer == null) {
                return;
            }
            this._bindedIndexBuffer = indexBuffer;
            this._nativeObj.applyIndexBuffer(indexBuffer._conchIndexBuffer3D);
        }
        destroy() {
            this._vertexBuffers = null;
            this._nativeVertexBuffers = [];
            this._bindedIndexBuffer = null;
            super.destroy();
            this._nativeObj.destroy();
        }
    }

    class NativeGLRenderDrawContext extends NativeGLObject {
        constructor(engine) {
            super(engine);
            this._nativeObj = new window.conchGLRenderDrawContext(engine._nativeObj);
        }
        drawElementsInstanced(mode, count, type, offset, instanceCount) {
            this._nativeObj.drawElementsInstanced(mode, count, type, offset, instanceCount);
        }
        drawArraysInstanced(mode, first, count, instanceCount) {
            this._nativeObj.drawArraysInstanced(mode, first, count, instanceCount);
        }
        drawArrays(mode, first, count) {
            this._nativeObj.drawArrays(mode, first, count);
        }
        drawElements(mode, count, type, offset) {
            this._nativeObj.drawElements(mode, count, type, offset);
        }
        drawGeometryElement(geometryElement) {
            this._nativeObj.drawGeometryElement(geometryElement._nativeObj);
        }
    }

    class NativeRenderStateCommand extends RenderStateCommand {
        constructor() {
            super();
            this._nativeObj = new window.conchRenderStateCommand();
        }
        addCMD(renderstate, value) {
            switch (renderstate) {
                case exports.RenderStateType.DepthTest:
                case exports.RenderStateType.DepthMask:
                case exports.RenderStateType.DepthFunc:
                case exports.RenderStateType.StencilTest:
                case exports.RenderStateType.StencilMask:
                case exports.RenderStateType.BlendEquation:
                case exports.RenderStateType.CullFace:
                case exports.RenderStateType.FrontFace:
                    this._nativeObj.addCMDInt1(renderstate, value);
                    break;
                case exports.RenderStateType.StencilFunc:
                case exports.RenderStateType.BlendFunc:
                case exports.RenderStateType.BlendEquationSeparate:
                    this._nativeObj.addCMDInt2(renderstate, value[0], value[1]);
                    break;
                case exports.RenderStateType.StencilOp:
                    this._nativeObj.addCMDInt3(renderstate, value[0], value[1], value[2]);
                    break;
                case exports.RenderStateType.BlendType:
                    this._nativeObj.addCMDInt1(renderstate, value != exports.BlendType.BLEND_DISABLE ? 1 : 0);
                    break;
                case exports.RenderStateType.BlendFuncSeperate:
                    this._nativeObj.addCMDInt4(renderstate, value[0], value[1], value[2], value[3]);
                    break;
                default:
                    throw "unknow type of renderStateType";
            }
        }
        applyCMD() {
            LayaGL.renderEngine.applyRenderStateCMD(this);
        }
        clear() {
            this._nativeObj.clear();
        }
    }

    class NativeWebGLEngine {
        constructor(config, webglMode = exports.WebGLMode.Auto) {
            this._isShaderDebugMode = true;
            this._nativeObj = new window.conchWebGLEngine(webglMode);
        }
        createRenderStateComand() {
            return new NativeRenderStateCommand();
        }
        getUBOPointer(name) {
            return this._nativeObj.getUBOPointer(name);
        }
        _addStatisticsInfo(info, value) {
            this._nativeObj.addStatisticsInfo(info, value);
        }
        clearStatisticsInfo(info) {
            this._nativeObj.clearStatisticsInfo(info);
        }
        getStatisticsInfo(info) {
            return this._nativeObj.getStatisticsInfo(info);
        }
        get gl() {
            return this._gl;
        }
        get isWebGL2() {
            return this._nativeObj.isWebGL2;
        }
        get webglConfig() {
            return this._config;
        }
        initRenderEngine(canvas) {
            this._nativeObj.initRenderEngine();
            this._GLRenderDrawContext = new NativeGLRenderDrawContext(this);
            if (this.isWebGL2) {
                this._GLTextureContext = new NativeGL2TextureContext(this, new window.conchGL2TextureContext(this._nativeObj));
            }
            else {
                this._GLTextureContext = new NativeGLTextureContext(this, new window.conchGLTextureContext(this._nativeObj));
            }
        }
        bindTexture(texture) {
            throw new Error("Method not implemented.");
        }
        applyRenderStateCMD(cmd) {
            this._nativeObj.applyRenderStateCommand(cmd._nativeObj);
        }
        getCapable(capatableType) {
            return this._nativeObj.getCapable(capatableType);
        }
        viewport(x, y, width, height) {
            this._nativeObj.viewport(x, y, width, height);
        }
        scissor(x, y, width, height) {
            this._nativeObj.scissor(x, y, width, height);
        }
        scissorTest(value) {
            this._nativeObj.scissorTest(value);
        }
        clearRenderTexture(clearFlag, clearcolor = null, clearDepth = 1) {
            if (clearcolor)
                this._nativeObj.clearRenderTexture(clearFlag, true, clearcolor.r, clearcolor.g, clearcolor.b, clearcolor.a, clearDepth);
            else
                this._nativeObj.clearRenderTexture(clearFlag, false, Color.BLACK.r, Color.BLACK.g, Color.BLACK.b, Color.BLACK.a, clearDepth);
        }
        copySubFrameBuffertoTex(texture, level, xoffset, yoffset, x, y, width, height) {
            this._nativeObj.copySubFrameBuffertoTex(texture._texture, level, xoffset, yoffset, x, y, width, height);
        }
        colorMask(r, g, b, a) {
            this._nativeObj.colorMask(r, g, b, a);
        }
        getParams(params) {
            return this._nativeObj.getParams(params);
        }
        createBuffer(targetType, bufferUsageType) {
            return new window.conchGLBuffer(this._nativeObj, targetType, bufferUsageType);
        }
        createShaderInstance(vs, ps, attributeMap) {
            throw new Error("Method not implemented.");
        }
        createVertexState() {
            return new NativeGLVertexState(this);
        }
        getTextureContext() {
            return this._GLTextureContext;
        }
        getDrawContext() {
            return this._GLRenderDrawContext;
        }
        get2DRenderContext() {
            return this._GL2DRenderContext;
        }
        getCreateRenderOBJContext() {
            return this._renderOBJCreateContext;
        }
        propertyNameToID(name) {
            return this._nativeObj.propertyNameToID(name);
        }
        propertyIDToName(id) {
            throw new Error("Method not implemented.");
        }
        uploadUniforms(shader, commandEncoder, shaderData, uploadUnTexture) {
            throw new Error("Method not implemented.");
        }
        uploadCustomUniforms(shader, custom, index, data) {
            throw new Error("Method not implemented.");
        }
    }

    class Render {
        constructor(width, height, mainCanv) {
            this._first = true;
            this._startTm = 0;
            this._timeId = 0;
            Render._Render = this;
            Render._mainCanvas = mainCanv;
            let source = Render._mainCanvas.source;
            source.id = "layaCanvas";
            source.width = width;
            source.height = height;
            if (LayaEnv.isConch) {
                document.body.appendChild(source);
            }
            this.initRender(Render._mainCanvas, width, height);
            window.requestAnimationFrame(loop);
            let me = this;
            performance.now();
            let fps = Config.FPS;
            let ifps = Render.ifps = 1000 / fps;
            function loop(stamp) {
                performance.now();
                if (me._first) {
                    me._startTm = Math.floor(stamp / ifps) * ifps;
                    me._first = false;
                }
                stamp -= me._startTm;
                let frm = Math.floor(stamp / ifps);
                let dfrm = frm - Render.lastFrm;
                if (dfrm > 0 || LayaEnv.isConch) {
                    Render.lastFrm = frm;
                    ILaya.stage._loop();
                }
                if (!!Render._customRequestAnimationFrame && !!Render._loopFunction) {
                    Render._customRequestAnimationFrame(Render._loopFunction);
                }
                else
                    window.requestAnimationFrame(loop);
            }
            ILaya.stage.on("visibilitychange", this, this._onVisibilitychange);
        }
        static customRequestAnimationFrame(value, loopFun) {
            Render._customRequestAnimationFrame = value;
            Render._loopFunction = loopFun;
        }
        static set customRenderEngine(engine) {
            Render._customEngine = engine;
        }
        static get customRenderEngine() {
            return Render._customEngine;
        }
        _onVisibilitychange() {
            if (!ILaya.stage.isVisibility) {
                this._timeId = window.setInterval(this._enterFrame, 1000);
            }
            else if (this._timeId != 0) {
                window.clearInterval(this._timeId);
            }
        }
        static vsyncTime() {
            return Render.lastFrm * Render.ifps;
        }
        initRender(canvas, w, h) {
            let glConfig = { stencil: Config.isStencil, alpha: Config.isAlpha, antialias: Config.isAntialias, premultipliedAlpha: Config.premultipliedAlpha, preserveDrawingBuffer: Config.preserveDrawingBuffer, depth: Config.isDepth, failIfMajorPerformanceCaveat: Config.isfailIfMajorPerformanceCaveat, powerPreference: Config.powerPreference };
            const webglMode = Config.useWebGL2 ? exports.WebGLMode.Auto : exports.WebGLMode.WebGL1;
            let engine;
            if (!Render.customRenderEngine) {
                if (LayaEnv.isConch && !window.conchConfig.conchWebGL) {
                    engine = new NativeWebGLEngine(glConfig, webglMode);
                    engine.initRenderEngine(Render._mainCanvas.source);
                    WebGL._isWebGL2 = engine.isWebGL2;
                }
                else {
                    engine = new WebGLEngine(glConfig, webglMode);
                    engine.initRenderEngine(Render._mainCanvas.source);
                    var gl = RenderStateContext.mainContext = engine.gl;
                    if (Config.printWebglOrder)
                        this._replaceWebglcall(gl);
                    if (!gl)
                        return false;
                    if (gl) {
                        WebGL._isWebGL2 = engine.isWebGL2;
                    }
                }
            }
            else {
                engine = Render.customRenderEngine;
                engine.initRenderEngine(Render._mainCanvas.source);
            }
            LayaGL.renderEngine = engine;
            LayaGL.textureContext = engine.getTextureContext();
            LayaGL.renderDrawContext = engine.getDrawContext();
            LayaGL.render2DContext = engine.get2DRenderContext();
            canvas.size(w, h);
            VertexElementFormat.__init__();
            Context.__init__();
            SubmitBase.__init__();
            var ctx = new Context();
            Context._rendercontex = ctx;
            ctx.isMain = true;
            Render._context = ctx;
            canvas._setContext(ctx);
            ShaderDefines2D.__init__();
            Value2D.__init__();
            Shader2D.__init__();
            BlendMode._init_();
            return true;
        }
        _replaceWebglcall(gl) {
            var tempgl = {};
            for (const key in gl) {
                if (typeof gl[key] == "function" && key != "getError" && key != "__SPECTOR_Origin_getError" && key != "__proto__") {
                    tempgl[key] = gl[key];
                    gl[key] = function () {
                        let arr = [];
                        for (let i = 0; i < arguments.length; i++) {
                            arr.push(arguments[i]);
                        }
                        let result = tempgl[key].apply(gl, arr);
                        let err = gl.getError();
                        if (err) {
                            debugger;
                        }
                        return result;
                    };
                }
            }
        }
        _enterFrame(e = null) {
            ILaya.stage._loop();
        }
        static get context() {
            return Render._context;
        }
        static get canvas() {
            return Render._mainCanvas.source;
        }
    }
    Render.lastFrm = 0;
    Render.ifps = 1000 / 60;

    class Input extends Text {
        constructor() {
            super();
            this._multiline = false;
            this._editable = true;
            this._maxChars = 1E5;
            this._type = "text";
            this._prompt = '';
            this._promptColor = "#A9A9A9";
            this._originColor = "#000000";
            this._content = '';
            Input.IOS_IFRAME = (ILaya.Browser.onIOS && ILaya.Browser.window.top != ILaya.Browser.window.self);
            this._width = 100;
            this._height = 20;
            this.multiline = false;
            this.overflow = Text.SCROLL;
            this.on(Event.MOUSE_DOWN, this, this._onMouseDown);
            this.on(Event.UNDISPLAY, this, this._onUnDisplay);
        }
        static __init__() {
            Input._createInputElement();
            if (ILaya.Browser.onMobile) {
                var isTrue = false;
                if (ILaya.Browser.onMiniGame || ILaya.Browser.onBDMiniGame || ILaya.Browser.onQGMiniGame || ILaya.Browser.onKGMiniGame || ILaya.Browser.onVVMiniGame || ILaya.Browser.onAlipayMiniGame || ILaya.Browser.onQQMiniGame || ILaya.Browser.onBLMiniGame || ILaya.Browser.onTTMiniGame || ILaya.Browser.onHWMiniGame || ILaya.Browser.onTBMiniGame) {
                    isTrue = true;
                }
                Render.canvas.addEventListener(Input.IOS_IFRAME ? (isTrue ? "touchend" : "click") : "touchend", Input._popupInputMethod);
            }
        }
        static _popupInputMethod(e) {
            if (!InputManager.isTextInputting)
                return;
            var input = Input.inputElement;
            input.focus();
        }
        static _createInputElement() {
            Input._initInput(Input.area = ILaya.Browser.createElement("textarea"));
            Input._initInput(Input.input = ILaya.Browser.createElement("input"));
            Input.inputContainer = ILaya.Browser.createElement("div");
            Input.inputContainer.style.position = "absolute";
            Input.inputContainer.style.zIndex = '1E5';
            ILaya.Browser.container.appendChild(Input.inputContainer);
            Input.inputContainer.setPos = function (x, y) {
                Input.inputContainer.style.left = x + 'px';
                Input.inputContainer.style.top = y + 'px';
            };
        }
        static _initInput(input) {
            var style = input.style;
            style.cssText = "position:absolute;overflow:hidden;resize:none;transform-origin:0 0;-webkit-transform-origin:0 0;-moz-transform-origin:0 0;-o-transform-origin:0 0;";
            style.resize = 'none';
            style.backgroundColor = 'transparent';
            style.border = 'none';
            style.outline = 'none';
            style.zIndex = '1';
            input.addEventListener('input', Input._processInputting);
            input.addEventListener('mousemove', Input._stopEvent, { passive: false });
            input.addEventListener('mousedown', Input._stopEvent, { passive: false });
            input.addEventListener('touchmove', Input._stopEvent, { passive: false });
            input.setFontFace = function (fontFace) { input.style.fontFamily = fontFace; };
            if (!(LayaEnv.isConch && !Input.isAppUseNewInput)) {
                input.setColor = function (color) { input.style.color = color; };
                input.setFontSize = function (fontSize) { input.style.fontSize = fontSize + 'px'; };
            }
        }
        static _processInputting(e) {
            var input = Input.inputElement.target;
            if (!input)
                return;
            var value = Input.inputElement.value;
            if (input._restrictPattern) {
                value = value.replace(/\u2006|\x27/g, "");
                if (input._restrictPattern.test(value)) {
                    value = value.replace(input._restrictPattern, "");
                    Input.inputElement.value = value;
                }
            }
            input._text = value;
            input.event(Event.INPUT);
        }
        static _stopEvent(e) {
            if (e.type == 'touchmove')
                e.preventDefault();
            e.stopPropagation && e.stopPropagation();
        }
        setSelection(startIndex, endIndex) {
            this.focus = true;
            Input.inputElement.selectionStart = startIndex;
            Input.inputElement.selectionEnd = endIndex;
        }
        get multiline() {
            return this._multiline;
        }
        set multiline(value) {
            this._multiline = value;
            this.valign = value ? "top" : "middle";
        }
        get nativeInput() {
            return this._multiline ? Input.area : Input.input;
        }
        _onUnDisplay(e = null) {
            this.focus = false;
        }
        _onMouseDown(e) {
            this.focus = true;
        }
        _syncInputTransform() {
            var inputElement = this.nativeInput;
            var transform = SpriteUtils.getTransformRelativeToWindow(this, this.padding[3], this.padding[0]);
            var inputWid = this._width - this.padding[1] - this.padding[3];
            var inputHei = this._height - this.padding[0] - this.padding[2];
            if (LayaEnv.isConch && !Input.isAppUseNewInput) {
                inputElement.setScale(transform.scaleX, transform.scaleY);
                inputElement.setSize(inputWid, inputHei);
                inputElement.setPos(transform.x, transform.y);
            }
            else {
                Input.inputContainer.style.transform = Input.inputContainer.style.webkitTransform = "scale(" + transform.scaleX + "," + transform.scaleY + ") rotate(" + (ILaya.stage.canvasDegree) + "deg)";
                inputElement.style.width = inputWid + 'px';
                inputElement.style.height = inputHei + 'px';
                Input.inputContainer.style.left = transform.x + 'px';
                Input.inputContainer.style.top = transform.y + 'px';
            }
        }
        select() {
            this.nativeInput.select();
        }
        get focus() {
            return this._focus;
        }
        set focus(value) {
            var input = this.nativeInput;
            if (this._focus !== value) {
                if (value) {
                    if (input.target) {
                        input.target._focusOut();
                    }
                    else {
                        this._setInputMethod();
                    }
                    input = this.nativeInput;
                    input.target = this;
                    this._focusIn();
                }
                else {
                    input.target = null;
                    this._focusOut();
                    ILaya.Browser.document.body.scrollTop = 0;
                    input.blur();
                    if (LayaEnv.isConch && !Input.isAppUseNewInput)
                        input.setPos(-10000, -10000);
                    else if (Input.inputContainer.contains(input))
                        Input.inputContainer.removeChild(input);
                }
            }
        }
        _setInputMethod() {
            Input.input.parentElement && (Input.inputContainer.removeChild(Input.input));
            Input.area.parentElement && (Input.inputContainer.removeChild(Input.area));
            if (ILaya.Browser.onAndroid) {
                Input.input = Input.inputElement = ILaya.Browser.createElement('input');
                Input._initInput(Input.input);
            }
            Input.inputElement = (this._multiline ? Input.area : Input.input);
            Input.inputContainer.appendChild(Input.inputElement);
            if (Text.RightToLeft) {
                Input.inputElement.style.direction = "rtl";
            }
        }
        _focusIn() {
            InputManager.isTextInputting = true;
            var input = this.nativeInput;
            Input.input && (Input.input.type = this._type);
            this._focus = true;
            var cssStyle = input.style;
            cssStyle.whiteSpace = (this.wordWrap ? "pre-wrap" : "nowrap");
            this._setPromptColor();
            input.readOnly = !this._editable;
            if (LayaEnv.isConch && !Input.isAppUseNewInput) {
                input.setType(this._type);
                input.setForbidEdit(!this._editable);
            }
            input.maxLength = this._maxChars;
            input.value = this._content;
            input.placeholder = this._prompt;
            ILaya.stage.off(Event.KEY_DOWN, this, this._onKeyDown);
            ILaya.stage.on(Event.KEY_DOWN, this, this._onKeyDown);
            ILaya.stage.focus = this;
            this.event(Event.FOCUS);
            if (ILaya.Browser.onPC)
                input.focus();
            if (!(LayaEnv.isConch && Input.isAppUseNewInput) && !ILaya.Browser.onMiniGame && !ILaya.Browser.onBDMiniGame && !ILaya.Browser.onQGMiniGame && !ILaya.Browser.onKGMiniGame && !ILaya.Browser.onVVMiniGame && !ILaya.Browser.onAlipayMiniGame && !ILaya.Browser.onQQMiniGame && !ILaya.Browser.onBLMiniGame && !ILaya.Browser.onTTMiniGame && !ILaya.Browser.onHWMiniGame && !ILaya.Browser.onTBMiniGame) {
                this._text = null;
            }
            this.typeset();
            input.setColor(this._originColor);
            input.setFontSize(this.fontSize);
            input.setFontFace(ILaya.Browser.onIPhone ? (Config.fontFamilyMap[this.font] || this.font) : this.font);
            if (LayaEnv.isConch && !Input.isAppUseNewInput) {
                input.setMultiAble && input.setMultiAble(this._multiline);
            }
            cssStyle.lineHeight = (this.leading + this.fontSize) + "px";
            cssStyle.fontStyle = (this.italic ? "italic" : "normal");
            cssStyle.fontWeight = (this.bold ? "bold" : "normal");
            cssStyle.textAlign = this.align;
            cssStyle.padding = "0 0";
            this._syncInputTransform();
            if (!LayaEnv.isConch && ILaya.Browser.onPC)
                ILaya.systemTimer.frameLoop(1, this, this._syncInputTransform);
        }
        _setPromptColor() {
            Input.promptStyleDOM = ILaya.Browser.getElementById("promptStyle");
            if (!Input.promptStyleDOM) {
                Input.promptStyleDOM = ILaya.Browser.createElement("style");
                Input.promptStyleDOM.setAttribute("id", "promptStyle");
                ILaya.Browser.document.head.appendChild(Input.promptStyleDOM);
            }
            Input.promptStyleDOM.innerText = "input::-webkit-input-placeholder, textarea::-webkit-input-placeholder {" + "color:" + this._promptColor + "}" + "input:-moz-placeholder, textarea:-moz-placeholder {" + "color:" + this._promptColor + "}" + "input::-moz-placeholder, textarea::-moz-placeholder {" + "color:" + this._promptColor + "}" + "input:-ms-input-placeholder, textarea:-ms-input-placeholder {" + "color:" + this._promptColor + "}";
        }
        _focusOut() {
            if (!InputManager.isTextInputting)
                return;
            if (!InputManager.isiOSWKwebView)
                InputManager.isTextInputting = false;
            this._focus = false;
            this._text = null;
            this._content = this.nativeInput.value;
            if (!this._content) {
                super.set_text(this._prompt);
                super.set_color(this._promptColor);
            }
            else {
                super.set_text(this._content);
                super.set_color(this._originColor);
            }
            ILaya.stage.off(Event.KEY_DOWN, this, this._onKeyDown);
            ILaya.stage.focus = null;
            this.event(Event.BLUR);
            this.event(Event.CHANGE);
            if (LayaEnv.isConch && !Input.isAppUseNewInput)
                this.nativeInput.blur();
            ILaya.Browser.onPC && ILaya.systemTimer.clear(this, this._syncInputTransform);
        }
        _onKeyDown(e) {
            if (e.keyCode === 13) {
                if (ILaya.Browser.onMobile && !this._multiline)
                    this.focus = false;
                this.event(Event.ENTER);
            }
        }
        miniGameTxt(value) {
            super.set_color(this._originColor);
            value += '';
            if (!this._multiline)
                value = value.replace(/\r?\n/g, '');
            this._content = value;
            if (value)
                super.set_text(value);
            else {
                super.set_text(this._prompt);
                super.set_color(this.promptColor);
            }
        }
        set text(value) {
            super.set_color(this._originColor);
            value += '';
            if (this._focus) {
                this.nativeInput.value = value || '';
                this.event(Event.CHANGE);
            }
            else {
                if (!this._multiline)
                    value = value.replace(/\r?\n/g, '');
                this._content = value;
                if (value)
                    super.set_text(value);
                else {
                    super.set_text(this._prompt);
                    super.set_color(this.promptColor);
                }
            }
        }
        get text() {
            if (this._focus)
                return this.nativeInput.value;
            else
                return this._content || "";
        }
        changeText(text) {
            this._content = text;
            if (this._focus) {
                this.nativeInput.value = text || '';
                this.event(Event.CHANGE);
            }
            else
                super.changeText(text);
        }
        set color(value) {
            if (this._focus)
                this.nativeInput.setColor(value);
            super.set_color(this._content ? value : this._promptColor);
            this._originColor = value;
        }
        get color() {
            return super.color;
        }
        set bgColor(value) {
            super.set_bgColor(value);
            if (LayaEnv.isConch && !Input.isAppUseNewInput)
                this.nativeInput.setBgColor(value);
        }
        get bgColor() {
            return super.bgColor;
        }
        get restrict() {
            if (this._restrictPattern) {
                return this._restrictPattern.source;
            }
            return "";
        }
        set restrict(pattern) {
            if (pattern) {
                pattern = "[^" + pattern + "]";
                if (pattern.indexOf("^^") > -1)
                    pattern = pattern.replace("^^", "");
                this._restrictPattern = new RegExp(pattern, "g");
            }
            else
                this._restrictPattern = null;
        }
        set editable(value) {
            this._editable = value;
            if (LayaEnv.isConch && !Input.isAppUseNewInput) {
                Input.input.setForbidEdit(!value);
            }
        }
        get editable() {
            return this._editable;
        }
        get maxChars() {
            return this._maxChars;
        }
        set maxChars(value) {
            if (value <= 0)
                value = 1E5;
            this._maxChars = value;
        }
        get prompt() {
            return this._prompt;
        }
        set prompt(value) {
            if (!this._text && value)
                super.set_color(this._promptColor);
            this.promptColor = this._promptColor;
            if (this._text)
                super.set_text((this._text == this._prompt) ? value : this._text);
            else
                super.set_text(value);
            this._prompt = Text.langPacks && Text.langPacks[value] ? Text.langPacks[value] : value;
        }
        get promptColor() {
            return this._promptColor;
        }
        set promptColor(value) {
            this._promptColor = value;
            if (!this._content)
                super.set_color(value);
        }
        get type() {
            return this._type;
        }
        set type(value) {
            if (value === "password")
                this._getTextStyle().asPassword = true;
            else
                this._getTextStyle().asPassword = false;
            this._type = value;
        }
    }
    Input.TYPE_TEXT = "text";
    Input.TYPE_PASSWORD = "password";
    Input.TYPE_EMAIL = "email";
    Input.TYPE_URL = "url";
    Input.TYPE_NUMBER = "number";
    Input.TYPE_RANGE = "range";
    Input.TYPE_DATE = "date";
    Input.TYPE_MONTH = "month";
    Input.TYPE_WEEK = "week";
    Input.TYPE_TIME = "time";
    Input.TYPE_DATE_TIME = "datetime";
    Input.TYPE_DATE_TIME_LOCAL = "datetime-local";
    Input.TYPE_SEARCH = "search";
    Input.IOS_IFRAME = false;
    Input.isAppUseNewInput = false;

    class Timer {
        constructor(autoActive = true) {
            this.scale = 1;
            this.currFrame = 0;
            this._delta = 0;
            this._map = {};
            this._handlers = [];
            this._temp = [];
            this._count = 0;
            autoActive && Timer.gSysTimer && Timer.gSysTimer.frameLoop(1, this, this._update);
            this.currTimer = this._getNowData();
            this._lastTimer = this._getNowData();
        }
        get delta() {
            return this._delta;
        }
        _update() {
            if (this.scale <= 0) {
                this._lastTimer = this._getNowData();
                this._delta = 0;
                return;
            }
            var frame = this.currFrame = this.currFrame + this.scale;
            var now = this._getNowData();
            var awake = (now - this._lastTimer) > 30000;
            this._delta = (now - this._lastTimer) * this.scale;
            var timer = this.currTimer = this.currTimer + this._delta;
            this._lastTimer = now;
            var handlers = this._handlers;
            this._count = 0;
            for (var i = 0, n = handlers.length; i < n; i++) {
                var handler = handlers[i];
                if (handler.method !== null) {
                    var t = handler.userFrame ? frame : timer;
                    if (t >= handler.exeTime) {
                        if (handler.repeat) {
                            if (!handler.jumpFrame || awake) {
                                handler.exeTime += handler.delay;
                                handler.run(false);
                                if (t > handler.exeTime) {
                                    handler.exeTime += Math.ceil((t - handler.exeTime) / handler.delay) * handler.delay;
                                }
                            }
                            else {
                                while (t >= handler.exeTime) {
                                    handler.exeTime += handler.delay;
                                    handler.run(false);
                                }
                            }
                        }
                        else {
                            handler.run(true);
                        }
                    }
                }
                else {
                    this._count++;
                }
            }
            if (this._count > 30 || frame % 200 === 0)
                this._clearHandlers();
        }
        _clearHandlers() {
            var handlers = this._handlers;
            for (var i = 0, n = handlers.length; i < n; i++) {
                var handler = handlers[i];
                if (handler.method !== null)
                    this._temp.push(handler);
                else
                    this._recoverHandler(handler);
            }
            this._handlers = this._temp;
            handlers.length = 0;
            this._temp = handlers;
        }
        _recoverHandler(handler) {
            if (this._map[handler.key] == handler)
                delete this._map[handler.key];
            handler.clear();
            Timer._pool.push(handler);
        }
        _getNowData() {
            return Date.now();
        }
        _create(useFrame, repeat, delay, caller, method, args, coverBefore) {
            if (!delay) {
                method.apply(caller, args);
                return null;
            }
            if (coverBefore) {
                var handler = this._getHandler(caller, method);
                if (handler) {
                    handler.repeat = repeat;
                    handler.userFrame = useFrame;
                    handler.delay = delay;
                    handler.caller = caller;
                    handler.method = method;
                    handler.args = args;
                    handler.exeTime = delay + (useFrame ? this.currFrame : this.currTimer + this._getNowData() - this._lastTimer);
                    return handler;
                }
            }
            handler = Timer._pool.length > 0 ? Timer._pool.pop() : new TimerHandler();
            handler.repeat = repeat;
            handler.userFrame = useFrame;
            handler.delay = delay;
            handler.caller = caller;
            handler.method = method;
            handler.args = args;
            handler.exeTime = delay + (useFrame ? this.currFrame : this.currTimer + this._getNowData() - this._lastTimer);
            this._indexHandler(handler);
            this._handlers.push(handler);
            return handler;
        }
        _indexHandler(handler) {
            var caller = handler.caller;
            var method = handler.method;
            var cid = caller ? caller.$_GID || (caller.$_GID = Utils.getGID()) : 0;
            var mid = method.$_TID || (method.$_TID = Timer._mid++);
            handler.key = cid + "_" + mid;
            this._map[handler.key] = handler;
        }
        once(delay, caller, method, args = null, coverBefore = true) {
            this._create(false, false, delay, caller, method, args, coverBefore);
        }
        loop(delay, caller, method, args = null, coverBefore = true, jumpFrame = false) {
            var handler = this._create(false, true, delay, caller, method, args, coverBefore);
            if (handler)
                handler.jumpFrame = jumpFrame;
        }
        frameOnce(delay, caller, method, args = null, coverBefore = true) {
            this._create(true, false, delay, caller, method, args, coverBefore);
        }
        frameLoop(delay, caller, method, args = null, coverBefore = true) {
            this._create(true, true, delay, caller, method, args, coverBefore);
        }
        toString() {
            return " handlers:" + this._handlers.length + " pool:" + Timer._pool.length;
        }
        clear(caller, method) {
            var handler = this._getHandler(caller, method);
            if (handler) {
                handler.clear();
            }
        }
        clearAll(caller) {
            if (!caller)
                return;
            for (var i = 0, n = this._handlers.length; i < n; i++) {
                var handler = this._handlers[i];
                if (handler.caller === caller) {
                    handler.clear();
                }
            }
        }
        _getHandler(caller, method) {
            var cid = caller ? caller.$_GID || (caller.$_GID = Utils.getGID()) : 0;
            var mid = method.$_TID || (method.$_TID = Timer._mid++);
            var key = cid + "_" + mid;
            return this._map[key];
        }
        callLater(caller, method, args = null) {
            CallLater.I.callLater(caller, method, args);
        }
        runCallLater(caller, method) {
            CallLater.I.runCallLater(caller, method);
        }
        runTimer(caller, method) {
            var handler = this._getHandler(caller, method);
            if (handler && handler.method != null) {
                this._map[handler.key] = null;
                handler.run(true);
            }
        }
        pause() {
            this.scale = 0;
        }
        resume() {
            this.scale = 1;
        }
        destroy() {
            for (var i = 0, n = this._handlers.length; i < n; i++) {
                var handler = this._handlers[i];
                handler.clear();
            }
            this._handlers.length = 0;
            this._map = {};
            this._temp.length = 0;
        }
    }
    Timer.gSysTimer = null;
    Timer._pool = [];
    Timer._mid = 1;
    class TimerHandler {
        clear() {
            this.caller = null;
            this.method = null;
            this.args = null;
        }
        run(withClear) {
            var caller = this.caller;
            if (caller && caller.destroyed)
                return this.clear();
            var method = this.method;
            var args = this.args;
            withClear && this.clear();
            if (method == null)
                return;
            args ? method.apply(caller, args) : method.call(caller);
        }
    }

    class CallLater {
        constructor() {
            this._pool = [];
            this._map = {};
            this._laters = [];
        }
        _update() {
            let laters = this._laters;
            let len = laters.length;
            if (len > 0) {
                for (let i = 0, n = len - 1; i <= n; i++) {
                    let handler = laters[i];
                    this._map[handler.key] = null;
                    if (handler.method !== null) {
                        handler.run();
                        handler.clear();
                    }
                    this._pool.push(handler);
                    i === n && (n = laters.length - 1);
                }
                laters.length = 0;
            }
        }
        _getHandler(caller, method) {
            var cid = caller ? caller.$_GID || (caller.$_GID = Utils.getGID()) : 0;
            var mid = method.$_TID || (method.$_TID = (Timer._mid++));
            return this._map[cid + '.' + mid];
        }
        callLater(caller, method, args = null) {
            if (this._getHandler(caller, method) == null) {
                let handler;
                if (this._pool.length)
                    handler = this._pool.pop();
                else
                    handler = new LaterHandler();
                handler.caller = caller;
                handler.method = method;
                handler.args = args;
                var cid = caller ? caller.$_GID : 0;
                var mid = method["$_TID"];
                handler.key = cid + '.' + mid;
                this._map[handler.key] = handler;
                this._laters.push(handler);
            }
        }
        runCallLater(caller, method) {
            var handler = this._getHandler(caller, method);
            if (handler && handler.method != null) {
                this._map[handler.key] = null;
                handler.run();
                handler.clear();
            }
        }
        clear(caller, method) {
            var handler = this._getHandler(caller, method);
            if (handler) {
                this._map[handler.key] = null;
                handler.key = "";
                handler.clear();
                return true;
            }
            return false;
        }
        clearAll(caller) {
            if (!caller)
                return;
            for (var i = 0, n = this._laters.length; i < n; i++) {
                var handler = this._laters[i];
                if (handler.caller === caller) {
                    this._map[handler.key] = null;
                    handler.key = "";
                    handler.clear();
                }
            }
        }
    }
    CallLater.I = new CallLater();
    class LaterHandler {
        clear() {
            this.caller = null;
            this.method = null;
            this.args = null;
        }
        run() {
            var caller = this.caller;
            if (caller && caller.destroyed)
                return this.clear();
            var method = this.method;
            var args = this.args;
            if (method == null)
                return;
            args ? method.apply(caller, args) : method.call(caller);
        }
    }

    class RunDriver {
    }
    RunDriver.createShaderCondition = function (conditionScript) {
        var fn = "(function() {return " + conditionScript + ";})";
        return window.Laya._runScript(fn);
    };
    RunDriver.changeWebGLSize = function (w, h) {
        WebGL.onStageResize(w, h);
    };

    class ComponentDriver {
        constructor() {
            this._onUpdates = new Set();
            this._onLateUpdates = new Set();
            this._onPreRenders = new Set();
            this._onPostRenders = new Set();
            this._toStarts = new Set();
            this._toDestroys = new Set();
        }
        callStart() {
            for (let ele of this._toStarts) {
                if (ele._status == 2) {
                    ele._status = 3;
                    try {
                        ele.onStart();
                    }
                    catch (err) {
                        console.log(err);
                    }
                }
            }
            this._toStarts.clear();
        }
        callUpdate() {
            for (let ele of this._onUpdates) {
                if (ele._status == 3) {
                    try {
                        ele.onUpdate();
                    }
                    catch (err) {
                        console.log(err);
                    }
                }
            }
        }
        callLateUpdate() {
            for (let ele of this._onLateUpdates) {
                if (ele._status == 3) {
                    try {
                        ele.onLateUpdate();
                    }
                    catch (err) {
                        console.log(err);
                    }
                }
            }
        }
        callPreRender() {
            for (let ele of this._onPreRenders) {
                if (ele._status == 3) {
                    try {
                        ele.onPreRender();
                    }
                    catch (err) {
                        console.log(err);
                    }
                }
            }
        }
        callPostRender() {
            for (let ele of this._onPostRenders) {
                if (ele._status == 3) {
                    try {
                        ele.onPostRender();
                    }
                    catch (err) {
                        console.log(err);
                    }
                }
            }
        }
        callDestroy() {
            for (let ele of this._toDestroys) {
                try {
                    ele._destroy(true);
                }
                catch (err) {
                    console.log(err);
                }
            }
            this._toDestroys.clear();
        }
        add(comp) {
            if (comp._status == 1) {
                if (comp.onStart) {
                    comp._status = 2;
                    this._toStarts.add(comp);
                }
                else
                    comp._status = 3;
            }
            if (comp.onUpdate)
                this._onUpdates.add(comp);
            if (comp.onLateUpdate)
                this._onLateUpdates.add(comp);
            if (comp.onPreRender)
                this._onPreRenders.add(comp);
            if (comp.onPostRender)
                this._onPostRenders.add(comp);
        }
        remove(comp) {
            if (comp._status == 2)
                comp._status = 1;
            if (comp.onUpdate)
                this._onUpdates.delete(comp);
            if (comp.onLateUpdate)
                this._onLateUpdates.delete(comp);
            if (comp.onPreRender)
                this._onPreRenders.delete(comp);
            if (comp.onPostRender)
                this._onPostRenders.delete(comp);
        }
        destroy() {
        }
    }

    class Stage extends Sprite {
        constructor() {
            super();
            this.offset = new Point();
            this._frameRate = "fast";
            this.designWidth = 0;
            this.designHeight = 0;
            this.canvasRotation = false;
            this.canvasDegree = 0;
            this.renderingEnabled = true;
            this.screenAdaptationEnabled = true;
            this._canvasTransform = new Matrix();
            this._screenMode = "none";
            this._scaleMode = "noscale";
            this._alignV = "top";
            this._alignH = "left";
            this._bgColor = "black";
            this._mouseMoveTime = 0;
            this._renderCount = 0;
            this._safariOffsetY = 0;
            this._frameStartTime = 0;
            this._previousOrientation = Browser.window.orientation;
            this._wgColor = [0, 0, 0, 1];
            this._scene3Ds = [];
            this._globalRepaintSet = false;
            this._globalRepaintGet = false;
            this.useRetinalCanvas = false;
            this._needUpdateCanvasSize = false;
            super.set_transform(this._createTransform());
            this.mouseEnabled = true;
            this.hitTestPrior = true;
            this.autoSize = false;
            this._setBit(NodeFlags.DISPLAYED_INSTAGE, true);
            this._setBit(NodeFlags.ACTIVE_INHIERARCHY, true);
            this._isFocused = true;
            this._isVisibility = true;
            this.useRetinalCanvas = Config.useRetinalCanvas;
            var window = Browser.window;
            window.addEventListener("focus", () => {
                this._isFocused = true;
                this.event(Event.FOCUS);
                this.event(Event.FOCUS_CHANGE);
            });
            window.addEventListener("blur", () => {
                this._isFocused = false;
                this.event(Event.BLUR);
                this.event(Event.FOCUS_CHANGE);
                if (this._isInputting())
                    Input["inputElement"].target.focus = false;
            });
            var state = "visibilityState", visibilityChange = "visibilitychange";
            var document = window.document;
            if (typeof document.hidden !== "undefined") {
                visibilityChange = "visibilitychange";
                state = "visibilityState";
            }
            else if (typeof document.mozHidden !== "undefined") {
                visibilityChange = "mozvisibilitychange";
                state = "mozVisibilityState";
            }
            else if (typeof document.msHidden !== "undefined") {
                visibilityChange = "msvisibilitychange";
                state = "msVisibilityState";
            }
            else if (typeof document.webkitHidden !== "undefined") {
                visibilityChange = "webkitvisibilitychange";
                state = "webkitVisibilityState";
            }
            window.document.addEventListener(visibilityChange, () => {
                if (Browser.document[state] == "hidden") {
                    this._isVisibility = false;
                    if (this._isInputting())
                        Input["inputElement"].target.focus = false;
                }
                else {
                    this._isVisibility = true;
                }
                this.renderingEnabled = this._isVisibility;
                this.event(Event.VISIBILITY_CHANGE);
            });
            window.addEventListener("resize", () => {
                var orientation = Browser.window.orientation;
                if (orientation != null && orientation != this._previousOrientation && this._isInputting()) {
                    Input["inputElement"].target.focus = false;
                }
                this._previousOrientation = orientation;
                if (this._isInputting())
                    return;
                if (Browser.onSafari)
                    this._safariOffsetY = (Browser.window.__innerHeight || Browser.document.body.clientHeight || Browser.document.documentElement.clientHeight) - Browser.window.innerHeight;
                if (this.screenAdaptationEnabled) {
                    this.event(Event.WILL_RESIZE);
                    this.updateCanvasSize();
                }
            });
            window.addEventListener("orientationchange", (e) => {
                if (this.screenAdaptationEnabled) {
                    this.event(Event.WILL_RESIZE);
                    this.updateCanvasSize();
                }
            });
            this._componentDriver = new ComponentDriver();
        }
        _isInputting() {
            return (Browser.onMobile && InputManager.isTextInputting);
        }
        set width(value) {
            this.designWidth = value;
            super.set_width(value);
            this.updateCanvasSize(true);
        }
        get width() {
            this.needUpdateCanvasSize();
            return super.get_width();
        }
        set height(value) {
            this.designHeight = value;
            super.set_height(value);
            this.updateCanvasSize(true);
        }
        get height() {
            this.needUpdateCanvasSize();
            return super.get_height();
        }
        set transform(value) {
            super.set_transform(value);
        }
        get transform() {
            if (this._tfChanged)
                this._adjustTransform();
            return (this._transform = this._transform || this._createTransform());
        }
        get isFocused() {
            return this._isFocused;
        }
        get isVisibility() {
            return this._isVisibility;
        }
        updateCanvasSize(delay) {
            if (delay) {
                if (!this._needUpdateCanvasSize) {
                    this._needUpdateCanvasSize = true;
                    ILaya.systemTimer.callLater(this, this.updateCanvasSize);
                }
            }
            else {
                this.setScreenSize(Browser.clientWidth * Browser.pixelRatio, Browser.clientHeight * Browser.pixelRatio);
            }
        }
        needUpdateCanvasSize() {
            if (this._needUpdateCanvasSize)
                this.updateCanvasSize();
        }
        setScreenSize(screenWidth, screenHeight) {
            this._needUpdateCanvasSize = false;
            var rotation = false;
            if (this._screenMode !== Stage.SCREEN_NONE) {
                var screenType = screenWidth / screenHeight < 1 ? Stage.SCREEN_VERTICAL : Stage.SCREEN_HORIZONTAL;
                rotation = screenType !== this._screenMode;
                if (rotation) {
                    var temp = screenHeight;
                    screenHeight = screenWidth;
                    screenWidth = temp;
                }
            }
            this.canvasRotation = rotation;
            var canvas = Render._mainCanvas;
            var canvasStyle = canvas.source.style;
            var mat = this._canvasTransform.identity();
            var scaleMode = this._scaleMode;
            var scaleX = screenWidth / this.designWidth;
            var scaleY = screenHeight / this.designHeight;
            var canvasWidth = this.useRetinalCanvas ? screenWidth : this.designWidth;
            var canvasHeight = this.useRetinalCanvas ? screenHeight : this.designHeight;
            var realWidth = screenWidth;
            var realHeight = screenHeight;
            var pixelRatio = Browser.pixelRatio;
            this._width = this.designWidth;
            this._height = this.designHeight;
            switch (scaleMode) {
                case Stage.SCALE_NOSCALE:
                    scaleX = scaleY = 1;
                    realWidth = this.designWidth;
                    realHeight = this.designHeight;
                    break;
                case Stage.SCALE_SHOWALL:
                    scaleX = scaleY = Math.min(scaleX, scaleY);
                    canvasWidth = realWidth = Math.round(this.designWidth * scaleX);
                    canvasHeight = realHeight = Math.round(this.designHeight * scaleY);
                    break;
                case Stage.SCALE_NOBORDER:
                    scaleX = scaleY = Math.max(scaleX, scaleY);
                    realWidth = Math.round(this.designWidth * scaleX);
                    realHeight = Math.round(this.designHeight * scaleY);
                    break;
                case Stage.SCALE_FULL:
                    scaleX = scaleY = pixelRatio;
                    canvasWidth = screenWidth;
                    canvasHeight = screenHeight;
                    this._width = screenWidth / pixelRatio;
                    this._height = screenHeight / pixelRatio;
                    break;
                case Stage.SCALE_FIXED_WIDTH:
                    scaleY = scaleX;
                    this._height = canvasHeight = Math.round(screenHeight / scaleX);
                    break;
                case Stage.SCALE_FIXED_HEIGHT:
                    scaleX = scaleY;
                    this._width = canvasWidth = Math.round(screenWidth / scaleY);
                    break;
                case Stage.SCALE_FIXED_AUTO:
                    if ((screenWidth / screenHeight) < (this.designWidth / this.designHeight)) {
                        scaleY = scaleX;
                        this._height = canvasHeight = Math.round(screenHeight / scaleX);
                    }
                    else {
                        scaleX = scaleY;
                        this._width = canvasWidth = Math.round(screenWidth / scaleY);
                    }
                    break;
                case Stage.SCALE_FIXED_AUTO_LAYAME:
                    if (screenWidth < screenHeight) {
                        scaleY = scaleX;
                        this._height = canvasHeight = Math.round(screenHeight / scaleX);
                    }
                    else {
                        scaleX = screenHeight / this.designWidth;
                        scaleY = scaleX;
                        this._width = canvasWidth = Math.round(screenWidth / scaleX);
                        this._height = canvasHeight = Math.round(screenHeight / scaleY);
                    }
                    break;
                case Stage.SCALE_FIXED_AUTO_LAYAVERSE:
                    if (screenWidth > screenHeight) {
                        scaleX = scaleY;
                        this._width = canvasWidth = Math.round(screenWidth / scaleY);
                    }
                    else {
                        scaleX = screenWidth / this.designHeight;
                        scaleY = scaleX;
                        this._width = canvasWidth = Math.round(screenWidth / scaleX);
                        this._height = canvasHeight = Math.round(screenHeight / scaleY);
                    }
                    break;
            }
            if (this.useRetinalCanvas) {
                realWidth = canvasWidth = screenWidth;
                realHeight = canvasHeight = screenHeight;
            }
            scaleX *= this.scaleX;
            scaleY *= this.scaleY;
            if (scaleX === 1 && scaleY === 1) {
                this.transform.identity();
            }
            else {
                this.transform.a = this._formatData(scaleX / (realWidth / canvasWidth));
                this.transform.d = this._formatData(scaleY / (realHeight / canvasHeight));
            }
            canvas.size(canvasWidth, canvasHeight);
            RunDriver.changeWebGLSize(canvasWidth, canvasHeight);
            mat.scale(realWidth / canvasWidth / pixelRatio, realHeight / canvasHeight / pixelRatio);
            if (this._alignH === Stage.ALIGN_LEFT)
                this.offset.x = 0;
            else if (this._alignH === Stage.ALIGN_RIGHT)
                this.offset.x = screenWidth - realWidth;
            else
                this.offset.x = (screenWidth - realWidth) * 0.5 / pixelRatio;
            if (this._alignV === Stage.ALIGN_TOP)
                this.offset.y = 0;
            else if (this._alignV === Stage.ALIGN_BOTTOM)
                this.offset.y = screenHeight - realHeight;
            else
                this.offset.y = (screenHeight - realHeight) * 0.5 / pixelRatio;
            this.offset.x = Math.round(this.offset.x);
            this.offset.y = Math.round(this.offset.y);
            mat.translate(this.offset.x, this.offset.y);
            if (this._safariOffsetY)
                mat.translate(0, this._safariOffsetY);
            this.canvasDegree = 0;
            if (rotation) {
                if (this._screenMode === Stage.SCREEN_HORIZONTAL) {
                    mat.rotate(Math.PI / 2);
                    mat.translate(screenHeight / pixelRatio, 0);
                    this.canvasDegree = 90;
                }
                else {
                    mat.rotate(-Math.PI / 2);
                    mat.translate(0, screenWidth / pixelRatio);
                    this.canvasDegree = -90;
                }
            }
            mat.a = this._formatData(mat.a);
            mat.d = this._formatData(mat.d);
            mat.tx = this._formatData(mat.tx);
            mat.ty = this._formatData(mat.ty);
            super.set_transform(this.transform);
            canvasStyle.transformOrigin = canvasStyle.webkitTransformOrigin = canvasStyle.msTransformOrigin = canvasStyle.mozTransformOrigin = canvasStyle.oTransformOrigin = "0px 0px 0px";
            canvasStyle.transform = canvasStyle.webkitTransform = canvasStyle.msTransform = canvasStyle.mozTransform = canvasStyle.oTransform = "matrix(" + mat.toString() + ")";
            canvasStyle.width = canvasWidth;
            canvasStyle.height = canvasHeight;
            if (this._safariOffsetY)
                mat.translate(0, -this._safariOffsetY);
            mat.translate(parseInt(canvasStyle.left) || 0, parseInt(canvasStyle.top) || 0);
            this.visible = true;
            this._repaint |= SpriteConst.REPAINT_CACHE;
            this.event(Event.RESIZE);
        }
        setScreenSizeForScene(screenWidth, screenHeight, _screenMode) {
            var rotation = false;
            if (_screenMode !== Stage.SCREEN_NONE) {
                var screenType = screenWidth / screenHeight < 1 ? Stage.SCREEN_VERTICAL : Stage.SCREEN_HORIZONTAL;
                rotation = screenType !== _screenMode;
                if (rotation) {
                    var temp = screenHeight;
                    screenHeight = screenWidth;
                    screenWidth = temp;
                }
            }
            this.canvasRotation = rotation;
            var canvas = Render._mainCanvas;
            canvas.source.style;
            this._canvasTransform.clone().identity();
            var scaleMode = this._scaleMode;
            var scaleX = screenWidth / this.designWidth;
            var scaleY = screenHeight / this.designHeight;
            var canvasWidth = this.useRetinalCanvas ? screenWidth : this.designWidth;
            var canvasHeight = this.useRetinalCanvas ? screenHeight : this.designHeight;
            var realWidth = screenWidth;
            var realHeight = screenHeight;
            Browser.pixelRatio;
            let _width = this.designWidth;
            let _height = this.designHeight;
            switch (scaleMode) {
                case Stage.SCALE_NOSCALE:
                    scaleX = scaleY = 1;
                    realWidth = this.designWidth;
                    realHeight = this.designHeight;
                    break;
                case Stage.SCALE_SHOWALL:
                    scaleX = scaleY = Math.min(scaleX, scaleY);
                    canvasWidth = realWidth = Math.round(this.designWidth * scaleX);
                    canvasHeight = realHeight = Math.round(this.designHeight * scaleY);
                    break;
                case Stage.SCALE_NOBORDER:
                    scaleX = scaleY = Math.max(scaleX, scaleY);
                    realWidth = Math.round(this.designWidth * scaleX);
                    realHeight = Math.round(this.designHeight * scaleY);
                    break;
                case Stage.SCALE_FULL:
                    scaleX = scaleY = 1;
                    _width = canvasWidth = screenWidth;
                    _height = canvasHeight = screenHeight;
                    break;
                case Stage.SCALE_FIXED_WIDTH:
                    scaleY = scaleX;
                    _height = canvasHeight = Math.round(screenHeight / scaleX);
                    break;
                case Stage.SCALE_FIXED_HEIGHT:
                    scaleX = scaleY;
                    _width = canvasWidth = Math.round(screenWidth / scaleY);
                    break;
                case Stage.SCALE_FIXED_AUTO:
                    if ((screenWidth / screenHeight) < (this.designWidth / this.designHeight)) {
                        scaleY = scaleX;
                        _height = canvasHeight = Math.round(screenHeight / scaleX);
                    }
                    else {
                        scaleX = scaleY;
                        _width = canvasWidth = Math.round(screenWidth / scaleY);
                    }
                    break;
            }
            if (this.useRetinalCanvas) {
                realWidth = canvasWidth = screenWidth;
                realHeight = canvasHeight = screenHeight;
            }
            return {
                stageWidth: _width,
                stageHeight: _height,
                canvasWidth: canvasWidth,
                canvasHeight: canvasHeight,
                scaleX: scaleX / (realWidth / canvasWidth),
                scaleY: scaleY / (realHeight / canvasHeight),
            };
        }
        _formatData(value) {
            if (Math.abs(value) < 0.000001)
                return 0;
            if (Math.abs(1 - value) < 0.001)
                return value > 0 ? 1 : -1;
            return value;
        }
        get scaleMode() {
            return this._scaleMode;
        }
        set scaleMode(value) {
            this._scaleMode = value;
            this.updateCanvasSize(true);
        }
        get alignH() {
            this.needUpdateCanvasSize();
            return this._alignH;
        }
        set alignH(value) {
            this._alignH = value;
            this.updateCanvasSize(true);
        }
        get alignV() {
            this.needUpdateCanvasSize();
            return this._alignV;
        }
        set alignV(value) {
            this._alignV = value;
            this.updateCanvasSize(true);
        }
        get bgColor() {
            return this._bgColor;
        }
        set bgColor(value) {
            this._bgColor = value;
            if (value)
                this._wgColor = ColorUtils.create(value).arrColor;
            else
                this._wgColor = null;
            if (value) {
                Render.canvas.style.background = value;
            }
            else {
                Render.canvas.style.background = "none";
            }
        }
        get mouseX() {
            return Math.round(InputManager.mouseX / this.clientScaleX);
        }
        get mouseY() {
            return Math.round(InputManager.mouseY / this.clientScaleY);
        }
        getMousePoint() {
            return Point.TEMP.setTo(this.mouseX, this.mouseY);
        }
        get clientScaleX() {
            this.needUpdateCanvasSize();
            return this._transform ? this._transform.getScaleX() : 1;
        }
        get clientScaleY() {
            this.needUpdateCanvasSize();
            return this._transform ? this._transform.getScaleY() : 1;
        }
        get screenMode() {
            return this._screenMode;
        }
        set screenMode(value) {
            this._screenMode = value;
        }
        repaint(type = SpriteConst.REPAINT_CACHE) {
            this._repaint |= type;
        }
        parentRepaint(type = SpriteConst.REPAINT_CACHE) {
        }
        _loop() {
            this._globalRepaintGet = this._globalRepaintSet;
            this._globalRepaintSet = false;
            this.render(Render._context, 0, 0);
            return true;
        }
        getFrameTm() {
            return this._frameStartTime;
        }
        getTimeFromFrameStart() {
            return Browser.now() - this._frameStartTime;
        }
        set visible(value) {
            if (this.visible !== value) {
                super.set_visible(value);
                var style = Render._mainCanvas.source.style;
                style.visibility = value ? "visible" : "hidden";
            }
        }
        get visible() {
            return super.visible;
        }
        render(context, x, y) {
            if (LayaEnv.isConch) {
                this.renderToNative(context, x, y);
                return;
            }
            let delta = ILaya.timer._delta / 1000;
            if (this._frameRate === Stage.FRAME_SLEEP) {
                var now = Browser.now();
                if (now - this._frameStartTime < 1000)
                    return;
                this._frameStartTime = now;
            }
            else {
                if (!this._visible) {
                    this._renderCount++;
                    if (this._renderCount % 5 === 0) {
                        CallLater.I._update();
                        Stat.loopCount++;
                        RenderInfo.loopCount = Stat.loopCount;
                        this._runComponents();
                        this._updateTimers();
                    }
                    return;
                }
                this._frameStartTime = Browser.now();
                RenderInfo.loopStTm = this._frameStartTime;
            }
            this._renderCount++;
            var frameMode = this._frameRate === Stage.FRAME_MOUSE ? (((this._frameStartTime - this._mouseMoveTime) < 2000) ? Stage.FRAME_FAST : Stage.FRAME_SLOW) : this._frameRate;
            var isFastMode = (frameMode !== Stage.FRAME_SLOW);
            var isDoubleLoop = (this._renderCount % 2 === 0);
            Stat.renderSlow = !isFastMode;
            if (!isFastMode && !isDoubleLoop)
                return;
            CallLater.I._update();
            Stat.loopCount++;
            RenderInfo.loopCount = Stat.loopCount;
            if (this.renderingEnabled) {
                for (let i = 0, n = this._scene3Ds.length; i < n; i++)
                    this._scene3Ds[i]._update(delta);
                this._runComponents();
                context.clear();
                this._componentDriver.callPreRender();
                super.render(context, x, y);
                Stat._StatRender.renderNotCanvas(context, x, y);
                Stage.clear(this._bgColor);
                context.flush();
                this._componentDriver.callPostRender();
                VectorGraphManager.instance && VectorGraphManager.getInstance().endDispose();
            }
            else
                this._runComponents();
            this._updateTimers();
        }
        renderToNative(context, x, y) {
            this._renderCount++;
            if (!this._visible) {
                if (this._renderCount % 5 === 0) {
                    CallLater.I._update();
                    Stat.loopCount++;
                    RenderInfo.loopCount = Stat.loopCount;
                    this._runComponents();
                    this._updateTimers();
                }
                return;
            }
            this._frameStartTime = Browser.now();
            CallLater.I._update();
            Stat.loopCount++;
            RenderInfo.loopCount = Stat.loopCount;
            if (this.renderingEnabled) {
                for (let i = 0, n = this._scene3Ds.length; i < n; i++)
                    this._scene3Ds[i]._update();
                this._runComponents();
                this._componentDriver.callPreRender();
                context.clear();
                super.render(context, x, y);
                Stat._StatRender.renderNotCanvas(context, x, y);
                this._componentDriver.callPostRender();
            }
            else
                this._runComponents();
            if (this.renderingEnabled) {
                Stage.clear(this._bgColor);
                context.flush();
                VectorGraphManager.instance && VectorGraphManager.getInstance().endDispose();
            }
            this._updateTimers();
        }
        _runComponents() {
            this._componentDriver.callStart();
            this._componentDriver.callUpdate();
            this._componentDriver.callLateUpdate();
            this._componentDriver.callDestroy();
        }
        _updateTimers() {
            ILaya.systemTimer._update();
            ILaya.physicsTimer._update();
            ILaya.timer._update();
        }
        set fullScreenEnabled(value) {
            var document = Browser.document;
            var canvas = Render.canvas;
            if (value) {
                canvas.addEventListener('mousedown', this._requestFullscreen);
                canvas.addEventListener('touchstart', this._requestFullscreen);
                document.addEventListener("fullscreenchange", this._fullScreenChanged);
                document.addEventListener("mozfullscreenchange", this._fullScreenChanged);
                document.addEventListener("webkitfullscreenchange", this._fullScreenChanged);
                document.addEventListener("msfullscreenchange", this._fullScreenChanged);
            }
            else {
                canvas.removeEventListener('mousedown', this._requestFullscreen);
                canvas.removeEventListener('touchstart', this._requestFullscreen);
                document.removeEventListener("fullscreenchange", this._fullScreenChanged);
                document.removeEventListener("mozfullscreenchange", this._fullScreenChanged);
                document.removeEventListener("webkitfullscreenchange", this._fullScreenChanged);
                document.removeEventListener("msfullscreenchange", this._fullScreenChanged);
            }
        }
        get frameRate() {
            if (!LayaEnv.isConch) {
                return this._frameRate;
            }
            else {
                return this._frameRateNative;
            }
        }
        set frameRate(value) {
            if (!LayaEnv.isConch) {
                this._frameRate = value;
            }
            else {
                var c = window.conch;
                switch (value) {
                    case Stage.FRAME_FAST:
                        c.config.setLimitFPS(60);
                        break;
                    case Stage.FRAME_MOUSE:
                        c.config.setMouseFrame(2000);
                        break;
                    case Stage.FRAME_SLOW:
                        c.config.setSlowFrame(true);
                        break;
                    case Stage.FRAME_SLEEP:
                        c.config.setLimitFPS(1);
                        break;
                }
                this._frameRateNative = value;
            }
        }
        _requestFullscreen() {
            var element = Browser.document.documentElement;
            if (element.requestFullscreen) {
                element.requestFullscreen();
            }
            else if (element.mozRequestFullScreen) {
                element.mozRequestFullScreen();
            }
            else if (element.webkitRequestFullscreen) {
                element.webkitRequestFullscreen();
            }
            else if (element.msRequestFullscreen) {
                element.msRequestFullscreen();
            }
        }
        _fullScreenChanged() {
            this.event(Event.FULL_SCREEN_CHANGE);
        }
        exitFullscreen() {
            var document = Browser.document;
            if (document.exitFullscreen) {
                document.exitFullscreen();
            }
            else if (document.mozCancelFullScreen) {
                document.mozCancelFullScreen();
            }
            else if (document.webkitExitFullscreen) {
                document.webkitExitFullscreen();
            }
        }
        isGlobalRepaint() {
            return this._globalRepaintGet;
        }
        setGlobalRepaint() {
            this._globalRepaintSet = true;
        }
    }
    Stage.SCALE_NOSCALE = "noscale";
    Stage.SCALE_EXACTFIT = "exactfit";
    Stage.SCALE_SHOWALL = "showall";
    Stage.SCALE_NOBORDER = "noborder";
    Stage.SCALE_FULL = "full";
    Stage.SCALE_FIXED_WIDTH = "fixedwidth";
    Stage.SCALE_FIXED_HEIGHT = "fixedheight";
    Stage.SCALE_FIXED_AUTO = "fixedauto";
    Stage.SCALE_FIXED_AUTO_LAYAME = "fixedauto_layame";
    Stage.SCALE_FIXED_AUTO_LAYAVERSE = "fixedauto_layaverse";
    Stage.ALIGN_LEFT = "left";
    Stage.ALIGN_RIGHT = "right";
    Stage.ALIGN_CENTER = "center";
    Stage.ALIGN_TOP = "top";
    Stage.ALIGN_MIDDLE = "middle";
    Stage.ALIGN_BOTTOM = "bottom";
    Stage.SCREEN_NONE = "none";
    Stage.SCREEN_HORIZONTAL = "horizontal";
    Stage.SCREEN_VERTICAL = "vertical";
    Stage.FRAME_FAST = "fast";
    Stage.FRAME_SLOW = "slow";
    Stage.FRAME_MOUSE = "mouse";
    Stage.FRAME_SLEEP = "sleep";
    Stage.clear = function (value) {
        Context.set2DRenderConfig();
        RenderState2D.worldScissorTest && LayaGL.renderEngine.scissorTest(false);
        var ctx = Render.context;
        var c = (ctx._submits._length == 0 || Config.preserveDrawingBuffer) ? ColorUtils.create(value).arrColor : ILaya.stage._wgColor;
        if (c)
            ctx.clearBG(c[0], c[1], c[2], c[3]);
        else
            ctx.clearBG(0, 0, 0, 0);
        RenderState2D.clear();
    };

    class SoundChannel extends EventDispatcher {
        constructor() {
            super(...arguments);
            this.isStopped = false;
        }
        set volume(v) {
        }
        get volume() {
            return 1;
        }
        get position() {
            return 0;
        }
        get duration() {
            return 0;
        }
        play() {
        }
        stop() {
            if (this.completeHandler)
                this.completeHandler.runWith(false);
        }
        pause() {
        }
        resume() {
        }
        __runComplete(handler) {
            if (handler) {
                handler.runWith(true);
            }
        }
    }

    class AudioSoundChannel extends SoundChannel {
        constructor(audio) {
            super();
            this._audio = null;
            this._onEnd = this.__onEnd.bind(this);
            this._resumePlay = this.__resumePlay.bind(this);
            audio.addEventListener("ended", this._onEnd);
            this._audio = audio;
            this._src = audio.src;
        }
        __onEnd(evt) {
            if (this.loops == 1) {
                if (this.completeHandler) {
                    ILaya.systemTimer.once(10, this, this.__runComplete, [this.completeHandler], false);
                    this.completeHandler = null;
                }
                this.stop();
                this.event(Event.COMPLETE);
                return;
            }
            if (this.loops > 0) {
                this.loops--;
            }
            this.startTime = 0;
            this.play();
        }
        __resumePlay() {
            if (this._audio)
                this._audio.removeEventListener("canplay", this._resumePlay);
            if (this.isStopped)
                return;
            try {
                this._audio.currentTime = this.startTime;
                Browser.container.appendChild(this._audio);
                this._audio.play();
            }
            catch (e) {
                this.event(Event.ERROR);
            }
        }
        play() {
            this.isStopped = false;
            try {
                this._audio.playbackRate = SoundManager.playbackRate;
                this._audio.currentTime = this.startTime;
            }
            catch (e) {
                this._audio.addEventListener("canplay", this._resumePlay);
                return;
            }
            SoundManager.addChannel(this);
            Browser.container.appendChild(this._audio);
            if ("play" in this._audio)
                this._audio.play();
        }
        get position() {
            if (!this._audio)
                return 0;
            return this._audio.currentTime;
        }
        get duration() {
            if (!this._audio)
                return 0;
            return this._audio.duration;
        }
        stop() {
            super.stop();
            this.isStopped = true;
            SoundManager.removeChannel(this);
            this.completeHandler = null;
            if (!this._audio)
                return;
            if ("pause" in this._audio)
                if (LayaEnv.isConch) {
                    this._audio.stop();
                }
            this._audio.pause();
            this._audio.removeEventListener("ended", this._onEnd);
            this._audio.removeEventListener("canplay", this._resumePlay);
            if (!ILaya.Browser.onIE) {
                if (this._audio != AudioSound._musicAudio) {
                    Pool.recover("audio:" + this.url, this._audio);
                }
            }
            Browser.removeElement(this._audio);
            this._audio = null;
            if (SoundManager.autoReleaseSound)
                SoundManager.disposeSoundLater(this.url);
        }
        pause() {
            this.isStopped = true;
            SoundManager.removeChannel(this);
            if (!this._audio)
                return;
            if ("pause" in this._audio)
                this._audio.pause();
            if (SoundManager.autoReleaseSound)
                SoundManager.disposeSoundLater(this.url);
        }
        resume() {
            var audio = this._audio;
            if (!audio)
                return;
            this.isStopped = false;
            if (audio.readyState == 0) {
                audio.src = this._src;
                audio.addEventListener("canplay", this._resumePlay);
                audio.load();
            }
            SoundManager.addChannel(this);
            if ("play" in audio) {
                audio.play();
            }
        }
        set volume(v) {
            if (!this._audio)
                return;
            this._audio.volume = v;
        }
        get volume() {
            if (!this._audio)
                return 1;
            return this._audio.volume;
        }
    }

    class AudioSound extends EventDispatcher {
        constructor() {
            super(...arguments);
            this.loaded = false;
        }
        dispose() {
            var ad = AudioSound._audioCache[this.url];
            Pool.clearBySign("audio:" + this.url);
            if (ad) {
                if (!LayaEnv.isConch) {
                    ad.src = "";
                }
                delete AudioSound._audioCache[this.url];
            }
        }
        static _initMusicAudio() {
            if (AudioSound._musicAudio)
                return;
            if (!AudioSound._musicAudio)
                AudioSound._musicAudio = Browser.createElement("audio");
            if (!LayaEnv.isConch) {
                Browser.document.addEventListener("mousedown", AudioSound._makeMusicOK);
            }
        }
        static _makeMusicOK() {
            Browser.document.removeEventListener("mousedown", AudioSound._makeMusicOK);
            if (!AudioSound._musicAudio.src) {
                AudioSound._musicAudio.src = "";
                AudioSound._musicAudio.load();
            }
            else {
                AudioSound._musicAudio.play();
            }
        }
        load(url) {
            this.url = url;
            var ad;
            if (url == SoundManager._bgMusic) {
                AudioSound._initMusicAudio();
                ad = AudioSound._musicAudio;
                if (ad.originalUrl != url) {
                    delete AudioSound._audioCache[ad.originalUrl];
                    ad = null;
                }
            }
            else {
                ad = AudioSound._audioCache[url];
            }
            if (ad && ad.readyState >= 2) {
                this.event(Event.COMPLETE);
                return;
            }
            if (!ad) {
                if (url == SoundManager._bgMusic) {
                    AudioSound._initMusicAudio();
                    ad = AudioSound._musicAudio;
                }
                else {
                    ad = Browser.createElement("audio");
                }
                AudioSound._audioCache[url] = ad;
                AssetDb.inst.resolveURL(url, url => {
                    ad.src = URL.postFormatURL(URL.formatURL(url));
                });
            }
            ad.originalUrl = url;
            ad.addEventListener("canplaythrough", onLoaded);
            ad.addEventListener("error", onErr);
            var me = this;
            function onLoaded() {
                offs();
                me.loaded = true;
                me.event(Event.COMPLETE);
            }
            function onErr() {
                ad.load = null;
                offs();
                me.event(Event.ERROR);
            }
            function offs() {
                ad.removeEventListener("canplaythrough", onLoaded);
                ad.removeEventListener("error", onErr);
            }
            this.audio = ad;
            if (ad.load) {
                ad.load();
            }
            else {
                onErr();
            }
        }
        play(startTime = 0, loops = 0) {
            if (!this.url)
                return null;
            var ad;
            if (this.url == SoundManager._bgMusic) {
                ad = AudioSound._musicAudio;
                if (ad.src != "" && ad.originalUrl != this.url) {
                    delete AudioSound._audioCache[ad.originalUrl];
                    AudioSound._audioCache[this.url] = ad;
                }
            }
            else {
                ad = AudioSound._audioCache[this.url];
            }
            if (!ad)
                return null;
            var tAd;
            tAd = Pool.getItem("audio:" + this.url);
            if (LayaEnv.isConch) {
                if (!tAd) {
                    tAd = Browser.createElement("audio");
                    AssetDb.inst.resolveURL(this.url, url => {
                        tAd.src = URL.postFormatURL(URL.formatURL(url));
                    });
                }
            }
            else {
                if (this.url == SoundManager._bgMusic) {
                    AudioSound._initMusicAudio();
                    tAd = AudioSound._musicAudio;
                    AssetDb.inst.resolveURL(this.url, url => {
                        tAd.src = URL.postFormatURL(URL.formatURL(url));
                    });
                }
                else {
                    tAd = tAd ? tAd : ad.cloneNode(true);
                }
            }
            tAd.originalUrl = this.url;
            var channel = new AudioSoundChannel(tAd);
            channel.url = this.url;
            channel.loops = loops;
            channel.startTime = startTime;
            channel.play();
            SoundManager.addChannel(channel);
            return channel;
        }
        get duration() {
            var ad;
            ad = AudioSound._audioCache[this.url];
            if (!ad)
                return 0;
            return ad.duration;
        }
    }
    AudioSound._audioCache = {};

    class WebAudioSoundChannel extends SoundChannel {
        constructor() {
            super();
            this.bufferSource = null;
            this._currentTime = 0;
            this._volume = 1;
            this._startTime = 0;
            this._pauseTime = 0;
            this.context = WebAudioSound.ctx;
            this._onPlayEnd = this.__onPlayEnd.bind(this);
            if (this.context["createGain"]) {
                this.gain = this.context["createGain"]();
            }
            else {
                this.gain = this.context["createGainNode"]();
            }
        }
        play() {
            SoundManager.addChannel(this);
            this.isStopped = false;
            this._clearBufferSource();
            if (!this.audioBuffer)
                return;
            if (this.startTime >= this.duration)
                return this.stop();
            var context = this.context;
            var gain = this.gain;
            var bufferSource = context.createBufferSource();
            this.bufferSource = bufferSource;
            bufferSource.buffer = this.audioBuffer;
            bufferSource.connect(gain);
            if (gain)
                gain.disconnect();
            gain.connect(context.destination);
            bufferSource.onended = this._onPlayEnd;
            this._startTime = Browser.now();
            if (this.gain.gain.setTargetAtTime) {
                this.gain.gain.setTargetAtTime(this._volume, this.context.currentTime, WebAudioSoundChannel.SetTargetDelay);
            }
            else
                this.gain.gain.value = this._volume;
            if (this.loops == 0) {
                bufferSource.loop = true;
            }
            if (bufferSource.playbackRate.setTargetAtTime) {
                bufferSource.playbackRate.setTargetAtTime(SoundManager.playbackRate, this.context.currentTime, WebAudioSoundChannel.SetTargetDelay);
            }
            else
                bufferSource.playbackRate.value = SoundManager.playbackRate;
            bufferSource.start(0, this.startTime);
            this._currentTime = 0;
        }
        __onPlayEnd() {
            if (this.loops == 1) {
                if (this.completeHandler) {
                    ILaya.timer.once(10, this, this.__runComplete, [this.completeHandler], false);
                    this.completeHandler = null;
                }
                this.stop();
                this.event(Event.COMPLETE);
                return;
            }
            if (this.loops > 0) {
                this.loops--;
            }
            this.startTime = 0;
            this.play();
        }
        get position() {
            if (this.bufferSource) {
                return (Browser.now() - this._startTime) / 1000 + this.startTime;
            }
            return 0;
        }
        get duration() {
            if (this.audioBuffer) {
                return this.audioBuffer.duration;
            }
            return 0;
        }
        _clearBufferSource() {
            if (this.bufferSource) {
                var sourceNode = this.bufferSource;
                if (sourceNode.stop) {
                    sourceNode.stop(0);
                }
                else {
                    sourceNode.noteOff(0);
                }
                sourceNode.disconnect(0);
                sourceNode.onended = null;
                if (!WebAudioSoundChannel._tryCleanFailed)
                    this._tryClearBuffer(sourceNode);
                this.bufferSource = null;
            }
        }
        _tryClearBuffer(sourceNode) {
            try {
                sourceNode.buffer = null;
            }
            catch (e) {
                WebAudioSoundChannel._tryCleanFailed = true;
            }
        }
        stop() {
            super.stop();
            this._clearBufferSource();
            this.audioBuffer = null;
            if (this.gain)
                this.gain.disconnect();
            this.isStopped = true;
            SoundManager.removeChannel(this);
            this.completeHandler = null;
            if (SoundManager.autoReleaseSound)
                SoundManager.disposeSoundLater(this.url);
        }
        pause() {
            if (!this.isStopped) {
                this._pauseTime = this.position;
            }
            this._clearBufferSource();
            if (this.gain)
                this.gain.disconnect();
            this.isStopped = true;
            SoundManager.removeChannel(this);
            if (SoundManager.autoReleaseSound)
                SoundManager.disposeSoundLater(this.url);
        }
        resume() {
            this.startTime = this._pauseTime;
            this.play();
        }
        set volume(v) {
            this._volume = v;
            if (this.isStopped) {
                return;
            }
            if (this.gain.gain.setTargetAtTime) {
                this.gain.gain.setTargetAtTime(v, this.context.currentTime, WebAudioSoundChannel.SetTargetDelay);
            }
            else
                this.gain.gain.value = v;
        }
        get volume() {
            return this._volume;
        }
    }
    WebAudioSoundChannel._tryCleanFailed = false;
    WebAudioSoundChannel.SetTargetDelay = 0.001;

    class AtlasInfoManager {
        static enable(infoFile, callback = null) {
            ILaya.loader.fetch(infoFile, "json").then(data => {
                if (!data)
                    return;
                AtlasInfoManager.addToDict(data);
                callback && callback.run();
            });
        }
        static addToDict(data) {
            for (let tKey in data) {
                let tArr = data[tKey];
                let tPrefix = URL.formatURL(tArr[0]);
                tArr = tArr[1];
                let len = tArr.length;
                let entry = { url: tKey };
                for (let i = 0; i < len; i++) {
                    AtlasInfoManager._fileLoadDic[tPrefix + tArr[i]] = entry;
                }
            }
        }
        static getFileLoadPath(file) {
            return AtlasInfoManager._fileLoadDic[file];
        }
    }
    AtlasInfoManager._fileLoadDic = {};

    class WorkerLoader extends EventDispatcher {
        constructor() {
            super();
            this.worker = new Worker(WorkerLoader.workerPath);
            this.worker.onmessage = (evt) => {
                this.workerMessage(evt.data);
            };
        }
        static __init__() {
            if (WorkerLoader.I)
                return;
            if (!Worker)
                return;
            WorkerLoader.I = new WorkerLoader();
        }
        static workerSupported() {
            return Worker ? true : false;
        }
        static enableWorkerLoader() {
            WorkerLoader.enable = true;
        }
        static set enable(value) {
            if (WorkerLoader._enable != value) {
                WorkerLoader._enable = value;
                if (value) {
                    if (WorkerLoader.I == null)
                        WorkerLoader.__init__();
                    if (WorkerLoader.I.worker == null)
                        WorkerLoader._enable = false;
                }
            }
        }
        static get enable() {
            return WorkerLoader._enable;
        }
        workerMessage(data) {
            if (data) {
                switch (data.type) {
                    case "Image":
                        this.imageLoaded(data);
                        break;
                    case "Disable":
                        WorkerLoader.enable = false;
                        break;
                }
            }
        }
        imageLoaded(data) {
            if (!data.dataType || data.dataType != "imageBitmap") {
                this.event(data.url, null);
                return;
            }
            var imageData = data.imageBitmap;
            console.log("load:", data.url);
            this.event(data.url, imageData);
        }
    }
    WorkerLoader.workerPath = "libs/workerloader.js";
    WorkerLoader._enable = false;

    class AtlasResource extends Resource {
        constructor(dir, textures, frames) {
            super();
            this.dir = dir;
            this.textures = textures;
            this.frames = frames;
            this.lock = true;
        }
        _disposeResource() {
            for (let tex of this.textures) {
                if (tex)
                    tex.destroy();
            }
            for (let tex of this.frames)
                tex.destroy();
            this.frames.length = 0;
            this.textures.length = 0;
        }
    }

    class BatchProgress {
        constructor(callback) {
            this._callback = callback;
            this._items = [];
            this._weights = [];
            this._progress = 0;
        }
        get itemCount() {
            return this._items.length;
        }
        reset() {
            this._items.length = 0;
            this._weights.length = 0;
            this._progress = 0;
        }
        createCallback(weight) {
            let index = this._items.length;
            this._items.push(0);
            if (weight == null)
                this._weights.push(null);
            else
                this._weights.push(Math.max(0, Math.min(weight, 1)));
            return (progress) => this.update(index, progress);
        }
        update(index, value) {
            if (index != -1) {
                this._items[index] = Math.max(0, Math.min(value, 1));
                let np = 0;
                let col = this._items;
                let ws = this._weights;
                let perc = 1 / col.length;
                for (let i = 0; i < col.length; i++) {
                    let p = col[i];
                    let w = ws[i];
                    if (p != null)
                        np += p * (w != null ? w : perc);
                }
                value = np;
            }
            if (value > this._progress) {
                this._progress = value;
                this._callback(value);
            }
        }
    }

    class ImgUtils {
        static compareVersion(curVersion, needVersion) {
            let curVersionArr = curVersion.split('.');
            let needVersionArr = needVersion.split('.');
            const len = Math.max(curVersionArr.length, needVersionArr.length);
            while (curVersionArr.length < len) {
                curVersionArr.push('0');
            }
            while (needVersionArr.length < len) {
                needVersionArr.push('0');
            }
            for (let i = 0; i < len; i++) {
                const num1 = parseInt(curVersionArr[i]);
                const num2 = parseInt(needVersionArr[i]);
                if (num1 > num2) {
                    return true;
                }
                else if (num1 < num2) {
                    return false;
                }
            }
            return true;
        }
        static get isSupport() {
            if (Browser.onMiniGame) {
                var version = Browser.window.wx.getSystemInfoSync().SDKVersion;
                return ImgUtils.compareVersion(version, '2.14.0');
            }
            else if (Browser.onLayaRuntime) {
                return true;
            }
            else if (Browser.window.Blob)
                return Browser.window.Blob ? true : false;
            return false;
        }
        static arrayBufferToURL(url, arrayBuffer) {
            if (!ImgUtils.isSupport)
                return null;
            if (ImgUtils.data[url])
                return ImgUtils.data[url];
            var newurl = "";
            if (Browser.onMiniGame || Browser.onLayaRuntime) {
                newurl = Browser.window.wx.createBufferURL(arrayBuffer);
            }
            else if (Browser.window.Blob) {
                let blob = new Blob([arrayBuffer], { type: 'application/octet-binary' });
                newurl = Browser.window.URL.createObjectURL(blob);
            }
            if (ImgUtils.isSavaData)
                ImgUtils.data[url] = newurl;
            return newurl;
        }
        static _arrayBufferToURL(arrayBuffer) {
            if (!ImgUtils.isSupport)
                return null;
            var newurl = "";
            if (Browser.onMiniGame || Browser.onLayaRuntime) {
                newurl = Browser.window.wx.createBufferURL(arrayBuffer);
            }
            else if (Browser.window.Blob) {
                let blob = new Blob([arrayBuffer], { type: 'application/octet-binary' });
                newurl = Browser.window.URL.createObjectURL(blob);
            }
            return newurl;
        }
        static destroy(url) {
            if (!ImgUtils.isSupport)
                return;
            var newurl = ImgUtils.data[url];
            if (newurl) {
                if (Browser.onMiniGame || Browser.onLayaRuntime)
                    Browser.window.wx.revokeBufferURL(newurl);
                else if (Browser.window.Blob)
                    Browser.window.URL.revokeObjectURL(newurl);
                delete ImgUtils.data[url];
            }
        }
    }
    ImgUtils.data = {};
    ImgUtils.isSavaData = false;

    class HttpRequest extends EventDispatcher {
        constructor() {
            super(...arguments);
            this._http = new XMLHttpRequest();
        }
        send(url, data = null, method = "get", responseType = "text", headers = null) {
            this._responseType = responseType;
            this._data = null;
            if (Browser.onVVMiniGame || Browser.onQGMiniGame || Browser.onQQMiniGame || Browser.onAlipayMiniGame || Browser.onBLMiniGame || Browser.onHWMiniGame || Browser.onTTMiniGame || Browser.onTBMiniGame) {
                url = HttpRequest._urlEncode(url);
            }
            this._url = url;
            let http = this._http;
            http.open(method, url, true);
            if (headers) {
                for (let i = 0; i < headers.length; i++) {
                    http.setRequestHeader(headers[i++], headers[i]);
                }
            }
            if (data) {
                if (typeof (data) == 'string') {
                    http.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
                }
                else {
                    http.setRequestHeader("Content-Type", "application/json");
                    if (!(data instanceof ArrayBuffer))
                        data = JSON.stringify(data);
                }
            }
            else if (Browser.onBLMiniGame && Browser.onAndroid)
                data = {};
            let restype = responseType !== "arraybuffer" ? "text" : "arraybuffer";
            http.responseType = restype;
            if (http.dataType) {
                http.dataType = restype;
            }
            http.onerror = (e) => {
                this._onError(e);
            };
            http.onabort = (e) => {
                this._onAbort(e);
            };
            http.onprogress = (e) => {
                this._onProgress(e);
            };
            http.onload = (e) => {
                this._onLoad(e);
            };
            http.send(data);
        }
        _onProgress(e) {
            if (e && e.lengthComputable)
                this.event(Event.PROGRESS, e.loaded / e.total);
        }
        _onAbort(e) {
            this.error("Request was aborted by user");
        }
        _onError(e) {
            this.error("Request failed Status:" + this._http.status + " text:" + this._http.statusText);
        }
        _onLoad(e) {
            var http = this._http;
            var status = http.status !== undefined ? http.status : 200;
            if (status === 200 || status === 204 || status === 0) {
                this.complete();
            }
            else {
                this.error("[" + http.status + "]" + http.statusText + ":" + http.responseURL);
            }
        }
        error(message) {
            this.clear();
            this.event(Event.ERROR, message);
        }
        complete() {
            this.clear();
            var flag = true;
            try {
                if (this._responseType === "json") {
                    this._data = JSON.parse(this._http.responseText);
                }
                else if (this._responseType === "xml") {
                    this._data = Utils.parseXMLFromString(this._http.responseText);
                }
                else {
                    this._data = this._http.response || this._http.responseText;
                }
            }
            catch (e) {
                flag = false;
                this.error(e.message);
            }
            flag && this.event(Event.COMPLETE, this._data instanceof Array ? [this._data] : this._data);
        }
        clear() {
            var http = this._http;
            http.onerror = http.onabort = http.onprogress = http.onload = null;
        }
        get url() {
            return this._url;
        }
        get data() {
            return this._data;
        }
        get http() {
            return this._http;
        }
        reset() {
            this.offAll();
            this._data = null;
        }
    }
    HttpRequest._urlEncode = encodeURI;

    class Downloader {
        constructor() {
            this.httpRequestPool = [];
        }
        common(owner, url, originalUrl, contentType, onProgress, onComplete) {
            let http = this.getRequestInst();
            http.on(Event.COMPLETE, () => {
                let data = http.data;
                this.returnRequestInst(http);
                onComplete(data);
            });
            http.on(Event.ERROR, null, (error) => {
                this.returnRequestInst(http);
                onComplete(null, error);
            });
            if (onProgress)
                http.on(Event.PROGRESS, onProgress);
            http.send(url, null, "get", contentType);
            owner.$ref = http;
        }
        image(owner, url, originalUrl, onProgress, onComplete) {
            let image = new Browser.window.Image();
            image.crossOrigin = "";
            image.onload = () => {
                image.onload = null;
                image.onerror = null;
                onComplete(image);
            };
            image.onerror = () => {
                image.onload = null;
                image.onerror = null;
                onComplete(null, "");
            };
            image.src = url;
            owner.$ref = image;
        }
        imageWithBlob(owner, blob, originalUrl, onProgress, onComplete) {
            let url = ImgUtils.arrayBufferToURL(originalUrl, blob);
            this.image(owner, url, originalUrl, onProgress, onComplete);
        }
        imageWithWorker(owner, url, originalUrl, onProgress, onComplete) {
            WorkerLoader.enableWorkerLoader();
            if (WorkerLoader.enable) {
                let workerLoader = WorkerLoader.I;
                workerLoader.once(url, null, (imageData) => {
                    if (imageData)
                        onComplete(imageData);
                    else
                        onComplete(null, "workerloader failed!");
                });
                workerLoader.worker.postMessage(url);
            }
            else
                this.image(owner, url, originalUrl, onProgress, onComplete);
        }
        audio(owner, url, originalUrl, onProgress, onComplete) {
            let audio = Browser.createElement("audio");
            audio.crossOrigin = "";
            audio.oncanplaythrough = () => {
                audio.oncanplaythrough = null;
                audio.onerror = null;
                onComplete(audio);
            };
            audio.onerror = () => {
                audio.oncanplaythrough = null;
                audio.onerror = null;
                onComplete(null, "");
            };
            audio.src = url;
            owner.$ref = audio;
        }
        getRequestInst() {
            if (this.httpRequestPool.length == 0
                || Browser.onVVMiniGame || Browser.onHWMiniGame) {
                return new HttpRequest();
            }
            else {
                return this.httpRequestPool.pop();
            }
        }
        returnRequestInst(inst) {
            inst.reset();
            if (this.httpRequestPool.length < 10)
                this.httpRequestPool.push(inst);
        }
    }

    var typeIdCounter = 0;
    const NullURLInfo = { ext: null, typeId: null, main: false, loaderType: null };
    class Loader extends EventDispatcher {
        constructor() {
            super();
            this.retryNum = 1;
            this.retryDelay = 0;
            this.maxLoader = 5;
            this._loadings = new Map();
            this._queue = [];
            this._downloadings = new Set();
        }
        static registerLoader(exts, cls, type) {
            let typeEntry;
            if (type) {
                typeEntry = Loader.typeMap[type];
                if (!typeEntry)
                    Loader.typeMap[type] = typeEntry = { typeId: typeIdCounter++, loaderType: cls };
                else if (typeEntry.loaderType != cls)
                    typeEntry = { typeId: typeEntry.typeId, loaderType: cls };
            }
            else
                typeEntry = { typeId: typeIdCounter++, loaderType: cls };
            for (let ext of exts) {
                let entry = Loader.extMap[ext];
                if (entry && type) {
                    let i = entry.findIndex(e => e.typeId == typeEntry.typeId);
                    if (i == -1)
                        entry.push(typeEntry);
                    else
                        entry[i].loaderType = cls;
                }
                else {
                    Loader.extMap[ext] = [typeEntry];
                }
            }
        }
        get loading() {
            return this._loadings.size > 0;
        }
        load(url, arg1, arg2, arg3, priority, cache, group, ignoreCache, useWorkerLoader) {
            let complete;
            let type;
            let options = dummyOptions;
            if (arg1 instanceof Handler) {
                complete = arg1;
                type = arg3;
            }
            else if (typeof (arg1) === "string")
                type = arg1;
            else if (arg1 != null) {
                type = arg1.type;
                options = arg1;
            }
            if (priority != null || cache != null || group != null || useWorkerLoader != null) {
                if (options === dummyOptions)
                    options = { priority, cache, group, useWorkerLoader };
                else
                    options = Object.assign(options, { priority, cache, group, useWorkerLoader });
            }
            let onProgress;
            if (arg2 instanceof Handler)
                onProgress = (value) => arg2.runWith(value);
            else
                onProgress = arg2;
            let promise;
            if (Array.isArray(url)) {
                let pd;
                if (onProgress)
                    pd = new BatchProgress(onProgress);
                let promises = [];
                for (let i = 0; i < url.length; i++) {
                    let url2 = url[i];
                    if (!url2)
                        continue;
                    if (typeof (url2) === "string") {
                        promises.push(this._load1(url2, type, options, pd === null || pd === void 0 ? void 0 : pd.createCallback()));
                    }
                    else {
                        promises.push(this._load1(url2.url, url2.type || type, options !== dummyOptions ? Object.assign({}, options, url2) : url2, pd === null || pd === void 0 ? void 0 : pd.createCallback()));
                    }
                }
                promise = Promise.all(promises);
            }
            else if (typeof (url) === "string")
                promise = this._load1(url, type, options, onProgress);
            else
                promise = this._load1(url.url, url.type || type, options !== dummyOptions ? Object.assign({}, options, url) : url, onProgress);
            if (complete)
                return promise.then(result => {
                    complete.runWith(result);
                    return result;
                });
            else
                return promise;
        }
        _load1(url, type, options, onProgress) {
            let uuid = null;
            if (url.startsWith("res://")) {
                uuid = url.substring(6);
                let url2 = AssetDb.inst.UUID_to_URL(uuid);
                if (!url2) {
                    let promise = AssetDb.inst.UUID_to_URL_async(uuid);
                    if (!promise) {
                        !options.silent && Loader.warn(url);
                        return Promise.resolve(null);
                    }
                    return promise.then(url2 => {
                        if (url2)
                            return this._load2(url2, uuid, type, options, onProgress);
                        else {
                            !options.silent && Loader.warn(url);
                            return null;
                        }
                    });
                }
                else
                    url = url2;
            }
            else {
                let promise = AssetDb.inst.URL_to_UUID_async(url);
                if (promise) {
                    return promise.then(uuid => {
                        return this._load2(url, uuid, type, options, onProgress);
                    });
                }
            }
            return this._load2(url, uuid, type, options, onProgress);
        }
        _load2(url, uuid, type, options, onProgress) {
            let { ext, typeId, main, loaderType } = Loader.getURLInfo(url, type);
            if (!loaderType) {
                !options.silent && Loader.warn(url);
                return Promise.resolve(null);
            }
            let formattedUrl = URL.formatURL(url);
            if (options.group) {
                let set = Loader.groupMap[options.group];
                if (!set)
                    set = Loader.groupMap[options.group] = new Set();
                set.add(formattedUrl);
            }
            let obsoluteRes;
            if (options.cache == null || options.cache) {
                let cacheRes = Loader._getRes(formattedUrl, type);
                if (cacheRes !== undefined) {
                    if (cacheRes == null)
                        return Promise.resolve(null);
                    else {
                        if (!(cacheRes instanceof Resource))
                            return Promise.resolve(cacheRes);
                        if (cacheRes.obsolute)
                            obsoluteRes = cacheRes;
                        if (!obsoluteRes && (!cacheRes.uuid || !uuid || uuid == cacheRes.uuid))
                            return Promise.resolve(cacheRes);
                    }
                }
            }
            let loadingKey = formattedUrl;
            if (!main)
                loadingKey += "@" + typeId;
            let task = this._loadings.get(loadingKey);
            if (task) {
                if (onProgress)
                    task.onProgress.add(onProgress);
                return new Promise((resolve) => task.onComplete.add(resolve));
            }
            let atlasInfo = AtlasInfoManager.getFileLoadPath(formattedUrl);
            if (atlasInfo) {
                return this.load(atlasInfo.url, { type: Loader.ATLAS, baseUrl: atlasInfo.baseUrl }).then(() => {
                    return Loader.getRes(url, type);
                });
            }
            if (loadTaskPool.length > 0)
                task = loadTaskPool.pop();
            else
                task = new LoadTask();
            task.type = type;
            task.url = url;
            task.uuid = uuid;
            task.ext = ext;
            options = Object.assign(task.options, options);
            delete options.type;
            if (options.priority == null)
                options.priority = 0;
            if (options.useWorkerLoader == null)
                options.useWorkerLoader = WorkerLoader.enable;
            if (onProgress)
                task.onProgress.add(onProgress);
            task.loader = this;
            task.obsoluteInst = obsoluteRes;
            let assetLoader = new loaderType();
            this._loadings.set(loadingKey, task);
            let promise;
            try {
                promise = assetLoader.load(task);
            }
            catch (err) {
                !options.silent && Loader.warn(url, err);
                promise = Promise.resolve(null);
            }
            return promise.then(content => {
                if (content instanceof Resource) {
                    content._setCreateURL(url, uuid);
                }
                if (task.options.cache == null || task.options.cache)
                    Loader._cacheRes(formattedUrl, content, typeId, main);
                task.progress.update(-1, 1);
                task.onComplete.invoke(content);
                return content;
            }).catch(error => {
                !options.silent && Loader.warn(url, error);
                if (task.options.cache == null || task.options.cache)
                    Loader._cacheRes(formattedUrl, null, typeId, main);
                task.onComplete.invoke(null);
                return null;
            }).then((result) => {
                this._loadings.delete(loadingKey);
                task.reset();
                loadTaskPool.push(task);
                if (this._loadings.size == 0)
                    this.event(Event.COMPLETE);
                return result;
            });
        }
        fetch(url, contentType, onProgress, options) {
            var _a;
            options = options || dummyOptions;
            let task = {
                originalUrl: url,
                url: url,
                contentType: contentType,
                priority: (_a = options.priority) !== null && _a !== void 0 ? _a : 1,
                retryCnt: 0,
                onProgress: onProgress,
                onComplete: null,
            };
            if (options.useWorkerLoader)
                task.useWorkerLoader = true;
            if (options.blob)
                task.blob = options.blob;
            if (options.noRetry)
                task.retryCnt = -1;
            if (options.silent)
                task.silent = true;
            return new Promise((resolve) => {
                AssetDb.inst.resolveURL(url, url => {
                    task.url = URL.formatURL(url);
                    task.onComplete = resolve;
                    this.queueToDownload(task);
                });
            });
        }
        queueToDownload(item) {
            if (this._downloadings.size < this.maxLoader) {
                this.download(item);
                return;
            }
            let priority = item.priority;
            if (priority == 0)
                this._queue.push(item);
            else {
                let i = this._queue.findIndex(e => e.priority < priority);
                if (i != -1)
                    this._queue.splice(i, 0, item);
                else
                    this._queue.push(item);
            }
        }
        download(item) {
            this._downloadings.add(item);
            let url = URL.postFormatURL(item.url);
            if (item.contentType == "image") {
                let preloadedContent = Loader.preLoadedMap[item.url];
                if (preloadedContent) {
                    if (!(preloadedContent instanceof ArrayBuffer)) {
                        this.completeItem(item, preloadedContent);
                        return;
                    }
                    item.blob = preloadedContent;
                }
                if (item.blob) {
                    Loader.downloader.imageWithBlob(item, item.blob, item.originalUrl, item.onProgress, (data, error) => {
                        if (!data)
                            item.retryCnt = -1;
                        this.completeItem(item, data, error);
                    });
                }
                else if (item.useWorkerLoader) {
                    Loader.downloader.imageWithWorker(item, url, item.originalUrl, item.onProgress, (data, error) => {
                        if (!data)
                            item.useWorkerLoader = false;
                        this.completeItem(item, data, error);
                    });
                }
                else {
                    Loader.downloader.image(item, url, item.originalUrl, item.onProgress, (data, error) => this.completeItem(item, data, error));
                }
            }
            else if (item.contentType == "sound") {
                Loader.downloader.audio(item, url, item.originalUrl, item.onProgress, (data, error) => this.completeItem(item, data, error));
            }
            else {
                let preloadedContent = Loader.preLoadedMap[item.url];
                if (preloadedContent) {
                    this.completeItem(item, preloadedContent);
                    return;
                }
                Loader.downloader.common(item, url, item.originalUrl, item.contentType, item.onProgress, (data, error) => this.completeItem(item, data, error));
            }
        }
        completeItem(item, content, error) {
            this._downloadings.delete(item);
            if (content) {
                if (this._downloadings.size < this.maxLoader && this._queue.length > 0)
                    this.download(this._queue.shift());
                if (item.onProgress)
                    item.onProgress(1);
                item.onComplete(content);
            }
            else if (item.retryCnt != -1 && item.retryCnt < this.retryNum) {
                item.retryCnt++;
                if (!item.silent)
                    console.debug(`Retry to load ${item.url} (${item.retryCnt})`);
                ILaya.systemTimer.once(this.retryDelay, this, this.queueToDownload, [item], false);
            }
            else {
                !item.silent && Loader.warn(item.url);
                if (item.onProgress)
                    item.onProgress(1);
                if (this._downloadings.size < this.maxLoader && this._queue.length > 0)
                    this.download(this._queue.shift());
                item.onComplete(null);
            }
        }
        static getURLInfo(url, type) {
            let ext = url.startsWith("data:") ? "png" : Utils.getFileExtension(url);
            let extEntry;
            if (ext.length > 0)
                extEntry = Loader.extMap[ext];
            let typeId;
            let main;
            let loaderType;
            if (type) {
                let typeEntry = Loader.typeMap[type];
                if (!typeEntry) {
                    console.warn(`not recognize type: '${type}'`);
                    return NullURLInfo;
                }
                typeId = typeEntry.typeId;
                let i = 0;
                if (extEntry) {
                    if (extEntry[0].typeId === typeId
                        || (i = extEntry.findIndex(e => e.typeId === typeId)) != -1) {
                        main = i == 0;
                        loaderType = extEntry[i].loaderType;
                    }
                    else {
                        main = false;
                        loaderType = typeEntry.loaderType;
                    }
                }
                else {
                    main = type != Loader.TEXTURE2D;
                    loaderType = typeEntry.loaderType;
                }
            }
            else {
                if (!extEntry) {
                    console.warn(`not recognize the resource suffix: '${url}'`);
                    return NullURLInfo;
                }
                main = true;
                typeId = extEntry[0].typeId;
                loaderType = extEntry[0].loaderType;
            }
            return { ext, main, typeId, loaderType };
        }
        static warn(url, err) {
            console.warn(`Failed to load ${url}` + (err ? (":" + err) : ""));
        }
        static getRes(url, type) {
            url = URL.formatURL(url);
            let ret = Loader._getRes(url, type);
            return ret || null;
        }
        static _getRes(url, type) {
            let resArr = Loader.loadedMap[url];
            if (!resArr)
                return undefined;
            let ret;
            if (type) {
                let typeEntry = Loader.typeMap[type];
                if (!typeEntry)
                    return undefined;
                if (resArr.length == 2) {
                    if (resArr[0] == typeEntry.typeId)
                        ret = resArr[1];
                }
                else {
                    let i = resArr.indexOf(typeEntry.typeId);
                    if (i != -1)
                        ret = resArr[i + 1];
                }
            }
            else
                ret = resArr[1];
            if ((ret instanceof Resource) && ret.destroyed)
                return undefined;
            else
                return ret;
        }
        static getTexture2D(url) {
            return Loader.getRes(url, Loader.TEXTURE2D);
        }
        static getBaseTexture(url) {
            return Loader.getRes(url, Loader.TEXTURE2D);
        }
        static getAtlas(url) {
            return Loader.getRes(url, Loader.ATLAS);
        }
        getRes(url, type) {
            return Loader.getRes(url, type);
        }
        static createNodes(url) {
            var _a;
            return (_a = Loader.getRes(url)) === null || _a === void 0 ? void 0 : _a.create();
        }
        static cacheRes(url, data, type) {
            url = URL.formatURL(url);
            let urlInfo = Loader.getURLInfo(url, type);
            if (urlInfo.typeId != null)
                Loader._cacheRes(url, data, urlInfo.typeId, urlInfo.main);
        }
        static _cacheRes(url, data, typeId, main) {
            let entry = Loader.loadedMap[url];
            if (main) {
                if (entry) {
                    entry[0] = typeId;
                    entry[1] = data;
                }
                else
                    entry = Loader.loadedMap[url] = [typeId, data];
            }
            else {
                if (entry) {
                    let i = entry.findIndex(e => e === typeId);
                    if (i != -1)
                        entry[i + 1] = data;
                    else
                        entry.push(typeId, data);
                }
                else
                    entry = Loader.loadedMap[url] = [null, undefined, typeId, data];
            }
        }
        cacheRes(url, data, type) {
            Loader.cacheRes(url, data, type);
        }
        static clearRes(url, checkObj) {
            url = URL.formatURL(url);
            Loader._clearRes(url, checkObj);
        }
        clearRes(url, checkObj) {
            url = URL.formatURL(url);
            Loader._clearRes(url, checkObj);
        }
        static _clearRes(url, checkObj) {
            let entry = Loader.loadedMap[url];
            if (!entry)
                return;
            if (checkObj) {
                if (entry[1] == checkObj) {
                    if (entry.length == 2)
                        delete Loader.loadedMap[url];
                    else
                        entry[1] = undefined;
                }
                else {
                    let i = entry.indexOf(checkObj);
                    if (i == -1)
                        return;
                    if (entry.length == 4 && entry[0] == null)
                        delete Loader.loadedMap[url];
                    else
                        entry.splice(i - 1, 2);
                }
                if ((checkObj instanceof Resource) && !checkObj.destroyed) {
                    checkObj.destroy();
                }
            }
            else {
                delete Loader.loadedMap[url];
                if (entry.length > 2) {
                    for (let i = 1; i < entry.length; i += 2) {
                        let obj = entry[i];
                        if ((obj instanceof Resource) && !obj.destroyed) {
                            obj.destroy();
                        }
                    }
                }
                else {
                    let obj = entry[1];
                    if ((obj instanceof Resource) && !obj.destroyed) {
                        obj.destroy();
                    }
                }
            }
        }
        clearTextureRes(url) {
            url = URL.formatURL(url);
            let entry = Loader.loadedMap[url];
            if (!entry)
                return;
            let res = entry[0];
            if (res instanceof Texture) {
                res.disposeBitmap();
            }
            else if (res instanceof AtlasResource) {
                for (let tex of res.textures)
                    tex.disposeBitmap();
            }
        }
        static setGroup(url, group) {
            url = URL.formatURL(url);
            let set = Loader.groupMap[group];
            if (!set)
                set = Loader.groupMap[group] = new Set();
            set.add(url);
        }
        static clearResByGroup(group) {
            let set = Loader.groupMap[group];
            if (set) {
                for (let k of set)
                    Loader._clearRes(k);
            }
        }
        clearUnLoaded() {
            if (this._queue.length == 0)
                return;
            let arr = this._queue.concat();
            this._queue.length = 0;
            for (let item of arr)
                item.onComplete(null);
        }
        cancelLoadByUrls(urls) {
            if (!urls)
                return;
            for (var i = 0, n = urls.length; i < n; i++) {
                this.cancelLoadByUrl(urls[i]);
            }
        }
        cancelLoadByUrl(url) {
            url = URL.formatURL(url);
            let i = this._queue.findIndex(item => item.url == url);
            if (i != -1) {
                let item = this._queue[i];
                this._queue.splice(i, 1);
                item.onComplete(null);
            }
        }
    }
    Loader.TEXT = "text";
    Loader.JSON = "json";
    Loader.XML = "xml";
    Loader.BUFFER = "arraybuffer";
    Loader.IMAGE = "image";
    Loader.SOUND = "sound";
    Loader.VIDEO = "video";
    Loader.ATLAS = "atlas";
    Loader.FONT = "font";
    Loader.TTF = "ttf";
    Loader.HIERARCHY = "HIERARCHY";
    Loader.MESH = "MESH";
    Loader.MATERIAL = "MATERIAL";
    Loader.TEXTURE2D = "TEXTURE2D";
    Loader.TEXTURECUBE = "TEXTURE2D";
    Loader.ANIMATIONCLIP = "ANIMATIONCLIP";
    Loader.TERRAINHEIGHTDATA = "TERRAINHEIGHTDATA";
    Loader.TERRAINRES = "TERRAIN";
    Loader.SPINE = "SPINE";
    Loader.extMap = {};
    Loader.typeMap = {};
    Loader.downloader = new Downloader();
    Loader.groupMap = {};
    Loader.loadedMap = {};
    Loader.preLoadedMap = {};
    class LoadTask {
        constructor() {
            this.options = {};
            this.onProgress = new Delegate();
            this.onComplete = new Delegate();
            this.progress = new BatchProgress((progress) => this.onProgress.invoke(progress));
        }
        reset() {
            for (let k in this.options)
                delete this.options[k];
            this.onProgress.clear();
            this.onComplete.clear();
            this.progress.reset();
            this.obsoluteInst = null;
        }
    }
    const loadTaskPool = [];
    const dummyOptions = {};

    class WebAudioSound extends EventDispatcher {
        constructor() {
            super(...arguments);
            this.loaded = false;
            this._disposed = false;
        }
        static _playEmptySound() {
            if (WebAudioSound.ctx == null) {
                return;
            }
            var source = WebAudioSound.ctx.createBufferSource();
            source.buffer = WebAudioSound._miniBuffer;
            source.connect(WebAudioSound.ctx.destination);
            source.start(0, 0, 0);
        }
        static _unlock() {
            if (WebAudioSound._unlocked) {
                return;
            }
            WebAudioSound._playEmptySound();
            if (WebAudioSound.ctx.state == "running") {
                window.document.removeEventListener("mousedown", WebAudioSound._unlock, true);
                window.document.removeEventListener("touchend", WebAudioSound._unlock, true);
                window.document.removeEventListener("touchstart", WebAudioSound._unlock, true);
                WebAudioSound._unlocked = true;
            }
        }
        static initWebAudio() {
            WebAudioSound.ctx = new (window["AudioContext"] || window["webkitAudioContext"] || window["mozAudioContext"])();
            if (WebAudioSound.ctx.state != "running") {
                WebAudioSound._unlock();
                window.document.addEventListener("mousedown", WebAudioSound._unlock, true);
                window.document.addEventListener("touchend", WebAudioSound._unlock, true);
                window.document.addEventListener("touchstart", WebAudioSound._unlock, true);
            }
        }
        load(url) {
            this.url = url;
            this.audioBuffer = ILaya.loader.getRes(url);
            if (this.audioBuffer) {
                this._loaded(this.audioBuffer);
                return;
            }
            ILaya.loader.load(url, Loader.SOUND).then(audioBuffer => this._loaded(audioBuffer));
        }
        _loaded(audioBuffer) {
            if (this._disposed)
                return;
            this.audioBuffer = audioBuffer;
            this.loaded = true;
            this.event(Event.COMPLETE);
        }
        __playAfterLoaded() {
            if (!this.__toPlays)
                return;
            var i, len;
            var toPlays;
            toPlays = this.__toPlays;
            len = toPlays.length;
            var tParams;
            for (i = 0; i < len; i++) {
                tParams = toPlays[i];
                if (tParams[2] && !tParams[2].isStopped) {
                    this.play(tParams[0], tParams[1], tParams[2]);
                }
            }
            this.__toPlays.length = 0;
        }
        play(startTime = 0, loops = 0, channel = null) {
            channel = channel ? channel : new WebAudioSoundChannel();
            if (!this.audioBuffer) {
                if (this.url) {
                    if (!this.__toPlays)
                        this.__toPlays = [];
                    this.__toPlays.push([startTime, loops, channel]);
                    this.once(Event.COMPLETE, this, this.__playAfterLoaded);
                    this.load(this.url);
                }
            }
            channel.url = this.url;
            channel.loops = loops;
            channel.audioBuffer = this.audioBuffer;
            channel.startTime = startTime;
            channel.play();
            SoundManager.addChannel(channel);
            return channel;
        }
        get duration() {
            if (this.audioBuffer) {
                return this.audioBuffer.duration;
            }
            return 0;
        }
        dispose() {
            this._disposed = true;
            if (this.audioBuffer) {
                ILaya.loader.clearRes(this.url, this.audioBuffer);
                this.audioBuffer = null;
            }
            this.__toPlays = [];
        }
    }
    WebAudioSound._miniBuffer = WebAudioSound.ctx ? WebAudioSound.ctx.createBuffer(1, 1, 22050) : undefined;
    WebAudioSound._unlocked = false;

    class SoundManager {
        static __init__() {
            var win = ILaya.Browser.window;
            var supportWebAudio = win["AudioContext"] || win["webkitAudioContext"] || win["mozAudioContext"] ? true : false;
            if (supportWebAudio)
                WebAudioSound.initWebAudio();
            SoundManager._soundClass = supportWebAudio ? WebAudioSound : AudioSound;
            if (!Browser.onTBMiniGame) {
                AudioSound._initMusicAudio();
            }
            SoundManager._musicClass = AudioSound;
            return supportWebAudio;
        }
        static addChannel(channel) {
            if (SoundManager._channels.indexOf(channel) >= 0)
                return;
            SoundManager._channels.push(channel);
        }
        static removeChannel(channel) {
            for (let i = SoundManager._channels.length - 1; i >= 0; i--) {
                if (SoundManager._channels[i] == channel) {
                    SoundManager._channels.splice(i, 1);
                }
            }
        }
        static disposeSoundLater(url) {
            SoundManager._lastSoundUsedTimeDic[url] = ILaya.Browser.now();
            if (!SoundManager._isCheckingDispose) {
                SoundManager._isCheckingDispose = true;
                ILaya.timer.loop(5000, null, SoundManager._checkDisposeSound);
            }
        }
        static _checkDisposeSound() {
            let tTime = ILaya.Browser.now();
            let hasCheck = false;
            for (let key in SoundManager._lastSoundUsedTimeDic) {
                if (tTime - SoundManager._lastSoundUsedTimeDic[key] > 30000) {
                    delete SoundManager._lastSoundUsedTimeDic[key];
                    SoundManager.disposeSoundIfNotUsed(key);
                }
                else {
                    hasCheck = true;
                }
            }
            if (!hasCheck) {
                SoundManager._isCheckingDispose = false;
                ILaya.timer.clear(null, SoundManager._checkDisposeSound);
            }
        }
        static disposeSoundIfNotUsed(url) {
            for (let i = SoundManager._channels.length - 1; i >= 0; i--) {
                if (SoundManager._channels[i].url == url) {
                    return;
                }
            }
            SoundManager.destroySound(url);
        }
        static set autoStopMusic(v) {
            ILaya.stage.off(Event.BLUR, null, SoundManager._stageOnBlur);
            ILaya.stage.off(Event.FOCUS, null, SoundManager._stageOnFocus);
            ILaya.stage.off(Event.VISIBILITY_CHANGE, null, SoundManager._visibilityChange);
            SoundManager._autoStopMusic = v;
            if (v) {
                ILaya.stage.on(Event.BLUR, null, SoundManager._stageOnBlur);
                ILaya.stage.on(Event.FOCUS, null, SoundManager._stageOnFocus);
                ILaya.stage.on(Event.VISIBILITY_CHANGE, null, SoundManager._visibilityChange);
            }
        }
        static get autoStopMusic() {
            return SoundManager._autoStopMusic;
        }
        static _visibilityChange() {
            if (ILaya.stage.isVisibility) {
                SoundManager._stageOnFocus();
            }
            else {
                SoundManager._stageOnBlur();
            }
        }
        static _stageOnBlur() {
            SoundManager._isActive = false;
            if (SoundManager._musicChannel) {
                if (!SoundManager._musicChannel.isStopped) {
                    SoundManager._blurPaused = true;
                    SoundManager._musicChannel.pause();
                }
            }
            SoundManager.stopAllSound();
            ILaya.stage.once(Event.MOUSE_DOWN, null, SoundManager._stageOnFocus);
        }
        static _recoverWebAudio() {
            if (WebAudioSound.ctx && WebAudioSound.ctx.state != "running" && WebAudioSound.ctx.resume)
                WebAudioSound.ctx.resume();
        }
        static _stageOnFocus() {
            SoundManager._isActive = true;
            SoundManager._recoverWebAudio();
            ILaya.stage.off(Event.MOUSE_DOWN, null, SoundManager._stageOnFocus);
            if (SoundManager._blurPaused) {
                if (SoundManager._musicChannel && SoundManager._musicChannel.isStopped) {
                    SoundManager._blurPaused = false;
                    SoundManager._musicChannel.resume();
                }
            }
        }
        static set muted(value) {
            if (value == SoundManager._muted)
                return;
            if (value) {
                SoundManager.stopAllSound();
            }
            SoundManager.musicMuted = value;
            SoundManager._muted = value;
        }
        static get muted() {
            return SoundManager._muted;
        }
        static set soundMuted(value) {
            SoundManager._soundMuted = value;
        }
        static get soundMuted() {
            return SoundManager._soundMuted;
        }
        static set musicMuted(value) {
            if (value == SoundManager._musicMuted)
                return;
            if (value) {
                if (SoundManager._bgMusic) {
                    if (SoundManager._musicChannel && !SoundManager._musicChannel.isStopped) {
                        if (LayaEnv.isConch) {
                            if (SoundManager._musicChannel._audio)
                                SoundManager._musicChannel._audio.muted = true;
                        }
                        else {
                            SoundManager._musicChannel.pause();
                        }
                    }
                    else {
                        SoundManager._musicChannel = null;
                    }
                }
                else {
                    SoundManager._musicChannel = null;
                }
                SoundManager._musicMuted = value;
            }
            else {
                SoundManager._musicMuted = value;
                if (SoundManager._bgMusic) {
                    if (SoundManager._musicChannel) {
                        if (LayaEnv.isConch) {
                            if (SoundManager._musicChannel._audio)
                                SoundManager._musicChannel._audio.muted = false;
                        }
                        else {
                            SoundManager._musicChannel.resume();
                        }
                    }
                }
            }
        }
        static get musicMuted() {
            return SoundManager._musicMuted;
        }
        static get useAudioMusic() {
            return SoundManager._useAudioMusic;
        }
        static set useAudioMusic(value) {
            SoundManager._useAudioMusic = value;
            if (value) {
                SoundManager._musicClass = AudioSound;
            }
            else {
                SoundManager._musicClass = null;
            }
        }
        static playSound(url, loops = 1, complete = null, soundClass = null, startTime = 0) {
            if (!SoundManager._isActive || !url)
                return null;
            if (SoundManager._muted)
                return null;
            SoundManager._recoverWebAudio();
            if (url == SoundManager._bgMusic) {
                if (SoundManager._musicMuted)
                    return null;
            }
            else {
                if (SoundManager._soundMuted)
                    return null;
            }
            let tSound;
            if (!Browser._isMiniGame) {
                tSound = SoundManager._soundCache[url];
            }
            if (!soundClass)
                soundClass = SoundManager._soundClass;
            if (!tSound) {
                tSound = new soundClass();
                tSound.load(url);
                if (!Browser._isMiniGame) {
                    SoundManager._soundCache[url] = tSound;
                }
            }
            let channel = tSound.play(startTime, loops);
            if (!channel)
                return null;
            channel.url = url;
            channel.volume = (url == SoundManager._bgMusic) ? SoundManager.musicVolume : SoundManager.soundVolume;
            channel.completeHandler = complete;
            return channel;
        }
        static destroySound(url) {
            let tSound = SoundManager._soundCache[url];
            if (tSound) {
                delete SoundManager._soundCache[url];
                tSound.dispose();
            }
        }
        static playMusic(url, loops = 0, complete = null, startTime = 0) {
            SoundManager._bgMusic = url;
            if (SoundManager._musicChannel)
                SoundManager._musicChannel.stop();
            return SoundManager._musicChannel = SoundManager.playSound(url, loops, complete, SoundManager._musicClass, startTime);
        }
        static stopSound(url) {
            for (let i = SoundManager._channels.length - 1; i >= 0; i--) {
                let channel = SoundManager._channels[i];
                if (channel.url == url) {
                    channel.stop();
                }
            }
        }
        static stopAll() {
            SoundManager._bgMusic = null;
            var i;
            var channel;
            for (i = SoundManager._channels.length - 1; i >= 0; i--) {
                channel = SoundManager._channels[i];
                channel.stop();
            }
        }
        static stopAllSound() {
            for (let i = SoundManager._channels.length - 1; i >= 0; i--) {
                let channel = SoundManager._channels[i];
                if (channel.url != SoundManager._bgMusic) {
                    channel.stop();
                }
            }
        }
        static stopMusic() {
            if (SoundManager._musicChannel)
                SoundManager._musicChannel.stop();
            SoundManager._bgMusic = null;
        }
        static setSoundVolume(volume, url = null) {
            if (url) {
                SoundManager._setVolume(url, volume);
            }
            else {
                SoundManager.soundVolume = volume;
                for (let i = SoundManager._channels.length - 1; i >= 0; i--) {
                    let channel = SoundManager._channels[i];
                    if (channel.url != SoundManager._bgMusic) {
                        channel.volume = volume;
                    }
                }
            }
        }
        static setMusicVolume(volume) {
            SoundManager.musicVolume = volume;
            SoundManager._setVolume(SoundManager._bgMusic, volume);
        }
        static _setVolume(url, volume) {
            for (let i = SoundManager._channels.length - 1; i >= 0; i--) {
                let channel = SoundManager._channels[i];
                if (channel.url == url) {
                    channel.volume = volume;
                }
            }
        }
    }
    SoundManager.musicVolume = 1;
    SoundManager.soundVolume = 1;
    SoundManager.playbackRate = 1;
    SoundManager._useAudioMusic = true;
    SoundManager._muted = false;
    SoundManager._soundMuted = false;
    SoundManager._musicMuted = false;
    SoundManager._bgMusic = null;
    SoundManager._musicChannel = null;
    SoundManager._channels = [];
    SoundManager._blurPaused = false;
    SoundManager._isActive = true;
    SoundManager._lastSoundUsedTimeDic = {};
    SoundManager._isCheckingDispose = false;
    SoundManager._soundCache = {};
    SoundManager.autoReleaseSound = true;

    class LocalStorage {
        static __init__() {
            if (!LocalStorage._baseClass) {
                LocalStorage._baseClass = Storage;
                Storage.init();
            }
            LocalStorage.items = LocalStorage._baseClass.items;
            LocalStorage.support = LocalStorage._baseClass.support;
            return LocalStorage.support;
        }
        static setItem(key, value) {
            LocalStorage._baseClass.setItem(key, value);
        }
        static getItem(key) {
            return LocalStorage._baseClass.getItem(key);
        }
        static setJSON(key, value) {
            LocalStorage._baseClass.setJSON(key, value);
        }
        static getJSON(key) {
            return LocalStorage._baseClass.getJSON(key);
        }
        static removeItem(key) {
            LocalStorage._baseClass.removeItem(key);
        }
        static clear() {
            LocalStorage._baseClass.clear();
        }
    }
    LocalStorage.support = false;
    class Storage {
        static init() {
            try {
                Storage.support = true;
                Storage.items = window.localStorage;
                Storage.setItem('laya', '1');
                Storage.removeItem('laya');
            }
            catch (e) {
                Storage.support = false;
            }
            if (!Storage.support)
                console.log('LocalStorage is not supprot or browser is private mode.');
        }
        static setItem(key, value) {
            try {
                Storage.support && Storage.items.setItem(key, value);
            }
            catch (e) {
                console.warn("set localStorage failed", e);
            }
        }
        static getItem(key) {
            return Storage.support ? Storage.items.getItem(key) : null;
        }
        static setJSON(key, value) {
            try {
                Storage.support && Storage.items.setItem(key, JSON.stringify(value));
            }
            catch (e) {
                console.warn("set localStorage failed", e);
            }
        }
        static getJSON(key) {
            try {
                let obj = JSON.parse(Storage.support ? Storage.items.getItem(key) : null);
                return obj;
            }
            catch (err) {
                return Storage.items.getItem(key);
            }
        }
        static removeItem(key) {
            Storage.support && Storage.items.removeItem(key);
        }
        static clear() {
            Storage.support && Storage.items.clear();
        }
    }
    Storage.support = false;

    class IStatRender {
        show(x = 0, y = 0, views) {
        }
        showToggle(x = 0, y = 0, views) {
        }
        enable() {
        }
        hide() {
        }
        set_onclick(fn) {
        }
        isCanvasRender() {
            return true;
        }
        renderNotCanvas(ctx, x, y) { }
    }

    class StatUI extends IStatRender {
        constructor() {
            super(...arguments);
            this._show = false;
            this._showToggle = false;
            this._height = 100;
            this._view = [];
            this._toggleView = [];
            this._checkBoxArray = [];
        }
        show(x = 0, y = 0, views) {
            this._view.length = views.length;
            for (let i = 0, n = this._view.length; i < n; i++) {
                this._view[i] = views[i];
            }
            if (!this._show) {
                this.createUI(x, y);
                this.enable();
            }
            this._show = true;
        }
        showToggle(x = 0, y = 0, views) {
            ILaya.Loader.cacheRes("defaultCheckBox", Texture2D.defalutUITexture, "TEXTURE2D");
            this._toggleView.length = views.length;
            for (let i = 0, n = this._toggleView.length; i < n; i++) {
                this._toggleView[i] = views[i];
            }
            if (!this._showToggle) {
                this.createToggleUI(x, y);
                this.enable();
            }
            this._showToggle = true;
        }
        createToggleUI(x, y) {
            var stat = this._toggleSprite;
            var pixel = Browser.pixelRatio;
            if (!stat) {
                stat = new Sprite();
                this._toggleleftText = new Text();
                this._toggleleftText.pos(5, 5);
                this._toggleleftText.color = "#ffffff";
                stat.addChild(this._toggleleftText);
                this._toggletxt = new Sprite();
                this._toggletxt.pos(170 * pixel, 5);
                stat.addChild(this._toggletxt);
                this._toggleSprite = stat;
                this._checkBoxArray.length = 0;
            }
            stat.pos(x, y);
            var text = "";
            for (var i = 0; i < this._toggleView.length; i++) {
                var one = this._toggleView[i];
                text += one.title + "\n";
                let checkBox = new exports.CheckBox("defaultCheckBox");
                checkBox.selected = Stat[one.value];
                this._checkBoxArray.push(checkBox);
                checkBox.scale(StatUI._toggleSize, StatUI._toggleSize);
                this._toggletxt.addChild(checkBox);
                checkBox.pos(0, i * (StatUI._toggleSize + 5));
            }
            this._toggleleftText.text = text;
            var width = pixel * 138;
            var height = pixel * (this._toggleView.length * (StatUI._toggleSize + 5)) + 4;
            this._toggleleftText.fontSize = (StatUI._toggleSize + 5) * pixel;
            stat.size(width, height);
            stat.graphics.clear();
            stat.graphics.alpha(0.5);
            stat.graphics.drawRect(0, 0, width + 110, height + 10, "#999999");
            stat.graphics.alpha(2);
            Laya.stage.addChild(stat);
            this.loop();
        }
        createUI(x, y) {
            var stat = this._sp;
            var pixel = Browser.pixelRatio;
            if (!stat) {
                stat = new Sprite();
                this._leftText = new Text();
                this._leftText.pos(5, 5);
                this._leftText.color = "#ffffff";
                stat.addChild(this._leftText);
                this._txt = new Text();
                this._txt.pos(171 * pixel, 5);
                this._txt.color = "#ffffff";
                stat.addChild(this._txt);
                this._sp = stat;
            }
            stat.pos(x, y);
            var text = "";
            for (var i = 0; i < this._view.length; i++) {
                var one = this._view[i];
                text += one.title + "\n";
            }
            this._leftText.text = text;
            var width = pixel * 138;
            var height = pixel * (this._view.length * StatUI._fontSize) + 4;
            this._txt.fontSize = StatUI._fontSize * pixel;
            this._leftText.fontSize = StatUI._fontSize * pixel;
            stat.size(width, height);
            stat.graphics.clear();
            stat.graphics.alpha(0.5);
            stat.graphics.drawRect(0, 0, width + 110, height + 10, "#999999");
            stat.graphics.alpha(2);
            this.loop();
        }
        enable() {
            ILaya.systemTimer.frameLoop(1, this, this.loop);
        }
        hide() {
            this._show = false;
            this._showToggle = false;
            ILaya.systemTimer.clear(this, this.loop);
            if (this._canvas) {
                Browser.removeElement(this._canvas.source);
            }
        }
        set_onclick(fn) {
            if (this._sp) {
                this._sp.on("click", this._sp, fn);
            }
            if (this._canvas) {
                this._canvas.source.onclick = fn;
                this._canvas.source.style.pointerEvents = '';
            }
        }
        loop() {
            Stat._count++;
            var timer = Browser.now();
            if (timer - Stat._timer < 1000)
                return;
            var count = Stat._count;
            Stat.FPS = Math.round((count * 1000) / (timer - Stat._timer));
            if (this._show) {
                Stat.updateEngineData();
                var delay = Stat.FPS > 0 ? Math.floor(1000 / Stat.FPS).toString() : " ";
                Stat._fpsStr = Stat.FPS + (Stat.renderSlow ? " slow" : "") + " " + delay;
                this.renderInfo(count);
                Stat.clear();
            }
            if (this._showToggle) {
                for (var i = 0; i < this._toggleView.length; i++) {
                    let one = this._toggleView[i];
                    Stat[one.value] = this._checkBoxArray[i].selected;
                }
            }
            Stat._count = 0;
            Stat._timer = timer;
        }
        renderInfo(count) {
            var text = "";
            for (var i = 0; i < this._view.length; i++) {
                let vieparam = this._view[i];
                let isAverage = vieparam.mode == "average";
                var value = Stat[vieparam.value];
                (vieparam.units == "M") && (value = Math.floor(value / (1024 * 1024) * 100) / 100);
                (vieparam.units == "K") && (value = Math.floor(value / (1024) * 100) / 100);
                if (isAverage) {
                    value /= count;
                    value = Math.floor(value);
                }
                (vieparam.units == "M") && (value += "M");
                (vieparam.units == "K") && (value += "K");
                text += value + "\n";
            }
            this._txt.text = text;
        }
        renderNotCanvas(ctx, x, y) {
            this._show && this._sp && this._sp.render(ctx, 0, 0);
        }
    }
    StatUI._fontSize = 14;
    StatUI._toggleSize = 16;

    class SkinSV extends Value2D {
        constructor(type) {
            super(ShaderDefines2D.SKINMESH, 0);
            this.offsetX = 300;
            this.offsetY = 0;
            var _vlen = 8 * Const.BYTES_PE;
            const glfloat = LayaGL.renderEngine.getParams(exports.RenderParams.FLOAT);
            this.position = [2, glfloat, false, _vlen, 0];
            this.texcoord = [2, glfloat, false, _vlen, 2 * Const.BYTES_PE];
            this.color = [4, glfloat, false, _vlen, 4 * Const.BYTES_PE];
        }
    }

    class PrimitiveSV extends Value2D {
        constructor(args) {
            super(ShaderDefines2D.PRIMITIVE, 0);
            this._attribLocation = ['position', 0, 'attribColor', 1];
        }
    }

    class TextureSV extends Value2D {
        constructor(subID = 0) {
            super(ShaderDefines2D.TEXTURE2D, subID);
            this.strength = 0;
            this.blurInfo = null;
            this.colorMat = null;
            this.colorAlpha = null;
            this._attribLocation = ['posuv', 0, 'attribColor', 1, 'attribFlags', 2];
        }
        clear() {
            this.texture = null;
            this.shader = null;
            this.defines._value = this.subID;
        }
    }

    class Mouse {
        static set cursor(cursorStr) {
            Mouse._style.cursor = cursorStr;
        }
        static get cursor() {
            return Mouse._style.cursor;
        }
        static __init__() {
            Mouse._style = Browser.document.body.style;
        }
        static hide() {
            if (Mouse.cursor != "none") {
                Mouse._preCursor = Mouse.cursor;
                Mouse.cursor = "none";
            }
        }
        static show() {
            if (Mouse.cursor == "none") {
                if (Mouse._preCursor) {
                    Mouse.cursor = Mouse._preCursor;
                }
                else {
                    Mouse.cursor = "auto";
                }
            }
        }
    }

    class MeshParticle2D extends Mesh2D {
        constructor(maxNum) {
            super(MeshParticle2D.const_stride, maxNum * 4 * MeshParticle2D.const_stride, 4);
            this.canReuse = true;
            this.setAttributes(MeshParticle2D._fixattriInfo);
            this.createQuadIB(maxNum);
            this._quadNum = maxNum;
            if (!MeshParticle2D.vertexDeclaration) {
                MeshParticle2D.vertexDeclaration = new VertexDeclaration(116, [
                    new VertexElement(0, VertexElementFormat.Vector4, 0),
                    new VertexElement(16, VertexElementFormat.Vector3, 1),
                    new VertexElement(28, VertexElementFormat.Vector3, 2),
                    new VertexElement(40, VertexElementFormat.Vector4, 3),
                    new VertexElement(56, VertexElementFormat.Vector4, 4),
                    new VertexElement(72, VertexElementFormat.Vector3, 5),
                    new VertexElement(84, VertexElementFormat.Vector2, 6),
                    new VertexElement(92, VertexElementFormat.Vector4, 7),
                    new VertexElement(108, VertexElementFormat.Single, 8),
                    new VertexElement(112, VertexElementFormat.Single, 9)
                ]);
            }
            this._vb.vertexDeclaration = MeshParticle2D.vertexDeclaration;
        }
        static __init__() {
            const glfloat = LayaGL.renderEngine.getParams(exports.RenderParams.FLOAT);
            MeshParticle2D._fixattriInfo = [
                glfloat, 4, 0,
                glfloat, 3, 16,
                glfloat, 3, 28,
                glfloat, 4, 40,
                glfloat, 4, 56,
                glfloat, 3, 72,
                glfloat, 2, 84,
                glfloat, 4, 92,
                glfloat, 1, 108,
                glfloat, 1, 112
            ];
        }
        setMaxParticleNum(maxNum) {
            this._vb.buffer2D._resizeBuffer(maxNum * 4 * MeshParticle2D.const_stride, false);
            this.createQuadIB(maxNum);
        }
        static getAMesh(maxNum) {
            if (MeshParticle2D._POOL.length) {
                var ret = MeshParticle2D._POOL.pop();
                ret.setMaxParticleNum(maxNum);
                return ret;
            }
            return new MeshParticle2D(maxNum);
        }
        releaseMesh() {
            this._vb.buffer2D.setByteLength(0);
            this.vertNum = 0;
            this.indexNum = 0;
            MeshParticle2D._POOL.push(this);
        }
        destroy() {
            this._ib.destroy();
            this._vb.destroy();
            this._vb.deleteBuffer();
        }
    }
    MeshParticle2D.const_stride = 116;
    MeshParticle2D._POOL = [];
    MeshParticle2D.vertexDeclaration = null;

    class WeakObject {
        constructor() {
            this._obj = {};
            WeakObject._maps.push(this);
        }
        static __init__() {
            WeakObject.I = new WeakObject();
            if (!WeakObject.supportWeakMap)
                ILaya.systemTimer.loop(WeakObject.delInterval, null, WeakObject.clearCache);
        }
        static clearCache() {
            for (var i = 0, n = WeakObject._maps.length; i < n; i++) {
                var obj = WeakObject._maps[i];
                obj._obj = {};
            }
        }
        set(key, value) {
            if (key == null)
                return;
            if (WeakObject.supportWeakMap) ;
            else {
                if (typeof (key) == 'string' || typeof (key) == 'number') {
                    this._obj[key] = value;
                }
                else {
                    key.$_GID || (key.$_GID = Utils.getGID());
                    this._obj[key.$_GID] = value;
                }
            }
        }
        get(key) {
            if (key == null)
                return null;
            if (WeakObject.supportWeakMap) ;
            else {
                if (typeof (key) == 'string' || typeof (key) == 'number')
                    return this._obj[key];
                return this._obj[key.$_GID];
            }
        }
        del(key) {
            if (key == null)
                return;
            if (WeakObject.supportWeakMap) ;
            else {
                if (typeof (key) == 'string' || typeof (key) == 'number')
                    delete this._obj[key];
                else
                    delete this._obj[this._obj.$_GID];
            }
        }
        has(key) {
            if (key == null)
                return false;
            if (WeakObject.supportWeakMap) {
                return false;
            }
            else {
                if (typeof (key) == 'string' || typeof (key) == 'number')
                    return this._obj[key] != null;
                return this._obj[this._obj.$_GID] != null;
            }
        }
    }
    WeakObject.supportWeakMap = false;
    WeakObject.delInterval = 10 * 60 * 1000;
    WeakObject._maps = [];

    class DefineDatas {
        constructor() {
            this._mask = [];
            this._length = 0;
        }
        _intersectionDefineDatas(define) {
            var unionMask = define._mask;
            var mask = this._mask;
            for (var i = this._length - 1; i >= 0; i--) {
                var value = mask[i] & unionMask[i];
                if (value == 0 && i == this._length - 1)
                    this._length--;
                else
                    mask[i] = value;
            }
        }
        add(define) {
            var index = define._index;
            var size = index + 1;
            var mask = this._mask;
            var maskStart = this._length;
            if (maskStart < size) {
                (mask.length < size) && (mask.length = size);
                for (; maskStart < index; maskStart++)
                    mask[maskStart] = 0;
                mask[index] = define._value;
                this._length = size;
            }
            else {
                mask[index] |= define._value;
            }
        }
        remove(define) {
            var index = define._index;
            var mask = this._mask;
            var endIndex = this._length - 1;
            if (index > endIndex)
                return;
            var newValue = mask[index] & ~define._value;
            if (index == endIndex && newValue === 0)
                this._length--;
            else
                mask[index] = newValue;
        }
        addDefineDatas(define) {
            var addMask = define._mask;
            var size = define._length;
            var mask = this._mask;
            var maskStart = this._length;
            if (maskStart < size) {
                mask.length = size;
                for (var i = 0; i < maskStart; i++)
                    mask[i] |= addMask[i];
                for (; i < size; i++)
                    mask[i] = addMask[i];
                this._length = size;
            }
            else {
                for (var i = 0; i < size; i++) {
                    mask[i] |= addMask[i];
                }
            }
        }
        removeDefineDatas(define) {
            var removeMask = define._mask;
            var mask = this._mask;
            var endIndex = this._length - 1;
            var i = Math.min(define._length, endIndex);
            for (; i >= 0; i--) {
                var newValue = mask[i] & ~removeMask[i];
                if (i == endIndex && newValue === 0) {
                    endIndex--;
                    this._length--;
                }
                else {
                    mask[i] = newValue;
                }
            }
        }
        has(define) {
            var index = define._index;
            if (index >= this._length)
                return false;
            return (this._mask[index] & define._value) !== 0;
        }
        clear() {
            this._length = 0;
        }
        cloneTo(destObject) {
            var destDefineData = destObject;
            var destMask = destDefineData._mask;
            var mask = this._mask;
            var count = this._length;
            destMask.length = count;
            for (var i = 0; i < count; i++)
                destMask[i] = mask[i];
            destDefineData._length = count;
        }
        clone() {
            var dest = new DefineDatas();
            this.cloneTo(dest);
            return dest;
        }
        destroy() {
            delete this._mask;
        }
    }

    class ShaderDefine {
        constructor(index, value) {
            this._index = index;
            this._value = value;
        }
    }
    ShaderDefine._texGammaDefine = {};

    class ShaderVariant {
        constructor(shader, subShaderIndex, passIndex, defines) {
            this._subShaderIndex = 0;
            this._passIndex = 0;
            this.setValue(shader, subShaderIndex, passIndex, defines);
        }
        get shader() {
            return this._shader;
        }
        get subShaderIndex() {
            return this._subShaderIndex;
        }
        get passIndex() {
            return this._passIndex;
        }
        get defineNames() {
            return this._defineNames;
        }
        setValue(shader, subShaderIndex, passIndex, defineNames) {
            if (shader) {
                var subShader = shader.getSubShaderAt(subShaderIndex);
                if (subShader) {
                    var pass = subShader._passes[passIndex];
                    if (pass) {
                        var validDefine = pass._validDefine;
                        for (var i = 0, n = defineNames.length; i < n; i++) {
                            var defname = defineNames[i];
                            if (!validDefine.has(Shader3D.getDefineByName(defname)))
                                throw `ShaderVariantInfo:Invalid defineName ${defname} in ${shader._name} subShaderIndex of ${subShaderIndex} passIndex of ${passIndex}.`;
                        }
                    }
                    else {
                        throw `ShaderVariantInfo:Shader don't have passIndex of ${passIndex}.`;
                    }
                }
                else {
                    throw `ShaderVariantInfo:Shader don't have subShaderIndex of ${subShaderIndex}.`;
                }
            }
            else {
                throw `ShaderVariantInfo:Shader can't be null.`;
            }
            this._shader = shader;
            this._subShaderIndex = subShaderIndex;
            this._passIndex = passIndex;
            this._defineNames = defineNames;
        }
        equal(other) {
            if (this._shader !== other._shader || this._subShaderIndex !== other._subShaderIndex || this._passIndex !== other._passIndex)
                return false;
            var defines = this._defineNames;
            var otherDefines = other._defineNames;
            if (defines.length !== otherDefines.length)
                return false;
            for (var i = 0, n = this._defineNames.length; i < n; i++) {
                if (defines[i] !== otherDefines[i])
                    return false;
            }
            return true;
        }
        clone() {
            var dest = new ShaderVariant(this._shader, this._subShaderIndex, this._passIndex, this._defineNames.slice());
            return dest;
        }
    }
    class ShaderVariantCollection {
        constructor() {
            this._allCompiled = false;
            this._variants = [];
        }
        get allCompiled() {
            return this._allCompiled;
        }
        get variantCount() {
            return this._variants.length;
        }
        add(variant) {
            for (var i = 0, n = this._variants.length; i < n; i++) {
                if (this._variants[i].equal(variant))
                    return false;
            }
            this._variants.push(variant.clone());
            this._allCompiled = false;
            return true;
        }
        remove(variant) {
            for (var i = 0, n = this._variants.length; i < n; i++) {
                if (this._variants[i].equal(variant)) {
                    this._variants.splice(i, 1);
                    return true;
                }
            }
            return false;
        }
        contatins(variant) {
            for (var i = 0, n = this._variants.length; i < n; i++) {
                if (this._variants[i].equal(variant))
                    return true;
            }
            return false;
        }
        getByIndex(index) {
            return this._variants[index];
        }
        clear() {
            this._variants.length = 0;
        }
        compile() {
            if (!this._allCompiled) {
                var variants = this._variants;
                for (var i = 0, n = variants.length; i < n; i++) {
                    var variant = variants[i];
                    Shader3D.compileShaderByDefineNames(variant._shader._name, variant._subShaderIndex, variant._passIndex, variant._defineNames);
                }
                this._allCompiled = true;
            }
        }
    }

    const _DEFAULTELEMENTS = new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
    const _tempV30 = new Vector3();
    const _tempV31 = new Vector3();
    const _tempV32 = new Vector3();
    class Matrix3x3 {
        constructor(createElement = true) {
            createElement && (this.elements = _DEFAULTELEMENTS.slice());
        }
        static createRotationQuaternion(rotation, out) {
            var rotX = rotation.x;
            var rotY = rotation.y;
            var rotZ = rotation.z;
            var rotW = rotation.w;
            var xx = rotX * rotX;
            var yy = rotY * rotY;
            var zz = rotZ * rotZ;
            var xy = rotX * rotY;
            var zw = rotZ * rotW;
            var zx = rotZ * rotX;
            var yw = rotY * rotW;
            var yz = rotY * rotZ;
            var xw = rotX * rotW;
            var resultE = out.elements;
            resultE[0] = 1.0 - (2.0 * (yy + zz));
            resultE[1] = 2.0 * (xy + zw);
            resultE[2] = 2.0 * (zx - yw);
            resultE[3] = 2.0 * (xy - zw);
            resultE[4] = 1.0 - (2.0 * (zz + xx));
            resultE[5] = 2.0 * (yz + xw);
            resultE[6] = 2.0 * (zx + yw);
            resultE[7] = 2.0 * (yz - xw);
            resultE[8] = 1.0 - (2.0 * (yy + xx));
        }
        static createFromTranslation(trans, out) {
            var e = out.elements;
            e[0] = 1;
            e[1] = 0;
            e[2] = 0;
            e[3] = 0;
            e[4] = 1;
            e[5] = 0;
            e[6] = trans.x;
            e[7] = trans.y;
            e[8] = 1;
        }
        static createFromRotation(rad, out) {
            var e = out.elements;
            var s = Math.sin(rad), c = Math.cos(rad);
            e[0] = c;
            e[1] = s;
            e[2] = 0;
            e[3] = -s;
            e[4] = c;
            e[5] = 0;
            e[6] = 0;
            e[7] = 0;
            e[8] = 1;
        }
        static createFromScaling(scale, out) {
            var e = out.elements;
            e[0] = scale.x;
            e[1] = 0;
            e[2] = 0;
            e[3] = 0;
            e[4] = scale.y;
            e[5] = 0;
            e[6] = 0;
            e[7] = 0;
            e[8] = scale.z;
        }
        static createFromMatrix4x4(sou, out) {
            var souE = sou.elements;
            var outE = out.elements;
            outE[0] = souE[0];
            outE[1] = souE[1];
            outE[2] = souE[2];
            outE[3] = souE[4];
            outE[4] = souE[5];
            outE[5] = souE[6];
            outE[6] = souE[8];
            outE[7] = souE[9];
            outE[8] = souE[10];
        }
        static multiply(left, right, out) {
            var l = left.elements;
            var r = right.elements;
            var e = out.elements;
            var l11 = l[0], l12 = l[1], l13 = l[2];
            var l21 = l[3], l22 = l[4], l23 = l[5];
            var l31 = l[6], l32 = l[7], l33 = l[8];
            var r11 = r[0], r12 = r[1], r13 = r[2];
            var r21 = r[3], r22 = r[4], r23 = r[5];
            var r31 = r[6], r32 = r[7], r33 = r[8];
            e[0] = r11 * l11 + r12 * l21 + r13 * l31;
            e[1] = r11 * l12 + r12 * l22 + r13 * r32;
            e[2] = r11 * l13 + r12 * l23 + r13 * l33;
            e[3] = r21 * l11 + r22 * l21 + r23 * l31;
            e[4] = r21 * l12 + r22 * l22 + r23 * l32;
            e[5] = r21 * l13 + r22 * l23 + r23 * l33;
            e[6] = r31 * l11 + r32 * l21 + r33 * l31;
            e[7] = r31 * l12 + r32 * l22 + r33 * l32;
            e[8] = r31 * l13 + r32 * l23 + r33 * l33;
        }
        determinant() {
            var f = this.elements;
            var a00 = f[0], a01 = f[1], a02 = f[2];
            var a10 = f[3], a11 = f[4], a12 = f[5];
            var a20 = f[6], a21 = f[7], a22 = f[8];
            return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
        }
        translate(trans, out) {
            var e = out.elements;
            var f = this.elements;
            var a00 = f[0], a01 = f[1], a02 = f[2];
            var a10 = f[3], a11 = f[4], a12 = f[5];
            var a20 = f[6], a21 = f[7], a22 = f[8];
            var x = trans.x, y = trans.y;
            e[0] = a00;
            e[1] = a01;
            e[2] = a02;
            e[3] = a10;
            e[4] = a11;
            e[5] = a12;
            e[6] = x * a00 + y * a10 + a20;
            e[7] = x * a01 + y * a11 + a21;
            e[8] = x * a02 + y * a12 + a22;
        }
        rotate(rad, out) {
            var e = out.elements;
            var f = this.elements;
            var a00 = f[0], a01 = f[1], a02 = f[2];
            var a10 = f[3], a11 = f[4], a12 = f[5];
            var a20 = f[6], a21 = f[7], a22 = f[8];
            var s = Math.sin(rad);
            var c = Math.cos(rad);
            e[0] = c * a00 + s * a10;
            e[1] = c * a01 + s * a11;
            e[2] = c * a02 + s * a12;
            e[3] = c * a10 - s * a00;
            e[4] = c * a11 - s * a01;
            e[5] = c * a12 - s * a02;
            e[6] = a20;
            e[7] = a21;
            e[8] = a22;
        }
        scale(scale, out) {
            var e = out.elements;
            var f = this.elements;
            var x = scale.x, y = scale.y;
            e[0] = x * f[0];
            e[1] = x * f[1];
            e[2] = x * f[2];
            e[3] = y * f[3];
            e[4] = y * f[4];
            e[5] = y * f[5];
            e[6] = f[6];
            e[7] = f[7];
            e[8] = f[8];
        }
        invert(out) {
            var e = out.elements;
            var f = this.elements;
            var a00 = f[0], a01 = f[1], a02 = f[2];
            var a10 = f[3], a11 = f[4], a12 = f[5];
            var a20 = f[6], a21 = f[7], a22 = f[8];
            var b01 = a22 * a11 - a12 * a21;
            var b11 = -a22 * a10 + a12 * a20;
            var b21 = a21 * a10 - a11 * a20;
            var det = a00 * b01 + a01 * b11 + a02 * b21;
            if (!det) {
                return;
            }
            det = 1.0 / det;
            e[0] = b01 * det;
            e[1] = (-a22 * a01 + a02 * a21) * det;
            e[2] = (a12 * a01 - a02 * a11) * det;
            e[3] = b11 * det;
            e[4] = (a22 * a00 - a02 * a20) * det;
            e[5] = (-a12 * a00 + a02 * a10) * det;
            e[6] = b21 * det;
            e[7] = (-a21 * a00 + a01 * a20) * det;
            e[8] = (a11 * a00 - a01 * a10) * det;
        }
        transpose(out) {
            var e = out.elements;
            var f = this.elements;
            if (out === this) {
                var a01 = f[1], a02 = f[2], a12 = f[5];
                e[1] = f[3];
                e[2] = f[6];
                e[3] = a01;
                e[5] = f[7];
                e[6] = a02;
                e[7] = a12;
            }
            else {
                e[0] = f[0];
                e[1] = f[3];
                e[2] = f[6];
                e[3] = f[1];
                e[4] = f[4];
                e[5] = f[7];
                e[6] = f[2];
                e[7] = f[5];
                e[8] = f[8];
            }
        }
        identity() {
            this.elements.set(_DEFAULTELEMENTS);
        }
        cloneTo(destObject) {
            var s, d;
            s = this.elements;
            d = destObject.elements;
            if (s === d) {
                return;
            }
            s.set(d);
        }
        clone() {
            var dest = new Matrix3x3(false);
            dest.elements = this.elements.slice();
            return dest;
        }
        static lookAt(eye, target, up, out) {
            Vector3.subtract(eye, target, _tempV30);
            Vector3.normalize(_tempV30, _tempV30);
            Vector3.cross(up, _tempV30, _tempV31);
            Vector3.normalize(_tempV31, _tempV31);
            Vector3.cross(_tempV30, _tempV31, _tempV32);
            var v0 = _tempV30;
            var v1 = _tempV31;
            var v2 = _tempV32;
            var me = out.elements;
            me[0] = v1.x;
            me[3] = v1.y;
            me[6] = v1.z;
            me[1] = v2.x;
            me[4] = v2.y;
            me[7] = v2.z;
            me[2] = v0.x;
            me[5] = v0.y;
            me[8] = v0.z;
        }
        static forwardLookAt(eye, target, up, out) {
            var vx = _tempV31;
            var vy = _tempV32;
            var vz = _tempV30;
            target.vsub(eye, vz).normalize();
            up.cross(vz, vx).normalize();
            vz.cross(vx, vy);
            var m = out.elements;
            m[0] = vx.x;
            m[1] = vx.y;
            m[2] = vx.z;
            m[3] = vy.x;
            m[4] = vy.y;
            m[5] = vy.z;
            m[6] = vz.x;
            m[7] = vz.y;
            m[8] = vz.z;
        }
    }
    Matrix3x3.DEFAULT = new Matrix3x3();

    const TEMPVector30 = new Vector3();
    const TEMPVector31 = new Vector3();
    const TEMPVector32 = new Vector3();
    const TEMPVector33 = new Vector3();
    const _tempMatrix3x3 = new Matrix3x3();
    class Quaternion {
        constructor(x = 0, y = 0, z = 0, w = 1) {
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
        }
        static createFromYawPitchRoll(yaw, pitch, roll, out) {
            var halfRoll = roll * 0.5;
            var halfPitch = pitch * 0.5;
            var halfYaw = yaw * 0.5;
            var sinRoll = Math.sin(halfRoll);
            var cosRoll = Math.cos(halfRoll);
            var sinPitch = Math.sin(halfPitch);
            var cosPitch = Math.cos(halfPitch);
            var sinYaw = Math.sin(halfYaw);
            var cosYaw = Math.cos(halfYaw);
            out.x = (cosYaw * sinPitch * cosRoll) + (sinYaw * cosPitch * sinRoll);
            out.y = (sinYaw * cosPitch * cosRoll) - (cosYaw * sinPitch * sinRoll);
            out.z = (cosYaw * cosPitch * sinRoll) - (sinYaw * sinPitch * cosRoll);
            out.w = (cosYaw * cosPitch * cosRoll) + (sinYaw * sinPitch * sinRoll);
        }
        static multiply(left, right, out) {
            var lx = left.x;
            var ly = left.y;
            var lz = left.z;
            var lw = left.w;
            var rx = right.x;
            var ry = right.y;
            var rz = right.z;
            var rw = right.w;
            var a = (ly * rz - lz * ry);
            var b = (lz * rx - lx * rz);
            var c = (lx * ry - ly * rx);
            var d = (lx * rx + ly * ry + lz * rz);
            out.x = (lx * rw + rx * lw) + a;
            out.y = (ly * rw + ry * lw) + b;
            out.z = (lz * rw + rz * lw) + c;
            out.w = lw * rw - d;
        }
        static arcTanAngle(x, y) {
            if (x == 0) {
                if (y == 1)
                    return Math.PI / 2;
                return -Math.PI / 2;
            }
            if (x > 0)
                return Math.atan(y / x);
            if (x < 0) {
                if (y > 0)
                    return Math.atan(y / x) + Math.PI;
                return Math.atan(y / x) - Math.PI;
            }
            return 0;
        }
        static angleTo(from, location, angle) {
            Vector3.subtract(location, from, TEMPVector30);
            Vector3.normalize(TEMPVector30, TEMPVector30);
            angle.x = Math.asin(TEMPVector30.y);
            angle.y = Quaternion.arcTanAngle(-TEMPVector30.z, -TEMPVector30.x);
        }
        static createFromAxisAngle(axis, rad, out) {
            rad = rad * 0.5;
            var s = Math.sin(rad);
            out.x = s * axis.x;
            out.y = s * axis.y;
            out.z = s * axis.z;
            out.w = Math.cos(rad);
        }
        static createFromMatrix4x4(mat, out) {
            var me = mat.elements;
            var sqrt;
            var half;
            var scale = me[0] + me[5] + me[10];
            if (scale > 0.0) {
                sqrt = Math.sqrt(scale + 1.0);
                out.w = sqrt * 0.5;
                sqrt = 0.5 / sqrt;
                out.x = (me[6] - me[9]) * sqrt;
                out.y = (me[8] - me[2]) * sqrt;
                out.z = (me[1] - me[4]) * sqrt;
            }
            else if ((me[0] >= me[5]) && (me[0] >= me[10])) {
                sqrt = Math.sqrt(1.0 + me[0] - me[5] - me[10]);
                half = 0.5 / sqrt;
                out.x = 0.5 * sqrt;
                out.y = (me[1] + me[4]) * half;
                out.z = (me[2] + me[8]) * half;
                out.w = (me[6] - me[9]) * half;
            }
            else if (me[5] > me[10]) {
                sqrt = Math.sqrt(1.0 + me[5] - me[0] - me[10]);
                half = 0.5 / sqrt;
                out.x = (me[4] + me[1]) * half;
                out.y = 0.5 * sqrt;
                out.z = (me[9] + me[6]) * half;
                out.w = (me[8] - me[2]) * half;
            }
            else {
                sqrt = Math.sqrt(1.0 + me[10] - me[0] - me[5]);
                half = 0.5 / sqrt;
                out.x = (me[8] + me[2]) * half;
                out.y = (me[9] + me[6]) * half;
                out.z = 0.5 * sqrt;
                out.w = (me[1] - me[4]) * half;
            }
        }
        static slerp(left, right, t, out) {
            var ax = left.x, ay = left.y, az = left.z, aw = left.w, bx = right.x, by = right.y, bz = right.z, bw = right.w;
            var omega, cosom, sinom, scale0, scale1;
            cosom = ax * bx + ay * by + az * bz + aw * bw;
            if (cosom < 0.0) {
                cosom = -cosom;
                bx = -bx;
                by = -by;
                bz = -bz;
                bw = -bw;
            }
            if ((1.0 - cosom) > 0.000001) {
                omega = Math.acos(cosom);
                sinom = Math.sin(omega);
                scale0 = Math.sin((1.0 - t) * omega) / sinom;
                scale1 = Math.sin(t * omega) / sinom;
            }
            else {
                scale0 = 1.0 - t;
                scale1 = t;
            }
            out.x = scale0 * ax + scale1 * bx;
            out.y = scale0 * ay + scale1 * by;
            out.z = scale0 * az + scale1 * bz;
            out.w = scale0 * aw + scale1 * bw;
            return out;
        }
        static lerp(left, right, amount, out) {
            var inverse = 1.0 - amount;
            if (Quaternion.dot(left, right) >= 0) {
                out.x = (inverse * left.x) + (amount * right.x);
                out.y = (inverse * left.y) + (amount * right.y);
                out.z = (inverse * left.z) + (amount * right.z);
                out.w = (inverse * left.w) + (amount * right.w);
            }
            else {
                out.x = (inverse * left.x) - (amount * right.x);
                out.y = (inverse * left.y) - (amount * right.y);
                out.z = (inverse * left.z) - (amount * right.z);
                out.w = (inverse * left.w) - (amount * right.w);
            }
            out.normalize(out);
        }
        static add(left, right, out) {
            out.x = left.x + right.x;
            out.y = left.y + right.y;
            out.z = left.z + right.z;
            out.w = left.w + right.w;
        }
        static dot(left, right) {
            return left.x * right.x + left.y * right.y + left.z * right.z + left.w * right.w;
        }
        setValue(x, y, z, w) {
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
        }
        set(x, y, z, w) {
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
            return this;
        }
        scaling(scaling, out) {
            out.x = this.x * scaling;
            out.y = this.y * scaling;
            out.z = this.z * scaling;
            out.w = this.w * scaling;
        }
        normalize(out) {
            var len = this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
            if (len > 0) {
                len = 1 / Math.sqrt(len);
                out.x = this.x * len;
                out.y = this.y * len;
                out.z = this.z * len;
                out.w = this.w * len;
            }
        }
        length() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
        }
        rotateX(rad, out) {
            rad *= 0.5;
            var bx = Math.sin(rad), bw = Math.cos(rad);
            out.x = this.x * bw + this.w * bx;
            out.y = this.y * bw + this.z * bx;
            out.z = this.z * bw - this.y * bx;
            out.w = this.w * bw - this.x * bx;
        }
        rotateY(rad, out) {
            rad *= 0.5;
            var by = Math.sin(rad), bw = Math.cos(rad);
            out.x = this.x * bw - this.z * by;
            out.y = this.y * bw + this.w * by;
            out.z = this.z * bw + this.x * by;
            out.w = this.w * bw - this.y * by;
        }
        rotateZ(rad, out) {
            rad *= 0.5;
            var bz = Math.sin(rad), bw = Math.cos(rad);
            out.x = this.x * bw + this.y * bz;
            out.y = this.y * bw - this.x * bz;
            out.z = this.z * bw + this.w * bz;
            out.w = this.w * bw - this.z * bz;
        }
        getYawPitchRoll(out) {
            Vector3.transformQuat(Vector3.ForwardRH, this, TEMPVector31);
            Vector3.transformQuat(Vector3.Up, this, TEMPVector32);
            var upe = TEMPVector32;
            Quaternion.angleTo(Vector3.ZERO, TEMPVector31, TEMPVector33);
            var angle = TEMPVector33;
            if (angle.x == Math.PI / 2) {
                angle.y = Quaternion.arcTanAngle(upe.z, upe.x);
                angle.z = 0;
            }
            else if (angle.x == -Math.PI / 2) {
                angle.y = Quaternion.arcTanAngle(-upe.z, -upe.x);
                angle.z = 0;
            }
            else {
                Matrix4x4.createRotationY(-angle.y, Matrix4x4.TEMPMatrix0);
                Matrix4x4.createRotationX(-angle.x, Matrix4x4.TEMPMatrix1);
                Vector3.transformCoordinate(TEMPVector32, Matrix4x4.TEMPMatrix0, TEMPVector32);
                Vector3.transformCoordinate(TEMPVector32, Matrix4x4.TEMPMatrix1, TEMPVector32);
                angle.z = Quaternion.arcTanAngle(upe.y, -upe.x);
            }
            if (angle.y <= -Math.PI)
                angle.y = Math.PI;
            if (angle.z <= -Math.PI)
                angle.z = Math.PI;
            if (angle.y >= Math.PI && angle.z >= Math.PI) {
                angle.y = 0;
                angle.z = 0;
                angle.x = Math.PI - angle.x;
            }
            var oe = out;
            oe.x = angle.y;
            oe.y = angle.x;
            oe.z = angle.z;
        }
        invert(out) {
            var a0 = this.x, a1 = this.y, a2 = this.z, a3 = this.w;
            var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
            var invDot = dot ? 1.0 / dot : 0;
            out.x = -a0 * invDot;
            out.y = -a1 * invDot;
            out.z = -a2 * invDot;
            out.w = a3 * invDot;
        }
        identity() {
            this.x = 0;
            this.y = 0;
            this.z = 0;
            this.w = 1;
        }
        fromArray(array, offset = 0) {
            this.x = array[offset + 0];
            this.y = array[offset + 1];
            this.z = array[offset + 2];
            this.w = array[offset + 3];
        }
        cloneTo(destObject) {
            if (this === destObject) {
                return;
            }
            destObject.x = this.x;
            destObject.y = this.y;
            destObject.z = this.z;
            destObject.w = this.w;
        }
        clone() {
            var dest = new Quaternion();
            this.cloneTo(dest);
            return dest;
        }
        equals(b) {
            return MathUtils3D.nearEqual(this.x, b.x) && MathUtils3D.nearEqual(this.y, b.y) && MathUtils3D.nearEqual(this.z, b.z) && MathUtils3D.nearEqual(this.w, b.w);
        }
        static rotationLookAt(forward, up, out) {
            Quaternion.lookAt(Vector3.ZERO, forward, up, out);
        }
        static lookAt(eye, target, up, out) {
            Matrix3x3.lookAt(eye, target, up, _tempMatrix3x3);
            Quaternion.rotationMatrix(_tempMatrix3x3, out);
        }
        static forwardLookAt(eye, target, up, out) {
            Matrix3x3.forwardLookAt(eye, target, up, _tempMatrix3x3);
            Quaternion.rotationMatrix(_tempMatrix3x3, out);
        }
        lengthSquared() {
            return (this.x * this.x) + (this.y * this.y) + (this.z * this.z) + (this.w * this.w);
        }
        static invert(value, out) {
            var lengthSq = value.lengthSquared();
            if (!MathUtils3D.isZero(lengthSq)) {
                lengthSq = 1.0 / lengthSq;
                out.x = -value.x * lengthSq;
                out.y = -value.y * lengthSq;
                out.z = -value.z * lengthSq;
                out.w = value.w * lengthSq;
            }
        }
        static rotationMatrix(matrix3x3, out) {
            var me = matrix3x3.elements;
            var m11 = me[0];
            var m12 = me[1];
            var m13 = me[2];
            var m21 = me[3];
            var m22 = me[4];
            var m23 = me[5];
            var m31 = me[6];
            var m32 = me[7];
            var m33 = me[8];
            var sqrt, half;
            var scale = m11 + m22 + m33;
            if (scale > 0) {
                sqrt = Math.sqrt(scale + 1);
                out.w = sqrt * 0.5;
                sqrt = 0.5 / sqrt;
                out.x = (m23 - m32) * sqrt;
                out.y = (m31 - m13) * sqrt;
                out.z = (m12 - m21) * sqrt;
            }
            else if ((m11 >= m22) && (m11 >= m33)) {
                sqrt = Math.sqrt(1 + m11 - m22 - m33);
                half = 0.5 / sqrt;
                out.x = 0.5 * sqrt;
                out.y = (m12 + m21) * half;
                out.z = (m13 + m31) * half;
                out.w = (m23 - m32) * half;
            }
            else if (m22 > m33) {
                sqrt = Math.sqrt(1 + m22 - m11 - m33);
                half = 0.5 / sqrt;
                out.x = (m21 + m12) * half;
                out.y = 0.5 * sqrt;
                out.z = (m32 + m23) * half;
                out.w = (m31 - m13) * half;
            }
            else {
                sqrt = Math.sqrt(1 + m33 - m11 - m22);
                half = 0.5 / sqrt;
                out.x = (m31 + m13) * half;
                out.y = (m32 + m23) * half;
                out.z = 0.5 * sqrt;
                out.w = (m12 - m21) * half;
            }
        }
        forNativeElement(nativeElements = null) {
            if (nativeElements) {
                this.elements = nativeElements;
                this.elements[0] = this.x;
                this.elements[1] = this.y;
                this.elements[2] = this.z;
                this.elements[3] = this.w;
            }
            else {
                this.elements = new Float32Array([this.x, this.y, this.z, this.w]);
            }
            Vector2.rewriteNumProperty(this, "x", 0);
            Vector2.rewriteNumProperty(this, "y", 1);
            Vector2.rewriteNumProperty(this, "z", 2);
            Vector2.rewriteNumProperty(this, "w", 3);
        }
    }
    Quaternion.TEMP = new Quaternion();
    Quaternion.DEFAULT = new Quaternion();
    Quaternion.NAN = new Quaternion(NaN, NaN, NaN, NaN);

    const _tempVector0 = new Vector3();
    const _tempVector1 = new Vector3();
    const _tempVector2 = new Vector3();
    const _tempVector3 = new Vector3();
    const DEFAULTARRAY = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
    class Matrix4x4 {
        constructor(m11 = 1, m12 = 0, m13 = 0, m14 = 0, m21 = 0, m22 = 1, m23 = 0, m24 = 0, m31 = 0, m32 = 0, m33 = 1, m34 = 0, m41 = 0, m42 = 0, m43 = 0, m44 = 1, elements = null) {
            if (arguments.length == 0) {
                this.elements = DEFAULTARRAY.slice();
                return;
            }
            if (arguments.length === 1 && arguments[0] === null)
                return;
            var e = elements ? this.elements = elements : this.elements = new Float32Array(16);
            e[0] = m11;
            e[1] = m12;
            e[2] = m13;
            e[3] = m14;
            e[4] = m21;
            e[5] = m22;
            e[6] = m23;
            e[7] = m24;
            e[8] = m31;
            e[9] = m32;
            e[10] = m33;
            e[11] = m34;
            e[12] = m41;
            e[13] = m42;
            e[14] = m43;
            e[15] = m44;
        }
        static createRotationX(rad, out) {
            var oe = out.elements;
            var s = Math.sin(rad), c = Math.cos(rad);
            oe[1] = oe[2] = oe[3] = oe[4] = oe[7] = oe[8] = oe[11] = oe[12] = oe[13] = oe[14] = 0;
            oe[0] = oe[15] = 1;
            oe[5] = oe[10] = c;
            oe[6] = s;
            oe[9] = -s;
        }
        static createRotationY(rad, out) {
            var oe = out.elements;
            var s = Math.sin(rad), c = Math.cos(rad);
            oe[1] = oe[3] = oe[4] = oe[6] = oe[7] = oe[9] = oe[11] = oe[12] = oe[13] = oe[14] = 0;
            oe[5] = oe[15] = 1;
            oe[0] = oe[10] = c;
            oe[2] = -s;
            oe[8] = s;
        }
        static createRotationZ(rad, out) {
            var oe = out.elements;
            var s = Math.sin(rad), c = Math.cos(rad);
            oe[2] = oe[3] = oe[6] = oe[7] = oe[8] = oe[9] = oe[11] = oe[12] = oe[13] = oe[14] = 0;
            oe[10] = oe[15] = 1;
            oe[0] = oe[5] = c;
            oe[1] = s;
            oe[4] = -s;
        }
        static createRotationYawPitchRoll(yaw, pitch, roll, result) {
            Quaternion.createFromYawPitchRoll(yaw, pitch, roll, Quaternion.TEMP);
            Matrix4x4.createRotationQuaternion(Quaternion.TEMP, result);
        }
        static createRotationAxis(axis, angle, result) {
            var x = axis.x;
            var y = axis.y;
            var z = axis.z;
            var cos = Math.cos(angle);
            var sin = Math.sin(angle);
            var xx = x * x;
            var yy = y * y;
            var zz = z * z;
            var xy = x * y;
            var xz = x * z;
            var yz = y * z;
            var resultE = result.elements;
            resultE[3] = resultE[7] = resultE[11] = resultE[12] = resultE[13] = resultE[14] = 0;
            resultE[15] = 1.0;
            resultE[0] = xx + (cos * (1.0 - xx));
            resultE[1] = (xy - (cos * xy)) + (sin * z);
            resultE[2] = (xz - (cos * xz)) - (sin * y);
            resultE[4] = (xy - (cos * xy)) - (sin * z);
            resultE[5] = yy + (cos * (1.0 - yy));
            resultE[6] = (yz - (cos * yz)) + (sin * x);
            resultE[8] = (xz - (cos * xz)) + (sin * y);
            resultE[9] = (yz - (cos * yz)) - (sin * x);
            resultE[10] = zz + (cos * (1.0 - zz));
        }
        static createRotationQuaternion(rotation, result) {
            var resultE = result.elements;
            var rotationX = rotation.x;
            var rotationY = rotation.y;
            var rotationZ = rotation.z;
            var rotationW = rotation.w;
            var xx = rotationX * rotationX;
            var yy = rotationY * rotationY;
            var zz = rotationZ * rotationZ;
            var xy = rotationX * rotationY;
            var zw = rotationZ * rotationW;
            var zx = rotationZ * rotationX;
            var yw = rotationY * rotationW;
            var yz = rotationY * rotationZ;
            var xw = rotationX * rotationW;
            resultE[3] = resultE[7] = resultE[11] = resultE[12] = resultE[13] = resultE[14] = 0;
            resultE[15] = 1.0;
            resultE[0] = 1.0 - (2.0 * (yy + zz));
            resultE[1] = 2.0 * (xy + zw);
            resultE[2] = 2.0 * (zx - yw);
            resultE[4] = 2.0 * (xy - zw);
            resultE[5] = 1.0 - (2.0 * (zz + xx));
            resultE[6] = 2.0 * (yz + xw);
            resultE[8] = 2.0 * (zx + yw);
            resultE[9] = 2.0 * (yz - xw);
            resultE[10] = 1.0 - (2.0 * (yy + xx));
        }
        static createTranslate(trans, out) {
            var oe = out.elements;
            oe[4] = oe[8] = oe[1] = oe[9] = oe[2] = oe[6] = oe[3] = oe[7] = oe[11] = 0;
            oe[0] = oe[5] = oe[10] = oe[15] = 1;
            oe[12] = trans.x;
            oe[13] = trans.y;
            oe[14] = trans.z;
        }
        static createScaling(scale, out) {
            var oe = out.elements;
            oe[0] = scale.x;
            oe[5] = scale.y;
            oe[10] = scale.z;
            oe[1] = oe[4] = oe[8] = oe[12] = oe[9] = oe[13] = oe[2] = oe[6] = oe[14] = oe[3] = oe[7] = oe[11] = 0;
            oe[15] = 1;
        }
        static multiply(left, right, out) {
            var l = right.elements;
            var r = left.elements;
            var e = out.elements;
            var l11 = l[0], l12 = l[1], l13 = l[2], l14 = l[3];
            var l21 = l[4], l22 = l[5], l23 = l[6], l24 = l[7];
            var l31 = l[8], l32 = l[9], l33 = l[10], l34 = l[11];
            var l41 = l[12], l42 = l[13], l43 = l[14], l44 = l[15];
            var r11 = r[0], r12 = r[1], r13 = r[2], r14 = r[3];
            var r21 = r[4], r22 = r[5], r23 = r[6], r24 = r[7];
            var r31 = r[8], r32 = r[9], r33 = r[10], r34 = r[11];
            var r41 = r[12], r42 = r[13], r43 = r[14], r44 = r[15];
            e[0] = (l11 * r11) + (l12 * r21) + (l13 * r31) + (l14 * r41);
            e[1] = (l11 * r12) + (l12 * r22) + (l13 * r32) + (l14 * r42);
            e[2] = (l11 * r13) + (l12 * r23) + (l13 * r33) + (l14 * r43);
            e[3] = (l11 * r14) + (l12 * r24) + (l13 * r34) + (l14 * r44);
            e[4] = (l21 * r11) + (l22 * r21) + (l23 * r31) + (l24 * r41);
            e[5] = (l21 * r12) + (l22 * r22) + (l23 * r32) + (l24 * r42);
            e[6] = (l21 * r13) + (l22 * r23) + (l23 * r33) + (l24 * r43);
            e[7] = (l21 * r14) + (l22 * r24) + (l23 * r34) + (l24 * r44);
            e[8] = (l31 * r11) + (l32 * r21) + (l33 * r31) + (l34 * r41);
            e[9] = (l31 * r12) + (l32 * r22) + (l33 * r32) + (l34 * r42);
            e[10] = (l31 * r13) + (l32 * r23) + (l33 * r33) + (l34 * r43);
            e[11] = (l31 * r14) + (l32 * r24) + (l33 * r34) + (l34 * r44);
            e[12] = (l41 * r11) + (l42 * r21) + (l43 * r31) + (l44 * r41);
            e[13] = (l41 * r12) + (l42 * r22) + (l43 * r32) + (l44 * r42);
            e[14] = (l41 * r13) + (l42 * r23) + (l43 * r33) + (l44 * r43);
            e[15] = (l41 * r14) + (l42 * r24) + (l43 * r34) + (l44 * r44);
        }
        static createFromQuaternion(rotation, out) {
            var e = out.elements;
            var x = rotation.x, y = rotation.y, z = rotation.z, w = rotation.w;
            var x2 = x + x;
            var y2 = y + y;
            var z2 = z + z;
            var xx = x * x2;
            var yx = y * x2;
            var yy = y * y2;
            var zx = z * x2;
            var zy = z * y2;
            var zz = z * z2;
            var wx = w * x2;
            var wy = w * y2;
            var wz = w * z2;
            e[0] = 1 - yy - zz;
            e[1] = yx + wz;
            e[2] = zx - wy;
            e[3] = 0;
            e[4] = yx - wz;
            e[5] = 1 - xx - zz;
            e[6] = zy + wx;
            e[7] = 0;
            e[8] = zx + wy;
            e[9] = zy - wx;
            e[10] = 1 - xx - yy;
            e[11] = 0;
            e[12] = 0;
            e[13] = 0;
            e[14] = 0;
            e[15] = 1;
        }
        static createAffineTransformation(trans, rot, scale, out) {
            var oe = out.elements;
            var x = rot.x, y = rot.y, z = rot.z, w = rot.w, x2 = x + x, y2 = y + y, z2 = z + z;
            var xx = x * x2, xy = x * y2, xz = x * z2, yy = y * y2, yz = y * z2, zz = z * z2;
            var wx = w * x2, wy = w * y2, wz = w * z2, sx = scale.x, sy = scale.y, sz = scale.z;
            oe[0] = (1 - (yy + zz)) * sx;
            oe[1] = (xy + wz) * sx;
            oe[2] = (xz - wy) * sx;
            oe[3] = 0;
            oe[4] = (xy - wz) * sy;
            oe[5] = (1 - (xx + zz)) * sy;
            oe[6] = (yz + wx) * sy;
            oe[7] = 0;
            oe[8] = (xz + wy) * sz;
            oe[9] = (yz - wx) * sz;
            oe[10] = (1 - (xx + yy)) * sz;
            oe[11] = 0;
            oe[12] = trans.x;
            oe[13] = trans.y;
            oe[14] = trans.z;
            oe[15] = 1;
        }
        static createLookAt(eye, target, up, out) {
            var oE = out.elements;
            var xaxis = _tempVector0;
            var yaxis = _tempVector1;
            var zaxis = _tempVector2;
            Vector3.subtract(eye, target, zaxis);
            Vector3.normalize(zaxis, zaxis);
            Vector3.cross(up, zaxis, xaxis);
            Vector3.normalize(xaxis, xaxis);
            Vector3.cross(zaxis, xaxis, yaxis);
            oE[3] = oE[7] = oE[11] = 0;
            oE[15] = 1;
            oE[0] = xaxis.x;
            oE[4] = xaxis.y;
            oE[8] = xaxis.z;
            oE[1] = yaxis.x;
            oE[5] = yaxis.y;
            oE[9] = yaxis.z;
            oE[2] = zaxis.x;
            oE[6] = zaxis.y;
            oE[10] = zaxis.z;
            oE[12] = -Vector3.dot(xaxis, eye);
            oE[13] = -Vector3.dot(yaxis, eye);
            oE[14] = -Vector3.dot(zaxis, eye);
        }
        static createPerspective(fov, aspect, znear, zfar, out) {
            var yScale = 1.0 / Math.tan(fov * 0.5);
            var xScale = yScale / aspect;
            var halfWidth = znear / xScale;
            var halfHeight = znear / yScale;
            Matrix4x4.createPerspectiveOffCenter(-halfWidth, halfWidth, -halfHeight, halfHeight, znear, zfar, out);
        }
        static createPerspectiveOffCenter(left, right, bottom, top, znear, zfar, out) {
            var oe = out.elements;
            var zRange = zfar / (zfar - znear);
            oe[1] = oe[2] = oe[3] = oe[4] = oe[6] = oe[7] = oe[12] = oe[13] = oe[15] = 0;
            oe[0] = 2.0 * znear / (right - left);
            oe[5] = 2.0 * znear / (top - bottom);
            oe[8] = (left + right) / (right - left);
            oe[9] = (top + bottom) / (top - bottom);
            oe[10] = -zRange;
            oe[11] = -1.0;
            oe[14] = -znear * zRange;
        }
        static createOrthoOffCenter(left, right, bottom, top, znear, zfar, out) {
            var oe = out.elements;
            var zRange = 1.0 / (zfar - znear);
            oe[1] = oe[2] = oe[3] = oe[4] = oe[6] = oe[8] = oe[7] = oe[9] = oe[11] = 0;
            oe[15] = 1;
            oe[0] = 2.0 / (right - left);
            oe[5] = 2.0 / (top - bottom);
            oe[10] = -zRange;
            oe[12] = (left + right) / (left - right);
            oe[13] = (top + bottom) / (bottom - top);
            oe[14] = -znear * zRange;
        }
        getElementByRowColumn(row, column) {
            if (row < 0 || row > 3)
                throw new Error("row Rows and columns for matrices run from 0 to 3, inclusive.");
            if (column < 0 || column > 3)
                throw new Error("column Rows and columns for matrices run from 0 to 3, inclusive.");
            return this.elements[(row * 4) + column];
        }
        setElementByRowColumn(row, column, value) {
            if (row < 0 || row > 3)
                throw new Error("row Rows and columns for matrices run from 0 to 3, inclusive.");
            if (column < 0 || column > 3)
                throw new Error("column Rows and columns for matrices run from 0 to 3, inclusive.");
            this.elements[(row * 4) + column] = value;
        }
        setRotation(rotation) {
            var rotationX = rotation.x;
            var rotationY = rotation.y;
            var rotationZ = rotation.z;
            var rotationW = rotation.w;
            var xx = rotationX * rotationX;
            var yy = rotationY * rotationY;
            var zz = rotationZ * rotationZ;
            var xy = rotationX * rotationY;
            var zw = rotationZ * rotationW;
            var zx = rotationZ * rotationX;
            var yw = rotationY * rotationW;
            var yz = rotationY * rotationZ;
            var xw = rotationX * rotationW;
            var e = this.elements;
            e[0] = 1.0 - (2.0 * (yy + zz));
            e[1] = 2.0 * (xy + zw);
            e[2] = 2.0 * (zx - yw);
            e[4] = 2.0 * (xy - zw);
            e[5] = 1.0 - (2.0 * (zz + xx));
            e[6] = 2.0 * (yz + xw);
            e[8] = 2.0 * (zx + yw);
            e[9] = 2.0 * (yz - xw);
            e[10] = 1.0 - (2.0 * (yy + xx));
        }
        setPosition(position) {
            var e = this.elements;
            e[12] = position.x;
            e[13] = position.y;
            e[14] = position.z;
        }
        equalsOtherMatrix(other) {
            var e = this.elements;
            var oe = other.elements;
            return (MathUtils3D.nearEqual(e[0], oe[0]) && MathUtils3D.nearEqual(e[1], oe[1]) && MathUtils3D.nearEqual(e[2], oe[2]) && MathUtils3D.nearEqual(e[3], oe[3]) && MathUtils3D.nearEqual(e[4], oe[4]) && MathUtils3D.nearEqual(e[5], oe[5]) && MathUtils3D.nearEqual(e[6], oe[6]) && MathUtils3D.nearEqual(e[7], oe[7]) && MathUtils3D.nearEqual(e[8], oe[8]) && MathUtils3D.nearEqual(e[9], oe[9]) && MathUtils3D.nearEqual(e[10], oe[10]) && MathUtils3D.nearEqual(e[11], oe[11]) && MathUtils3D.nearEqual(e[12], oe[12]) && MathUtils3D.nearEqual(e[13], oe[13]) && MathUtils3D.nearEqual(e[14], oe[14]) && MathUtils3D.nearEqual(e[15], oe[15]));
        }
        decomposeTransRotScale(translation, rotation, scale) {
            var rotationMatrix = _tempMatrix4x4;
            if (this.decomposeTransRotMatScale(translation, rotationMatrix, scale)) {
                Quaternion.createFromMatrix4x4(rotationMatrix, rotation);
                return true;
            }
            else {
                rotation.identity();
                return false;
            }
        }
        decomposeTransRotMatScale(translation, rotationMatrix, scale) {
            var e = this.elements;
            var te = translation;
            var re = rotationMatrix.elements;
            var se = scale;
            te.x = e[12];
            te.y = e[13];
            te.z = e[14];
            var m11 = e[0], m12 = e[1], m13 = e[2];
            var m21 = e[4], m22 = e[5], m23 = e[6];
            var m31 = e[8], m32 = e[9], m33 = e[10];
            var sX = se.x = Math.sqrt((m11 * m11) + (m12 * m12) + (m13 * m13));
            var sY = se.y = Math.sqrt((m21 * m21) + (m22 * m22) + (m23 * m23));
            var sZ = se.z = Math.sqrt((m31 * m31) + (m32 * m32) + (m33 * m33));
            if (MathUtils3D.isZero(sX) || MathUtils3D.isZero(sY) || MathUtils3D.isZero(sZ)) {
                re[1] = re[2] = re[3] = re[4] = re[6] = re[7] = re[8] = re[9] = re[11] = re[12] = re[13] = re[14] = 0;
                re[0] = re[5] = re[10] = re[15] = 1;
                return false;
            }
            var at = _tempVector0;
            at.x = m31 / sZ;
            at.y = m32 / sZ;
            at.z = m33 / sZ;
            var tempRight = _tempVector1;
            tempRight.x = m11 / sX;
            tempRight.y = m12 / sX;
            tempRight.z = m13 / sX;
            var up = _tempVector2;
            Vector3.cross(at, tempRight, up);
            var right = _tempVector1;
            Vector3.cross(up, at, right);
            re[3] = re[7] = re[11] = re[12] = re[13] = re[14] = 0;
            re[15] = 1;
            re[0] = right.x;
            re[1] = right.y;
            re[2] = right.z;
            re[4] = up.x;
            re[5] = up.y;
            re[6] = up.z;
            re[8] = at.x;
            re[9] = at.y;
            re[10] = at.z;
            ((re[0] * m11 + re[1] * m12 + re[2] * m13) < 0.0) && (se.x = -sX);
            ((re[4] * m21 + re[5] * m22 + re[6] * m23) < 0.0) && (se.y = -sY);
            ((re[8] * m31 + re[9] * m32 + re[10] * m33) < 0.0) && (se.z = -sZ);
            return true;
        }
        decomposeYawPitchRoll(yawPitchRoll) {
            var pitch = Math.asin(-this.elements[9]);
            yawPitchRoll.y = pitch;
            var test = Math.cos(pitch);
            if (test > MathUtils3D.zeroTolerance) {
                yawPitchRoll.z = Math.atan2(this.elements[1], this.elements[5]);
                yawPitchRoll.x = Math.atan2(this.elements[8], this.elements[10]);
            }
            else {
                yawPitchRoll.z = Math.atan2(-this.elements[4], this.elements[0]);
                yawPitchRoll.x = 0.0;
            }
        }
        normalize() {
            var v = this.elements;
            var c = v[0], d = v[1], e = v[2], g = Math.sqrt(c * c + d * d + e * e);
            if (g) {
                if (g == 1)
                    return;
            }
            else {
                v[0] = 0;
                v[1] = 0;
                v[2] = 0;
                return;
            }
            g = 1 / g;
            v[0] = c * g;
            v[1] = d * g;
            v[2] = e * g;
        }
        transpose() {
            var e, t;
            e = this.elements;
            t = e[1];
            e[1] = e[4];
            e[4] = t;
            t = e[2];
            e[2] = e[8];
            e[8] = t;
            t = e[3];
            e[3] = e[12];
            e[12] = t;
            t = e[6];
            e[6] = e[9];
            e[9] = t;
            t = e[7];
            e[7] = e[13];
            e[13] = t;
            t = e[11];
            e[11] = e[14];
            e[14] = t;
            return this;
        }
        invert(out) {
            var ae = this.elements;
            var oe = out.elements;
            var a00 = ae[0], a01 = ae[1], a02 = ae[2], a03 = ae[3], a10 = ae[4], a11 = ae[5], a12 = ae[6], a13 = ae[7], a20 = ae[8], a21 = ae[9], a22 = ae[10], a23 = ae[11], a30 = ae[12], a31 = ae[13], a32 = ae[14], a33 = ae[15], b00 = a00 * a11 - a01 * a10, b01 = a00 * a12 - a02 * a10, b02 = a00 * a13 - a03 * a10, b03 = a01 * a12 - a02 * a11, b04 = a01 * a13 - a03 * a11, b05 = a02 * a13 - a03 * a12, b06 = a20 * a31 - a21 * a30, b07 = a20 * a32 - a22 * a30, b08 = a20 * a33 - a23 * a30, b09 = a21 * a32 - a22 * a31, b10 = a21 * a33 - a23 * a31, b11 = a22 * a33 - a23 * a32, det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
            if (Math.abs(det) === 0.0) {
                return;
            }
            det = 1.0 / det;
            oe[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
            oe[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
            oe[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
            oe[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
            oe[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
            oe[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
            oe[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
            oe[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
            oe[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
            oe[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
            oe[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
            oe[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
            oe[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
            oe[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
            oe[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
            oe[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
        }
        static billboard(objectPosition, cameraPosition, cameraUp, cameraForward, mat) {
            Vector3.subtract(objectPosition, cameraPosition, _tempVector0);
            var lengthSq = Vector3.scalarLengthSquared(_tempVector0);
            if (MathUtils3D.isZero(lengthSq)) {
                Vector3.scale(cameraForward, -1, _tempVector1);
                _tempVector1.cloneTo(_tempVector0);
            }
            else {
                Vector3.scale(_tempVector0, 1 / Math.sqrt(lengthSq), _tempVector0);
            }
            Vector3.cross(cameraUp, _tempVector0, _tempVector2);
            Vector3.normalize(_tempVector2, _tempVector2);
            Vector3.cross(_tempVector0, _tempVector2, _tempVector3);
            var crosse = _tempVector2;
            var finale = _tempVector3;
            var diffee = _tempVector0;
            var obpose = objectPosition;
            var mate = mat.elements;
            mate[0] = crosse.x;
            mate[1] = crosse.y;
            mate[2] = crosse.z;
            mate[3] = 0.0;
            mate[4] = finale.x;
            mate[5] = finale.y;
            mate[6] = finale.z;
            mate[7] = 0.0;
            mate[8] = diffee.x;
            mate[9] = diffee.y;
            mate[10] = diffee.z;
            mate[11] = 0.0;
            mate[12] = obpose.x;
            mate[13] = obpose.y;
            mate[14] = obpose.z;
            mate[15] = 1.0;
        }
        identity() {
            this.elements.set(DEFAULTARRAY);
        }
        isIdentity() {
            let delty = function (num0, num1) {
                return Math.abs(num0 - num1) < 1e-7;
            };
            let e = this.elements;
            let defined = Matrix4x4.DEFAULT.elements;
            for (let i = 0, n = e.length; i < n; i++) {
                if (!delty(e[i], defined[i]))
                    return false;
            }
            return true;
        }
        cloneTo(destObject) {
            var s, d;
            s = this.elements;
            d = destObject.elements;
            if (s === d) {
                return;
            }
            destObject.elements.set(this.elements);
        }
        cloneByArray(destObject) {
            this.elements.set(destObject);
        }
        clone() {
            var dest = new Matrix4x4(null);
            dest.elements = this.elements.slice();
            return dest;
        }
        static translation(v3, out) {
            var oe = out.elements;
            oe[0] = oe[5] = oe[10] = oe[15] = 1;
            oe[12] = v3.x;
            oe[13] = v3.y;
            oe[14] = v3.z;
        }
        getTranslationVector(out) {
            var me = this.elements;
            out.x = me[12];
            out.y = me[13];
            out.z = me[14];
        }
        setTranslationVector(translate) {
            var me = this.elements;
            var ve = translate;
            me[12] = ve.x;
            me[13] = ve.y;
            me[14] = ve.z;
        }
        getForward(out) {
            var me = this.elements;
            out.x = -me[8];
            out.y = -me[9];
            out.z = -me[10];
        }
        setForward(forward) {
            var me = this.elements;
            me[8] = -forward.x;
            me[9] = -forward.y;
            me[10] = -forward.z;
        }
        getInvertFront() {
            this.decomposeTransRotScale(_tempVector0, Quaternion.TEMP, _tempVector1);
            var scale = _tempVector1;
            var isInvert = scale.x < 0;
            (scale.y < 0) && (isInvert = !isInvert);
            (scale.z < 0) && (isInvert = !isInvert);
            return isInvert;
        }
    }
    Matrix4x4.TEMPMatrix0 = new Matrix4x4();
    Matrix4x4.TEMPMatrix1 = new Matrix4x4();
    Matrix4x4.DEFAULT = new Matrix4x4();
    Matrix4x4.ZERO = new Matrix4x4(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const _tempMatrix4x4 = new Matrix4x4();

    exports.ShaderDataType = void 0;
    (function (ShaderDataType) {
        ShaderDataType[ShaderDataType["Int"] = 0] = "Int";
        ShaderDataType[ShaderDataType["Bool"] = 1] = "Bool";
        ShaderDataType[ShaderDataType["Float"] = 2] = "Float";
        ShaderDataType[ShaderDataType["Vector2"] = 3] = "Vector2";
        ShaderDataType[ShaderDataType["Vector3"] = 4] = "Vector3";
        ShaderDataType[ShaderDataType["Vector4"] = 5] = "Vector4";
        ShaderDataType[ShaderDataType["Color"] = 6] = "Color";
        ShaderDataType[ShaderDataType["Matrix4x4"] = 7] = "Matrix4x4";
        ShaderDataType[ShaderDataType["Texture2D"] = 8] = "Texture2D";
        ShaderDataType[ShaderDataType["TextureCube"] = 9] = "TextureCube";
        ShaderDataType[ShaderDataType["Buffer"] = 10] = "Buffer";
    })(exports.ShaderDataType || (exports.ShaderDataType = {}));
    function ShaderDataDefaultValue(type) {
        switch (type) {
            case exports.ShaderDataType.Int:
                return 0;
            case exports.ShaderDataType.Bool:
                return false;
            case exports.ShaderDataType.Float:
                return 0;
            case exports.ShaderDataType.Vector2:
                return Vector2.ZERO;
            case exports.ShaderDataType.Vector3:
                return Vector3.ZERO;
            case exports.ShaderDataType.Vector4:
                return Vector4.ZERO;
            case exports.ShaderDataType.Color:
                return Color.BLACK;
            case exports.ShaderDataType.Matrix4x4:
                return Matrix4x4.DEFAULT;
        }
        return null;
    }
    class ShaderData {
        constructor(ownerResource = null) {
            this._ownerResource = null;
            this._data = null;
            this._defineDatas = new DefineDatas();
            this._ownerResource = ownerResource;
            this._initData();
            this._uniformBufferDatas = new Map();
            this._uniformBuffersMap = new Map();
        }
        get uniformBufferDatas() {
            return this._uniformBufferDatas;
        }
        get uniformBuffersMap() {
            return this._uniformBuffersMap;
        }
        _addCheckUBO(key, ubo, uboData) {
            this._uniformBufferDatas.set(key, ubo);
            uboData._uniformParamsState.forEach((value, id) => {
                this.uniformBuffersMap.set(id, ubo);
            });
            ubo.setDataByUniformBufferData(uboData);
        }
        _initData() {
            this._data = {};
            this._gammaColorMap = new Map();
        }
        getData() {
            return this._data;
        }
        addDefine(define) {
            this._defineDatas.add(define);
        }
        removeDefine(define) {
            this._defineDatas.remove(define);
        }
        hasDefine(define) {
            return this._defineDatas.has(define);
        }
        clearDefine() {
            this._defineDatas.clear();
        }
        getBool(index) {
            return this._data[index];
        }
        setBool(index, value) {
            this._data[index] = value;
        }
        getInt(index) {
            return this._data[index];
        }
        setInt(index, value) {
            this._data[index] = value;
            let ubo = this._uniformBuffersMap.get(index);
            if (ubo) {
                ubo._updateDataInfo._setData(index, this.getInt(index));
                ubo.setDataByUniformBufferData(ubo._updateDataInfo);
            }
        }
        getNumber(index) {
            return this._data[index];
        }
        setNumber(index, value) {
            this._data[index] = value;
            let ubo = this._uniformBuffersMap.get(index);
            if (ubo) {
                ubo._updateDataInfo._setData(index, this.getNumber(index));
                ubo.setDataByUniformBufferData(ubo._updateDataInfo);
            }
        }
        getVector2(index) {
            return this._data[index];
        }
        setVector2(index, value) {
            if (this._data[index]) {
                value.cloneTo(this._data[index]);
            }
            else
                this._data[index] = value.clone();
            let ubo = this._uniformBuffersMap.get(index);
            if (ubo) {
                ubo._updateDataInfo._setData(index, this.getVector2(index));
                ubo.setDataByUniformBufferData(ubo._updateDataInfo);
            }
        }
        getVector3(index) {
            return this._data[index];
        }
        setVector3(index, value) {
            if (this._data[index]) {
                value.cloneTo(this._data[index]);
            }
            else
                this._data[index] = value.clone();
            let ubo = this._uniformBuffersMap.get(index);
            if (ubo) {
                ubo._updateDataInfo._setData(index, this.getVector3(index));
                ubo.setDataByUniformBufferData(ubo._updateDataInfo);
            }
        }
        getVector(index) {
            return this._data[index];
        }
        setVector(index, value) {
            if (this._data[index]) {
                value.cloneTo(this._data[index]);
            }
            else
                this._data[index] = value.clone();
            let ubo = this._uniformBuffersMap.get(index);
            if (ubo) {
                ubo._updateDataInfo._setData(index, this.getVector(index));
                ubo.setDataByUniformBufferData(ubo._updateDataInfo);
            }
        }
        getColor(index) {
            return this._gammaColorMap.get(index);
        }
        setColor(index, value) {
            if (!value)
                return;
            if (this._data[index]) {
                let gammaColor = this._gammaColorMap.get(index);
                value.cloneTo(gammaColor);
                let linearColor = this._data[index];
                linearColor.x = Color.gammaToLinearSpace(value.r);
                linearColor.y = Color.gammaToLinearSpace(value.g);
                linearColor.z = Color.gammaToLinearSpace(value.b);
                linearColor.w = value.a;
            }
            else {
                let linearColor = new Vector4();
                linearColor.x = Color.gammaToLinearSpace(value.r);
                linearColor.y = Color.gammaToLinearSpace(value.g);
                linearColor.z = Color.gammaToLinearSpace(value.b);
                linearColor.w = value.a;
                this._data[index] = linearColor;
                this._gammaColorMap.set(index, value.clone());
            }
            let ubo = this._uniformBuffersMap.get(index);
            if (ubo) {
                ubo._updateDataInfo._setData(index, this.getLinearColor(index));
                ubo.setDataByUniformBufferData(ubo._updateDataInfo);
            }
        }
        getLinearColor(index) {
            return this._data[index];
        }
        getMatrix4x4(index) {
            return this._data[index];
        }
        setMatrix4x4(index, value) {
            if (this._data[index]) {
                value.cloneTo(this._data[index]);
            }
            else {
                this._data[index] = value.clone();
            }
            let ubo = this._uniformBuffersMap.get(index);
            if (ubo) {
                ubo._updateDataInfo._setData(index, this.getVector(index));
                ubo.setDataByUniformBufferData(ubo._updateDataInfo);
            }
        }
        getBuffer(index) {
            return this._data[index];
        }
        setBuffer(index, value) {
            this._data[index] = value;
        }
        setTexture(index, value) {
            var lastValue = this._data[index];
            if (value) {
                let shaderDefine = ShaderDefine._texGammaDefine[index];
                if (shaderDefine && value && value.gammaCorrection > 1) {
                    this.addDefine(shaderDefine);
                }
                else {
                    shaderDefine && this.removeDefine(shaderDefine);
                }
            }
            this._data[index] = value ? value : Texture2D.erroTextur;
            (lastValue) && (lastValue._removeReference());
            (value) && (value._addReference());
        }
        getTexture(index) {
            return this._data[index];
        }
        getSourceIndex(value) {
            for (var i in this._data) {
                if (this._data[i] == value)
                    return Number(i);
            }
            return -1;
        }
        setValueData(index, value) {
            if (value instanceof Color) {
                this.setColor(index, value);
                return;
            }
            else if (!value) {
                this._data[index] = value;
            }
            else if (!!value.clone) {
                this._data[index] = value.clone();
            }
            else
                this._data[index] = value;
            let ubo = this._uniformBuffersMap.get(index);
            if (ubo) {
                ubo._updateDataInfo._setData(index, this.getValueData(index));
                ubo.setDataByUniformBufferData(ubo._updateDataInfo);
            }
        }
        setUniformBuffer(index, value) {
            this._data[index] = value;
        }
        getUniformBuffer(index) {
            return this._data[index];
        }
        setShaderData(uniformIndex, type, value) {
            switch (type) {
                case exports.ShaderDataType.Int:
                    this.setInt(uniformIndex, value);
                    break;
                case exports.ShaderDataType.Bool:
                    this.setBool(uniformIndex, value);
                    break;
                case exports.ShaderDataType.Float:
                    this.setNumber(uniformIndex, value);
                    break;
                case exports.ShaderDataType.Vector2:
                    this.setVector2(uniformIndex, value);
                    break;
                case exports.ShaderDataType.Vector3:
                    this.setVector3(uniformIndex, value);
                    break;
                case exports.ShaderDataType.Vector4:
                    this.setVector(uniformIndex, value);
                    break;
                case exports.ShaderDataType.Color:
                    this.setColor(uniformIndex, value);
                    break;
                case exports.ShaderDataType.Matrix4x4:
                    this.setMatrix4x4(uniformIndex, value);
                    break;
                case exports.ShaderDataType.Texture2D:
                case exports.ShaderDataType.TextureCube:
                    this.setTexture(uniformIndex, value);
                    break;
                case exports.ShaderDataType.Buffer:
                    this.setBuffer(uniformIndex, value);
                    break;
                default:
                    throw "unkone shader data type.";
            }
        }
        getShaderData(uniformIndex, type) {
            switch (type) {
                case exports.ShaderDataType.Int:
                    return this.getInt(uniformIndex);
                case exports.ShaderDataType.Bool:
                    return this.getBool(uniformIndex);
                case exports.ShaderDataType.Float:
                    return this.getNumber(uniformIndex);
                case exports.ShaderDataType.Vector2:
                    return this.getVector2(uniformIndex);
                case exports.ShaderDataType.Vector3:
                    return this.getVector3(uniformIndex);
                case exports.ShaderDataType.Vector4:
                    return this.getVector(uniformIndex);
                case exports.ShaderDataType.Color:
                    return this.getColor(uniformIndex);
                case exports.ShaderDataType.Matrix4x4:
                    return this.getMatrix4x4(uniformIndex);
                case exports.ShaderDataType.Texture2D:
                case exports.ShaderDataType.TextureCube:
                    return this.getTexture(uniformIndex);
                case exports.ShaderDataType.Buffer:
                    return this.getBuffer(uniformIndex);
                default:
                    throw "unkone shader data type.";
            }
        }
        getValueData(index) {
            return this._data[index];
        }
        cloneTo(destObject) {
            var dest = destObject;
            var destData = dest._data;
            for (var k in this._data) {
                var value = this._data[k];
                if (value != null) {
                    if (typeof (value) == 'number') {
                        destData[k] = value;
                    }
                    else if (typeof (value) == 'number') {
                        destData[k] = value;
                    }
                    else if (typeof (value) == "boolean") {
                        destData[k] = value;
                    }
                    else if (value instanceof Vector2) {
                        var v2 = (destData[k]) || (destData[k] = new Vector2());
                        value.cloneTo(v2);
                        destData[k] = v2;
                    }
                    else if (value instanceof Vector3) {
                        var v3 = (destData[k]) || (destData[k] = new Vector3());
                        value.cloneTo(v3);
                        destData[k] = v3;
                    }
                    else if (value instanceof Vector4) {
                        let color = this.getColor(parseInt(k));
                        if (color) {
                            let clonecolor = color.clone();
                            destObject.setColor(parseInt(k), clonecolor);
                        }
                        else {
                            var v4 = (destData[k]) || (destData[k] = new Vector4());
                            value.cloneTo(v4);
                            destData[k] = v4;
                        }
                    }
                    else if (value instanceof Matrix4x4) {
                        var mat = (destData[k]) || (destData[k] = new Matrix4x4());
                        value.cloneTo(mat);
                        destData[k] = mat;
                    }
                    else if (value instanceof BaseTexture) {
                        destData[k] = value;
                        value._addReference();
                    }
                }
            }
            this._defineDatas.cloneTo(dest._defineDatas);
            this._gammaColorMap.forEach((color, index) => {
                destObject._gammaColorMap.set(index, color.clone());
            });
        }
        clone() {
            var dest = new ShaderData();
            this.cloneTo(dest);
            return dest;
        }
        reset() {
            for (var k in this._data) {
                var value = this._data[k];
                if (value instanceof Resource) {
                    value._removeReference();
                }
            }
            this._data = {};
            this._gammaColorMap.clear();
            this._uniformBufferDatas.clear();
            this._uniformBuffersMap.clear();
            this._defineDatas.clear();
        }
        destroy() {
            this._defineDatas.destroy();
            this._defineDatas = null;
            for (var k in this._data) {
                var value = this._data[k];
                if (value instanceof Resource) {
                    value._removeReference();
                }
            }
            this._data = null;
            this._gammaColorMap.clear();
            this._gammaColorMap = null;
            delete this._uniformBufferDatas;
            delete this._uniformBuffersMap;
            this._uniformBufferDatas = null;
            this._uniformBuffersMap = null;
        }
    }

    exports.UniformBufferParamsType = void 0;
    (function (UniformBufferParamsType) {
        UniformBufferParamsType[UniformBufferParamsType["Number"] = 0] = "Number";
        UniformBufferParamsType[UniformBufferParamsType["Vector2"] = 1] = "Vector2";
        UniformBufferParamsType[UniformBufferParamsType["Vector3"] = 2] = "Vector3";
        UniformBufferParamsType[UniformBufferParamsType["Vector4"] = 3] = "Vector4";
        UniformBufferParamsType[UniformBufferParamsType["Matrix4x4"] = 4] = "Matrix4x4";
        UniformBufferParamsType[UniformBufferParamsType["Vector4Array"] = 5] = "Vector4Array";
        UniformBufferParamsType[UniformBufferParamsType["MatrixArray"] = 6] = "MatrixArray";
    })(exports.UniformBufferParamsType || (exports.UniformBufferParamsType = {}));
    class UnifromBufferData {
        constructor(uniformParamsStat) {
            this._uniformParamsState = new Map(uniformParamsStat);
            this._createBuffer();
            this._updateFlag = new Vector2();
            this._resetUpdateFlag();
        }
        _createBuffer() {
            var dataPos = 0;
            this._layoutMap = {};
            const elementSize = 4;
            this._uniformParamsState.forEach((key, value) => {
                dataPos += this._addUniformParams(value, key, dataPos);
            });
            this._bytelength = Math.ceil(dataPos / 4) * 4 * elementSize;
            this._buffer = new Float32Array(dataPos);
        }
        _getArraySize(key) {
            let left = key.indexOf("[");
            let right = key.indexOf("]");
            if (left != -1 && right != -1 && left < right) {
                return parseFloat(key.substring(left + 1, right));
            }
            else
                throw key + " is illegal ";
        }
        _addUniformParams(uniformID, value, offset) {
            let size = 0;
            let posAdd = 0;
            let posG = offset % 4;
            let offsetadd;
            switch (value) {
                case exports.UniformBufferParamsType.Number:
                    size = 1;
                    posAdd = 1;
                    break;
                case exports.UniformBufferParamsType.Vector2:
                    size = 2;
                    switch (posG) {
                        case 0:
                        case 2:
                            posAdd = 2;
                            break;
                        case 1:
                        case 3:
                            offset += 1;
                            posAdd = 3;
                            break;
                    }
                    break;
                case exports.UniformBufferParamsType.Vector3:
                    size = 3;
                    posAdd = 3;
                    switch (posG) {
                        case 1:
                        case 2:
                        case 3:
                            offset += (4 - posG);
                            posAdd = (4 - posG) + 3;
                            break;
                    }
                    break;
                case exports.UniformBufferParamsType.Vector4:
                    size = 4;
                    switch (posG) {
                        case 0:
                            posAdd = 4;
                            break;
                        case 1:
                            offset += 3;
                            posAdd = 7;
                            break;
                        case 2:
                            offset += 2;
                            posAdd = 6;
                            break;
                        case 3:
                            offset += 1;
                            posAdd = 5;
                            break;
                    }
                    break;
                case exports.UniformBufferParamsType.Matrix4x4:
                    size = 16;
                    offsetadd = posG ? 4 - posG : posG;
                    offset += offsetadd;
                    posAdd = size + offsetadd;
                    break;
                case exports.UniformBufferParamsType.Vector4Array:
                    size = this._getArraySize(Shader3D.propertyIDToName(uniformID)) * 4;
                    offsetadd = posG ? 4 - posG : posG;
                    offset += offsetadd;
                    posAdd = size + offsetadd;
                    break;
                case exports.UniformBufferParamsType.MatrixArray:
                    size = this._getArraySize(Shader3D.propertyIDToName(uniformID)) * 16;
                    offsetadd = posG ? 4 - posG : posG;
                    offset += offsetadd;
                    posAdd = size + offsetadd;
                    break;
                default:
                    throw "Unifrom Buffer Params Type is illegal ";
            }
            const paramsInfo = new Vector2(offset, size);
            this._layoutMap[uniformID] = paramsInfo;
            return posAdd;
        }
        _getParamsInfo(key) {
            return this._layoutMap[key];
        }
        _setUpdateFlag(min, max) {
            if (min < this._updateFlag.x)
                this._updateFlag.x = min;
            if (max > this._updateFlag.y)
                this._updateFlag.y = max;
        }
        destroy() {
            delete this._buffer;
            this._uniformParamsState.clear();
            this._uniformParamsState = null;
            this._layoutMap = null;
            this._updateFlag = null;
        }
        _resetUpdateFlag() {
            this._updateFlag.setValue(this._buffer.length, 0);
        }
        _has(uniformID) {
            const info = this._getParamsInfo(uniformID);
            return !!info;
        }
        _setData(uniformID, value) {
            let uniformType = this._uniformParamsState.get(uniformID);
            switch (uniformType) {
                case exports.UniformBufferParamsType.Number:
                    this.setNumberbyIndex(uniformID, value);
                    break;
                case exports.UniformBufferParamsType.Vector2:
                    this.setVector2byIndex(uniformID, value);
                    break;
                case exports.UniformBufferParamsType.Vector3:
                    this.setVector3byIndex(uniformID, value);
                    break;
                case exports.UniformBufferParamsType.Vector4:
                    this.setVector4byIndex(uniformID, value);
                    break;
                case exports.UniformBufferParamsType.Matrix4x4:
                    this.setMatrixbyIndex(uniformID, value);
                    break;
                case exports.UniformBufferParamsType.Vector4Array:
                    this.setVector4ArraybyIndex(uniformID, value);
                    break;
                case exports.UniformBufferParamsType.MatrixArray:
                    this.setMatrixArraybyIndex(uniformID, value);
                    break;
            }
        }
        getbyteLength() {
            return this._bytelength;
        }
        setVector4Array(name, value) {
            const uniformID = Shader3D.propertyNameToID(name);
            this.setVector4ArraybyIndex(uniformID, value);
        }
        setVector4ArraybyIndex(uniformID, value) {
            const info = this._getParamsInfo(uniformID);
            if (!info)
                return;
            let pos = info.x;
            let count = info.y / 4;
            for (let i = 0; i < count; i++) {
                let vec = value[i];
                this._buffer[pos++] = vec.x;
                this._buffer[pos++] = vec.y;
                this._buffer[pos++] = vec.z;
                this._buffer[pos++] = vec.w;
            }
            this._setUpdateFlag(info.x, pos);
        }
        setMatrixArray(name, value) {
            const uniformID = Shader3D.propertyNameToID(name);
            this.setMatrixArraybyIndex(uniformID, value);
        }
        setMatrixArraybyIndex(uniformID, value) {
            const info = this._getParamsInfo(uniformID);
            if (!info)
                return;
            let pos = info.x;
            let count = info.y / 4;
            for (let i = 0; i < count; i++) {
                let mat = value[i];
                this._buffer.set(mat.elements, pos);
                pos += 16;
            }
            this._setUpdateFlag(info.x, pos);
        }
        setNumber(name, value) {
            const uniformID = Shader3D.propertyNameToID(name);
            this.setNumberbyIndex(uniformID, value);
        }
        setNumberbyIndex(uniformID, value) {
            const info = this._getParamsInfo(uniformID);
            if (!info)
                return;
            let pos = info.x;
            this._buffer[pos++] = value;
            this._setUpdateFlag(info.x, pos);
        }
        setVector2(name, value) {
            const uniformID = Shader3D.propertyNameToID(name);
            this.setVector2byIndex(uniformID, value);
        }
        setVector2byIndex(uniformID, value) {
            const info = this._getParamsInfo(uniformID);
            if (!info)
                return;
            let pos = info.x;
            this._buffer[pos++] = value.x;
            this._buffer[pos++] = value.y;
            this._setUpdateFlag(info.x, pos);
        }
        setVector3(name, value) {
            const uniformID = Shader3D.propertyNameToID(name);
            this.setVector3byIndex(uniformID, value);
        }
        setVector3byIndex(uniformID, value) {
            const info = this._getParamsInfo(uniformID);
            if (!info)
                return;
            let pos = info.x;
            this._buffer[pos++] = value.x;
            this._buffer[pos++] = value.y;
            this._buffer[pos++] = value.z;
            this._setUpdateFlag(info.x, pos);
        }
        setVector4(name, value) {
            const uniformID = Shader3D.propertyNameToID(name);
            this.setVector4byIndex(uniformID, value);
        }
        setVector4byIndex(uniformID, value) {
            const info = this._getParamsInfo(uniformID);
            if (!info)
                return;
            let pos = info.x;
            this._buffer[pos++] = value.x;
            this._buffer[pos++] = value.y;
            this._buffer[pos++] = value.z;
            this._buffer[pos++] = value.w;
            this._setUpdateFlag(info.x, pos);
        }
        setColor(name, value) {
            const uniformID = Shader3D.propertyNameToID(name);
            this.setColorbyIndex(uniformID, value);
        }
        setColorbyIndex(uniformID, value) {
            const info = this._getParamsInfo(uniformID);
            if (!info)
                return;
            let pos = info.x;
            this._buffer[pos++] = Color.gammaToLinearSpace(value.r);
            this._buffer[pos++] = Color.gammaToLinearSpace(value.g);
            this._buffer[pos++] = Color.gammaToLinearSpace(value.b);
            this._buffer[pos++] = Color.gammaToLinearSpace(value.a);
            this._setUpdateFlag(info.x, pos);
        }
        setMatrix(name, value) {
            const uniformID = Shader3D.propertyNameToID(name);
            this.setMatrixbyIndex(uniformID, value);
        }
        setMatrixbyIndex(uniformID, value) {
            const info = this._getParamsInfo(uniformID);
            if (!info)
                return;
            let pos = info.x;
            this._buffer.set(value.elements, pos);
            pos += 16;
            this._setUpdateFlag(info.x, pos);
        }
        clone() {
            let ubd = new UnifromBufferData(this._uniformParamsState);
            return ubd;
        }
    }

    class ShaderCompileDefineBase {
        constructor(owner, name, compiledObj) {
            this._validDefine = new DefineDatas();
            this._cacheShaderHierarchy = 1;
            this._cacheSharders = {};
            this._owner = owner;
            this.name = name;
            this._VS = compiledObj.vsNode;
            this._PS = compiledObj.psNode;
            this._defs = compiledObj.defs;
            for (let k of compiledObj.defs)
                this._validDefine.add(Shader3D.getDefineByName(k));
        }
        _resizeCacheShaderMap(cacheMap, hierarchy, resizeLength) {
            var end = this._cacheShaderHierarchy - 1;
            if (hierarchy == end) {
                for (var k in cacheMap) {
                    var shader = cacheMap[k];
                    for (var i = 0, n = resizeLength - end; i < n; i++) {
                        if (i == n - 1)
                            cacheMap[0] = shader;
                        else
                            cacheMap = cacheMap[i == 0 ? k : 0] = {};
                    }
                }
            }
            else {
                ++hierarchy;
                for (var k in cacheMap)
                    this._resizeCacheShaderMap(cacheMap[k], hierarchy, resizeLength);
            }
        }
        withCompile(compileDefine) {
            var debugDefineString = ShaderCompileDefineBase._debugDefineString;
            var debugDefineMask = ShaderCompileDefineBase._debugDefineMask;
            var debugMaskLength;
            compileDefine._intersectionDefineDatas(this._validDefine);
            if (Shader3D.debugMode) {
                debugMaskLength = compileDefine._length;
            }
            var cacheShaders = this._cacheSharders;
            var maskLength = compileDefine._length;
            if (maskLength > this._cacheShaderHierarchy) {
                this._resizeCacheShaderMap(cacheShaders, 0, maskLength);
                this._cacheShaderHierarchy = maskLength;
            }
            var mask = compileDefine._mask;
            var endIndex = compileDefine._length - 1;
            var maxEndIndex = this._cacheShaderHierarchy - 1;
            for (var i = 0; i < maxEndIndex; i++) {
                var subMask = endIndex < i ? 0 : mask[i];
                var subCacheShaders = cacheShaders[subMask];
                (subCacheShaders) || (cacheShaders[subMask] = subCacheShaders = {});
                cacheShaders = subCacheShaders;
            }
            var cacheKey = endIndex < maxEndIndex ? 0 : mask[maxEndIndex];
            var shader = cacheShaders[cacheKey];
            if (shader)
                return shader;
            var defineString = ShaderCompileDefineBase._defineString;
            Shader3D._getNamesByDefineData(compileDefine, defineString);
            var defMap = {};
            var vertexHead;
            var fragmentHead;
            var defineStr = "";
            if (WebGL._isWebGL2) {
                vertexHead =
                    `#version 300 es\n
                #define attribute in
                #define varying out
                #define textureCube texture
                #define texture2D texture\n`;
                fragmentHead =
                    `#version 300 es\n
                #define varying in
                out highp vec4 pc_fragColor;
                #define gl_FragColor pc_fragColor
                #define gl_FragDepthEXT gl_FragDepth
                #define texture2D texture
                #define textureCube texture
                #define texture2DProj textureProj
                #define texture2DLodEXT textureLod
                #define texture2DProjLodEXT textureProjLod
                #define textureCubeLodEXT textureLod
                #define texture2DGradEXT textureGrad
                #define texture2DProjGradEXT textureProjGrad
                #define textureCubeGradEXT textureGrad\n`;
            }
            else {
                vertexHead = "";
                fragmentHead =
                    `#ifdef GL_EXT_shader_texture_lod
                    #extension GL_EXT_shader_texture_lod : enable
                #endif
                #if !defined(GL_EXT_shader_texture_lod)
                    #define texture1DLodEXT texture1D
                    #define texture2DLodEXT texture2D
                    #define texture2DProjLodEXT texture2DProj
                    #define texture3DLodEXT texture3D
                    #define textureCubeLodEXT textureCube
                #endif\n`;
            }
            for (var i = 0, n = defineString.length; i < n; i++) {
                var def = defineString[i];
                defineStr += "#define " + def + "\n";
                defMap[def] = true;
            }
            var vs = this._VS.toscript(defMap, []);
            var vsVersion = '';
            if (vs[0].indexOf('#version') == 0) {
                vsVersion = vs[0] + '\n';
                vs.shift();
            }
            var ps = this._PS.toscript(defMap, []);
            var psVersion = '';
            if (ps[0].indexOf('#version') == 0) {
                psVersion = ps[0] + '\n';
                ps.shift();
            }
            shader = LayaGL.renderOBJCreate.createShaderInstance(vsVersion + vertexHead + defineStr + vs.join('\n'), psVersion + fragmentHead + defineStr + ps.join('\n'), this._owner._attributeMap, this);
            cacheShaders[cacheKey] = shader;
            if (Shader3D.debugMode) {
                var defStr = "";
                var defMask = "";
                for (var i = 0, n = debugMaskLength; i < n; i++)
                    (i == n - 1) ? defMask += debugDefineMask[i] : defMask += debugDefineMask[i] + ",";
                for (var i = 0, n = debugDefineString.length; i < n; i++)
                    (i == n - 1) ? defStr += debugDefineString[i] : defStr += debugDefineString[i] + ",";
                console.log("%cLayaAir: Shader Compile Information---ShaderName:" + this.name + " " + " DefineMask:[" + defMask + "]" + " DefineNames:[" + defStr + "]", "color:green");
            }
            return shader;
        }
    }
    ShaderCompileDefineBase._defineString = [];
    ShaderCompileDefineBase._debugDefineString = [];
    ShaderCompileDefineBase._debugDefineMask = [];

    class GLSLCodeGenerator {
        static glslAttributeString(attributeMap) {
            let res = "";
            for (const key in attributeMap) {
                let type = getAttributeType(attributeMap[key][1]);
                res = `${res}attribute ${type} ${key};\n`;
            }
            return res;
        }
        static glslUniformString(uniformsMap, useUniformBlock) {
            if (useUniformBlock) {
                let blocksStr = "";
                let uniformsStr = "";
                for (const key in uniformsMap) {
                    if (typeof uniformsMap[key] == "object") {
                        let blockUniforms = uniformsMap[key];
                        blocksStr += `uniform ${key} {\n`;
                        for (const uniformName in blockUniforms) {
                            let dataType = blockUniforms[uniformName];
                            blocksStr += `${getAttributeType(dataType)} ${uniformName};\n`;
                        }
                        blocksStr += "};\n";
                    }
                    else {
                        let dataType = uniformsMap[key];
                        uniformsStr += `uniform ${getAttributeType(dataType)} ${key};\n`;
                    }
                }
                return blocksStr + uniformsStr;
            }
            else {
                let uniformsStr = "";
                for (const key in uniformsMap) {
                    if (typeof uniformsMap[key] == "object") {
                        let blockUniforms = uniformsMap[key];
                        for (const uniformName in blockUniforms) {
                            let dataType = blockUniforms[uniformName];
                            uniformsStr += `uniform ${getAttributeType(dataType)} ${uniformName};\n`;
                        }
                    }
                    else {
                        let dataType = uniformsMap[key];
                        uniformsStr += `uniform ${getAttributeType(dataType)} ${key};\n`;
                    }
                }
                return uniformsStr;
            }
        }
    }
    function getAttributeType(type) {
        switch (type) {
            case exports.ShaderDataType.Int:
                return "int";
            case exports.ShaderDataType.Bool:
                return "bool";
            case exports.ShaderDataType.Float:
                return "float";
            case exports.ShaderDataType.Vector2:
                return "vec2";
            case exports.ShaderDataType.Vector3:
                return "vec3";
            case exports.ShaderDataType.Vector4:
            case exports.ShaderDataType.Color:
                return "vec4";
            case exports.ShaderDataType.Matrix4x4:
                return "mat4";
            case exports.ShaderDataType.Texture2D:
                return "sampler2D";
            case exports.ShaderDataType.TextureCube:
                return "samplerCube";
            default:
                return "";
        }
    }

    class ShaderPass extends ShaderCompileDefineBase {
        constructor(owner, compiledObj) {
            super(owner, null, compiledObj);
            this._tags = {};
            this.statefirst = false;
            this._renderState = LayaGL.renderOBJCreate.createRenderState();
            this._renderState.setNull();
        }
        get renderState() {
            return this._renderState;
        }
        _addDebugShaderVariantCollection(compileDefine, outDebugDefines, outDebugDefineMask) {
            var dbugShaderVariantInfo = Shader3D._debugShaderVariantInfo;
            var debugSubShader = this._owner;
            var debugShader = debugSubShader._owner;
            var mask = compileDefine._mask;
            Shader3D._getNamesByDefineData(compileDefine, outDebugDefines);
            outDebugDefineMask.length = mask.length;
            for (var i = 0, n = mask.length; i < n; i++)
                outDebugDefineMask[i] = mask[i];
            if (dbugShaderVariantInfo)
                dbugShaderVariantInfo.setValue(debugShader, debugShader._subShaders.indexOf(debugSubShader), debugSubShader._passes.indexOf(this), outDebugDefines);
            else
                Shader3D._debugShaderVariantInfo = dbugShaderVariantInfo = new ShaderVariant(debugShader, debugShader._subShaders.indexOf(debugSubShader), debugSubShader._passes.indexOf(this), outDebugDefines);
            Shader3D.debugShaderVariantCollection.add(dbugShaderVariantInfo);
        }
        withCompile(compileDefine) {
            var debugDefineString = ShaderPass._debugDefineStrings;
            var debugDefineMask = ShaderPass._debugDefineMasks;
            var debugMaskLength;
            compileDefine._intersectionDefineDatas(this._validDefine);
            if (Shader3D.debugMode) {
                debugMaskLength = compileDefine._length;
                this._addDebugShaderVariantCollection(compileDefine, debugDefineString, debugDefineMask);
            }
            var cacheShaders = this._cacheSharders;
            var maskLength = compileDefine._length;
            if (maskLength > this._cacheShaderHierarchy) {
                this._resizeCacheShaderMap(cacheShaders, 0, maskLength);
                this._cacheShaderHierarchy = maskLength;
            }
            var mask = compileDefine._mask;
            var endIndex = compileDefine._length - 1;
            var maxEndIndex = this._cacheShaderHierarchy - 1;
            for (var i = 0; i < maxEndIndex; i++) {
                var subMask = endIndex < i ? 0 : mask[i];
                var subCacheShaders = cacheShaders[subMask];
                (subCacheShaders) || (cacheShaders[subMask] = subCacheShaders = {});
                cacheShaders = subCacheShaders;
            }
            var cacheKey = endIndex < maxEndIndex ? 0 : mask[maxEndIndex];
            var shader = cacheShaders[cacheKey];
            if (shader)
                return shader;
            var defineString = ShaderPass._defineStrings;
            Shader3D._getNamesByDefineData(compileDefine, defineString);
            var clusterSlices = Config3D.lightClusterCount;
            var defMap = {};
            var vertexHead;
            var fragmentHead;
            var defineStr = "";
            let attributeMap = this._owner._attributeMap;
            let uniformMap = this._owner._uniformMap;
            let useUniformBlock = Config3D._uniformBlock;
            let attributeglsl = GLSLCodeGenerator.glslAttributeString(attributeMap);
            let uniformglsl = GLSLCodeGenerator.glslUniformString(uniformMap, useUniformBlock);
            if (WebGL._isWebGL2) {
                vertexHead =
                    `#version 300 es
#if defined(GL_FRAGMENT_PRECISION_HIGH)
    precision highp float;
    precision highp int;
#else
    precision mediump float;
    precision mediump int;
#endif
layout(std140, column_major) uniform;
#define attribute in
#define varying out
#define textureCube texture
#define texture2D texture
${attributeglsl}
${uniformglsl}
`;
                fragmentHead =
                    `#version 300 es
#if defined(GL_FRAGMENT_PRECISION_HIGH)
    precision highp float;
    precision highp int;
#else
    precision mediump float;
    precision mediump int;
#endif
layout(std140, column_major) uniform;
#define varying in
out highp vec4 pc_fragColor;
#define gl_FragColor pc_fragColor
#define gl_FragDepthEXT gl_FragDepth
#define texture2D texture
#define textureCube texture
#define texture2DProj textureProj
#define texture2DLodEXT textureLod
#define texture2DProjLodEXT textureProjLod
#define textureCubeLodEXT textureLod
#define texture2DGradEXT textureGrad
#define texture2DProjGradEXT textureProjGrad
#define textureCubeGradEXT textureGrad
${uniformglsl}`;
            }
            else {
                vertexHead =
                    `#if defined(GL_FRAGMENT_PRECISION_HIGH)
    precision highp float;
    precision highp int;
#else
    precision mediump float;
    precision mediump int;
#endif
${attributeglsl}
${uniformglsl}`;
                fragmentHead =
                    `#ifdef GL_EXT_shader_texture_lod
    #extension GL_EXT_shader_texture_lod : enable
#endif

#if defined(GL_FRAGMENT_PRECISION_HIGH)
    precision highp float;
    precision highp int;
#else
    precision mediump float;
    precision mediump int;
#endif

#if !defined(GL_EXT_shader_texture_lod)
    #define texture1DLodEXT texture1D
    #define texture2DLodEXT texture2D
    #define texture2DProjLodEXT texture2DProj
    #define texture3DLodEXT texture3D
    #define textureCubeLodEXT textureCube
#endif
${uniformglsl}`;
            }
            defineStr += "#define MAX_LIGHT_COUNT " + Config3D.maxLightCount + "\n";
            defineStr += "#define MAX_LIGHT_COUNT_PER_CLUSTER " + Config3D._maxAreaLightCountPerClusterAverage + "\n";
            defineStr += "#define CLUSTER_X_COUNT " + clusterSlices.x + "\n";
            defineStr += "#define CLUSTER_Y_COUNT " + clusterSlices.y + "\n";
            defineStr += "#define CLUSTER_Z_COUNT " + clusterSlices.z + "\n";
            defineStr += "#define SHADER_CAPAILITY_LEVEL " + LayaGL.renderEngine.getParams(exports.RenderParams.SHADER_CAPAILITY_LEVEL) + "\n";
            for (var i = 0, n = defineString.length; i < n; i++) {
                var def = defineString[i];
                defineStr += "#define " + def + "\n";
                defMap[def] = true;
            }
            var vs = this._VS.toscript(defMap, []);
            var vsVersion = '';
            if (vs[0].indexOf('#version') == 0) {
                vsVersion = vs[0] + '\n';
                vs.shift();
            }
            var ps = this._PS.toscript(defMap, []);
            var psVersion = '';
            if (ps[0].indexOf('#version') == 0) {
                psVersion = ps[0] + '\n';
                ps.shift();
            }
            shader = LayaGL.renderOBJCreate.createShaderInstance(vsVersion + vertexHead + defineStr + vs.join('\n'), psVersion + fragmentHead + defineStr + ps.join('\n'), this._owner._attributeMap, this);
            cacheShaders[cacheKey] = shader;
            if (Shader3D.debugMode) {
                var defStr = "";
                var defMask = "";
                for (var i = 0, n = debugMaskLength; i < n; i++) {
                    (i == n - 1) ? defMask += debugDefineMask[i] : defMask += debugDefineMask[i] + ",";
                }
                for (var i = 0, n = debugDefineString.length; i < n; i++)
                    (i == n - 1) ? defStr += debugDefineString[i] : defStr += debugDefineString[i] + ",";
                console.log("%cLayaAir: Shader Compile Information---ShaderName:" + this._owner._owner._name + " SubShaderIndex:" + this._owner._owner._subShaders.indexOf(this._owner) + " PassIndex:" + this._owner._passes.indexOf(this) + " DefineMask:[" + defMask + "]" + " DefineNames:[" + defStr + "]", "color:green");
            }
            return shader;
        }
    }
    ShaderPass._defineStrings = [];
    ShaderPass._debugDefineStrings = [];
    ShaderPass._debugDefineMasks = [];

    class VertexMesh {
        static __init__() {
            VertexMesh.instanceWorldMatrixDeclaration = new VertexDeclaration(64, [new VertexElement(0, VertexElementFormat.Vector4, VertexMesh.MESH_WORLDMATRIX_ROW0),
                new VertexElement(16, VertexElementFormat.Vector4, VertexMesh.MESH_WORLDMATRIX_ROW1),
                new VertexElement(32, VertexElementFormat.Vector4, VertexMesh.MESH_WORLDMATRIX_ROW2),
                new VertexElement(48, VertexElementFormat.Vector4, VertexMesh.MESH_WORLDMATRIX_ROW3)]);
            VertexMesh.instanceSimpleAnimatorDeclaration = new VertexDeclaration(16, [new VertexElement(0, VertexElementFormat.Vector4, VertexMesh.MESH_SIMPLEANIMATOR)]);
        }
        static getVertexDeclaration(vertexFlag, compatible = true) {
            var verDec = VertexMesh._vertexDeclarationMap[vertexFlag + (compatible ? "_0" : "_1")];
            if (!verDec) {
                var subFlags = vertexFlag.split(",");
                var offset = 0;
                var elements = [];
                for (var i = 0, n = subFlags.length; i < n; i++) {
                    var element;
                    switch (subFlags[i]) {
                        case "POSITION":
                            element = new VertexElement(offset, VertexElementFormat.Vector3, VertexMesh.MESH_POSITION0);
                            offset += 12;
                            break;
                        case "NORMAL":
                            element = new VertexElement(offset, VertexElementFormat.Vector3, VertexMesh.MESH_NORMAL0);
                            offset += 12;
                            break;
                        case "COLOR":
                            element = new VertexElement(offset, VertexElementFormat.Vector4, VertexMesh.MESH_COLOR0);
                            offset += 16;
                            break;
                        case "UV":
                            element = new VertexElement(offset, VertexElementFormat.Vector2, VertexMesh.MESH_TEXTURECOORDINATE0);
                            offset += 8;
                            break;
                        case "UV1":
                            element = new VertexElement(offset, VertexElementFormat.Vector2, VertexMesh.MESH_TEXTURECOORDINATE1);
                            offset += 8;
                            break;
                        case "BLENDWEIGHT":
                            element = new VertexElement(offset, VertexElementFormat.Vector4, VertexMesh.MESH_BLENDWEIGHT0);
                            offset += 16;
                            break;
                        case "BLENDINDICES":
                            if (compatible) {
                                element = new VertexElement(offset, VertexElementFormat.Vector4, VertexMesh.MESH_BLENDINDICES0);
                                offset += 16;
                            }
                            else {
                                element = new VertexElement(offset, VertexElementFormat.Byte4, VertexMesh.MESH_BLENDINDICES0);
                                offset += 4;
                            }
                            break;
                        case "TANGENT":
                            element = new VertexElement(offset, VertexElementFormat.Vector4, VertexMesh.MESH_TANGENT0);
                            offset += 16;
                            break;
                        case "NORMAL_BYTE":
                            element = new VertexElement(offset, VertexElementFormat.NorByte4, VertexMesh.MESH_NORMAL0);
                            offset += 4;
                            break;
                        default:
                            throw "VertexMesh: unknown vertex flag.";
                    }
                    elements.push(element);
                }
                verDec = new VertexDeclaration(offset, elements);
                VertexMesh._vertexDeclarationMap[vertexFlag + (compatible ? "_0" : "_1")] = verDec;
            }
            return verDec;
        }
    }
    VertexMesh.MESH_POSITION0 = 0;
    VertexMesh.MESH_COLOR0 = 1;
    VertexMesh.MESH_TEXTURECOORDINATE0 = 2;
    VertexMesh.MESH_NORMAL0 = 3;
    VertexMesh.MESH_TANGENT0 = 4;
    VertexMesh.MESH_BLENDINDICES0 = 5;
    VertexMesh.MESH_BLENDWEIGHT0 = 6;
    VertexMesh.MESH_TEXTURECOORDINATE1 = 7;
    VertexMesh.MESH_WORLDMATRIX_ROW0 = 8;
    VertexMesh.MESH_WORLDMATRIX_ROW1 = 9;
    VertexMesh.MESH_WORLDMATRIX_ROW2 = 10;
    VertexMesh.MESH_WORLDMATRIX_ROW3 = 11;
    VertexMesh.MESH_SIMPLEANIMATOR = 12;
    VertexMesh.MESH_CUSTOME0 = 12;
    VertexMesh.MESH_CUSTOME1 = 13;
    VertexMesh.MESH_CUSTOME2 = 14;
    VertexMesh.MESH_CUSTOME3 = 15;
    VertexMesh._vertexDeclarationMap = {};

    class SubShader {
        constructor(attributeMap = SubShader.DefaultAttributeMap, uniformMap = {}, uniformDefaultValue = null) {
            this._uniformBufferDataMap = new Map();
            this._flags = {};
            this._passes = [];
            this._attributeMap = attributeMap;
            this._uniformMap = uniformMap;
            this._uniformDefaultValue = uniformDefaultValue;
            this._uniformTypeMap = new Map();
            for (const key in uniformMap) {
                if (typeof uniformMap[key] == "object") {
                    let block = (uniformMap[key]);
                    let blockUniformMap = new Map();
                    for (const uniformName in block) {
                        let uniformType = ShaderDataTypeToUniformBufferType(block[uniformName]);
                        blockUniformMap.set(uniformName, uniformType);
                        this._uniformTypeMap.set(uniformName, block[uniformName]);
                    }
                    let blockUniformIndexMap = new Map();
                    blockUniformMap.forEach((value, key) => {
                        blockUniformIndexMap.set(Shader3D.propertyNameToID(key), value);
                    });
                    let blockData = new UnifromBufferData(blockUniformIndexMap);
                    this._uniformBufferDataMap.set(key, blockData);
                }
                else {
                    let unifromType = uniformMap[key];
                    this._uniformTypeMap.set(key, unifromType);
                    if (unifromType == exports.ShaderDataType.Texture2D || unifromType == exports.ShaderDataType.TextureCube) {
                        let textureGammaDefine = Shader3D.getDefineByName(`Gamma_${key}`);
                        let uniformIndex = Shader3D.propertyNameToID(key);
                        ShaderDefine._texGammaDefine[uniformIndex] = textureGammaDefine;
                    }
                }
            }
        }
        static regIncludeBindUnifrom(includeName, uniformMap, defaultValue) {
            let obj = {};
            let data = obj[includeName] = {};
            data["uniformMap"] = uniformMap;
            data["defaultValue"] = defaultValue;
            Object.assign(SubShader.IncludeUniformMap, obj);
        }
        static __init__() {
            let DefaultShaderStateMap = {
                's_Cull': Shader3D.RENDER_STATE_CULL,
                's_Blend': Shader3D.RENDER_STATE_BLEND,
                's_BlendSrc': Shader3D.RENDER_STATE_BLEND_SRC,
                's_BlendDst': Shader3D.RENDER_STATE_BLEND_DST,
                's_BlendSrcRGB': Shader3D.RENDER_STATE_BLEND_SRC_RGB,
                's_BlendDstRGB': Shader3D.RENDER_STATE_BLEND_DST_RGB,
                's_BlendSrcAlpha': Shader3D.RENDER_STATE_BLEND_SRC_ALPHA,
                's_BlendDstAlpha': Shader3D.RENDER_STATE_BLEND_DST_ALPHA,
                's_BlendEquation': Shader3D.RENDER_STATE_BLEND_EQUATION,
                's_BlendEquationRGB': Shader3D.RENDER_STATE_BLEND_EQUATION_RGB,
                's_BlendEquationAlpha': Shader3D.RENDER_STATE_BLEND_EQUATION_ALPHA,
                's_DepthTest': Shader3D.RENDER_STATE_DEPTH_TEST,
                's_DepthWrite': Shader3D.RENDER_STATE_DEPTH_WRITE,
                's_StencilRef': Shader3D.RENDER_STATE_STENCIL_REF,
                's_StencilTest': Shader3D.RENDER_STATE_STENCIL_TEST,
                's_StencilWrite': Shader3D.RENDER_STATE_STENCIL_WRITE,
                's_StencilOp': Shader3D.RENDER_STATE_STENCIL_OP
            };
            this.StateParamsMap = {};
            for (let s in DefaultShaderStateMap) {
                this.StateParamsMap[DefaultShaderStateMap[s]] = Shader3D.propertyNameToID(s);
            }
            SubShader.IncludeUniformMap = {};
        }
        setFlag(key, value) {
            if (value)
                this._flags[key] = value;
            else
                delete this._flags[key];
        }
        getFlag(key) {
            return this._flags[key];
        }
        addShaderPass(vs, ps, pipelineMode = "Forward") {
            return this._addShaderPass(ShaderCompile.compile(vs, ps), pipelineMode);
        }
        _addShaderPass(compiledObj, pipelineMode = "Forward") {
            var shaderPass = new ShaderPass(this, compiledObj);
            shaderPass._pipelineMode = pipelineMode;
            this._passes.push(shaderPass);
            this._addIncludeUniform(compiledObj.includeNames);
            return shaderPass;
        }
        _addIncludeUniform(includemap) {
            for (let ele of includemap) {
                if (SubShader.IncludeUniformMap[ele]) {
                    let includeBindInfo = SubShader.IncludeUniformMap[ele];
                    let bindtypeMap = includeBindInfo["uniformMap"];
                    let bindDefaultValue = includeBindInfo["defaultValue"];
                    for (var i in bindtypeMap) {
                        if (!this._uniformTypeMap.has(i)) {
                            this._uniformTypeMap.set(i, bindtypeMap[i]);
                            this._uniformMap[i] = bindtypeMap[i];
                        }
                    }
                    for (var i in bindDefaultValue) {
                        if (!this._uniformDefaultValue[i]) {
                            this._uniformDefaultValue[i] = bindDefaultValue[i];
                        }
                    }
                }
            }
        }
    }
    SubShader.DefaultAttributeMap = {
        'a_Position': [VertexMesh.MESH_POSITION0, exports.ShaderDataType.Vector4],
        'a_Normal': [VertexMesh.MESH_NORMAL0, exports.ShaderDataType.Vector3],
        'a_Tangent0': [VertexMesh.MESH_TANGENT0, exports.ShaderDataType.Vector4],
        'a_Texcoord0': [VertexMesh.MESH_TEXTURECOORDINATE0, exports.ShaderDataType.Vector2],
        'a_Texcoord1': [VertexMesh.MESH_TEXTURECOORDINATE1, exports.ShaderDataType.Vector2],
        'a_Color': [VertexMesh.MESH_COLOR0, exports.ShaderDataType.Vector4],
        'a_BoneWeights': [VertexMesh.MESH_BLENDWEIGHT0, exports.ShaderDataType.Vector4],
        'a_BoneIndices': [VertexMesh.MESH_BLENDINDICES0, exports.ShaderDataType.Vector4],
        'a_WorldMat': [VertexMesh.MESH_WORLDMATRIX_ROW0, exports.ShaderDataType.Matrix4x4],
        'a_SimpleTextureParams': [VertexMesh.MESH_SIMPLEANIMATOR, exports.ShaderDataType.Vector2]
    };
    function ShaderDataTypeToUniformBufferType(shaderDataType) {
        switch (shaderDataType) {
            case exports.ShaderDataType.Float:
                return exports.UniformBufferParamsType.Number;
            case exports.ShaderDataType.Vector2:
                return exports.UniformBufferParamsType.Vector2;
            case exports.ShaderDataType.Vector3:
                return exports.UniformBufferParamsType.Vector3;
            case exports.ShaderDataType.Vector4:
            case exports.ShaderDataType.Color:
                return exports.UniformBufferParamsType.Vector4;
            case exports.ShaderDataType.Matrix4x4:
                return exports.UniformBufferParamsType.Matrix4x4;
            default:
                throw "ShaderDataType can not be in UniformBuffer.";
        }
    }

    class Shader3D {
        constructor(name, enableInstancing, supportReflectionProbe) {
            this._enableInstancing = false;
            this._supportReflectionProbe = false;
            this._subShaders = [];
            this._name = name;
            this._enableInstancing = enableInstancing;
            this._supportReflectionProbe = supportReflectionProbe;
        }
        static init() {
            Shader3D.debugShaderVariantCollection = new ShaderVariantCollection();
        }
        static _getNamesByDefineData(defineData, out) {
            var maskMap = Shader3D._maskMap;
            var mask = defineData._mask;
            out.length = 0;
            for (var i = 0, n = defineData._length; i < n; i++) {
                var subMaskMap = maskMap[i];
                var subMask = mask[i];
                for (var j = 0; j < 32; j++) {
                    var d = 1 << j;
                    if (subMask > 0 && d > subMask)
                        break;
                    if (subMask & d)
                        out.push(subMaskMap[d]);
                }
            }
        }
        static getDefineByName(name) {
            var define = Shader3D._defineMap[name];
            if (!define) {
                var maskMap = Shader3D._maskMap;
                var counter = Shader3D._defineCounter;
                var index = Math.floor(counter / 32);
                var value = 1 << counter % 32;
                define = new ShaderDefine(index, value);
                Shader3D._defineMap[name] = define;
                if (index == maskMap.length) {
                    maskMap.length++;
                    maskMap[index] = {};
                }
                maskMap[index][value] = name;
                Shader3D._defineCounter++;
            }
            return define;
        }
        static propertyNameToID(name) {
            return LayaGL.renderEngine.propertyNameToID(name);
        }
        static propertyIDToName(id) {
            return LayaGL.renderEngine.propertyIDToName(id);
        }
        static addInclude(fileName, txt) {
            ShaderCompile.addInclude(fileName, txt);
        }
        static compileShaderByDefineNames(shaderName, subShaderIndex, passIndex, defineNames) {
            var shader = Shader3D.find(shaderName);
            if (shader) {
                var subShader = shader.getSubShaderAt(subShaderIndex);
                if (subShader) {
                    var pass = subShader._passes[passIndex];
                    if (pass) {
                        var compileDefineDatas = Shader3D._compileDefineDatas;
                        compileDefineDatas.clear();
                        for (var i = 0, n = defineNames.length; i < n; i++)
                            compileDefineDatas.add(Shader3D.getDefineByName(defineNames[i]));
                        compileDefineDatas.addDefineDatas(Shader3D._configDefineValues);
                        pass.withCompile(compileDefineDatas);
                    }
                    else {
                        console.warn("Shader3D: unknown passIndex.");
                    }
                }
                else {
                    console.warn("Shader3D: unknown subShaderIndex.");
                }
            }
            else {
                console.warn("Shader3D: unknown shader name.");
            }
        }
        static add(name, enableInstancing = false, supportReflectionProbe = false) {
            return Shader3D._preCompileShader[name] = new Shader3D(name, enableInstancing, supportReflectionProbe);
        }
        static find(name) {
            return Shader3D._preCompileShader[name];
        }
        static parse(data, basePath) {
            if (!data.name || !data.uniformMap)
                console.error("TODO");
            let shader = Shader3D.add(data.name, data.enableInstancing, data.supportReflectionProbe);
            let subshader = new SubShader(data.attributeMap ? data.attributeMap : SubShader.DefaultAttributeMap, data.uniformMap, data.defaultValue);
            shader.addSubShader(subshader);
            let passArray = data.shaderPass;
            for (var i in passArray) {
                let pass = passArray[i];
                subshader._addShaderPass(ShaderCompile.compile(pass.VS, pass.FS, basePath), pass.pipeline);
            }
            return shader;
        }
        get name() {
            return this._name;
        }
        addSubShader(subShader) {
            this._subShaders.push(subShader);
            subShader._owner = this;
        }
        getSubShaderAt(index) {
            return this._subShaders[index];
        }
        static compileShader(shaderName, subShaderIndex, passIndex, ...defineMask) {
            var shader = Shader3D.find(shaderName);
            if (shader) {
                var subShader = shader.getSubShaderAt(subShaderIndex);
                if (subShader) {
                    var pass = subShader._passes[passIndex];
                    if (pass) {
                        var compileDefineDatas = Shader3D._compileDefineDatas;
                        var mask = compileDefineDatas._mask;
                        mask.length = 0;
                        for (var i = 0, n = defineMask.length; i < n; i++)
                            mask.push(defineMask[i]);
                        compileDefineDatas._length = defineMask.length;
                        pass.withCompile(compileDefineDatas);
                    }
                    else {
                        console.warn("Shader3D: unknown passIndex.");
                    }
                }
                else {
                    console.warn("Shader3D: unknown subShaderIndex.");
                }
            }
            else {
                console.warn("Shader3D: unknown shader name.");
            }
        }
    }
    Shader3D._configDefineValues = new DefineDatas();
    Shader3D._compileDefineDatas = new DefineDatas();
    Shader3D.RENDER_STATE_CULL = 0;
    Shader3D.RENDER_STATE_BLEND = 1;
    Shader3D.RENDER_STATE_BLEND_SRC = 2;
    Shader3D.RENDER_STATE_BLEND_DST = 3;
    Shader3D.RENDER_STATE_BLEND_SRC_RGB = 4;
    Shader3D.RENDER_STATE_BLEND_DST_RGB = 5;
    Shader3D.RENDER_STATE_BLEND_SRC_ALPHA = 6;
    Shader3D.RENDER_STATE_BLEND_DST_ALPHA = 7;
    Shader3D.RENDER_STATE_BLEND_CONST_COLOR = 8;
    Shader3D.RENDER_STATE_BLEND_EQUATION = 9;
    Shader3D.RENDER_STATE_BLEND_EQUATION_RGB = 10;
    Shader3D.RENDER_STATE_BLEND_EQUATION_ALPHA = 11;
    Shader3D.RENDER_STATE_DEPTH_TEST = 12;
    Shader3D.RENDER_STATE_DEPTH_WRITE = 13;
    Shader3D.RENDER_STATE_STENCIL_TEST = 14;
    Shader3D.RENDER_STATE_STENCIL_WRITE = 15;
    Shader3D.RENDER_STATE_STENCIL_REF = 16;
    Shader3D.RENDER_STATE_STENCIL_OP = 17;
    Shader3D.PERIOD_CUSTOM = 0;
    Shader3D.PERIOD_MATERIAL = 1;
    Shader3D.PERIOD_SPRITE = 2;
    Shader3D.PERIOD_CAMERA = 3;
    Shader3D.PERIOD_SCENE = 4;
    Shader3D._propertyNameMap = {};
    Shader3D._propertyNameCounter = 0;
    Shader3D._defineCounter = 0;
    Shader3D._defineMap = {};
    Shader3D._preCompileShader = {};
    Shader3D._maskMap = [];
    Shader3D.debugMode = false;

    var _isinit = false;
    class Laya {
        static init(...args) {
            if (_isinit)
                return Promise.resolve();
            _isinit = true;
            let stageConfig;
            if (typeof (args[0]) === "number") {
                stageConfig = {
                    designWidth: args[0],
                    designHeight: args[1]
                };
            }
            else
                stageConfig = args[0];
            ArrayBuffer.prototype.slice || (ArrayBuffer.prototype.slice = arrayBufferSlice);
            Float32Array.prototype.slice || (Float32Array.prototype.slice = float32ArraySlice);
            Uint16Array.prototype.slice || (Uint16Array.prototype.slice = uint16ArraySlice);
            Uint8Array.prototype.slice || (Uint8Array.prototype.slice = uint8ArraySlice);
            Browser.__init__();
            URL.__init__();
            let laya3D = window["Laya3D"];
            if (laya3D) {
                if (!WebGL.enable())
                    return Promise.reject("Must support webGL!");
                RunDriver.changeWebGLSize = laya3D._changeWebGLSize;
                Render.is3DMode = true;
            }
            var mainCanv = Browser.mainCanvas = new HTMLCanvas(true);
            var style = mainCanv.source.style;
            style.position = 'absolute';
            style.top = style.left = "0px";
            style.background = "#000000";
            if (!Browser.onKGMiniGame && !Browser.onAlipayMiniGame) {
                Browser.container.appendChild(mainCanv.source);
            }
            Browser.canvas = new HTMLCanvas(true);
            Browser.context = Browser.canvas.getContext('2d');
            Browser.supportWebAudio = SoundManager.__init__();
            Browser.supportLocalStorage = LocalStorage.__init__();
            Laya.systemTimer = new Timer(false);
            exports.systemTimer = Timer.gSysTimer = Laya.systemTimer;
            Laya.physicsTimer = new Timer(false);
            Laya.timer = new Timer(false);
            ILaya.systemTimer = Laya.systemTimer;
            exports.timer = ILaya.timer = Laya.timer;
            exports.physicsTimer = ILaya.physicsTimer = Laya.physicsTimer;
            Laya.loader = new Loader();
            ILaya.Laya = Laya;
            exports.loader = ILaya.loader = Laya.loader;
            WeakObject.__init__();
            Mouse.__init__();
            if (LayaEnv.beforeInit) {
                if (LayaEnv.isPlaying)
                    LayaEnv.beforeInit(stageConfig);
                else
                    LayaEnv.beforeInit = null;
            }
            if (LayaEnv.isConch) {
                Laya.enableNative();
            }
            CacheManger.beginCheck();
            exports.stage = Laya.stage = new Stage();
            ILaya.stage = Laya.stage;
            if (LayaEnv.isConch && window.conch.setGlobalRepaint) {
                window.conch.setGlobalRepaint(exports.stage.setGlobalRepaint.bind(exports.stage));
            }
            Shader3D.init();
            MeshQuadTexture.__int__();
            MeshVG.__init__();
            MeshTexture.__init__();
            Laya.render = new Render(0, 0, Browser.mainCanvas);
            exports.render = Laya.render;
            exports.stage.size(stageConfig.designWidth, stageConfig.designHeight);
            if (stageConfig.scaleMode)
                exports.stage.scaleMode = stageConfig.scaleMode;
            if (stageConfig.screenMode)
                exports.stage.screenMode = stageConfig.screenMode;
            if (stageConfig.alignV)
                exports.stage.alignV = stageConfig.alignV;
            if (stageConfig.alignH)
                exports.stage.alignH = stageConfig.alignH;
            if (Config.isAlpha)
                exports.stage.bgColor = null;
            else if (stageConfig.backgroundColor)
                exports.stage.bgColor = stageConfig.backgroundColor;
            window.stage = exports.stage;
            RenderStateContext.__init__();
            MeshParticle2D.__init__();
            RenderSprite.__init__();
            InputManager.__init__(exports.stage, Render.canvas);
            if (!!window.conch && "conchUseWXAdapter" in Browser.window) {
                Input.isAppUseNewInput = true;
            }
            Input.__init__();
            SoundManager.autoStopMusic = true;
            Stat._StatRender = new StatUI();
            Value2D._initone(ShaderDefines2D.TEXTURE2D, TextureSV);
            Value2D._initone(ShaderDefines2D.TEXTURE2D | ShaderDefines2D.FILTERGLOW, TextureSV);
            Value2D._initone(ShaderDefines2D.PRIMITIVE, PrimitiveSV);
            Value2D._initone(ShaderDefines2D.SKINMESH, SkinSV);
            if (laya3D) {
                return laya3D.__init__().then(() => {
                    if (LayaEnv.afterInit) {
                        if (LayaEnv.isPlaying)
                            LayaEnv.afterInit();
                        else
                            LayaEnv.afterInit = null;
                    }
                });
            }
            else {
                if (LayaEnv.afterInit) {
                    if (LayaEnv.isPlaying)
                        LayaEnv.afterInit();
                    else
                        LayaEnv.afterInit = null;
                }
                return Promise.resolve();
            }
        }
        static addWasmModule(id, exports, memory) {
            Laya.WasmModules[id] = { exports, memory };
        }
        static alertGlobalError(value) {
            var erralert = 0;
            if (value) {
                Browser.window.onerror = function (msg, url, line, column, detail) {
                    if (erralert++ < 5 && detail)
                        this.alert("出错啦，请把此信息截图给研发商\n" + msg + "\n" + detail.stack);
                };
            }
            else {
                Browser.window.onerror = null;
            }
        }
        static _runScript(script) {
            return Browser.window[Laya._evcode](script);
        }
        static enableDebugPanel(debugJsPath = "libs/laya.debugtool.js") {
            if (!window['Laya']["DebugPanel"]) {
                var script = Browser.createElement("script");
                script.onload = function () {
                    window['Laya']["DebugPanel"].enable();
                };
                script.src = debugJsPath;
                Browser.document.body.appendChild(script);
            }
            else {
                window['Laya']["DebugPanel"].enable();
            }
        }
        static enableNative() {
            if (Laya.isNativeRender_enable)
                return;
            Laya.isNativeRender_enable = true;
            RenderState2D.width = Browser.window.innerWidth;
            RenderState2D.height = Browser.window.innerHeight;
            Browser.measureText = function (txt, font) {
                window["conchTextCanvas"].font = font;
                return window["conchTextCanvas"].measureText(txt);
            };
            Stage.clear = function (color) {
                Context.set2DRenderConfig();
                var c = ColorUtils.create(color).arrColor;
                LayaGL.renderEngine.clearRenderTexture(exports.RenderClearFlag.Color | exports.RenderClearFlag.Depth, new Color(c[0], c[1], c[2], c[3]), 1);
                RenderState2D.clear();
            };
            Sprite.drawToCanvas = function (sprite, _renderType, canvasWidth, canvasHeight, offsetX, offsetY) {
                offsetX -= sprite.x;
                offsetY -= sprite.y;
                offsetX |= 0;
                offsetY |= 0;
                canvasWidth |= 0;
                canvasHeight |= 0;
                var canv = new HTMLCanvas(false);
                var ctx = canv.getContext('2d');
                canv.size(canvasWidth, canvasHeight);
                ctx.asBitmap = true;
                ctx._targets.start();
                RenderSprite.renders[_renderType]._fun(sprite, ctx, offsetX, offsetY);
                ctx.flush();
                ctx._targets.end();
                ctx._targets.restore();
                return canv;
            };
            Object["defineProperty"](RenderTexture2D.prototype, "uv", {
                "get": function () {
                    return this._uv;
                },
                "set": function (v) {
                    this._uv = v;
                }
            });
            HTMLCanvas.prototype.getTexture = function () {
                if (!this._texture) {
                    this._texture = this.context._targets;
                    this._texture.uv = RenderTexture2D.flipyuv;
                    this._texture.bitmap = this._texture;
                }
                return this._texture;
            };
        }
    }
    Laya.stage = null;
    Laya.systemTimer = null;
    Laya.physicsTimer = null;
    Laya.timer = null;
    Laya.loader = null;
    Laya.isWXOpenDataContext = false;
    Laya.isWXPosMsg = false;
    Laya.WasmModules = {};
    Laya._evcode = "eva" + "l";
    Laya.isNativeRender_enable = false;
    function arrayBufferSlice(start, end) {
        var arrU8List = new Uint8Array(this, start, end - start);
        var newU8List = new Uint8Array(arrU8List.length);
        newU8List.set(arrU8List);
        return newU8List.buffer;
    }
    function uint8ArraySlice() {
        var sz = this.length;
        var dec = new Uint8Array(this.length);
        for (var i = 0; i < sz; i++)
            dec[i] = this[i];
        return dec;
    }
    function float32ArraySlice() {
        var sz = this.length;
        var dec = new Float32Array(this.length);
        for (var i = 0; i < sz; i++)
            dec[i] = this[i];
        return dec;
    }
    function uint16ArraySlice(...arg) {
        var sz;
        var dec;
        var i;
        if (arg.length === 0) {
            sz = this.length;
            dec = new Uint16Array(sz);
            for (i = 0; i < sz; i++)
                dec[i] = this[i];
        }
        else if (arg.length === 2) {
            var start = arg[0];
            var end = arg[1];
            if (end > start) {
                sz = end - start;
                dec = new Uint16Array(sz);
                for (i = start; i < end; i++)
                    dec[i - start] = this[i];
            }
            else {
                dec = new Uint16Array(0);
            }
        }
        return dec;
    }
    ILaya.Loader = Loader;
    ILaya.Context = Context;
    ILaya.Browser = Browser;
    var init = Laya.init;
    exports.stage = void 0;
    exports.systemTimer = void 0;
    var startTimer;
    exports.physicsTimer = void 0;
    var updateTimer;
    var lateTimer;
    exports.timer = void 0;
    exports.loader = void 0;
    exports.render = void 0;
    var isWXOpenDataContext;
    var isWXPosMsg;
    var alertGlobalError = Laya.alertGlobalError;
    var enableDebugPanel = Laya.enableDebugPanel;

    class Component {
        constructor() {
            this._hideFlags = 0;
            this._status = 0;
            this._enabled = true;
            this._singleton = true;
            this._id = Utils.getGID();
            this._initialize();
        }
        get hideFlags() {
            return this._hideFlags;
        }
        set hideFlags(value) {
            this._hideFlags = value;
        }
        _initialize() {
            this._extra = {};
        }
        hasHideFlag(flag) {
            return (this._hideFlags & flag) != 0;
        }
        get id() {
            return this._id;
        }
        get enabled() {
            return this._enabled;
        }
        set enabled(value) {
            if (this._enabled != value) {
                this._enabled = value;
                if (this.owner)
                    this._setActive(value && this.owner.activeInHierarchy);
            }
        }
        get awaked() {
            return this._status > 0;
        }
        get destroyed() {
            return this._status == 4;
        }
        _isScript() {
            return false;
        }
        _resetComp() {
            this._enabled = true;
            this._status = 0;
            this._enableState = false;
            this.owner = null;
        }
        _setOwner(node) {
            if (this._status != 0) {
                throw 'reuse a destroyed component';
            }
            this.owner = node;
            if (this._isScript())
                node._setBit(NodeFlags.HAS_SCRIPT, true);
            this._onAdded();
            this.onAdded();
        }
        _onAdded() {
        }
        _onAwake() {
        }
        _onEnable() {
            this.onEnable();
        }
        _onDisable() {
            this.onDisable();
        }
        _onDestroy() {
        }
        _parse(data, interactMap = null) {
        }
        _parseInteractive(data = null, spriteMap = null) {
        }
        _cloneTo(dest) {
        }
        _setActive(value) {
            var _a, _b;
            if (value) {
                if (this._status == 0) {
                    this._status = 1;
                    if (LayaEnv.isPlaying || this.runInEditor) {
                        this._onAwake();
                        this.onAwake();
                    }
                }
                if (this._enabled && !this._enableState) {
                    this._enableState = true;
                    if (LayaEnv.isPlaying || this.runInEditor) {
                        let driver = ((_a = (this.owner._is3D && this.owner._scene)) === null || _a === void 0 ? void 0 : _a._componentDriver) || ILaya.stage._componentDriver;
                        driver.add(this);
                        if (LayaEnv.isPlaying && this._isScript())
                            this.setupScript();
                        this._onEnable();
                    }
                }
            }
            else if (this._enableState) {
                this._enableState = false;
                if (LayaEnv.isPlaying || this.runInEditor) {
                    let driver = ((_b = (this.owner._is3D && this.owner._scene)) === null || _b === void 0 ? void 0 : _b._componentDriver) || ILaya.stage._componentDriver;
                    driver.remove(this);
                    this.owner.offAllCaller(this);
                    this._onDisable();
                }
            }
        }
        setupScript() {
        }
        destroy() {
            if (this._status == 4)
                return;
            if (this.owner)
                this.owner._destroyComponent(this);
        }
        _destroy(second) {
            var _a;
            if (second) {
                this._onDestroy();
                this.onDestroy();
                if (this.onReset) {
                    this.onReset();
                    this._resetComp();
                    Pool.recoverByClass(this);
                }
                return;
            }
            this._setActive(false);
            this._status = 4;
            let driver = ((_a = (this.owner._is3D && this.owner._scene)) === null || _a === void 0 ? void 0 : _a._componentDriver) || ILaya.stage._componentDriver;
            driver._toDestroys.add(this);
        }
        onAdded() {
        }
        onAwake() {
        }
        onEnable() {
        }
        onDisable() {
        }
        onDestroy() {
        }
    }

    class AnimationBase extends Sprite {
        constructor() {
            super();
            this.wrapMode = 0;
            this._interval = Config.animationInterval;
            this._isReverse = false;
            this._frameRateChanged = false;
            this._setBitUp(NodeFlags.DISPLAY);
        }
        play(start = 0, loop = true, name = "") {
            this._isPlaying = true;
            this._actionName = name;
            this.index = (typeof (start) == 'string') ? this._getFrameByLabel(start) : start;
            this.loop = loop;
            this._isReverse = this.wrapMode === AnimationBase.WRAP_REVERSE;
            if (this.index == 0 && this._isReverse) {
                this.index = this.count - 1;
            }
            if (this.interval > 0)
                this.timerLoop(this.interval, this, this._frameLoop, null, true, true);
        }
        get interval() {
            return this._interval;
        }
        set interval(value) {
            if (this._interval != value) {
                this._frameRateChanged = true;
                this._interval = value;
                if (this._isPlaying && value > 0) {
                    this.timerLoop(value, this, this._frameLoop, null, true, true);
                }
            }
        }
        _getFrameByLabel(label) {
            for (var i = 0; i < this._count; i++) {
                var item = this._labels[i];
                if (item && item.indexOf(label) > -1)
                    return i;
            }
            return 0;
        }
        _frameLoop() {
            if (!this._controlNode || this._controlNode._destroyed) {
                this.clearTimer(this, this._frameLoop);
                return;
            }
            if (this._isReverse) {
                this._index--;
                if (this._index < 0) {
                    if (this.loop) {
                        if (this.wrapMode == AnimationBase.WRAP_PINGPONG) {
                            this._index = this._count > 0 ? 1 : 0;
                            this._isReverse = false;
                        }
                        else {
                            this._index = this._count - 1;
                        }
                        this.event(Event.COMPLETE);
                    }
                    else {
                        this._index = 0;
                        this.stop();
                        this.event(Event.COMPLETE);
                        return;
                    }
                }
            }
            else {
                this._index++;
                if (this._index >= this._count) {
                    if (this.loop) {
                        if (this.wrapMode == AnimationBase.WRAP_PINGPONG) {
                            this._index = this._count - 2 >= 0 ? this._count - 2 : 0;
                            this._isReverse = true;
                        }
                        else {
                            this._index = 0;
                        }
                        this.event(Event.COMPLETE);
                    }
                    else {
                        this._index--;
                        this.stop();
                        this.event(Event.COMPLETE);
                        return;
                    }
                }
            }
            this.index = this._index;
        }
        _setControlNode(node) {
            if (this._controlNode) {
                this._controlNode.off(Event.DISPLAY, this, this._resumePlay);
                this._controlNode.off(Event.UNDISPLAY, this, this._resumePlay);
            }
            this._controlNode = node;
            if (node && node != this) {
                node.on(Event.DISPLAY, this, this._resumePlay);
                node.on(Event.UNDISPLAY, this, this._resumePlay);
            }
        }
        _setDisplay(value) {
            super._setDisplay(value);
            this._resumePlay();
        }
        _resumePlay() {
            if (this._isPlaying) {
                if (this._controlNode.displayedInStage)
                    this.play(this._index, this.loop, this._actionName);
                else
                    this.clearTimer(this, this._frameLoop);
            }
        }
        stop() {
            this._isPlaying = false;
            this.clearTimer(this, this._frameLoop);
        }
        get isPlaying() {
            return this._isPlaying;
        }
        addLabel(label, index) {
            if (!this._labels)
                this._labels = {};
            if (!this._labels[index])
                this._labels[index] = [];
            this._labels[index].push(label);
        }
        removeLabel(label) {
            if (!label)
                this._labels = null;
            else if (this._labels) {
                for (var name in this._labels) {
                    this._removeLabelFromList(this._labels[name], label);
                }
            }
        }
        _removeLabelFromList(list, label) {
            if (!list)
                return;
            for (var i = list.length - 1; i >= 0; i--) {
                if (list[i] == label) {
                    list.splice(i, 1);
                }
            }
        }
        gotoAndStop(position) {
            this.index = (typeof (position) == 'string') ? this._getFrameByLabel(position) : position;
            this.stop();
        }
        get index() {
            return this._index;
        }
        set index(value) {
            this._index = value;
            this._displayToIndex(value);
            if (this._labels && this._labels[value]) {
                var tArr = this._labels[value];
                for (var i = 0, len = tArr.length; i < len; i++) {
                    this.event(Event.LABEL, tArr[i]);
                }
            }
        }
        _displayToIndex(value) {
        }
        get count() {
            return this._count;
        }
        clear() {
            this.stop();
            this._labels = null;
            return this;
        }
    }
    AnimationBase.WRAP_POSITIVE = 0;
    AnimationBase.WRAP_REVERSE = 1;
    AnimationBase.WRAP_PINGPONG = 2;

    class MathUtil {
        static subtractVector3(l, r, o) {
            o[0] = l[0] - r[0];
            o[1] = l[1] - r[1];
            o[2] = l[2] - r[2];
        }
        static lerp(left, right, amount) {
            return left * (1 - amount) + right * amount;
        }
        static scaleVector3(f, b, e) {
            e[0] = f[0] * b;
            e[1] = f[1] * b;
            e[2] = f[2] * b;
        }
        static lerpVector3(l, r, t, o) {
            var ax = l[0], ay = l[1], az = l[2];
            o[0] = ax + t * (r[0] - ax);
            o[1] = ay + t * (r[1] - ay);
            o[2] = az + t * (r[2] - az);
        }
        static lerpVector4(l, r, t, o) {
            var ax = l[0], ay = l[1], az = l[2], aw = l[3];
            o[0] = ax + t * (r[0] - ax);
            o[1] = ay + t * (r[1] - ay);
            o[2] = az + t * (r[2] - az);
            o[3] = aw + t * (r[3] - aw);
        }
        static slerpQuaternionArray(a, Offset1, b, Offset2, t, out, Offset3) {
            var ax = a[Offset1 + 0], ay = a[Offset1 + 1], az = a[Offset1 + 2], aw = a[Offset1 + 3], bx = b[Offset2 + 0], by = b[Offset2 + 1], bz = b[Offset2 + 2], bw = b[Offset2 + 3];
            var omega, cosom, sinom, scale0, scale1;
            cosom = ax * bx + ay * by + az * bz + aw * bw;
            if (cosom < 0.0) {
                cosom = -cosom;
                bx = -bx;
                by = -by;
                bz = -bz;
                bw = -bw;
            }
            if ((1.0 - cosom) > 0.000001) {
                omega = Math.acos(cosom);
                sinom = Math.sin(omega);
                scale0 = Math.sin((1.0 - t) * omega) / sinom;
                scale1 = Math.sin(t * omega) / sinom;
            }
            else {
                scale0 = 1.0 - t;
                scale1 = t;
            }
            out[Offset3 + 0] = scale0 * ax + scale1 * bx;
            out[Offset3 + 1] = scale0 * ay + scale1 * by;
            out[Offset3 + 2] = scale0 * az + scale1 * bz;
            out[Offset3 + 3] = scale0 * aw + scale1 * bw;
            return out;
        }
        static getRotation(x0, y0, x1, y1) {
            return Math.atan2(y1 - y0, x1 - x0) / Math.PI * 180;
        }
        static sortBigFirst(a, b) {
            if (a == b)
                return 0;
            return b > a ? 1 : -1;
        }
        static sortSmallFirst(a, b) {
            if (a == b)
                return 0;
            return b > a ? -1 : 1;
        }
        static sortNumBigFirst(a, b) {
            return parseFloat(b) - parseFloat(a);
        }
        static sortNumSmallFirst(a, b) {
            return parseFloat(a) - parseFloat(b);
        }
        static sortByKey(key, bigFirst = false, forceNum = true) {
            var _sortFun;
            if (bigFirst) {
                _sortFun = forceNum ? MathUtil.sortNumBigFirst : MathUtil.sortBigFirst;
            }
            else {
                _sortFun = forceNum ? MathUtil.sortNumSmallFirst : MathUtil.sortSmallFirst;
            }
            return function (a, b) {
                return _sortFun(a[key], b[key]);
            };
        }
    }

    class FrameAnimation extends AnimationBase {
        constructor() {
            super();
            if (FrameAnimation._sortIndexFun === undefined) {
                FrameAnimation._sortIndexFun = MathUtil.sortByKey("index", false, true);
            }
        }
        static _sortIndexFun(objpre, objnext) {
            return objpre.index - objnext.index;
        }
        _setUp(targetDic, animationData) {
            this._targetDic = targetDic;
            this._animationData = animationData;
            this.interval = 1000 / animationData.frameRate;
            if (animationData.parsed) {
                this._count = animationData.count;
                this._labels = animationData.labels;
                this._usedFrames = animationData.animationNewFrames;
            }
            else {
                this._usedFrames = [];
                this._calculateDatas();
                animationData.parsed = true;
                animationData.labels = this._labels;
                animationData.count = this._count;
                animationData.animationNewFrames = this._usedFrames;
            }
        }
        clear() {
            super.clear();
            this._targetDic = null;
            this._animationData = null;
            return this;
        }
        _displayToIndex(value) {
            if (!this._animationData)
                return;
            if (value < 0)
                value = 0;
            if (value > this._count)
                value = this._count;
            var nodes = this._animationData.nodes, i, len = nodes.length;
            for (i = 0; i < len; i++) {
                this._displayNodeToFrame(nodes[i], value);
            }
        }
        _displayNodeToFrame(node, frame, targetDic = null) {
            if (!targetDic)
                targetDic = this._targetDic;
            var target = targetDic[node.target];
            if (!target) {
                return;
            }
            var frames = node.frames, key, propFrames, value;
            var keys = node.keys, i, len = keys.length;
            for (i = 0; i < len; i++) {
                key = keys[i];
                propFrames = frames[key];
                if (propFrames.length > frame) {
                    value = propFrames[frame];
                }
                else {
                    value = propFrames[propFrames.length - 1];
                }
                target[key] = value;
            }
            var funkeys = node.funkeys;
            len = funkeys.length;
            var funFrames;
            if (len == 0)
                return;
            for (i = 0; i < len; i++) {
                key = funkeys[i];
                funFrames = frames[key];
                if (funFrames[frame] !== undefined) {
                    target[key] && target[key].apply(target, funFrames[frame]);
                }
            }
        }
        _calculateDatas() {
            if (!this._animationData)
                return;
            var nodes = this._animationData.nodes, i, len = nodes.length, tNode;
            this._count = 0;
            for (i = 0; i < len; i++) {
                tNode = nodes[i];
                this._calculateKeyFrames(tNode);
            }
            this._count += 1;
        }
        _calculateKeyFrames(node) {
            var keyFrames = node.keyframes, key, tKeyFrames, target = node.target;
            if (!node.frames)
                node.frames = {};
            if (!node.keys)
                node.keys = [];
            else
                node.keys.length = 0;
            if (!node.funkeys)
                node.funkeys = [];
            else
                node.funkeys.length = 0;
            if (!node.initValues)
                node.initValues = {};
            for (key in keyFrames) {
                var isFun = key.indexOf("()") != -1;
                tKeyFrames = keyFrames[key];
                if (isFun)
                    key = key.substr(0, key.length - 2);
                if (!node.frames[key]) {
                    node.frames[key] = [];
                }
                if (!isFun) {
                    if (this._targetDic && this._targetDic[target]) {
                        node.initValues[key] = this._targetDic[target][key];
                    }
                    tKeyFrames.sort(FrameAnimation._sortIndexFun);
                    node.keys.push(key);
                    this._calculateNodePropFrames(tKeyFrames, node.frames[key], key, target);
                }
                else {
                    node.funkeys.push(key);
                    var map = node.frames[key];
                    for (var i = 0; i < tKeyFrames.length; i++) {
                        var temp = tKeyFrames[i];
                        map[temp.index] = temp.value;
                        if (temp.index > this._count)
                            this._count = temp.index;
                    }
                }
            }
        }
        resetNodes() {
            if (!this._targetDic)
                return;
            if (!this._animationData)
                return;
            var nodes = this._animationData.nodes, i, len = nodes.length;
            var tNode;
            var initValues;
            for (i = 0; i < len; i++) {
                tNode = nodes[i];
                initValues = tNode.initValues;
                if (!initValues)
                    continue;
                var target = this._targetDic[tNode.target];
                if (!target)
                    continue;
                var key;
                for (key in initValues) {
                    target[key] = initValues[key];
                }
            }
        }
        _calculateNodePropFrames(keyframes, frames, key, target) {
            var i, len = keyframes.length - 1;
            frames.length = keyframes[len].index + 1;
            for (i = 0; i < len; i++) {
                this._dealKeyFrame(keyframes[i]);
                this._calculateFrameValues(keyframes[i], keyframes[i + 1], frames);
            }
            if (len == 0) {
                frames[0] = keyframes[0].value;
                if (this._usedFrames)
                    this._usedFrames[keyframes[0].index] = true;
            }
            this._dealKeyFrame(keyframes[i]);
        }
        _dealKeyFrame(keyFrame) {
            if (keyFrame.label && keyFrame.label != "")
                this.addLabel(keyFrame.label, keyFrame.index);
        }
        _calculateFrameValues(startFrame, endFrame, result) {
            var i, easeFun;
            var start = startFrame.index, end = endFrame.index;
            var startValue = startFrame.value;
            var dValue = endFrame.value - startFrame.value;
            var dLen = end - start;
            var frames = this._usedFrames;
            if (end > this._count)
                this._count = end;
            if (startFrame.tween) {
                easeFun = Ease[startFrame.tweenMethod];
                if (easeFun == null)
                    easeFun = Ease.linearNone;
                for (i = start; i < end; i++) {
                    result[i] = easeFun(i - start, startValue, dValue, dLen);
                    if (frames)
                        frames[i] = true;
                }
            }
            else {
                for (i = start; i < end; i++) {
                    result[i] = startValue;
                }
            }
            if (frames) {
                frames[startFrame.index] = true;
                frames[endFrame.index] = true;
            }
            result[endFrame.index] = endFrame.value;
        }
    }

    class GraphicAnimation extends FrameAnimation {
        constructor() {
            super(...arguments);
            this._nodeIDAniDic = {};
        }
        _parseNodeList(uiView) {
            if (!this._nodeList)
                this._nodeList = [];
            this._nodeDefaultProps[uiView.compId] = uiView.props;
            if (uiView.compId)
                this._nodeList.push(uiView.compId);
            var childs = uiView.child;
            if (childs) {
                var i, len = childs.length;
                for (i = 0; i < len; i++) {
                    this._parseNodeList(childs[i]);
                }
            }
        }
        _calGraphicData(aniData) {
            this._setUp(null, aniData);
            this._createGraphicData();
            if (this._nodeIDAniDic) {
                var key;
                for (key in this._nodeIDAniDic) {
                    this._nodeIDAniDic[key] = null;
                }
            }
        }
        _createGraphicData() {
            var gList = [];
            var i, len = this.count;
            var animationDataNew = this._usedFrames;
            if (!animationDataNew)
                animationDataNew = [];
            var preGraphic;
            for (i = 0; i < len; i++) {
                if (animationDataNew[i] || !preGraphic) {
                    preGraphic = this._createFrameGraphic(i);
                }
                gList.push(preGraphic);
            }
            this._gList = gList;
        }
        _createFrameGraphic(frame) {
            var g = new Graphics();
            if (!GraphicAnimation._rootMatrix)
                GraphicAnimation._rootMatrix = new Matrix();
            this._updateNodeGraphic(this._rootNode, frame, GraphicAnimation._rootMatrix, g);
            return g;
        }
        _updateNodeGraphic(node, frame, parentTransfrom, g, alpha = 1) {
            var tNodeG;
            tNodeG = this._nodeGDic[node.compId] = this._getNodeGraphicData(node.compId, frame, this._nodeGDic[node.compId]);
            if (!tNodeG.resultTransform)
                tNodeG.resultTransform = new Matrix();
            var tResultTransform;
            tResultTransform = tNodeG.resultTransform;
            Matrix.mul(tNodeG.transform, parentTransfrom, tResultTransform);
            var tTex;
            var tGraphicAlpha = tNodeG.alpha * alpha;
            if (tGraphicAlpha < 0.01)
                return;
            if (tNodeG.skin) {
                tTex = this._getTextureByUrl(tNodeG.skin);
                if (tTex) {
                    if (tResultTransform._checkTransform()) {
                        g.drawTexture(tTex, 0, 0, tNodeG.width, tNodeG.height, tResultTransform, tGraphicAlpha);
                        tNodeG.resultTransform = null;
                    }
                    else {
                        g.drawTexture(tTex, tResultTransform.tx, tResultTransform.ty, tNodeG.width, tNodeG.height, null, tGraphicAlpha);
                    }
                }
            }
            var childs = node.child;
            if (!childs)
                return;
            var i, len;
            len = childs.length;
            for (i = 0; i < len; i++) {
                this._updateNodeGraphic(childs[i], frame, tResultTransform, g, tGraphicAlpha);
            }
        }
        _updateNoChilds(tNodeG, g) {
            if (!tNodeG.skin)
                return;
            var tTex = this._getTextureByUrl(tNodeG.skin);
            if (!tTex)
                return;
            var tTransform = tNodeG.transform;
            tTransform._checkTransform();
            var onlyTranslate;
            onlyTranslate = !tTransform._bTransform;
            if (!onlyTranslate) {
                g.drawTexture(tTex, 0, 0, tNodeG.width, tNodeG.height, tTransform.clone(), tNodeG.alpha);
            }
            else {
                g.drawTexture(tTex, tTransform.tx, tTransform.ty, tNodeG.width, tNodeG.height, null, tNodeG.alpha);
            }
        }
        _updateNodeGraphic2(node, frame, g) {
            var tNodeG;
            tNodeG = this._nodeGDic[node.compId] = this._getNodeGraphicData(node.compId, frame, this._nodeGDic[node.compId]);
            if (!node.child) {
                this._updateNoChilds(tNodeG, g);
                return;
            }
            var tTransform = tNodeG.transform;
            tTransform._checkTransform();
            var onlyTranslate;
            onlyTranslate = !tTransform._bTransform;
            var hasTrans;
            hasTrans = onlyTranslate && (tTransform.tx != 0 || tTransform.ty != 0);
            var ifSave;
            ifSave = (tTransform._bTransform) || tNodeG.alpha != 1;
            if (ifSave)
                g.save();
            if (tNodeG.alpha != 1)
                g.alpha(tNodeG.alpha);
            if (!onlyTranslate)
                g.transform(tTransform.clone());
            else if (hasTrans)
                g.translate(tTransform.tx, tTransform.ty);
            var childs = node.child;
            var tTex;
            if (tNodeG.skin) {
                tTex = this._getTextureByUrl(tNodeG.skin);
                if (tTex) {
                    g.drawImage(tTex, 0, 0, tNodeG.width, tNodeG.height);
                }
            }
            if (childs) {
                var i, len;
                len = childs.length;
                for (i = 0; i < len; i++) {
                    this._updateNodeGraphic2(childs[i], frame, g);
                }
            }
            if (ifSave) {
                g.restore();
            }
            else {
                if (!onlyTranslate) {
                    g.transform(tTransform.clone().invert());
                }
                else if (hasTrans) {
                    g.translate(-tTransform.tx, -tTransform.ty);
                }
            }
        }
        _calculateKeyFrames(node) {
            super._calculateKeyFrames(node);
            this._nodeIDAniDic[node.target] = node;
        }
        getNodeDataByID(nodeID) {
            return this._nodeIDAniDic[nodeID];
        }
        _getParams(obj, params, frame, obj2) {
            var rst = GraphicAnimation._temParam;
            rst.length = params.length;
            var i, len = params.length;
            for (i = 0; i < len; i++) {
                rst[i] = this._getObjVar(obj, params[i][0], frame, params[i][1], obj2);
            }
            return rst;
        }
        _getObjVar(obj, key, frame, noValue, obj2) {
            if (key in obj) {
                var vArr = obj[key];
                if (frame >= vArr.length)
                    frame = vArr.length - 1;
                return obj[key][frame];
            }
            if (key in obj2) {
                return obj2[key];
            }
            return noValue;
        }
        _getNodeGraphicData(nodeID, frame, rst) {
            if (!rst)
                rst = new GraphicNode();
            if (!rst.transform) {
                rst.transform = new Matrix();
            }
            else {
                rst.transform.identity();
            }
            var node = this.getNodeDataByID(nodeID);
            if (!node)
                return rst;
            var frameData = node.frames;
            var params = this._getParams(frameData, GraphicAnimation._drawTextureCmd, frame, this._nodeDefaultProps[nodeID]);
            var url = params[0];
            var width, height;
            var px = params[5], py = params[6];
            var aX = params[13], aY = params[14];
            var sx = params[7], sy = params[8];
            var rotate = params[9];
            var skewX = params[11], skewY = params[12];
            width = params[3];
            height = params[4];
            if (width == 0 || height == 0)
                url = null;
            if (width == -1)
                width = 0;
            if (height == -1)
                height = 0;
            var tex;
            rst.skin = url;
            rst.width = width;
            rst.height = height;
            if (url) {
                tex = this._getTextureByUrl(url);
                if (tex) {
                    if (!width)
                        width = tex.sourceWidth;
                    if (!height)
                        height = tex.sourceHeight;
                }
                else {
                    console.warn("lost skin:", url, ",you may load pics first");
                }
            }
            rst.alpha = params[10];
            var m = rst.transform;
            if (aX != 0) {
                px = aX * width;
            }
            if (aY != 0) {
                py = aY * height;
            }
            if (px != 0 || py != 0) {
                m.translate(-px, -py);
            }
            var tm = null;
            if (rotate || sx !== 1 || sy !== 1 || skewX || skewY) {
                tm = GraphicAnimation._tempMt;
                tm.identity();
                tm._bTransform = true;
                var skx = (rotate - skewX) * 0.0174532922222222;
                var sky = (rotate + skewY) * 0.0174532922222222;
                var cx = Math.cos(sky);
                var ssx = Math.sin(sky);
                var cy = Math.sin(skx);
                var ssy = Math.cos(skx);
                tm.a = sx * cx;
                tm.b = sx * ssx;
                tm.c = -sy * cy;
                tm.d = sy * ssy;
                tm.tx = tm.ty = 0;
            }
            if (tm) {
                m = Matrix.mul(m, tm, m);
            }
            m.translate(params[1], params[2]);
            return rst;
        }
        _getTextureByUrl(url) {
            return Loader.getRes(url);
        }
        setAniData(uiView, aniName = null) {
            if (uiView.animations) {
                this._nodeDefaultProps = {};
                this._nodeGDic = {};
                if (this._nodeList)
                    this._nodeList.length = 0;
                this._rootNode = uiView;
                this._parseNodeList(uiView);
                var aniDic = {};
                var anilist = [];
                var animations = uiView.animations;
                var i, len = animations.length;
                var tAniO;
                for (i = 0; i < len; i++) {
                    tAniO = animations[i];
                    this._labels = null;
                    if (aniName && aniName != tAniO.name) {
                        continue;
                    }
                    if (!tAniO)
                        continue;
                    try {
                        this._calGraphicData(tAniO);
                    }
                    catch (e) {
                        console.warn("parse animation fail:" + tAniO.name + ",empty animation created");
                        this._gList = [];
                    }
                    var frameO = {};
                    frameO.interval = 1000 / tAniO["frameRate"];
                    frameO.frames = this._gList;
                    frameO.labels = this._labels;
                    frameO.name = tAniO.name;
                    anilist.push(frameO);
                    aniDic[tAniO.name] = frameO;
                }
                this.animationList = anilist;
                this.animationDic = aniDic;
            }
            GraphicAnimation._temParam.length = 0;
        }
        parseByData(aniData) {
            var rootNode, aniO;
            rootNode = aniData.nodeRoot;
            aniO = aniData.aniO;
            delete aniData.nodeRoot;
            delete aniData.aniO;
            this._nodeDefaultProps = {};
            this._nodeGDic = {};
            if (this._nodeList)
                this._nodeList.length = 0;
            this._rootNode = rootNode;
            this._parseNodeList(rootNode);
            this._labels = null;
            try {
                this._calGraphicData(aniO);
            }
            catch (e) {
                console.warn("parse animation fail:" + aniO.name + ",empty animation created");
                this._gList = [];
            }
            var frameO = aniData;
            frameO.interval = 1000 / aniO["frameRate"];
            frameO.frames = this._gList;
            frameO.labels = this._labels;
            frameO.name = aniO.name;
            return frameO;
        }
        setUpAniData(uiView) {
            if (uiView.animations) {
                var aniDic = {};
                var anilist = [];
                var animations = uiView.animations;
                var i, len = animations.length;
                var tAniO;
                for (i = 0; i < len; i++) {
                    tAniO = animations[i];
                    if (!tAniO)
                        continue;
                    var frameO = {};
                    frameO.name = tAniO.name;
                    frameO.aniO = tAniO;
                    frameO.nodeRoot = uiView;
                    anilist.push(frameO);
                    aniDic[tAniO.name] = frameO;
                }
                this.animationList = anilist;
                this.animationDic = aniDic;
            }
        }
        _clear() {
            this.animationList = null;
            this.animationDic = null;
            this._gList = null;
            this._nodeGDic = null;
        }
        static parseAnimationByData(animationObject) {
            if (!GraphicAnimation._I)
                GraphicAnimation._I = new GraphicAnimation();
            var rst;
            rst = GraphicAnimation._I.parseByData(animationObject);
            GraphicAnimation._I._clear();
            return rst;
        }
        static parseAnimationData(aniData) {
            if (!GraphicAnimation._I)
                GraphicAnimation._I = new GraphicAnimation();
            GraphicAnimation._I.setUpAniData(aniData);
            var rst;
            rst = {};
            rst.animationList = GraphicAnimation._I.animationList;
            rst.animationDic = GraphicAnimation._I.animationDic;
            GraphicAnimation._I._clear();
            return rst;
        }
    }
    GraphicAnimation._drawTextureCmd = [["skin", null], ["x", 0], ["y", 0], ["width", -1], ["height", -1], ["pivotX", 0], ["pivotY", 0], ["scaleX", 1], ["scaleY", 1], ["rotation", 0], ["alpha", 1], ["skewX", 0], ["skewY", 0], ["anchorX", 0], ["anchorY", 0]];
    GraphicAnimation._temParam = [];
    GraphicAnimation._tempMt = new Matrix();
    class GraphicNode {
        constructor() {
            this.alpha = 1;
        }
    }

    class Animation extends AnimationBase {
        constructor() {
            super();
            this._setControlNode(this);
        }
        destroy(destroyChild = true) {
            this.stop();
            super.destroy(destroyChild);
            this._frames = null;
            this._labels = null;
        }
        play(start = 0, loop = true, name = "") {
            if (name)
                this._setFramesFromCache(name, true);
            super.play(start, loop, name);
        }
        _setFramesFromCache(name, showWarn = false) {
            if (this._url)
                name = this._url + "#" + name;
            if (name && Animation.framesMap[name]) {
                var tAniO = Animation.framesMap[name];
                if (tAniO instanceof Array) {
                    this._frames = Animation.framesMap[name];
                    this._count = this._frames.length;
                }
                else {
                    if (tAniO.nodeRoot) {
                        Animation.framesMap[name] = GraphicAnimation.parseAnimationByData(tAniO);
                        tAniO = Animation.framesMap[name];
                    }
                    this._frames = tAniO.frames;
                    this._count = this._frames.length;
                    if (!this._frameRateChanged)
                        this._interval = tAniO.interval;
                    this._labels = this._copyLabels(tAniO.labels);
                }
                return true;
            }
            else {
                if (showWarn)
                    console.log("ani not found:", name);
            }
            return false;
        }
        _copyLabels(labels) {
            if (!labels)
                return null;
            var rst;
            rst = {};
            var key;
            for (key in labels) {
                rst[key] = Utils.copyArray([], labels[key]);
            }
            return rst;
        }
        _frameLoop() {
            if (this._visible && this._style.alpha > 0.01 && this._frames) {
                super._frameLoop();
            }
        }
        _displayToIndex(value) {
            if (this._frames)
                this.graphics = this._frames[value];
        }
        get frames() {
            return this._frames;
        }
        set frames(value) {
            this._frames = value;
            if (value) {
                this._count = value.length;
                if (this._actionName)
                    this._setFramesFromCache(this._actionName, true);
                this.index = this._index;
            }
        }
        set source(value) {
            if (value.indexOf(".ani") > -1)
                this.loadAnimation(value);
            else if (value.indexOf(".json") > -1 || value.indexOf("als") > -1 || value.indexOf("atlas") > -1)
                this.loadAtlas(value);
            else
                this.loadImages(value.split(","));
        }
        set autoAnimation(value) {
            this.play(0, true, value);
        }
        set autoPlay(value) {
            if (value)
                this.play();
            else
                this.stop();
        }
        clear() {
            super.clear();
            this.stop();
            this.graphics = null;
            this._frames = null;
            this._labels = null;
            return this;
        }
        loadImages(urls, cacheName = "") {
            this._url = "";
            if (!this._setFramesFromCache(cacheName)) {
                this.frames = Animation.framesMap[cacheName] ? Animation.framesMap[cacheName] : Animation.createFrames(urls, cacheName);
            }
            return this;
        }
        loadAtlas(url, loaded = null, cacheName = "") {
            this._url = "";
            var _this = this;
            if (!_this._setFramesFromCache(cacheName)) {
                function onLoaded(loadUrl) {
                    if (url === loadUrl) {
                        _this.frames = Animation.framesMap[cacheName] ? Animation.framesMap[cacheName] : Animation.createFrames(url, cacheName);
                        if (loaded)
                            loaded.run();
                    }
                }
                if (Loader.getAtlas(url))
                    onLoaded(url);
                else
                    ILaya.loader.load(url, Handler.create(null, onLoaded, [url]), null, Loader.ATLAS);
            }
            return this;
        }
        loadAnimation(url, loaded = null, atlas = null) {
            this._url = url;
            var _this = this;
            if (!this._actionName)
                this._actionName = "";
            if (!_this._setFramesFromCache(this._actionName)) {
                if (!atlas || Loader.getAtlas(atlas)) {
                    this._loadAnimationData(url, loaded, atlas);
                }
                else {
                    ILaya.loader.load(atlas, Handler.create(this, this._loadAnimationData, [url, loaded, atlas]), null, Loader.ATLAS);
                }
            }
            else {
                _this._setFramesFromCache(this._actionName, true);
                this.index = 0;
                if (loaded)
                    loaded.run();
            }
            return this;
        }
        _loadAnimationData(url, loaded = null, atlas = null) {
            if (atlas && !Loader.getAtlas(atlas)) {
                console.warn("atlas load fail:" + atlas);
                return;
            }
            ILaya.loader.fetch(url, "json").then(data => {
                if (this._url !== url)
                    return;
                if (!data) {
                    if (Animation.framesMap[url + "#"]) {
                        this._setFramesFromCache(this._actionName, true);
                        this.index = 0;
                        this._resumePlay();
                        if (loaded)
                            loaded.run();
                    }
                    return;
                }
                let tAniO;
                if (!Animation.framesMap[url + "#"]) {
                    let aniData = GraphicAnimation.parseAnimationData(data);
                    if (!aniData)
                        return;
                    let aniList = aniData.animationList;
                    let len = aniList.length;
                    let defaultO;
                    for (let i = 0; i < len; i++) {
                        tAniO = aniList[i];
                        Animation.framesMap[url + "#" + tAniO.name] = tAniO;
                        if (!defaultO)
                            defaultO = tAniO;
                    }
                    if (defaultO) {
                        Animation.framesMap[url + "#"] = defaultO;
                        this._setFramesFromCache(this._actionName, true);
                        this.index = 0;
                    }
                    this._resumePlay();
                }
                else {
                    this._setFramesFromCache(this._actionName, true);
                    this.index = 0;
                    this._resumePlay();
                }
                if (loaded)
                    loaded.run();
            });
        }
        static createFrames(url, name) {
            var arr;
            if (typeof (url) == 'string') {
                var atlas = Loader.getAtlas(url);
                if (atlas && atlas.frames.length) {
                    let frames = atlas.frames;
                    arr = [];
                    for (var i = 0, n = frames.length; i < n; i++) {
                        var g = new Graphics();
                        g.drawImage(frames[i], 0, 0);
                        arr.push(g);
                    }
                }
            }
            else if (url instanceof Array) {
                arr = [];
                for (i = 0, n = url.length; i < n; i++) {
                    g = new Graphics();
                    g.loadImage(url[i], 0, 0);
                    arr.push(g);
                }
            }
            if (name)
                Animation.framesMap[name] = arr;
            return arr;
        }
        static clearCache(key) {
            var cache = Animation.framesMap;
            var val;
            var key2 = key + "#";
            for (val in cache) {
                if (val === key || val.indexOf(key2) === 0) {
                    delete Animation.framesMap[val];
                }
            }
        }
    }
    Animation.framesMap = {};

    class BitmapFont {
        constructor() {
            this._fontCharDic = {};
            this._fontWidthMap = {};
            this._maxWidth = 0;
            this._spaceWidth = 10;
            this.fontSize = 12;
            this.autoScaleSize = false;
            this.letterSpacing = 0;
        }
        loadFont(path, complete) {
            this._path = path;
            if (!path || path.indexOf(".fnt") === -1) {
                console.error('Bitmap font configuration information must be a ".fnt" file');
                return;
            }
            ILaya.loader.load([path, path.replace(".fnt", ".png")]).then((contents) => {
                this.parseFont(contents[0].data, contents[1]);
                complete && complete.run();
            });
        }
        parseFont(xml, texture) {
            if (xml == null || texture == null)
                return;
            this._texture = texture;
            texture._addReference();
            let tScale = 1;
            let tInfo = xml.getElementsByTagName("info");
            if (!tInfo[0].getAttributeNode) {
                return this.parseFont2(xml, texture);
            }
            this.fontSize = parseInt(tInfo[0].getAttributeNode("size").nodeValue);
            let tPadding = tInfo[0].getAttributeNode("padding").nodeValue;
            let tPaddingArray = tPadding.split(",");
            this._padding = [parseInt(tPaddingArray[0]), parseInt(tPaddingArray[1]), parseInt(tPaddingArray[2]), parseInt(tPaddingArray[3])];
            let chars = xml.getElementsByTagName("char");
            for (let i = 0; i < chars.length; i++) {
                let tAttribute = chars[i];
                let tId = parseInt(tAttribute.getAttributeNode("id").nodeValue);
                let xOffset = parseInt(tAttribute.getAttributeNode("xoffset").nodeValue) / tScale;
                let yOffset = parseInt(tAttribute.getAttributeNode("yoffset").nodeValue) / tScale;
                let xAdvance = parseInt(tAttribute.getAttributeNode("xadvance").nodeValue) / tScale;
                let region = new Rectangle();
                region.x = parseInt(tAttribute.getAttributeNode("x").nodeValue);
                region.y = parseInt(tAttribute.getAttributeNode("y").nodeValue);
                region.width = parseInt(tAttribute.getAttributeNode("width").nodeValue);
                region.height = parseInt(tAttribute.getAttributeNode("height").nodeValue);
                let tTexture = Texture.create(texture, region.x, region.y, region.width, region.height, xOffset, yOffset);
                this._maxWidth = Math.max(this._maxWidth, xAdvance + this.letterSpacing);
                this._fontCharDic[tId] = tTexture;
                this._fontWidthMap[tId] = xAdvance;
            }
        }
        parseFont2(xml, texture) {
            if (xml == null || texture == null)
                return;
            this._texture = texture;
            let tScale = 1;
            let tInfo = xml.getElementsByTagName("info");
            this.fontSize = parseInt(tInfo[0].attributes["size"].nodeValue);
            let tPadding = tInfo[0].attributes["padding"].nodeValue;
            let tPaddingArray = tPadding.split(",");
            this._padding = [parseInt(tPaddingArray[0]), parseInt(tPaddingArray[1]), parseInt(tPaddingArray[2]), parseInt(tPaddingArray[3])];
            let chars = xml.getElementsByTagName("char");
            for (let i = 0; i < chars.length; i++) {
                let tAttribute = chars[i].attributes;
                let tId = parseInt(tAttribute["id"].nodeValue);
                let xOffset = parseInt(tAttribute["xoffset"].nodeValue) / tScale;
                let yOffset = parseInt(tAttribute["yoffset"].nodeValue) / tScale;
                let xAdvance = parseInt(tAttribute["xadvance"].nodeValue) / tScale;
                let region = new Rectangle();
                region.x = parseInt(tAttribute["x"].nodeValue);
                region.y = parseInt(tAttribute["y"].nodeValue);
                region.width = parseInt(tAttribute["width"].nodeValue);
                region.height = parseInt(tAttribute["height"].nodeValue);
                let tTexture = Texture.create(texture, region.x, region.y, region.width, region.height, xOffset, yOffset);
                this._maxWidth = Math.max(this._maxWidth, xAdvance + this.letterSpacing);
                this._fontCharDic[tId] = tTexture;
                this._fontWidthMap[tId] = xAdvance;
            }
        }
        getCharTexture(char) {
            return this._fontCharDic[char.charCodeAt(0)];
        }
        destroy() {
            if (this._texture) {
                for (let k in this._fontCharDic) {
                    this._fontCharDic[k].destroy();
                }
                this._texture._removeReference();
                this._fontCharDic = null;
                this._fontWidthMap = null;
                this._texture = null;
                this._padding = null;
            }
        }
        setSpaceWidth(spaceWidth) {
            this._spaceWidth = spaceWidth;
        }
        getCharWidth(char) {
            let code = char.charCodeAt(0);
            if (this._fontWidthMap[code])
                return this._fontWidthMap[code] + this.letterSpacing;
            if (char === " ")
                return this._spaceWidth + this.letterSpacing;
            return 0;
        }
        getTextWidth(text) {
            let tWidth = 0;
            for (let i = 0, n = text.length; i < n; i++) {
                tWidth += this.getCharWidth(text.charAt(i));
            }
            return tWidth;
        }
        getMaxWidth() {
            return this._maxWidth;
        }
        getMaxHeight() {
            return this.fontSize;
        }
        _drawText(text, sprite, drawX, drawY, align, width) {
            let tWidth = this.getTextWidth(text);
            let tTexture;
            let dx = 0;
            align === "center" && (dx = (width - tWidth) / 2);
            align === "right" && (dx = (width - tWidth));
            let tx = 0;
            for (let i = 0, n = text.length; i < n; i++) {
                tTexture = this.getCharTexture(text.charAt(i));
                if (tTexture) {
                    sprite.graphics.drawImage(tTexture, drawX + tx + dx, drawY);
                    tx += this.getCharWidth(text.charAt(i));
                }
            }
        }
    }

    class EffectAnimation extends FrameAnimation {
        constructor() {
            super(...arguments);
            this._initData = {};
        }
        set target(v) {
            if (this._target)
                this._target.off(EffectAnimation.EFFECT_BEGIN, this, this._onOtherBegin);
            this._target = v;
            if (this._target)
                this._target.on(EffectAnimation.EFFECT_BEGIN, this, this._onOtherBegin);
            this._addEvent();
        }
        get target() {
            return this._target;
        }
        _onOtherBegin(effect) {
            if (effect === this)
                return;
            this.stop();
        }
        set playEvent(event) {
            this._playEvent = event;
            if (!event)
                return;
            this._addEvent();
        }
        _addEvent() {
            if (!this._target || !this._playEvent)
                return;
            this._setControlNode(this._target);
            this._target.on(this._playEvent, this, this._onPlayAction);
        }
        _onPlayAction() {
            this.play(0, false);
        }
        play(start = 0, loop = true, name = "") {
            if (!this._target)
                return;
            this._target.event(EffectAnimation.EFFECT_BEGIN, [this]);
            this._recordInitData();
            super.play(start, loop, name);
        }
        _recordInitData() {
            if (!this._aniKeys)
                return;
            var i, len;
            len = this._aniKeys.length;
            var key;
            for (i = 0; i < len; i++) {
                key = this._aniKeys[i];
                this._initData[key] = this._target[key];
            }
        }
        set effectClass(classStr) {
            this._effectClass = ClassUtils.getClass(classStr);
            if (this._effectClass) {
                var uiData = this._effectClass["uiView"];
                if (uiData) {
                    var aniData = uiData["animations"];
                    if (aniData && aniData[0]) {
                        var data = aniData[0];
                        this._setUp({}, data);
                        if (data.nodes && data.nodes[0]) {
                            this._aniKeys = data.nodes[0].keys;
                        }
                    }
                }
            }
        }
        set effectData(uiData) {
            if (uiData) {
                var aniData = uiData["animations"];
                if (aniData && aniData[0]) {
                    var data = aniData[0];
                    this._setUp({}, data);
                    if (data.nodes && data.nodes[0]) {
                        this._aniKeys = data.nodes[0].keys;
                    }
                }
            }
        }
        _displayToIndex(value) {
            if (!this._animationData)
                return;
            if (value < 0)
                value = 0;
            if (value > this._count)
                value = this._count;
            var nodes = this._animationData.nodes, i, len = nodes.length;
            len = len > 1 ? 1 : len;
            for (i = 0; i < len; i++) {
                this._displayNodeToFrame(nodes[i], value);
            }
        }
        _displayNodeToFrame(node, frame, targetDic = null) {
            if (!this._target)
                return;
            var target = this._target;
            var frames = node.frames, key, propFrames, value;
            var keys = node.keys, i, len = keys.length;
            var secondFrames = node.secondFrames;
            var tSecondFrame;
            var easeFun;
            var tKeyFrames;
            var startFrame;
            var endFrame;
            for (i = 0; i < len; i++) {
                key = keys[i];
                propFrames = frames[key];
                tSecondFrame = secondFrames[key];
                if (tSecondFrame == -1) {
                    value = this._initData[key];
                }
                else {
                    if (frame < tSecondFrame) {
                        tKeyFrames = node.keyframes[key];
                        startFrame = tKeyFrames[0];
                        if (startFrame.tween) {
                            easeFun = Ease[startFrame.tweenMethod];
                            if (easeFun == null)
                                easeFun = Ease.linearNone;
                            endFrame = tKeyFrames[1];
                            value = easeFun(frame, this._initData[key], endFrame.value - this._initData[key], endFrame.index);
                        }
                        else {
                            value = this._initData[key];
                        }
                    }
                    else {
                        if (propFrames.length > frame)
                            value = propFrames[frame];
                        else
                            value = propFrames[propFrames.length - 1];
                    }
                }
                target[key] = value;
            }
        }
        _calculateKeyFrames(node) {
            super._calculateKeyFrames(node);
            var keyFrames = node.keyframes, key, tKeyFrames; node.target;
            var secondFrames = {};
            node.secondFrames = secondFrames;
            for (key in keyFrames) {
                tKeyFrames = keyFrames[key];
                if (tKeyFrames.length <= 1)
                    secondFrames[key] = -1;
                else
                    secondFrames[key] = tKeyFrames[1].index;
            }
        }
    }
    EffectAnimation.EFFECT_BEGIN = "effectbegin";

    class Widget extends Component {
        constructor() {
            super();
            this._top = null;
            this._bottom = null;
            this._left = null;
            this._right = null;
            this._centerX = null;
            this._centerY = null;
            this.runInEditor = true;
            this.hideFlags |= HideFlags.HideAndDontSave;
        }
        onReset() {
            this._top = this._bottom = this._left = this._right = this._centerX = this._centerY = null;
        }
        _onEnable() {
            if (this.owner.parent)
                this._onAdded();
            else
                this.owner.once(Event.ADDED, this, this._onAdded);
        }
        _onDisable() {
            this.owner.off(Event.ADDED, this, this._onAdded);
            if (this.owner.parent)
                this.owner.parent.off(Event.RESIZE, this, this._onParentResize);
        }
        _onAdded() {
            if (this.owner.parent)
                this.owner.parent.on(Event.RESIZE, this, this._onParentResize);
            this.resetLayoutX();
            this.resetLayoutY();
        }
        _onParentResize() {
            var flagX = this.resetLayoutX();
            var flagY = this.resetLayoutY();
            if (flagX || flagY)
                this.owner.event(Event.RESIZE);
        }
        resetLayoutX() {
            var owner = this.owner;
            if (!owner)
                return false;
            var parent = owner.parent;
            if (parent) {
                if (this._centerX != null) {
                    owner.x = Math.round((parent.width - owner.displayWidth) * 0.5 + this._centerX + owner.pivotX * owner.scaleX);
                }
                else if (this._left != null) {
                    owner.x = Math.round(this._left + owner.pivotX * owner.scaleX);
                    if (this._right != null) {
                        if (!parent._width)
                            return false;
                        var temp = (parent._width - this._left - this._right) / (owner.scaleX || 0.01);
                        if (temp != owner._width) {
                            owner.width = temp;
                            return true;
                        }
                    }
                }
                else if (this._right != null) {
                    owner.x = Math.round(parent.width - owner.displayWidth - this._right + owner.pivotX * owner.scaleX);
                }
            }
            return false;
        }
        resetLayoutY() {
            var owner = this.owner;
            if (!owner)
                return false;
            var parent = owner.parent;
            if (parent) {
                if (this._centerY != null) {
                    owner.y = Math.round((parent.height - owner.displayHeight) * 0.5 + this._centerY + owner.pivotY * owner.scaleY);
                }
                else if (this._top != null) {
                    owner.y = Math.round(this._top + owner.pivotY * owner.scaleY);
                    if (this._bottom != null) {
                        if (!parent._height)
                            return false;
                        var temp = (parent._height - this._top - this._bottom) / (owner.scaleY || 0.01);
                        if (temp != owner._height) {
                            owner.height = temp;
                            return true;
                        }
                    }
                }
                else if (this._bottom != null) {
                    owner.y = Math.round(parent.height - owner.displayHeight - this._bottom + owner.pivotY * owner.scaleY);
                }
            }
            return false;
        }
        resetLayout() {
            if (this.owner) {
                this.resetLayoutX();
                this.resetLayoutY();
            }
        }
        get top() {
            return this._top;
        }
        set top(value) {
            if (isNaN(value))
                value = null;
            if (this._top != value) {
                this._top = value;
                this.resetLayoutY();
            }
        }
        get bottom() {
            return this._bottom;
        }
        set bottom(value) {
            if (isNaN(value))
                value = null;
            if (this._bottom != value) {
                this._bottom = value;
                this.resetLayoutY();
            }
        }
        get left() {
            return this._left;
        }
        set left(value) {
            if (isNaN(value))
                value = null;
            if (this._left != value) {
                this._left = value;
                this.resetLayoutX();
            }
        }
        get right() {
            return this._right;
        }
        set right(value) {
            if (isNaN(value))
                value = null;
            if (this._right != value) {
                this._right = value;
                this.resetLayoutX();
            }
        }
        get centerX() {
            return this._centerX;
        }
        set centerX(value) {
            if (isNaN(value))
                value = null;
            if (this._centerX != value) {
                this._centerX = value;
                this.resetLayoutX();
            }
        }
        get centerY() {
            return this._centerY;
        }
        set centerY(value) {
            if (isNaN(value))
                value = null;
            if (this._centerY != value) {
                this._centerY = value;
                this.resetLayoutY();
            }
        }
    }
    Widget.EMPTY = null;
    Widget.EMPTY = new Widget();

    const _rect = new Rectangle();
    const _ptPoint = new Point();
    class HitArea {
        contains(x, y, sp) {
            if (!HitArea._isHitGraphic(x, y, sp, this._hit))
                return false;
            return !HitArea._isHitGraphic(x, y, sp, this._unHit);
        }
        static _isHitGraphic(x, y, sp, graphic) {
            if (!graphic)
                return false;
            let cmds = graphic.cmds;
            if (cmds.length == 0)
                return false;
            let len = cmds.length;
            for (let i = 0; i < len; i++) {
                let cmd = cmds[i];
                if (!cmd)
                    continue;
                switch (cmd.cmdID) {
                    case "Translate":
                        x -= cmd.tx;
                        y -= cmd.ty;
                }
                if (HitArea._isHitCmd(x, y, sp, cmd))
                    return true;
            }
            return false;
        }
        static _isHitCmd(x, y, sp, cmd) {
            if (!cmd)
                return false;
            var rst = false;
            switch (cmd.cmdID) {
                case "DrawRect":
                    if (cmd.percent)
                        _rect.setTo(cmd.x * sp.width, cmd.y * sp.height, cmd.width * sp.width, cmd.height * sp.height);
                    else
                        _rect.setTo(cmd.x, cmd.y, cmd.width, cmd.height);
                    rst = _rect.contains(x, y);
                    break;
                case "DrawCircle":
                    let r = cmd.radius;
                    var d;
                    if (cmd.percent) {
                        x -= cmd.x * sp.width;
                        y -= cmd.y * sp.height;
                        r *= sp.width;
                    }
                    else {
                        x -= cmd.x;
                        y -= cmd.y;
                    }
                    d = x * x + y * y;
                    rst = d < r * r;
                    break;
                case "DrawPoly":
                    x -= cmd.x;
                    y -= cmd.y;
                    rst = HitArea._ptInPolygon(x, y, cmd.points);
                    break;
            }
            return rst;
        }
        static _ptInPolygon(x, y, areaPoints) {
            var p = _ptPoint;
            p.setTo(x, y);
            var nCross = 0;
            var p1x, p1y, p2x, p2y;
            var len;
            len = areaPoints.length;
            for (var i = 0; i < len; i += 2) {
                p1x = areaPoints[i];
                p1y = areaPoints[i + 1];
                p2x = areaPoints[(i + 2) % len];
                p2y = areaPoints[(i + 3) % len];
                if (p1y == p2y)
                    continue;
                if (p.y < Math.min(p1y, p2y))
                    continue;
                if (p.y >= Math.max(p1y, p2y))
                    continue;
                var tx = (p.y - p1y) * (p2x - p1x) / (p2y - p1y) + p1x;
                if (tx > p.x)
                    nCross++;
            }
            return (nCross % 2 == 1);
        }
        get hit() {
            if (!this._hit)
                this._hit = new Graphics();
            return this._hit;
        }
        set hit(value) {
            this._hit = value;
        }
        get unHit() {
            if (!this._unHit)
                this._unHit = new Graphics();
            return this._unHit;
        }
        set unHit(value) {
            this._unHit = value;
        }
        onAfterDeserialize() {
            if (LayaEnv.isPlaying) {
                if (this._hitCmds) {
                    this.hit.cmds = this._hitCmds;
                    delete this._hitCmds;
                }
                if (this._unHitCmds) {
                    this.unHit.cmds = this._unHitCmds;
                    delete this._unHitCmds;
                }
            }
        }
    }
    ClassUtils.regClass("HitArea", HitArea);

    class Prefab extends Resource {
        constructor(version) {
            super();
            this.version = version;
            this._deps = [];
        }
        create(options, errors) {
            if (this.json)
                return LegacyUIParser.createByData(null, this.json);
            else
                return null;
        }
        get deps() {
            return this._deps;
        }
        addDep(res) {
            if (res instanceof Resource) {
                res._addReference();
                this._deps.push(res);
                if (!LayaEnv.isPlaying && (res instanceof Prefab))
                    res.on("obsolute", this, this.onDepObsolute);
            }
        }
        addDeps(resArr) {
            for (let res of resArr) {
                if (res instanceof Resource) {
                    res._addReference();
                    this._deps.push(res);
                    if (!LayaEnv.isPlaying && (res instanceof Prefab))
                        res.on("obsolute", this, this.onDepObsolute);
                }
            }
        }
        _disposeResource() {
            for (let res of this._deps) {
                res._removeReference();
                if (!LayaEnv.isPlaying && (res instanceof Prefab))
                    res.off("obsolute", this, this.onDepObsolute);
            }
        }
        get obsolute() {
            return this._obsolute;
        }
        set obsolute(value) {
            if (this._obsolute != value) {
                this._obsolute = value;
                if (value && !LayaEnv.isPlaying)
                    this.event("obsolute");
            }
        }
        onDepObsolute() {
            this.obsolute = true;
        }
    }
    var HierarchyResource = Prefab;

    class PrefabImpl extends Prefab {
        constructor(api, data, version) {
            super(version);
            this.api = api;
            this.data = data;
        }
        create(options, errors) {
            let ret = this.api.parse(this.data, options, errors);
            if (Array.isArray(ret)) {
                if (ret.length == 1) {
                    ret[0].url = this.url;
                }
                return ret[0];
            }
            else {
                ret.url = this.url;
                return ret;
            }
        }
    }

    var _listClass;
    var _viewClass;
    class LegacyUIParser {
        static parse(data, options) {
            let root = options === null || options === void 0 ? void 0 : options.root;
            if (!root) {
                let runtime = (LayaEnv.isPlaying && data.props.runtime) ? data.props.runtime : data.type;
                let clas = ClassUtils.getClass(runtime);
                if (data.props.renderType == "instance")
                    root = clas.instance || (clas.instance = new clas());
                else
                    root = new clas();
            }
            if (root && root._viewCreated)
                return root;
            return LegacyUIParser.createByData(root, data);
        }
        static getBindFun(value) {
            let map = LegacyUIParser._funMap;
            if (!map)
                map = LegacyUIParser._funMap = new WeakObject();
            var fun = LegacyUIParser._funMap.get(value);
            if (fun == null) {
                var temp = "\"" + value + "\"";
                temp = temp.replace(/^"\${|}"$/g, "").replace(/\${/g, "\"+").replace(/}/g, "+\"");
                var str = "(function(data){if(data==null)return;with(data){try{\nreturn " + temp + "\n}catch(e){}}})";
                fun = window.Laya._runScript(str);
                LegacyUIParser._funMap.set(value, fun);
            }
            return fun;
        }
        static createByData(root, uiView) {
            var tInitTool = InitTool.create();
            root = LegacyUIParser.createComp(uiView, root, root, null, tInitTool);
            if ("_idMap" in root) {
                root["_idMap"] = tInitTool._idMap;
            }
            if (uiView.animations) {
                var anilist = [];
                var animations = uiView.animations;
                var i, len = animations.length;
                var tAni;
                var tAniO;
                for (i = 0; i < len; i++) {
                    tAni = new FrameAnimation();
                    tAniO = animations[i];
                    tAni._setUp(tInitTool._idMap, tAniO);
                    root[tAniO.name] = tAni;
                    tAni._setControlNode(root);
                    switch (tAniO.action) {
                        case 1:
                            tAni.play(0, false);
                            break;
                        case 2:
                            tAni.play(0, true);
                            break;
                    }
                    anilist.push(tAni);
                }
                root._aniList = anilist;
            }
            if ((root instanceof Scene) && root._width > 0 && uiView.props.hitTestPrior == null && !root.mouseThrough)
                root.hitTestPrior = true;
            tInitTool.finish();
            root._setBit(NodeFlags.NOT_READY, false);
            if (root.parent && root.parent.activeInHierarchy && root.active)
                root._processActive(true);
            return root;
        }
        static createInitTool() {
            return InitTool.create();
        }
        static createComp(uiView, comp = null, view = null, dataMap = null, initTool = null) {
            comp = comp || LegacyUIParser.getCompInstance(uiView);
            if (!comp) {
                if (uiView.props && uiView.props.runtime)
                    console.warn("runtime not found:" + uiView.props.runtime);
                else
                    console.warn("can not create:" + uiView.type);
                return null;
            }
            var child = uiView.child;
            if (child) {
                var isList = comp instanceof (_listClass || (_listClass = ClassUtils.getClass("List")));
                for (var i = 0, n = child.length; i < n; i++) {
                    var node = child[i];
                    if ('itemRender' in comp && (node.props.name == "render" || node.props.renderType === "render")) {
                        comp["itemRender"] = node;
                    }
                    else if (node.type == "Graphic") {
                        this._addGraphicsToSprite(node, comp);
                    }
                    else if (this._isDrawType(node.type)) {
                        this._addGraphicToSprite(node, comp, true);
                    }
                    else {
                        if (isList) {
                            var arr = [];
                            var tChild = LegacyUIParser.createComp(node, null, view, arr, initTool);
                            if (arr.length)
                                tChild["_$bindData"] = arr;
                        }
                        else {
                            tChild = LegacyUIParser.createComp(node, null, view, dataMap, initTool);
                        }
                        if (node.type == "Script") {
                            if (tChild instanceof Component) {
                                comp.addComponentInstance(tChild);
                            }
                            else {
                                if ("owner" in tChild) {
                                    tChild["owner"] = comp;
                                }
                                else if ("target" in tChild) {
                                    tChild["target"] = comp;
                                }
                            }
                        }
                        else if (node.props.renderType == "mask" || node.props.name == "mask") {
                            comp.mask = tChild;
                        }
                        else {
                            tChild instanceof Node && comp.addChild(tChild);
                        }
                    }
                }
            }
            var props = uiView.props;
            for (var prop in props) {
                var value = props[prop];
                if (typeof (value) == 'string' && (value.indexOf("@node:") >= 0 || value.indexOf("@Prefab:") >= 0)) {
                    if (initTool) {
                        initTool.addNodeRef(comp, prop, value);
                    }
                }
                else
                    LegacyUIParser.setCompValue(comp, prop, value, view, dataMap);
            }
            if (comp._afterInited) {
                comp._afterInited();
            }
            if (uiView.compId && initTool && initTool._idMap) {
                initTool._idMap[uiView.compId] = comp;
            }
            return comp;
        }
        static setCompValue(comp, prop, value, view = null, dataMap = null) {
            if (typeof (value) == 'string' && value.indexOf("${") > -1) {
                LegacyUIParser._sheet || (LegacyUIParser._sheet = ClassUtils.getClass("laya.data.Table"));
                if (!LegacyUIParser._sheet) {
                    console.warn("Can not find class Sheet");
                    return;
                }
                if (dataMap) {
                    dataMap.push(comp, prop, value);
                }
                else if (view) {
                    if (value.indexOf("].") == -1) {
                        value = value.replace(".", "[0].");
                    }
                    var watcher = new DataWatcher(comp, prop, value);
                    watcher.exe(view);
                    var one, temp;
                    var str = value.replace(/\[.*?\]\./g, ".");
                    while ((one = LegacyUIParser._parseWatchData.exec(str)) != null) {
                        var key1 = one[1];
                        while ((temp = LegacyUIParser._parseKeyWord.exec(key1)) != null) {
                            var key2 = temp[0];
                            var arr = (view._watchMap[key2] || (view._watchMap[key2] = []));
                            arr.push(watcher);
                            LegacyUIParser._sheet.I.notifer.on(key2, view, view.changeData, [key2]);
                        }
                        arr = (view._watchMap[key1] || (view._watchMap[key1] = []));
                        arr.push(watcher);
                        LegacyUIParser._sheet.I.notifer.on(key1, view, view.changeData, [key1]);
                    }
                }
                return;
            }
            if (prop === "var" && view) {
                view[value] = comp;
            }
            else {
                comp[prop] = (value === "true" ? true : (value === "false" ? false : value));
            }
        }
        static getCompInstance(json) {
            if (json.type == "UIView") {
                if (json.props && json.props.pageData) {
                    return LegacyUIParser.createByData(null, json.props.pageData);
                }
            }
            var runtime = LayaEnv.isPlaying ? ((json.props && json.props.runtime) || json.type) : json.type;
            var compClass = ClassUtils.getClass(runtime);
            if (!compClass)
                throw "Can not find class " + runtime;
            if (json.type === "Script" && compClass.prototype._doAwake) {
                var comp = Pool.createByClass(compClass);
                comp._destroyed = false;
                return comp;
            }
            if (json.props && "renderType" in json.props && json.props["renderType"] == "instance") {
                if (!compClass["instance"])
                    compClass["instance"] = new compClass();
                return compClass["instance"];
            }
            let ret = new compClass();
            if (ret instanceof (_viewClass || (_viewClass = ClassUtils.getClass("View"))))
                ret._scene = ret;
            return ret;
        }
        static collectResourceLinks(uiView) {
            let test = new Set();
            let innerUrls = [];
            function addInnerUrl(url) {
                if (!test.has(url)) {
                    test.add(url);
                    innerUrls.push(url);
                }
            }
            function check(uiView) {
                let props = uiView.props;
                for (let prop in props) {
                    let value = props[prop];
                    if (typeof (value) == 'string' && value.indexOf("@Prefab:") >= 0) {
                        let url = value.replace("@Prefab:", "");
                        addInnerUrl(url);
                    }
                }
                let child = uiView.child;
                if (child) {
                    for (let i = 0, n = child.length; i < n; i++) {
                        let node = child[i];
                        check(node);
                    }
                }
            }
            if (uiView.loadList) {
                for (let url of uiView.loadList)
                    addInnerUrl(url);
            }
            if (uiView.loadList3D) {
                for (let url of uiView.loadList3D)
                    addInnerUrl(url);
            }
            check(uiView);
            return innerUrls;
        }
        static createByJson(json, node = null, root = null, customHandler = null, instanceHandler = null) {
            if (typeof (json) == 'string')
                json = JSON.parse(json);
            var props = json.props;
            if (!node) {
                node = instanceHandler ? instanceHandler.runWith(json) : ClassUtils.getInstance(LayaEnv.isPlaying ? (props.runtime || json.type) : json.type);
                if (!node)
                    return null;
            }
            var child = json.child;
            if (child) {
                for (var i = 0, n = child.length; i < n; i++) {
                    var data = child[i];
                    if ((data.props.name === "render" || data.props.renderType === "render") && node["_$set_itemRender"])
                        node.itemRender = data;
                    else {
                        if (data.type == "Graphic") {
                            this._addGraphicsToSprite(data, node);
                        }
                        else if (this._isDrawType(data.type)) {
                            this._addGraphicToSprite(data, node, true);
                        }
                        else {
                            var tChild = this.createByJson(data, null, root, customHandler, instanceHandler);
                            if (data.type === "Script") {
                                if ("owner" in tChild) {
                                    tChild["owner"] = node;
                                }
                                else if ("target" in tChild) {
                                    tChild["target"] = node;
                                }
                            }
                            else if (data.props.renderType == "mask") {
                                node.mask = tChild;
                            }
                            else {
                                node.addChild(tChild);
                            }
                        }
                    }
                }
            }
            if (props) {
                for (var prop in props) {
                    var value = props[prop];
                    if (prop === "var" && root) {
                        root[value] = node;
                    }
                    else if (value instanceof Array && node[prop] instanceof Function) {
                        node[prop].apply(node, value);
                    }
                    else {
                        node[prop] = value;
                    }
                }
            }
            if (customHandler && json.customProps) {
                customHandler.runWith([node, json]);
            }
            if (node["created"])
                node.created();
            return node;
        }
        static _addGraphicsToSprite(graphicO, sprite) {
            var graphics = graphicO.child;
            if (!graphics || graphics.length < 1)
                return;
            var g = this._getGraphicsFromSprite(graphicO, sprite);
            var ox = 0;
            var oy = 0;
            if (graphicO.props) {
                ox = this._getObjVar(graphicO.props, "x", 0);
                oy = this._getObjVar(graphicO.props, "y", 0);
            }
            if (ox != 0 && oy != 0) {
                g.translate(ox, oy);
            }
            var i, len;
            len = graphics.length;
            for (i = 0; i < len; i++) {
                this._addGraphicToGraphics(graphics[i], g);
            }
            if (ox != 0 && oy != 0) {
                g.translate(-ox, -oy);
            }
        }
        static _addGraphicToSprite(graphicO, sprite, isChild = false) {
            var g = isChild ? this._getGraphicsFromSprite(graphicO, sprite) : sprite.graphics;
            this._addGraphicToGraphics(graphicO, g);
        }
        static _getGraphicsFromSprite(dataO, sprite) {
            if (!dataO || !dataO.props)
                return sprite.graphics;
            var propsName = dataO.props.renderType;
            if (propsName === "hit" || propsName === "unHit") {
                var hitArea = sprite._style.hitArea || (sprite.hitArea = new HitArea());
                if (!hitArea[propsName]) {
                    hitArea[propsName] = new Graphics();
                }
                var g = hitArea[propsName];
            }
            if (!g)
                g = sprite.graphics;
            return g;
        }
        static _getTransformData(propsO) {
            var m;
            if ("pivotX" in propsO || "pivotY" in propsO) {
                m = m || new Matrix();
                m.translate(-this._getObjVar(propsO, "pivotX", 0), -this._getObjVar(propsO, "pivotY", 0));
            }
            var sx = this._getObjVar(propsO, "scaleX", 1), sy = this._getObjVar(propsO, "scaleY", 1);
            var rotate = this._getObjVar(propsO, "rotation", 0);
            this._getObjVar(propsO, "skewX", 0);
            this._getObjVar(propsO, "skewY", 0);
            if (sx != 1 || sy != 1 || rotate != 0) {
                m = m || new Matrix();
                m.scale(sx, sy);
                m.rotate(rotate * 0.0174532922222222);
            }
            return m;
        }
        static _addGraphicToGraphics(graphicO, graphic) {
            var propsO;
            propsO = graphicO.props;
            if (!propsO)
                return;
            var drawConfig;
            drawConfig = this.DrawTypeDic[graphicO.type];
            if (!drawConfig)
                return;
            var g = graphic;
            var params = this._getParams(propsO, drawConfig[1], drawConfig[2], drawConfig[3]);
            var m = this._tM;
            if (m || this._alpha != 1) {
                g.save();
                if (m)
                    g.transform(m);
                if (this._alpha != 1)
                    g.alpha(this._alpha);
            }
            g[drawConfig[0]].apply(g, params);
            if (m || this._alpha != 1) {
                g.restore();
            }
        }
        static _adptLineData(params) {
            params[2] = parseFloat(params[0]) + parseFloat(params[2]);
            params[3] = parseFloat(params[1]) + parseFloat(params[3]);
            return params;
        }
        static _adptTextureData(params) {
            params[0] = ILaya.Loader.getRes(params[0]);
            return params;
        }
        static _adptLinesData(params) {
            params[2] = this._getPointListByStr(params[2]);
            return params;
        }
        static _isDrawType(type) {
            if (type === "Image")
                return false;
            return type in this.DrawTypeDic;
        }
        static _getParams(obj, params, xPos = 0, adptFun = null) {
            var rst = this._temParam;
            rst.length = params.length;
            var i, len;
            len = params.length;
            for (i = 0; i < len; i++) {
                rst[i] = this._getObjVar(obj, params[i][0], params[i][1]);
            }
            this._alpha = this._getObjVar(obj, "alpha", 1);
            var m;
            m = this._getTransformData(obj);
            if (m) {
                if (!xPos)
                    xPos = 0;
                m.translate(rst[xPos], rst[xPos + 1]);
                rst[xPos] = rst[xPos + 1] = 0;
                this._tM = m;
            }
            else {
                this._tM = null;
            }
            if (adptFun && this[adptFun]) {
                rst = this[adptFun](rst);
            }
            return rst;
        }
        static _getPointListByStr(str) {
            var pointArr = str.split(",");
            var i, len;
            len = pointArr.length;
            for (i = 0; i < len; i++) {
                pointArr[i] = parseFloat(pointArr[i]);
            }
            return pointArr;
        }
        static _getObjVar(obj, key, noValue) {
            if (key in obj) {
                return obj[key];
            }
            return noValue;
        }
    }
    LegacyUIParser._parseWatchData = /\${(.*?)}/g;
    LegacyUIParser._parseKeyWord = /[a-zA-Z_][a-zA-Z0-9_]*(?:(?:\.[a-zA-Z_][a-zA-Z0-9_]*)+)/g;
    LegacyUIParser.DrawTypeDic = { "Rect": ["drawRect", [["x", 0], ["y", 0], ["width", 0], ["height", 0], ["fillColor", null], ["lineColor", null], ["lineWidth", 1]]], "Circle": ["drawCircle", [["x", 0], ["y", 0], ["radius", 0], ["fillColor", null], ["lineColor", null], ["lineWidth", 1]]], "Pie": ["drawPie", [["x", 0], ["y", 0], ["radius", 0], ["startAngle", 0], ["endAngle", 0], ["fillColor", null], ["lineColor", null], ["lineWidth", 1]]], "Image": ["drawTexture", [["x", 0], ["y", 0], ["width", 0], ["height", 0]]], "Texture": ["drawTexture", [["skin", null], ["x", 0], ["y", 0], ["width", 0], ["height", 0]], 1, "_adptTextureData"], "FillTexture": ["fillTexture", [["skin", null], ["x", 0], ["y", 0], ["width", 0], ["height", 0], ["repeat", null]], 1, "_adptTextureData"], "FillText": ["fillText", [["text", ""], ["x", 0], ["y", 0], ["font", null], ["color", null], ["textAlign", null]], 1], "Line": ["drawLine", [["x", 0], ["y", 0], ["toX", 0], ["toY", 0], ["lineColor", null], ["lineWidth", 0]], 0, "_adptLineData"], "Lines": ["drawLines", [["x", 0], ["y", 0], ["points", ""], ["lineColor", null], ["lineWidth", 0]], 0, "_adptLinesData"], "Curves": ["drawCurves", [["x", 0], ["y", 0], ["points", ""], ["lineColor", null], ["lineWidth", 0]], 0, "_adptLinesData"], "Poly": ["drawPoly", [["x", 0], ["y", 0], ["points", ""], ["fillColor", null], ["lineColor", null], ["lineWidth", 1]], 0, "_adptLinesData"] };
    LegacyUIParser._temParam = [];
    class DataWatcher {
        constructor(comp, prop, value) {
            this.comp = comp;
            this.prop = prop;
            this.value = value;
        }
        exe(view) {
            var fun = LegacyUIParser.getBindFun(this.value);
            this.comp[this.prop] = fun.call(this, view);
        }
    }
    class InitTool {
        reset() {
            this._nodeRefList = null;
            this._initList = null;
            this._idMap = null;
        }
        recover() {
            this.reset();
            Pool.recover("InitTool", this);
        }
        static create() {
            var tool = Pool.getItemByClass("InitTool", InitTool);
            tool._idMap = {};
            return tool;
        }
        addNodeRef(node, prop, referStr) {
            if (!this._nodeRefList)
                this._nodeRefList = [];
            this._nodeRefList.push([node, prop, referStr]);
        }
        setNodeRef() {
            if (!this._nodeRefList)
                return;
            if (!this._idMap) {
                this._nodeRefList = null;
                return;
            }
            var i, len;
            len = this._nodeRefList.length;
            var tRefInfo;
            for (i = 0; i < len; i++) {
                tRefInfo = this._nodeRefList[i];
                tRefInfo[0][tRefInfo[1]] = this.getReferData(tRefInfo[2]);
            }
            this._nodeRefList = null;
        }
        getReferData(referStr) {
            if (referStr.indexOf("@Prefab:") >= 0) {
                return new PrefabImpl(LegacyUIParser, Loader.getRes(referStr.replace("@Prefab:", "")), 2);
            }
            else if (referStr.indexOf("@arr:") >= 0) {
                referStr = referStr.replace("@arr:", "");
                var list;
                list = referStr.split(",");
                var i, len;
                var tStr;
                len = list.length;
                var list2 = [];
                for (i = 0; i < len; i++) {
                    tStr = list[i];
                    if (tStr) {
                        list2.push(this._idMap[tStr.replace("@node:", "")]);
                    }
                    else {
                        list2.push(null);
                    }
                }
                return list2;
            }
            else {
                return this._idMap[referStr.replace("@node:", "")];
            }
        }
        addInitItem(item) {
            if (!this._initList)
                this._initList = [];
            this._initList.push(item);
        }
        doInits() {
            if (!this._initList)
                return;
            this._initList = null;
        }
        finish() {
            this.setNodeRef();
            this.doInits();
            this.recover();
        }
    }

    class Scene extends Sprite {
        constructor(createChildren = true) {
            super();
            this.autoDestroyAtClosed = false;
            this._anchorX = null;
            this._anchorY = null;
            this._viewCreated = false;
            this._timer = ILaya.timer;
            this._widget = Widget.EMPTY;
            this._scene = this;
            if (createChildren)
                this.createChildren();
        }
        createChildren() {
        }
        static setUIMap(url) {
            let uimap = ILaya.loader.getRes(url);
            if (uimap) {
                for (let key in uimap) {
                    ILaya.Loader.loadedMap[key + ".scene"] = uimap[key];
                }
            }
            else {
                throw "请提前加载uimap的json，再使用该接口设置！";
            }
        }
        loadScene(path) {
            Scene.unDestroyedScenes.add(this);
            let url = path.indexOf(".") > -1 ? path : path + ".scene";
            let content = ILaya.loader.getRes(url);
            if (content) {
                if (!this._viewCreated) {
                    content.create({ root: this });
                    this._viewCreated = true;
                    Scene.unDestroyedScenes.add(this);
                }
            }
            else {
                this._setBit(NodeFlags.NOT_READY, true);
                ILaya.loader.load(url, null, value => {
                    if (Scene._loadPage)
                        Scene._loadPage.event("progress", value);
                }).then((content) => {
                    if (!content)
                        throw "Can not find scene:" + path;
                    if (!this._viewCreated) {
                        this.url = url;
                        Scene.hideLoadingPage();
                        content.create({ root: this });
                        this._viewCreated = true;
                        Scene.unDestroyedScenes.add(this);
                    }
                    else
                        this._setBit(NodeFlags.NOT_READY, false);
                });
            }
        }
        createView(view) {
            if (view && !this._viewCreated) {
                this._viewCreated = true;
                LegacyUIParser.createByData(this, view);
            }
        }
        getNodeByID(id) {
            if (this._idMap)
                return this._idMap[id];
            return null;
        }
        open(closeOther = true, param = null) {
            if (closeOther)
                Scene.closeAll();
            Scene.root.addChild(this);
            if (this._scene3D)
                ILaya.stage.addChildAt(this._scene3D, 0);
            this.onOpened(param);
        }
        onOpened(param) {
        }
        close(type = null) {
            this.onClosed(type);
            if (this.autoDestroyAtClosed) {
                this.destroy();
                if (this._scene3D)
                    this._scene3D.destroy();
            }
            else {
                this.removeSelf();
                if (this._scene3D)
                    this._scene3D.removeSelf();
            }
        }
        onClosed(type = null) {
        }
        destroy(destroyChild = true) {
            super.destroy(destroyChild);
            if (this._scene3D) {
                this._scene3D.destroy();
                this._scene3D = null;
            }
            this._idMap = null;
            Scene.unDestroyedScenes.delete(this);
        }
        set scaleX(value) {
            if (super.get_scaleX() == value)
                return;
            super.set_scaleX(value);
            this.event(Event.RESIZE);
        }
        get scaleX() {
            return super.scaleX;
        }
        set scaleY(value) {
            if (super.get_scaleY() == value)
                return;
            super.set_scaleY(value);
            this.event(Event.RESIZE);
        }
        get scaleY() {
            return super.scaleY;
        }
        get width() {
            if (this._width)
                return this._width;
            var max = 0;
            for (var i = this.numChildren - 1; i > -1; i--) {
                var comp = this.getChildAt(i);
                if (comp._visible) {
                    max = Math.max(comp._x + comp.width * comp.scaleX, max);
                }
            }
            return max;
        }
        set width(value) {
            if (super.get_width() == value)
                return;
            super.set_width(value);
            this.callLater(this._sizeChanged);
        }
        get height() {
            if (this._height)
                return this._height;
            var max = 0;
            for (var i = this.numChildren - 1; i > -1; i--) {
                var comp = this.getChildAt(i);
                if (comp._visible) {
                    max = Math.max(comp._y + comp.height * comp.scaleY, max);
                }
            }
            return max;
        }
        set height(value) {
            if (super.get_height() == value)
                return;
            super.set_height(value);
            this.callLater(this._sizeChanged);
        }
        get timer() {
            return this._timer;
        }
        set timer(value) {
            this._timer = value;
        }
        get scene3D() {
            return this._scene3D;
        }
        get top() {
            return this._widget.top;
        }
        set top(value) {
            if (value != this._widget.top) {
                this._getWidget().top = value;
            }
        }
        get bottom() {
            return this._widget.bottom;
        }
        set bottom(value) {
            if (value != this._widget.bottom) {
                this._getWidget().bottom = value;
            }
        }
        get left() {
            return this._widget.left;
        }
        set left(value) {
            if (value != this._widget.left) {
                this._getWidget().left = value;
            }
        }
        get right() {
            return this._widget.right;
        }
        set right(value) {
            if (value != this._widget.right) {
                this._getWidget().right = value;
            }
        }
        get centerX() {
            return this._widget.centerX;
        }
        set centerX(value) {
            if (value != this._widget.centerX) {
                this._getWidget().centerX = value;
            }
        }
        get centerY() {
            return this._widget.centerY;
        }
        set centerY(value) {
            if (value != this._widget.centerY) {
                this._getWidget().centerY = value;
            }
        }
        get anchorX() {
            return this._anchorX;
        }
        set anchorX(value) {
            if (this._anchorX != value) {
                this._anchorX = value;
                this.callLater(this._sizeChanged);
            }
        }
        get anchorY() {
            return this._anchorY;
        }
        set anchorY(value) {
            if (this._anchorY != value) {
                this._anchorY = value;
                this.callLater(this._sizeChanged);
            }
        }
        _sizeChanged() {
            if (this._anchorX != null)
                this.pivotX = this.anchorX * this.width;
            if (this._anchorY != null)
                this.pivotY = this.anchorY * this.height;
            this.event(Event.RESIZE);
            if (this._widget != Widget.EMPTY) {
                this._widget.resetLayout();
            }
        }
        freshLayout() {
            if (this._widget != Widget.EMPTY) {
                this._widget.resetLayout();
            }
        }
        _getWidget() {
            this._widget === Widget.EMPTY && (this._widget = this.addComponent(Widget));
            return this._widget;
        }
        static get root() {
            let root = Scene._root;
            if (!root) {
                root = Scene._root = ILaya.stage.addChild(new Sprite());
                root.name = "root";
                root.mouseThrough = true;
                ILaya.stage.on("resize", null, () => {
                    root.size(ILaya.stage.width, ILaya.stage.height);
                    root.event(Event.RESIZE);
                });
                root.size(ILaya.stage.width, ILaya.stage.height);
                root.event(Event.RESIZE);
            }
            return root;
        }
        static load(url, complete = null, progress = null) {
            return ILaya.loader.load(url, null, value => {
                if (Scene._loadPage)
                    Scene._loadPage.event("progress", value);
                progress && progress.runWith(value);
            }).then((content) => {
                if (!content)
                    throw "Can not find scene:" + url;
                let scene;
                let errors = [];
                let ret = content.create(null, errors);
                if (errors.length > 0)
                    console.warn(`Error loading ${url}: \n${errors}`);
                if (ret instanceof Scene)
                    scene = ret;
                else if (ret._is3D) {
                    scene = new Scene();
                    scene.left = scene.right = scene.top = scene.bottom = 0;
                    scene._scene3D = ret;
                }
                else
                    throw "Not a scene:" + url;
                scene._viewCreated = true;
                Scene.hideLoadingPage();
                complete && complete.runWith(scene);
                return scene;
            });
        }
        static open(url, closeOther = true, param = null, complete = null, progress = null) {
            if (param instanceof Handler) {
                var temp = complete;
                complete = param;
                param = temp;
            }
            Scene.showLoadingPage();
            return Scene.load(url, Handler.create(null, this._onSceneLoaded, [closeOther, complete, param]), progress);
        }
        static _onSceneLoaded(closeOther, complete, param, scene) {
            scene.open(closeOther, param);
            if (complete)
                complete.runWith(scene);
        }
        static close(url, name) {
            let flag = false;
            for (let scene of Scene.unDestroyedScenes) {
                if (scene && scene.parent && scene.url === url && (name == null || scene.name == name)) {
                    scene.close();
                    flag = true;
                    break;
                }
            }
            return flag;
        }
        static closeAll() {
            let root = Scene.root;
            for (let i = 0, n = root.numChildren; i < n; i++) {
                var scene = root.getChildAt(0);
                if (scene instanceof Scene)
                    scene.close();
                else
                    scene.removeSelf();
            }
        }
        static destroy(url, name) {
            let flag = false;
            for (let scene of Scene.unDestroyedScenes) {
                if (scene.url === url && (name == null || scene.name == name) && !scene._destroyed) {
                    scene.destroy();
                    flag = true;
                    break;
                }
            }
            return flag;
        }
        static gc() {
            Resource.destroyUnusedResources();
        }
        static setLoadingPage(loadPage) {
            Scene._loadPage = loadPage;
        }
        static showLoadingPage(param = null, delay = 500) {
            if (Scene._loadPage) {
                ILaya.systemTimer.clear(null, Scene._showLoading);
                ILaya.systemTimer.clear(null, Scene._hideLoading);
                ILaya.systemTimer.once(delay, null, Scene._showLoading, [param], false);
            }
        }
        static _showLoading(param) {
            ILaya.stage.addChild(Scene._loadPage);
            if (Scene._loadPage instanceof Scene)
                Scene._loadPage.onOpened(param);
        }
        static _hideLoading() {
            if (Scene._loadPage instanceof Scene)
                Scene._loadPage.close();
            else
                Scene._loadPage.removeSelf();
        }
        static hideLoadingPage(delay = 500) {
            if (Scene._loadPage) {
                ILaya.systemTimer.clear(null, Scene._showLoading);
                ILaya.systemTimer.clear(null, Scene._hideLoading);
                ILaya.systemTimer.once(delay, null, Scene._hideLoading);
            }
        }
    }
    Scene.unDestroyedScenes = new Set();

    class BlurFilterGLRender {
        render(rt, ctx, width, height, filter) {
            var shaderValue = Value2D.create(ShaderDefines2D.TEXTURE2D, 0);
            this.setShaderInfo(shaderValue, filter, rt.width, rt.height);
            ctx.drawTarget(rt, 0, 0, width, height, Matrix.EMPTY.identity(), shaderValue);
        }
        setShaderInfo(shader, filter, w, h) {
            shader.defines.add(Filter.BLUR);
            var sv = shader;
            BlurFilterGLRender.blurinfo[0] = w;
            BlurFilterGLRender.blurinfo[1] = h;
            sv.blurInfo = BlurFilterGLRender.blurinfo;
            var sigma = filter.strength / 3.0;
            var sigma2 = sigma * sigma;
            filter.strength_sig2_2sig2_gauss1[0] = filter.strength;
            filter.strength_sig2_2sig2_gauss1[1] = sigma2;
            filter.strength_sig2_2sig2_gauss1[2] = 2.0 * sigma2;
            filter.strength_sig2_2sig2_gauss1[3] = 1.0 / (2.0 * Math.PI * sigma2);
            sv.strength_sig2_2sig2_gauss1 = filter.strength_sig2_2sig2_gauss1;
        }
    }
    BlurFilterGLRender.blurinfo = new Array(2);

    class BlurFilter extends Filter {
        constructor(strength = 4) {
            super();
            this.strength_sig2_2sig2_gauss1 = [];
            this.strength = strength;
            this._glRender = new BlurFilterGLRender();
        }
        get type() {
            return Filter.BLUR;
        }
        getStrenth_sig2_2sig2_native() {
            if (!this.strength_sig2_native) {
                this.strength_sig2_native = new Float32Array(4);
            }
            var sigma = this.strength / 3.0;
            var sigma2 = sigma * sigma;
            this.strength_sig2_native[0] = this.strength;
            this.strength_sig2_native[1] = sigma2;
            this.strength_sig2_native[2] = 2.0 * sigma2;
            this.strength_sig2_native[3] = 1.0 / (2.0 * Math.PI * sigma2);
            return this.strength_sig2_native;
        }
    }

    class GlowFilterGLRender {
        setShaderInfo(shader, w, h, data) {
            shader.defines.add(data.type);
            var sv = shader;
            sv.u_blurInfo1 = data._sv_blurInfo1;
            var info2 = data._sv_blurInfo2;
            info2[0] = w;
            info2[1] = h;
            sv.u_blurInfo2 = info2;
            sv.u_color = data.getColor();
        }
        render(rt, ctx, width, height, filter) {
            var w = width, h = height;
            var svBlur = Value2D.create(ShaderDefines2D.TEXTURE2D, 0);
            this.setShaderInfo(svBlur, w, h, filter);
            var svCP = Value2D.create(ShaderDefines2D.TEXTURE2D, 0);
            var matI = Matrix.TEMP.identity();
            ctx.drawTarget(rt, 0, 0, w, h, matI, svBlur);
            ctx.drawTarget(rt, 0, 0, w, h, matI, svCP);
        }
    }

    class GlowFilter extends Filter {
        constructor(color, blur = 4, offX = 6, offY = 6) {
            super();
            this._elements = new Float32Array(9);
            this._sv_blurInfo1 = new Array(4);
            this._sv_blurInfo2 = [0, 0, 1, 0];
            this._color = new ColorUtils(color || "#000");
            this.blur = Math.min(blur, 20);
            this.offX = offX;
            this.offY = offY;
            this._sv_blurInfo1[0] = this._sv_blurInfo1[1] = this.blur;
            this._sv_blurInfo1[2] = offX;
            this._sv_blurInfo1[3] = -offY;
            this._glRender = new GlowFilterGLRender();
        }
        get type() {
            return BlurFilter.GLOW;
        }
        get offY() {
            return this._elements[6];
        }
        set offY(value) {
            this._elements[6] = value;
            this._sv_blurInfo1[3] = -value;
        }
        get offX() {
            return this._elements[5];
        }
        set offX(value) {
            this._elements[5] = value;
            this._sv_blurInfo1[2] = value;
        }
        get color() {
            return this._color.strColor;
        }
        set color(value) {
            this._color = new ColorUtils(value);
        }
        getColor() {
            return this._color.arrColor;
        }
        get blur() {
            return this._elements[4];
        }
        set blur(value) {
            this._elements[4] = value;
            this._sv_blurInfo1[0] = this._sv_blurInfo1[1] = value;
        }
        getColorNative() {
            if (!this._color_native) {
                this._color_native = new Float32Array(4);
            }
            var color = this.getColor();
            this._color_native[0] = color[0];
            this._color_native[1] = color[1];
            this._color_native[2] = color[2];
            this._color_native[3] = color[3];
            return this._color_native;
        }
        getBlurInfo1Native() {
            if (!this._blurInof1_native) {
                this._blurInof1_native = new Float32Array(4);
            }
            this._blurInof1_native[0] = this._blurInof1_native[1] = this.blur;
            this._blurInof1_native[2] = this.offX;
            this._blurInof1_native[3] = this.offY;
            return this._blurInof1_native;
        }
        getBlurInfo2Native() {
            if (!this._blurInof2_native) {
                this._blurInof2_native = new Float32Array(4);
            }
            this._blurInof2_native[2] = 1;
            return this._blurInof2_native;
        }
    }

    class SoundNode extends Sprite {
        constructor() {
            super();
            this.visible = false;
            this.on(Event.ADDED, this, this._onParentChange);
            this.on(Event.REMOVED, this, this._onParentChange);
        }
        get source() {
            return this._source;
        }
        set source(value) {
            this._source = value;
            if (!value)
                this.stop();
        }
        _onParentChange() {
            this.target = this.parent;
        }
        play(loops = 1, complete = null) {
            if (isNaN(loops)) {
                loops = 1;
            }
            if (!this._source)
                return;
            this.stop();
            this._channel = SoundManager.playSound(this._source, loops, complete);
        }
        stop() {
            if (this._channel && !this._channel.isStopped) {
                this._channel.stop();
            }
            this._channel = null;
        }
        _setPlayAction(tar, event, action, add = true) {
            if (!this[action])
                return;
            if (!tar)
                return;
            if (add) {
                tar.on(event, this, this[action]);
            }
            else {
                tar.off(event, this, this[action]);
            }
        }
        _setPlayActions(tar, events, action, add = true) {
            if (!tar)
                return;
            if (!events)
                return;
            var eventArr = events.split(",");
            var i, len;
            len = eventArr.length;
            for (i = 0; i < len; i++) {
                this._setPlayAction(tar, eventArr[i], action, add);
            }
        }
        set playEvent(events) {
            this._playEvents = events;
            if (!events)
                return;
            if (this._tar) {
                this._setPlayActions(this._tar, events, "play");
            }
        }
        set target(tar) {
            if (this._tar) {
                this._setPlayActions(this._tar, this._playEvents, "play", false);
                this._setPlayActions(this._tar, this._stopEvents, "stop", false);
            }
            this._tar = tar;
            if (this._tar) {
                this._setPlayActions(this._tar, this._playEvents, "play", true);
                this._setPlayActions(this._tar, this._stopEvents, "stop", true);
            }
        }
        set stopEvent(events) {
            this._stopEvents = events;
            if (!events)
                return;
            if (this._tar) {
                this._setPlayActions(this._tar, events, "stop");
            }
        }
    }

    class VideoTexture extends BaseTexture {
        constructor() {
            let ele = ILaya.Browser.createElement("video");
            super(ele.videoWidth, ele.videoHeight, exports.RenderTargetFormat.R8G8B8);
            this._needUpdate = false;
            this._frameRender = true;
            this._isLoaded = false;
            this.immediatelyPlay = false;
            this.element = ele;
            this._listeningEvents = {};
            this._dimension = exports.TextureDimension.Tex2D;
            var style = this.element.style;
            style.position = 'absolute';
            style.top = '0px';
            style.left = '0px';
            ele.setAttribute('crossorigin', 'anonymous');
            if (ILaya.Browser.onMobile) {
                ele["x5-playsInline"] = true;
                ele["x5-playsinline"] = true;
                ele.x5PlaysInline = true;
                ele.playsInline = true;
                ele["webkit-playsInline"] = true;
                ele["webkit-playsinline"] = true;
                ele.webkitPlaysInline = true;
                ele.playsinline = true;
                ele.style.playsInline = true;
                ele.crossOrigin = "anonymous";
                ele.setAttribute('playsinline', 'true');
                ele.setAttribute('x5-playsinline', 'true');
                ele.setAttribute('webkit-playsinline', 'true');
                ele.autoplay = true;
            }
            ele.addEventListener("loadedmetadata", () => {
                this.loadedmetadata();
            });
            const scope = this;
            function updateVideo() {
                scope._needUpdate = true;
                ele.requestVideoFrameCallback(updateVideo);
            }
            if ('requestVideoFrameCallback' in ele) {
                ele.requestVideoFrameCallback(updateVideo);
            }
            if (ILaya.Browser.onWeiXin) {
                this.loadedmetadata();
            }
        }
        isNeedUpdate() {
            return this._needUpdate;
        }
        loadedmetadata() {
            if (this._isLoaded)
                return;
            this._width = this.element.videoWidth;
            this._height = this.element.videoHeight;
            this._texture = LayaGL.textureContext.createTextureInternal(this._dimension, this.element.videoWidth, this.element.videoHeight, exports.TextureFormat.R8G8B8, false, false);
            this.wrapModeU = exports.WrapMode.Clamp;
            this.wrapModeV = exports.WrapMode.Clamp;
            this.filterMode = exports.FilterMode.Bilinear;
            LayaGL.textureContext.initVideoTextureData(this._texture);
            this._texture.gammaCorrection = 2.2;
            if (this.immediatelyPlay) {
                this.play();
            }
            this._isLoaded = true;
            this.event(Event.READY, this);
        }
        get source() {
            return this._source;
        }
        get gammaCorrection() {
            return 2.2;
        }
        set source(url) {
            this._source = url;
            if (!url)
                return;
            AssetDb.inst.resolveURL(url, url => {
                while (this.element.childElementCount)
                    this.element.firstChild.remove();
                if (url.startsWith("blob:"))
                    this.element.src = url;
                else
                    this.appendSource(url);
            });
        }
        appendSource(source) {
            var sourceElement = ILaya.Browser.createElement("source");
            sourceElement.src = URL.postFormatURL(URL.formatURL(source));
            sourceElement.type = "video/" + Utils.getFileExtension(source);
            this.element.appendChild(sourceElement);
        }
        render() {
            if (this.element.readyState == 0)
                return;
            if (this.isNeedUpdate()) {
                LayaGL.textureContext.updateVideoTexture(this._texture, this.element, false, false);
                this._needUpdate = false;
            }
        }
        set frameRender(value) {
            if (this._frameRender && !value) {
                ILaya.timer.clear(this, this.render);
            }
            if (!this._frameRender && value) {
                ILaya.timer.frameLoop(1, this, this.render);
            }
            this._frameRender = value;
        }
        get frameRender() {
            return this._frameRender;
        }
        play() {
            if (!this._texture) {
                this.immediatelyPlay = true;
            }
            else {
                this.element.play();
                if (this._frameRender) {
                    ILaya.timer.frameLoop(1, this, this.render);
                }
            }
        }
        _getSource() {
            return this._texture ? this._texture.resource : null;
        }
        get defaultTexture() {
            return Texture2D.whiteTexture;
        }
        pause() {
            this.element.pause();
            if (this._frameRender) {
                ILaya.timer.clear(this, this.render);
            }
        }
        load() {
            this.element.load();
        }
        canPlayType(type) {
            var typeString;
            switch (type) {
                case 1:
                    typeString = "video/mp4";
                    break;
                case 2:
                    typeString = "video/ogg";
                    break;
                case 8:
                    typeString = "video/webm";
                    break;
            }
            return this.element.canPlayType(typeString);
        }
        get buffered() {
            return this.element.buffered;
        }
        get currentSrc() {
            return this.element.currentSrc;
        }
        get currentTime() {
            return this.element.currentTime;
        }
        set currentTime(value) {
            if (!this.element)
                return;
            this.element.currentTime = value;
            this.render();
        }
        set volume(value) {
            if (!this.element)
                return;
            this.element.volume = value;
        }
        get volume() {
            return this.element.volume;
        }
        get readyState() {
            return this.element.readyState;
        }
        get videoWidth() {
            return this.element.videoWidth;
        }
        get videoHeight() {
            return this.element.videoHeight;
        }
        get duration() {
            return this.element.duration;
        }
        get ended() {
            return this.element.ended;
        }
        get error() {
            return this.element.error;
        }
        get loop() {
            return this.element.loop;
        }
        set loop(value) {
            if (!this.element)
                return;
            this.element.loop = value;
        }
        get playbackRate() {
            return this.element.playbackRate;
        }
        set playbackRate(value) {
            if (!this.element)
                return;
            this.element.playbackRate = value;
        }
        get muted() {
            return this.element.muted;
        }
        set muted(value) {
            if (!this.element)
                return;
            this.element.muted = value;
        }
        get paused() {
            return this.element.paused;
        }
        get preload() {
            return this.element.preload;
        }
        set preload(value) {
            if (!this.element)
                return;
            this.element.preload = value;
        }
        get seekable() {
            return this.element.seekable;
        }
        get seeking() {
            return this.element.seeking;
        }
        onStartListeningToType(type) {
            if (videoEvents.has(type)) {
                let func = this._listeningEvents[type];
                if (!func)
                    func = this._listeningEvents[type] = () => {
                        this.event(type);
                    };
                this.element.addEventListener(type, func);
            }
        }
        destroy() {
            var isConchApp = LayaEnv.isConch;
            if (isConchApp) {
                this.element._destroy();
            }
            ILaya.timer.clear(this, this.render);
            super.destroy();
        }
    }
    const videoEvents = new Set([
        "abort", "canplay", "canplaythrough", "durationchange", "emptied", "error", "loadeddata",
        "loadedmetadata", "loadstart", "pause", "play", "playing", "progress", "ratechange", "seeked", "seeking",
        "stalled", "suspend", "timeupdate", "volumechange", "waiting"
    ]);

    class VideoNode extends Sprite {
        constructor() {
            super();
            this.texture = this._internalTex = new Texture();
            if (LayaEnv.isPlaying && ILaya.Browser.onMobile) {
                let func = () => {
                    ILaya.Browser.document.removeEventListener("touchend", func);
                    if (!this._videoTexture)
                        return;
                    if (Browser.onIOS) {
                        this._videoTexture.load();
                    }
                    else {
                        this._videoTexture.play();
                        this._videoTexture.pause();
                    }
                };
                ILaya.Browser.document.addEventListener("touchend", func);
            }
        }
        get videoTexture() {
            return this._videoTexture;
        }
        set videoTexture(value) {
            if (this._videoTexture) {
                this._videoTexture._removeReference();
                this._videoTexture.off(Event.READY, this, this.onVideoMetaLoaded);
            }
            this._videoTexture = value;
            if (value) {
                this._videoTexture._addReference();
                this._videoTexture.on(Event.READY, this, this.onVideoMetaLoaded);
                if (this._videoTexture._isLoaded)
                    this._internalTex.setTo(this._videoTexture);
            }
            else {
                this._internalTex.setTo(null);
            }
        }
        get source() {
            var _a;
            return (_a = this._videoTexture) === null || _a === void 0 ? void 0 : _a.source;
        }
        set source(value) {
            if (value) {
                if (!this._videoTexture)
                    this.videoTexture = new VideoTexture();
                this._videoTexture.source = value;
            }
            else if (this._videoTexture)
                this._videoTexture.source = value;
        }
        load(url) {
            this.source = url;
        }
        play() {
            if (!this._videoTexture)
                return;
            this._videoTexture.play();
        }
        pause() {
            if (!this._videoTexture)
                return;
            this._videoTexture.pause();
        }
        reload() {
            if (!this._videoTexture)
                return;
            this._videoTexture.load();
        }
        canPlayType(type) {
            if (!this._videoTexture)
                this.videoTexture = new VideoTexture();
            return this._videoTexture.canPlayType(type);
        }
        onVideoMetaLoaded() {
            this._internalTex.setTo(this._videoTexture);
        }
        get buffered() {
            var _a;
            return (_a = this._videoTexture) === null || _a === void 0 ? void 0 : _a.buffered;
        }
        get currentSrc() {
            var _a;
            return (_a = this._videoTexture) === null || _a === void 0 ? void 0 : _a.currentSrc;
        }
        get currentTime() {
            var _a;
            return (_a = this._videoTexture) === null || _a === void 0 ? void 0 : _a.currentTime;
        }
        set currentTime(value) {
            if (!this._videoTexture)
                return;
            this._videoTexture.currentTime = value;
        }
        set volume(value) {
            if (!this._videoTexture)
                return;
            this._videoTexture.volume = value;
        }
        get volume() {
            var _a;
            return (_a = this._videoTexture) === null || _a === void 0 ? void 0 : _a.volume;
        }
        get readyState() {
            var _a;
            return (_a = this._videoTexture) === null || _a === void 0 ? void 0 : _a.readyState;
        }
        get videoWidth() {
            var _a;
            return (_a = this._videoTexture) === null || _a === void 0 ? void 0 : _a.videoWidth;
        }
        get videoHeight() {
            var _a;
            return (_a = this._videoTexture) === null || _a === void 0 ? void 0 : _a.videoHeight;
        }
        get duration() {
            var _a;
            return (_a = this._videoTexture) === null || _a === void 0 ? void 0 : _a.duration;
        }
        get ended() {
            var _a;
            return (_a = this._videoTexture) === null || _a === void 0 ? void 0 : _a.ended;
        }
        get error() {
            var _a;
            return (_a = this._videoTexture) === null || _a === void 0 ? void 0 : _a.error;
        }
        get loop() {
            var _a;
            return (_a = this._videoTexture) === null || _a === void 0 ? void 0 : _a.loop;
        }
        set loop(value) {
            if (!this._videoTexture)
                return;
            this._videoTexture.loop = value;
        }
        get playbackRate() {
            var _a;
            return (_a = this._videoTexture) === null || _a === void 0 ? void 0 : _a.playbackRate;
        }
        set playbackRate(value) {
            if (!this._videoTexture)
                return;
            this._videoTexture.playbackRate = value;
        }
        get muted() {
            var _a;
            return (_a = this._videoTexture) === null || _a === void 0 ? void 0 : _a.muted;
        }
        set muted(value) {
            if (!this._videoTexture)
                return;
            this._videoTexture.muted = value;
        }
        get paused() {
            var _a;
            return (_a = this._videoTexture) === null || _a === void 0 ? void 0 : _a.paused;
        }
        get preload() {
            var _a;
            return (_a = this._videoTexture) === null || _a === void 0 ? void 0 : _a.preload;
        }
        set preload(value) {
            if (!this._videoTexture)
                return;
            this._videoTexture.preload = value;
        }
        get seekable() {
            var _a;
            return (_a = this._videoTexture) === null || _a === void 0 ? void 0 : _a.seekable;
        }
        get seeking() {
            var _a;
            return (_a = this._videoTexture) === null || _a === void 0 ? void 0 : _a.seeking;
        }
        _setX(value) {
            super._setX(value);
            if (this._videoTexture && LayaEnv.isConch) {
                var transform = SpriteUtils.getTransformRelativeToWindow(this, 0, 0);
                this._videoTexture.element.style.left = transform.x;
            }
        }
        _setY(value) {
            super._setY(value);
            if (this._videoTexture && LayaEnv.isConch) {
                var transform = SpriteUtils.getTransformRelativeToWindow(this, 0, 0);
                this._videoTexture.element.style.top = transform.y;
            }
        }
        set_width(value) {
            super.set_width(value);
            if (!this._videoTexture)
                return;
            if (LayaEnv.isConch) {
                var transform = SpriteUtils.getTransformRelativeToWindow(this, 0, 0);
                this._videoTexture.element.width = value * transform.scaleX;
            }
            else {
                this._videoTexture.element.width = this.width / ILaya.Browser.pixelRatio;
            }
        }
        set_height(value) {
            super.set_height(value);
            if (!this._videoTexture)
                return;
            if (LayaEnv.isConch) {
                var transform = SpriteUtils.getTransformRelativeToWindow(this, 0, 0);
                this._videoTexture.element.height = value * transform.scaleY;
            }
            else {
                this._videoTexture.element.height = this.height / ILaya.Browser.pixelRatio;
            }
        }
        destroy(detroyChildren = true) {
            this.videoTexture = null;
            super.destroy(detroyChildren);
        }
    }

    class AnimatorPlayState2D {
        constructor() {
            this._currentState = null;
            this._frontPlay = true;
        }
        get duration() {
            return this._duration;
        }
        get animatorState() {
            return this._currentState;
        }
        _resetPlayState(startTime, clipDuration) {
            this._finish = false;
            this._startPlayTime = startTime;
            this._elapsedTime = startTime;
            this._playEventIndex = 0;
            this._lastIsFront = true;
            this._playNum = 0;
            this._playAllTime = 0;
            var playTime = (this._elapsedTime / clipDuration) % 1.0;
            this._normalizedPlayTime = playTime < 0 ? playTime + 1.0 : playTime;
            this._frontPlay = true;
        }
        _cloneTo(dest) {
            dest._finish = this._finish;
            dest._startPlayTime = this._startPlayTime;
            dest._elapsedTime = this._elapsedTime;
            dest._playNum = this._playNum;
            dest._normalizedPlayTime = this._normalizedPlayTime;
            dest._playEventIndex = this._playEventIndex;
            dest._lastIsFront = this._lastIsFront;
            dest._frontPlay = this._frontPlay;
            dest._playAllTime = this._playAllTime;
        }
    }

    class AnimatorControllerLayer2D {
        constructor(name) {
            this._referenceCount = 0;
            this._playStateInfo = new AnimatorPlayState2D();
            this._crossPlayStateInfo = new AnimatorPlayState2D();
            this._crossMark = 0;
            this._crossNodesOwnersCount = 0;
            this._crossNodesOwnersIndicesMap = {};
            this._srcCrossClipNodeIndices = [];
            this._destCrossClipNodeIndices = [];
            this.playOnWake = true;
            this.defaultWeight = 1.0;
            this.blendingMode = AnimatorControllerLayer2D.BLENDINGMODE_OVERRIDE;
            this.enable = true;
            this._states = [];
            this._playType = -1;
            this.name = name;
        }
        set states(states) {
            if (this._states === states)
                return;
            for (let i = this.states.length - 1; i >= 0; i--) {
                this.removeState(this.states[i]);
            }
            for (let i = states.length - 1; i >= 0; i--) {
                this.addState(states[i]);
            }
        }
        get states() {
            return this._states;
        }
        set defaultStateName(str) {
            this._defaultState = this.getStateByName(str);
            if (null == this._defaultState) {
                if (0 == this._states.length) {
                    this._defaultStateNameCatch = str;
                }
                else {
                    for (var i = this._states.length - 1; i >= 0; i--) {
                        if (this._states[i].name == str) {
                            this._defaultState = this._states[i];
                            break;
                        }
                    }
                }
            }
        }
        get defaultStateName() {
            if (!this._defaultState) {
                return null;
            }
            return this._defaultState.name;
        }
        get defaultState() {
            return this._defaultState;
        }
        set defaultState(value) {
            this._defaultState = value;
        }
        _removeClip(clipStateInfos, index, state) {
            clipStateInfos.splice(index, 1);
        }
        _getReferenceCount() {
            return this._referenceCount;
        }
        _addReference(count) {
            for (var i = 0, n = this._states.length; i < n; i++)
                this._states[i]._addReference(count);
            this._referenceCount += count;
        }
        _removeReference(count = 1) {
            for (var i = 0, n = this._states.length; i < n; i++)
                this._states[i]._removeReference(count);
            this._referenceCount -= count;
        }
        _clearReference() {
            this._removeReference(-this._referenceCount);
        }
        getCurrentPlayState() {
            return this._playStateInfo;
        }
        getStateByName(str) {
            for (let i = this._states.length - 1; i >= 0; i--) {
                if (this._states[i].name == str) {
                    return this._states[i];
                }
            }
            return null;
        }
        addState(state) {
            var stateName = state.name;
            if (this.getStateByName(stateName)) {
                throw "AnimatorControllerLayer:this stat's name has exist.";
            }
            else {
                this._states.push(state);
                if (stateName == this._defaultStateNameCatch) {
                    this._defaultState = state;
                    this._defaultStateNameCatch = null;
                }
            }
        }
        removeState(state) {
            var states = this._states;
            var index = -1;
            for (var i = 0, n = states.length; i < n; i++) {
                if (states[i] === state) {
                    index = i;
                    break;
                }
            }
            if (-1 != index)
                this._removeClip(states, index, state);
        }
        clone() {
            var dest = new AnimatorControllerLayer2D(this.name);
            this.cloneTo(dest);
            return dest;
        }
        cloneTo(destObject) {
            var dest = destObject;
            dest.name = this.name;
        }
        destroy() {
            this._removeReference();
            for (var i = 0, n = this._states.length; i < n; i++) {
                this._states[i].destroy();
            }
            this._states.length = 0;
        }
    }
    AnimatorControllerLayer2D.BLENDINGMODE_OVERRIDE = 0;
    AnimatorControllerLayer2D.BLENDINGMODE_ADDTIVE = 1;

    exports.AniParmType = void 0;
    (function (AniParmType) {
        AniParmType[AniParmType["Float"] = 0] = "Float";
        AniParmType[AniParmType["Bool"] = 1] = "Bool";
        AniParmType[AniParmType["Trigger"] = 2] = "Trigger";
    })(exports.AniParmType || (exports.AniParmType = {}));
    exports.AniStateConditionType = void 0;
    (function (AniStateConditionType) {
        AniStateConditionType[AniStateConditionType["Number"] = 0] = "Number";
        AniStateConditionType[AniStateConditionType["Bool"] = 1] = "Bool";
        AniStateConditionType[AniStateConditionType["Trigger"] = 2] = "Trigger";
    })(exports.AniStateConditionType || (exports.AniStateConditionType = {}));
    exports.AniStateConditionNumberCompressType = void 0;
    (function (AniStateConditionNumberCompressType) {
        AniStateConditionNumberCompressType[AniStateConditionNumberCompressType["Less"] = 0] = "Less";
        AniStateConditionNumberCompressType[AniStateConditionNumberCompressType["Greater"] = 1] = "Greater";
    })(exports.AniStateConditionNumberCompressType || (exports.AniStateConditionNumberCompressType = {}));
    class AnimatorControllerParse {
        static parse(data) {
            let ret = data;
            let layers = ret.controllerLayers;
            if (null == layers) {
                layers = [];
            }
            let clipsID = [];
            for (let i = layers.length - 1; i >= 0; i--) {
                let l = layers[i];
                let states = l.states;
                if (!states) {
                    states = [];
                    l.states = states;
                }
                l.defaultStateName = null;
                let retobj = this.checkStates(states, clipsID, ret);
                if (retobj) {
                    l.defaultStateName = retobj.enterName;
                }
                else {
                    layers.splice(i, 1);
                }
            }
            return { ret: ret, clipsID: clipsID };
        }
        static checkStates(states, clipsID, data) {
            let clipState = null;
            let enterState = null;
            for (let j = states.length - 1; j >= 0; j--) {
                let state = states[j];
                if (state.states) {
                    if (null == this.checkStates(state.states, clipsID, data)) {
                        states.splice(j, 1);
                    }
                    else {
                        if (null == clipState) {
                            clipState = [];
                        }
                        clipState.push(state);
                    }
                }
                else if ("-1" == state.id) {
                    enterState = state;
                }
                else if ("-2" == state.id) ;
                else if ("-3" == state.id) ;
                else if (null == state.clip || null == state.clip._$uuid || "" == state.clip._$uuid) {
                    states.splice(j, 1);
                }
                else {
                    if (0 > clipsID.indexOf(state.clip._$uuid)) {
                        clipsID.push(state.clip._$uuid);
                    }
                    this.checkNext(state, states, data);
                    if (null == clipState) {
                        clipState = [];
                    }
                    clipState.push(state);
                }
            }
            let ret = null;
            if (clipState && enterState) {
                let defName = this.checkDefault(enterState, clipState);
                if (null != defName) {
                    ret = { states: clipState, enterName: defName };
                }
            }
            return ret;
        }
        static checkNext(state, states, data) {
            let nexts = state.soloTransitions;
            if (nexts) {
                for (let i = nexts.length - 1; i >= 0; i--) {
                    let next = nexts[i];
                    let nState = this.getStateByID(states, next.id);
                    if (!nState || (null == nState.clip && "-3" != nState.id && null == nState.states)) {
                        nexts.splice(i, 1);
                    }
                    else {
                        next.name = nState.name;
                        next.conditions = this.checkConditions(next.conditions, data);
                    }
                }
            }
        }
        static checkConditions(conditions, data) {
            if (!conditions || 0 == conditions.length || null == data.animatorParams || 0 == data.animatorParams.length) {
                return [];
            }
            let parms = data.animatorParams;
            for (let i = conditions.length - 1; i >= 0; i--) {
                let o = conditions[i];
                let parm = null;
                for (let j = parms.length - 1; j >= 0; j--) {
                    if (parms[j].id == o.id) {
                        parm = parms[j];
                        break;
                    }
                }
                if (null == parm) {
                    conditions.splice(i, 1);
                }
                else {
                    o.name = parm.name;
                    if (parm.type == exports.AniParmType.Float) {
                        let num = Number(o.checkValue);
                        if (isNaN(num)) {
                            o.checkValue = 0;
                        }
                        num = Number(o.type);
                        if (isNaN(num)) {
                            o.type = 0;
                        }
                    }
                }
            }
            return conditions;
        }
        static checkDefault(state, states) {
            let nexts = state.soloTransitions;
            let id = null;
            if (nexts && 0 < nexts.length) {
                id = nexts[0].id;
            }
            let defState = null;
            if (null != id) {
                defState = this.getStateByID(states, id);
            }
            if (null != defState && (null != defState.clip || null != defState.states)) {
                return defState.name;
            }
            for (let i = states.length - 1; i >= 0; i--) {
                if (states[i].clip) {
                    return states[i].name;
                }
            }
            return null;
        }
        static getStateByID(states, id) {
            if (states) {
                for (let i = states.length - 1; i >= 0; i--) {
                    if (states[i].id == id) {
                        return states[i];
                    }
                }
            }
            return null;
        }
    }

    exports.AnimatorUpdateMode = void 0;
    (function (AnimatorUpdateMode) {
        AnimatorUpdateMode[AnimatorUpdateMode["Normal"] = 0] = "Normal";
        AnimatorUpdateMode[AnimatorUpdateMode["LowFrame"] = 1] = "LowFrame";
        AnimatorUpdateMode[AnimatorUpdateMode["UnScaleTime"] = 2] = "UnScaleTime";
    })(exports.AnimatorUpdateMode || (exports.AnimatorUpdateMode = {}));

    class Animator2D extends Component {
        constructor() {
            super();
            this._speed = 1;
            this._updateMode = exports.AnimatorUpdateMode.Normal;
            this._lowUpdateDelty = 20;
            this._isPlaying = true;
            this._controllerLayers = [];
            this._parameters = {};
        }
        set controller(val) {
            this._controller = val;
            if (val) {
                val.updateTo(this);
            }
        }
        get controller() {
            return this._controller;
        }
        set parameters(val) {
            this._parameters = val;
        }
        get parameters() {
            return this._parameters;
        }
        set speed(num) {
            this._speed = num;
        }
        get speed() {
            return this._speed;
        }
        get isPlaying() {
            return this._isPlaying;
        }
        _updateStateFinish(animatorState, playState) {
            if (playState._finish) {
                animatorState._eventExit();
            }
        }
        _setClipDatasToNode(stateInfo, additive, weight, isFirstLayer, controllerLayer = null) {
            var realtimeDatas = stateInfo._realtimeDatas;
            var nodes = stateInfo._clip._nodes;
            for (var i = 0, n = nodes.count; i < n; i++) {
                var node = nodes.getNodeByIndex(i);
                var o = this.getOwner(node);
                o && this._applyFloat(o, additive, weight, isFirstLayer, realtimeDatas[i]);
            }
        }
        _applyFloat(o, additive, weight, isFirstLayer, data) {
            var pro = o.pro;
            if (pro && pro.ower) {
                if (additive && "number" == typeof data) {
                    pro.ower[pro.key] = pro.defVal + weight * data;
                }
                else if ("number" == typeof data) {
                    pro.ower[pro.key] = weight * data;
                }
                else {
                    pro.ower[pro.key] = data;
                }
            }
        }
        getOwner(node) {
            var ret;
            if (this._ownerMap) {
                ret = this._ownerMap.get(node);
                if (ret) {
                    return ret;
                }
            }
            var property = this.owner;
            for (var j = 0, m = node.ownerPathCount; j < m; j++) {
                var ownPat = node.getOwnerPathByIndex(j);
                if ("" == ownPat) {
                    continue;
                }
                else {
                    property = property.getChildByName(ownPat);
                    if (!property)
                        break;
                }
            }
            ret = { ower: property };
            if (property) {
                var pobj = property;
                var propertyCount = node.propertyCount;
                if (1 == propertyCount) {
                    var pname = node.getPropertyByIndex(0);
                    ret.pro = { ower: property, key: pname, defVal: property[pname] };
                }
                else {
                    for (var i = 0; i < propertyCount; i++) {
                        var pname = node.getPropertyByIndex(i);
                        if (i == propertyCount - 1 || null == pobj) {
                            ret.pro = { ower: pobj, key: pname, defVal: pobj ? pobj[pname] : null };
                            break;
                        }
                        if (null == pobj[pname] && property == pobj) {
                            pobj = null;
                            var classObj = ClassUtils.getClass(pname);
                            if (classObj) {
                                pobj = property.getComponent(classObj);
                            }
                        }
                        else {
                            pobj = pobj[pname];
                        }
                    }
                }
            }
            if (null == this._ownerMap) {
                this._ownerMap = new Map();
            }
            this._ownerMap.set(node, ret);
            return ret;
        }
        _updateClipDatas(animatorState, addtive, playStateInfo) {
            var clip = animatorState._clip;
            var clipDuration = clip._duration;
            var curPlayTime = animatorState.clipStart * clipDuration + playStateInfo._normalizedPlayTime * playStateInfo._duration;
            var currentFrameIndices = animatorState._currentFrameIndices;
            let frontPlay = true;
            clip._evaluateClipDatasRealTime(curPlayTime, currentFrameIndices, addtive, frontPlay, animatorState._realtimeDatas);
        }
        _updatePlayer(animatorState, playState, elapsedTime, loop, layerIndex) {
            let isReplay = false;
            var clipDuration = animatorState._clip._duration * (animatorState.clipEnd - animatorState.clipStart);
            var lastElapsedTime = playState._elapsedTime;
            let pAllTime = playState._playAllTime;
            playState._playAllTime += Math.abs(elapsedTime);
            elapsedTime = lastElapsedTime + elapsedTime;
            playState._lastElapsedTime = lastElapsedTime;
            playState._elapsedTime = elapsedTime;
            var normalizedTime = elapsedTime / clipDuration;
            let scale = 1;
            if (animatorState.yoyo) {
                scale = 2;
            }
            let pTime = playState._playAllTime / (clipDuration * scale);
            if (Math.floor(pAllTime / (clipDuration * scale)) < Math.floor(pTime)) {
                isReplay = true;
            }
            var playTime = normalizedTime % 1.0;
            let normalizedPlayTime = playTime < 0 ? playTime + 1.0 : playTime;
            playState._normalizedPlayTime = normalizedPlayTime;
            playState._duration = clipDuration;
            if (1 != scale) {
                normalizedTime = playState._playAllTime / (clipDuration * scale);
                playTime = normalizedTime % 1.0;
                normalizedPlayTime = playTime < 0 ? playTime + 1.0 : playTime;
                if (animatorState.yoyo) {
                    if (0.5 > normalizedPlayTime) {
                        if (!playState._frontPlay) {
                            if (0 > animatorState.speed) {
                                playState._elapsedTime = animatorState.clipEnd;
                                playState._normalizedPlayTime = animatorState.clipEnd;
                            }
                            else {
                                playState._elapsedTime = animatorState.clipStart;
                                playState._normalizedPlayTime = animatorState.clipStart;
                            }
                            playState._frontPlay = true;
                        }
                    }
                    else {
                        if (playState._frontPlay) {
                            playState._frontPlay = false;
                            if (0 > animatorState.speed) {
                                playState._elapsedTime = animatorState.clipStart;
                                playState._normalizedPlayTime = animatorState.clipStart;
                            }
                            else {
                                playState._elapsedTime = animatorState.clipEnd;
                                playState._normalizedPlayTime = animatorState.clipEnd;
                            }
                        }
                    }
                }
            }
            animatorState._eventStateUpdate(normalizedPlayTime);
            let ret = this._applyTransition(layerIndex, animatorState._eventtransition(normalizedPlayTime, this.parameters, isReplay));
            if (!ret && isReplay) {
                let absTime = playState._playAllTime / (clipDuration * scale);
                if (0 < loop && loop <= absTime) {
                    playState._finish = true;
                    if (0 > animatorState.speed) {
                        if (animatorState.yoyo) {
                            playState._elapsedTime = animatorState.clipEnd;
                            playState._normalizedPlayTime = animatorState.clipEnd;
                        }
                        else {
                            playState._elapsedTime = animatorState.clipStart;
                            playState._normalizedPlayTime = animatorState.clipStart;
                        }
                    }
                    else {
                        if (animatorState.yoyo) {
                            playState._elapsedTime = animatorState.clipStart;
                            playState._normalizedPlayTime = animatorState.clipStart;
                        }
                        else {
                            playState._elapsedTime = animatorState.clipEnd;
                            playState._normalizedPlayTime = animatorState.clipEnd;
                        }
                    }
                    return;
                }
            }
        }
        _updateEventScript(stateInfo, playStateInfo) {
            let clip = stateInfo._clip;
            let events = clip._animationEvents;
            let clipDuration = clip._duration;
            let elapsedTime = playStateInfo._elapsedTime;
            let time = elapsedTime % clipDuration;
            let loopCount = Math.abs(Math.floor(elapsedTime / clipDuration) - Math.floor(playStateInfo._lastElapsedTime / clipDuration));
            let frontPlay = playStateInfo._elapsedTime >= playStateInfo._lastElapsedTime;
            if (playStateInfo._lastIsFront !== frontPlay) {
                if (frontPlay)
                    playStateInfo._playEventIndex++;
                else
                    playStateInfo._playEventIndex--;
                playStateInfo._lastIsFront = frontPlay;
            }
            let preEventIndex = playStateInfo._playEventIndex;
            if (frontPlay) {
                let newEventIndex = this._eventScript(events, playStateInfo._playEventIndex, loopCount > 0 ? clipDuration : time, true);
                (preEventIndex === playStateInfo._playEventIndex) && (playStateInfo._playEventIndex = newEventIndex);
                for (let i = 0, n = loopCount - 1; i < n; i++)
                    this._eventScript(events, 0, clipDuration, true);
                (loopCount > 0 && time > 0) && (playStateInfo._playEventIndex = this._eventScript(events, 0, time, true));
            }
            else {
                let newEventIndex = this._eventScript(events, playStateInfo._playEventIndex, loopCount > 0 ? 0 : time, false);
                (preEventIndex === playStateInfo._playEventIndex) && (playStateInfo._playEventIndex = newEventIndex);
                let eventIndex = events.length - 1;
                for (let i = 0, n = loopCount - 1; i < n; i++)
                    this._eventScript(events, eventIndex, 0, false);
                (loopCount > 0 && time > 0) && (playStateInfo._playEventIndex = this._eventScript(events, eventIndex, time, false));
            }
        }
        _eventScript(events, eventIndex, endTime, front) {
            let scripts = this.owner.components;
            if (front) {
                for (let n = events.length; eventIndex < n; eventIndex++) {
                    let event = events[eventIndex];
                    if (event.time <= endTime) {
                        for (let j = 0, m = scripts.length; j < m; j++) {
                            let script = scripts[j];
                            if (script._isScript()) {
                                let fun = script[event.eventName];
                                (fun) && (fun.apply(script, event.params));
                            }
                        }
                    }
                    else {
                        break;
                    }
                }
            }
            else {
                for (; eventIndex >= 0; eventIndex--) {
                    let event = events[eventIndex];
                    if (event.time >= endTime) {
                        for (let j = 0, m = scripts.length; j < m; j++) {
                            let script = scripts[j];
                            if (script._isScript()) {
                                let fun = script[event.eventName];
                                (fun) && (fun.apply(script, event.params));
                            }
                        }
                    }
                    else {
                        break;
                    }
                }
            }
            return eventIndex;
        }
        _applyTransition(layerindex, transition) {
            if (!transition)
                return false;
            return this.crossFade(transition.destState.name, transition.transduration, layerindex, transition.transstartoffset);
        }
        _applyUpdateMode(delta) {
            let ret;
            switch (this._updateMode) {
                case exports.AnimatorUpdateMode.Normal:
                    ret = delta;
                    break;
                case exports.AnimatorUpdateMode.LowFrame:
                    ret = (Stat.loopCount % this._lowUpdateDelty == 0) ? delta * this._lowUpdateDelty : 0;
                    break;
                case exports.AnimatorUpdateMode.UnScaleTime:
                    ret = 0;
                    break;
            }
            return ret;
        }
        play(name, layerIndex = 0, normalizedTime = Number.NEGATIVE_INFINITY) {
            this._isPlaying = true;
            var controllerLayer = this._controllerLayers[layerIndex];
            if (controllerLayer) {
                var defaultState = controllerLayer.defaultState;
                if (!name && !defaultState)
                    throw new Error("Animator:must have default clip value,please set clip property.");
                var playStateInfo = controllerLayer._playStateInfo;
                var curPlayState = playStateInfo._currentState;
                var animatorState = name ? controllerLayer.getStateByName(name) : defaultState;
                if (!animatorState._clip)
                    return;
                var clipDuration = animatorState._clip._duration;
                var calclipduration = animatorState._clip._duration * (animatorState.clipEnd - animatorState.clipStart);
                if (curPlayState !== animatorState) {
                    if (normalizedTime !== Number.NEGATIVE_INFINITY)
                        playStateInfo._resetPlayState(clipDuration * normalizedTime, calclipduration);
                    else
                        playStateInfo._resetPlayState(0.0, calclipduration);
                    controllerLayer._playType = 0;
                    playStateInfo._currentState = animatorState;
                }
                else {
                    if (normalizedTime !== Number.NEGATIVE_INFINITY) {
                        playStateInfo._resetPlayState(clipDuration * normalizedTime, calclipduration);
                        controllerLayer._playType = 0;
                    }
                }
                animatorState._eventStart();
            }
            var scripts = animatorState._scripts;
            if (scripts) {
                for (var i = 0, n = scripts.length; i < n; i++)
                    scripts[i].onStateEnter();
            }
        }
        stop() {
            this._isPlaying = false;
        }
        onUpdate() {
            if (!this._isPlaying)
                return;
            var delta = this.owner.timer._delta / 1000.0;
            delta = this._applyUpdateMode(delta);
            if (0 == this.speed || 0 == delta)
                return;
            for (var i = 0, n = this._controllerLayers.length; i < n; i++) {
                var controllerLayer = this._controllerLayers[i];
                if (!controllerLayer.enable)
                    continue;
                var playStateInfo = controllerLayer._playStateInfo;
                var addtive = controllerLayer.blendingMode != AnimatorControllerLayer2D.BLENDINGMODE_OVERRIDE;
                switch (controllerLayer._playType) {
                    case 0:
                        var animatorState = playStateInfo._currentState;
                        var speed = this._speed * animatorState.speed;
                        var finish = playStateInfo._finish;
                        var loop = animatorState.loop;
                        if (-1 >= loop) {
                            var clip = animatorState._clip;
                            if (clip.islooping) {
                                loop = 0;
                            }
                            else {
                                loop = 1;
                            }
                        }
                        let dir = 1;
                        if (!playStateInfo._frontPlay) {
                            dir = -1;
                        }
                        finish || this._updatePlayer(animatorState, playStateInfo, delta * speed * dir, loop, i);
                        {
                            this._updateClipDatas(animatorState, addtive, playStateInfo);
                            finish || this._setClipDatasToNode(animatorState, addtive, controllerLayer.defaultWeight, i == 0, controllerLayer);
                            finish || this._updateEventScript(animatorState, playStateInfo);
                        }
                        finish || this._updateStateFinish(animatorState, playStateInfo);
                        break;
                }
            }
        }
        addControllerLayer(controllderLayer) {
            this._controllerLayers.push(controllderLayer);
        }
        crossFade(name, transitionDuration, layerIndex = 0, normalizedTime = Number.NEGATIVE_INFINITY) {
            var controllerLayer = this._controllerLayers[layerIndex];
            if (controllerLayer) {
                var destAnimatorState = controllerLayer.getStateByName(name);
                if (destAnimatorState) {
                    this.play(name, layerIndex, normalizedTime);
                    return true;
                }
                else {
                    console.warn("Invalid layerIndex " + layerIndex + ".");
                }
            }
            return false;
        }
        onAfterDeserialize() {
            let arr = this.controllerLayers;
            if (!arr || null != this.controller)
                return;
            delete this.controllerLayers;
            this._controllerLayers.length = 0;
            for (let layer of arr) {
                this.addControllerLayer(layer);
            }
        }
        onEnable() {
            if (this._isPlaying) {
                for (var i = 0, n = this._controllerLayers.length; i < n; i++) {
                    if (this._controllerLayers[i].playOnWake) {
                        var defaultClip = this.getDefaultState(i);
                        (defaultClip) && (this.play(null, i));
                    }
                }
            }
        }
        getDefaultState(layerIndex = 0) {
            var controllerLayer = this._controllerLayers[layerIndex];
            return controllerLayer.defaultState;
        }
        setParamsTrigger(name) {
            this._parameters[name] = { name: name, type: exports.AniParmType.Trigger, value: true };
        }
        setParamsNumber(name, value) {
            this._parameters[name] = { name: name, type: exports.AniParmType.Float, value: value };
        }
        setParamsBool(name, value) {
            this._parameters[name] = { name: name, type: exports.AniParmType.Float, value: value };
        }
        getParamsvalue(name) {
            let parm = this._parameters[name];
            if (parm) {
                return parm.value;
            }
            return null;
        }
        onDestroy() {
            for (var i = 0, n = this._controllerLayers.length; i < n; i++)
                this._controllerLayers[i].destroy();
            this._controllerLayers.length = 0;
            this._isPlaying = false;
            this._parameters = null;
        }
    }

    class AnimatorState2D extends EventDispatcher {
        constructor() {
            super(...arguments);
            this._referenceCount = 0;
            this._clip = null;
            this._currentFrameIndices = null;
            this.speed = 1.0;
            this.clipStart = 0.0;
            this.clipEnd = 1.0;
            this.loop = -1;
            this.yoyo = false;
            this.transitions = [];
            this.soloTransitions = [];
            this._scripts = null;
            this._realtimeDatas = [];
        }
        get clip() {
            return this._clip;
        }
        set clip(value) {
            if (this._clip != value) {
                if (this._clip)
                    (this._referenceCount > 0) && (this._clip._removeReference(this._referenceCount));
                if (value) {
                    var clipNodes = value._nodes;
                    var count = clipNodes.count;
                    this._currentFrameIndices = new Int16Array(count);
                    this._resetFrameIndices();
                    (this._referenceCount > 0) && (value._addReference(this._referenceCount));
                    this._realtimeDatas.length = count;
                }
                this._clip = value;
            }
        }
        _eventStateUpdate(value) {
            this.event(AnimatorState2D.EVENT_OnStateUpdate, value);
            if (this._scripts) {
                for (var i = 0, n = this._scripts.length; i < n; i++)
                    this._scripts[i].onStateUpdate(value);
            }
        }
        _eventStart() {
            this.event(AnimatorState2D.EVENT_OnStateEnter);
            if (this._scripts) {
                for (var i = 0, n = this._scripts.length; i < n; i++)
                    this._scripts[i].onStateEnter();
            }
        }
        _eventExit() {
            this.event(AnimatorState2D.EVENT_OnStateExit);
            if (this._scripts) {
                for (let i = 0, n = this._scripts.length; i < n; i++) {
                    this._scripts[i].onStateExit();
                }
            }
        }
        _eventtransition(normalizeTime, paramsMap, isReplay) {
            let soloNums = this.soloTransitions.length;
            if (soloNums > 0) {
                for (var i = 0; i < soloNums; i++) {
                    if (this.soloTransitions[i].check(normalizeTime, paramsMap, isReplay))
                        return this.soloTransitions[i];
                }
                return null;
            }
            let transNums = this.transitions.length;
            for (var i = 0; i < transNums; i++) {
                if (this.transitions[i].check(normalizeTime, paramsMap, isReplay))
                    return this.transitions[i];
            }
            return null;
        }
        _resetFrameIndices() {
            for (var i = 0, n = this._currentFrameIndices.length; i < n; i++)
                this._currentFrameIndices[i] = -1;
        }
        _getReferenceCount() {
            return this._referenceCount;
        }
        _addReference(count) {
            (this._clip) && (this._clip._addReference(count));
            this._referenceCount += count;
        }
        _removeReference(count) {
            (this._clip) && (this._clip._removeReference(count));
            this._referenceCount -= count;
        }
        _clearReference() {
            this._removeReference(-this._referenceCount);
        }
        addScript(type) {
            var script = new type();
            this._scripts = this._scripts || [];
            this._scripts.push(script);
            return script;
        }
        getScript(type) {
            if (this._scripts) {
                for (var i = 0, n = this._scripts.length; i < n; i++) {
                    var script = this._scripts[i];
                    if (script instanceof type)
                        return script;
                }
            }
            return null;
        }
        getScripts(type) {
            var coms = null;
            if (this._scripts) {
                for (var i = 0, n = this._scripts.length; i < n; i++) {
                    var script = this._scripts[i];
                    if (script instanceof type) {
                        coms = coms || [];
                        coms.push(script);
                    }
                }
            }
            return coms;
        }
        clone() {
            var dest = new AnimatorState2D();
            this.cloneTo(dest);
            return dest;
        }
        cloneTo(destObject) {
            var dest = destObject;
            dest.name = this.name;
            dest.speed = this.speed;
            dest.clip = this._clip;
        }
        destroy() {
            this._clip = null;
            this._currentFrameIndices = null;
            this._scripts = null;
            this._realtimeDatas.length = 0;
        }
    }
    AnimatorState2D.EVENT_OnStateEnter = "OnStartEnter";
    AnimatorState2D.EVENT_OnStateUpdate = "OnStateUpdate";
    AnimatorState2D.EVENT_OnStateExit = "OnStateExit";

    class KeyframeNode2D {
        constructor() {
            this._ownerPath = [];
            this._propertys = [];
            this._keyFrames = [];
        }
        get keyFramesCount() {
            return this._keyFrames.length;
        }
        _setOwnerPathCount(value) {
            this._ownerPath.length = value;
        }
        _setOwnerPathByIndex(index, value) {
            this._ownerPath[index] = value;
        }
        _setPropertyCount(value) {
            this._propertys.length = value;
        }
        _setPropertyByIndex(index, value) {
            this._propertys[index] = value;
        }
        _setKeyframeCount(value) {
            this._keyFrames.length = value;
        }
        _joinOwnerPath(sep) {
            return this._ownerPath.join(sep);
        }
        _joinProperty(sep) {
            return this._propertys.join(sep);
        }
        getKeyframeByIndex(index) {
            return this._keyFrames[index];
        }
        get ownerPathCount() {
            return this._ownerPath.length;
        }
        get propertyCount() {
            return this._propertys.length;
        }
        getOwnerPathByIndex(index) {
            return this._ownerPath[index];
        }
        getPropertyByIndex(index) {
            return this._propertys[index];
        }
    }

    class Keyframe2D {
        clone() {
            var dest = new Keyframe2D();
            this.cloneTo(dest);
            return dest;
        }
        cloneTo(destObject) {
            var destKeyFrame = destObject;
            destKeyFrame.time = this.time;
        }
    }
    Keyframe2D.defaultWeight = 0.33333;

    class Animation2DEvent {
        constructor() {
        }
    }

    class AnimationClip2DParse01 {
        static READ_DATA() {
            this._DATA.offset = this._reader.getUint32();
            this._DATA.size = this._reader.getUint32();
        }
        static READ_BLOCK() {
            var count = this._BLOCK.count = this._reader.getUint16();
            var blockStarts = this._BLOCK.blockStarts = [];
            var blockLengths = this._BLOCK.blockLengths = [];
            for (var i = 0; i < count; i++) {
                blockStarts.push(this._reader.getUint32());
                blockLengths.push(this._reader.getUint32());
            }
        }
        static READ_STRINGS() {
            var offset = this._reader.getUint32();
            var count = this._reader.getUint16();
            var prePos = this._reader.pos;
            this._reader.pos = offset + this._DATA.offset;
            for (var i = 0; i < count; i++)
                this._strings[i] = this._reader.readUTFString();
            this._reader.pos = prePos;
        }
        static parse(clip, reader, version) {
            this._clip = clip;
            this._reader = reader;
            this._version = version;
            this.READ_DATA();
            this.READ_BLOCK();
            this.READ_STRINGS();
            for (var i = 0, n = this._BLOCK.count; i < n; i++) {
                var index = reader.getUint16();
                var blockName = this._strings[index];
                var fn = this["READ_" + blockName];
                if (!fn) {
                    throw new Error("model file err,no this function:" + index + " " + blockName);
                }
                else
                    fn.call(this);
            }
            this._version = null;
            this._reader = null;
            this._clip = null;
            this._strings.length = 0;
        }
        static timeToFrame(second, fps) {
            return Math.round(second * fps);
        }
        static READ_ANIMATIONS2D() {
            var i, j;
            var reader = this._reader;
            var clip = this._clip;
            var node;
            var numList = [];
            var numCount = reader.getUint16();
            numList.length = numCount;
            for (i = 0; i < numCount; i++) {
                numList[i] = reader.getFloat32();
            }
            clip._duration = numList[reader.getInt16()];
            clip.islooping = !!reader.getByte();
            clip._frameRate = reader.getInt16();
            var nodeCount = reader.getInt16();
            var nodes = clip._nodes;
            nodes.count = nodeCount;
            var nodesMap = clip._nodesMap = {};
            var nodesDic = clip._nodesDic = {};
            for (i = 0; i < nodeCount; i++) {
                node = new KeyframeNode2D();
                nodes.setNodeByIndex(i, node);
                node._indexInList = i;
                var pathLength = reader.getUint16();
                node._setOwnerPathCount(pathLength);
                for (j = 0; j < pathLength; j++) {
                    node._setOwnerPathByIndex(j, this._strings[reader.getUint16()]);
                }
                var nodePath = node._joinOwnerPath("/");
                var mapArray = nodesMap[nodePath];
                (mapArray) || (nodesMap[nodePath] = mapArray = []);
                mapArray.push(node);
                var propertyLength = reader.getUint16();
                node._setPropertyCount(propertyLength);
                for (j = 0; j < propertyLength; j++) {
                    node._setPropertyByIndex(j, this._strings[reader.getUint16()]);
                }
                var fullPath = nodePath + "." + node._joinProperty(".");
                nodesDic[fullPath] = node;
                node.fullPath = fullPath;
                node.nodePath = nodePath;
                var keyframeCount = reader.getUint16();
                for (j = 0; j < keyframeCount; j++) {
                    var k = new Keyframe2D();
                    k.time = numList[reader.getUint16()];
                    k.data = { f: this.timeToFrame(k.time, clip._frameRate), val: 0 };
                    if (1 == reader.getByte()) {
                        k.data.tweenType = this._strings[reader.getUint16()];
                    }
                    if (1 == reader.getByte()) {
                        k.data.tweenInfo = {};
                        k.data.tweenInfo.inTangent = numList[reader.getUint16()];
                        k.data.tweenInfo.outTangent = numList[reader.getUint16()];
                        if (1 == reader.getByte()) {
                            k.data.tweenInfo.inWeight = numList[reader.getUint16()];
                        }
                        if (1 == reader.getByte()) {
                            k.data.tweenInfo.outWeight = numList[reader.getUint16()];
                        }
                    }
                    var num = reader.getByte();
                    if (0 == num) {
                        k.data.val = numList[reader.getUint16()];
                    }
                    else if (1 == num) {
                        k.data.val = this._strings[reader.getUint16()];
                    }
                    else if (2 == num) {
                        k.data.val = !!reader.getByte();
                    }
                    if (1 == reader.getByte()) {
                        try {
                            k.data.extend = JSON.parse(this._strings[reader.getUint16()]);
                        }
                        catch (err) { }
                    }
                    node._keyFrames.push(k);
                }
            }
            var eventCount = reader.getUint16();
            for (i = 0; i < eventCount; i++) {
                var event = new Animation2DEvent();
                event.time = numList[reader.getUint16()];
                event.eventName = this._strings[reader.getUint16()];
                var params = [];
                var paramCount = reader.getUint16();
                (paramCount > 0) && (event.params = params = []);
                for (j = 0; j < paramCount; j++) {
                    var eventType = reader.getByte();
                    switch (eventType) {
                        case 0:
                            params.push(!!reader.getByte());
                            break;
                        case 1:
                            params.push(reader.getInt32());
                            break;
                        case 2:
                            params.push(numList[reader.getUint16()]);
                            break;
                        case 3:
                            params.push(this._strings[reader.getUint16()]);
                            break;
                        default:
                            throw new Error("unknown type.");
                    }
                }
                clip.addEvent(event);
            }
        }
    }
    AnimationClip2DParse01._strings = [];
    AnimationClip2DParse01._DATA = { offset: 0, size: 0 };
    AnimationClip2DParse01._BLOCK = { count: 0 };

    class KeyframeNodeList2D {
        constructor() {
            this._nodes = [];
        }
        get count() {
            return this._nodes.length;
        }
        set count(value) {
            this._nodes.length = value;
        }
        getNodeByIndex(index) {
            return this._nodes[index];
        }
        setNodeByIndex(index, node) {
            this._nodes[index] = node;
        }
    }

    class AnimationClip2D extends Resource {
        constructor() {
            super();
            this._nodes = new KeyframeNodeList2D();
            this._animationEvents = [];
        }
        static _parse(data) {
            var clip = new AnimationClip2D();
            var reader = new Byte(data);
            var version = reader.readUTFString();
            switch (version) {
                case "LAYAANIMATION2D:01":
                    AnimationClip2DParse01.parse(clip, reader, version);
                    break;
                default:
                    throw "unknown animationClip version.";
            }
            return clip;
        }
        duration() {
            return this._duration;
        }
        _evaluateClipDatasRealTime(playCurTime, realTimeCurrentFrameIndexes, addtive, frontPlay, outDatas) {
            var nodes = this._nodes;
            for (var i = 0, n = nodes.count; i < n; i++) {
                var node = nodes.getNodeByIndex(i);
                var nextFrameIndex;
                var keyFrames = node._keyFrames;
                var keyFramesCount = keyFrames.length;
                var frameIndex = realTimeCurrentFrameIndexes[i];
                if (frontPlay) {
                    if ((-1 != frameIndex) && (playCurTime < keyFrames[frameIndex].time)) {
                        frameIndex = -1;
                        realTimeCurrentFrameIndexes[i] = frameIndex;
                    }
                    nextFrameIndex = frameIndex + 1;
                    while (nextFrameIndex < keyFramesCount) {
                        if (keyFrames[nextFrameIndex].time > playCurTime)
                            break;
                        frameIndex++;
                        nextFrameIndex++;
                        realTimeCurrentFrameIndexes[i] = frameIndex;
                    }
                }
                else {
                    nextFrameIndex = frameIndex + 1;
                    if ((nextFrameIndex != keyFramesCount) && (playCurTime > keyFrames[nextFrameIndex].time)) {
                        frameIndex = keyFramesCount - 1;
                        realTimeCurrentFrameIndexes[i] = frameIndex;
                    }
                    nextFrameIndex = frameIndex + 1;
                    while (frameIndex > -1) {
                        if (keyFrames[frameIndex].time < playCurTime)
                            break;
                        frameIndex--;
                        nextFrameIndex--;
                        realTimeCurrentFrameIndexes[i] = frameIndex;
                    }
                }
                var isEnd = nextFrameIndex == keyFramesCount;
                if (-1 != frameIndex) {
                    var frame = keyFrames[frameIndex];
                    if (isEnd) {
                        outDatas[i] = frame.data.val;
                    }
                    else {
                        var nextFarme = keyFrames[nextFrameIndex];
                        var d = nextFarme.time - frame.time;
                        var t;
                        if (d !== 0)
                            t = (playCurTime - frame.time) / d;
                        else
                            t = 0;
                        outDatas[i] = this._getTweenVal(frame, nextFarme, t, d);
                    }
                }
                else {
                    outDatas[i] = keyFrames[0].data.val;
                }
                if (addtive && "number" == typeof keyFrames[0].data.val) {
                    outDatas[i] = outDatas[i] - keyFrames[0].data.val;
                }
            }
        }
        _getTweenVal(frame, nextFrame, t, dur) {
            var start = frame.data;
            var end = nextFrame.data;
            if ("number" != typeof start.val || "number" != typeof end.val) {
                return start.val;
            }
            var tweenFun = AnimationClip2D.tween[start.tweenType];
            var poval = start.val;
            var oval = end.val;
            if (null != tweenFun) {
                return tweenFun(t, poval, oval - poval, 1);
            }
            var outTangent = 0;
            var inTangent = 0;
            var outWeight = NaN;
            var inWeight = NaN;
            if (null != start.tweenInfo) {
                outTangent = start.tweenInfo.outTangent;
                outWeight = start.tweenInfo.outWeight;
            }
            if (null != end.tweenInfo) {
                inTangent = end.tweenInfo.inTangent;
                inWeight = end.tweenInfo.inWeight;
            }
            if (isNaN(outWeight) || 0 >= outWeight)
                outWeight = Keyframe2D.defaultWeight;
            if (isNaN(inWeight) || 0 >= inWeight)
                inWeight = Keyframe2D.defaultWeight;
            if (isNaN(outTangent))
                outTangent = 0;
            if (isNaN(inTangent))
                inTangent = 0;
            if (Math.abs(outTangent) == Number.MAX_VALUE) {
                if (0 > outTangent) {
                    outTangent = -Infinity;
                }
                else {
                    outTangent = Infinity;
                }
            }
            if (Math.abs(inTangent) == Number.MAX_VALUE) {
                if (0 > inTangent) {
                    inTangent = -Infinity;
                }
                else {
                    inTangent = Infinity;
                }
            }
            var tnum;
            if ((!start.tweenInfo && !end.tweenInfo) || (Keyframe2D.defaultWeight == inWeight && Keyframe2D.defaultWeight == outWeight)) {
                tnum = AnimationClip2D.tween.hermiteInterpolate(outTangent, inTangent, poval, oval, t, dur);
            }
            else {
                tnum = this.hermiteCurveSplineWeight(poval, frame.time, outWeight, outTangent, oval, nextFrame.time, inWeight, inTangent, t);
            }
            return tnum;
        }
        _binarySearchEventIndex(time) {
            var start = 0;
            var end = this._animationEvents.length - 1;
            var mid;
            while (start <= end) {
                mid = (start + end) >> 1;
                var midValue = this._animationEvents[mid].time;
                if (midValue == time)
                    return mid;
                else if (midValue > time)
                    end = mid - 1;
                else
                    start = mid + 1;
            }
            return start;
        }
        hermiteCurveSplineWeight(frameValue, frametime, frameOutWeight, frameOutTangent, nextframeValue, nextframetime, nextframeInweight, nextframeIntangent, time) {
            let Eps = 2.22e-16;
            let x = time;
            let x1 = frametime;
            let y1 = frameValue;
            let wt1 = frameOutWeight;
            let x2 = nextframetime;
            let y2 = nextframeValue;
            let wt2 = nextframeInweight;
            let dx = x2 - x1;
            let dy = y2 - y1;
            dy = Math.max(Math.abs(dy), Eps) * (dy < 0 ? -1 : 1);
            let yp1 = frameOutTangent;
            let yp2 = nextframeIntangent;
            if (!Number.isFinite(yp1) || !Number.isFinite(yp2)) {
                return frameValue;
            }
            yp1 = yp1 * dx / dy;
            yp2 = yp2 * dx / dy;
            let wt2s = 1 - wt2;
            let t = 0.5;
            let t2 = 0;
            if (Math.abs(wt1 - 0.33333334) < 0.0001 && Math.abs(wt2 - 0.33333334) < 0.0001) {
                t = x;
                t2 = 1 - t;
            }
            else {
                while (true) {
                    t2 = (1 - t);
                    let fg = 3 * t2 * t2 * t * wt1 + 3 * t2 * t * t * wt2s + t * t * t - x;
                    if (Math.abs(fg) <= 2.5 * Eps)
                        break;
                    let fpg = 3 * t2 * t2 * wt1 + 6 * t2 * t * (wt2s - wt1) + 3 * t * t * (1 - wt2s);
                    let fppg = 6 * t2 * (wt2s - 2 * wt1) + 6 * t * (1 - 2 * wt2s + wt1);
                    let fpppg = 18 * wt1 - 18 * wt2s + 6;
                    t -= (6 * fg * fpg * fpg - 3 * fg * fg * fppg) / (6 * fpg * fpg * fpg - 6 * fg * fpg * fppg + fg * fg * fpppg);
                }
            }
            let y = 3 * t2 * t2 * t * wt1 * yp1 + 3 * t2 * t * t * (1 - wt2 * yp2) + t * t * t;
            return y * dy + y1;
        }
        addEvent(event) {
            var index = this._binarySearchEventIndex(event.time);
            this._animationEvents.splice(index, 0, event);
        }
    }
    AnimationClip2D.tween = {
        Linear: function (t, b, c, d) { return c * t / d + b; },
        Quad_EaseIn: function (t, b, c, d) {
            return c * (t /= d) * t + b;
        },
        Quad_EaseOut: function (t, b, c, d) {
            return -c * (t /= d) * (t - 2) + b;
        },
        Quad_EaseInOut: function (t, b, c, d) {
            if ((t /= d / 2) < 1)
                return c / 2 * t * t + b;
            return -c / 2 * ((--t) * (t - 2) - 1) + b;
        },
        Cubic_EaseIn: function (t, b, c, d) {
            return c * (t /= d) * t * t + b;
        },
        Cubic_EaseOut: function (t, b, c, d) {
            return c * ((t = t / d - 1) * t * t + 1) + b;
        },
        Cubic_EaseInOut: function (t, b, c, d) {
            if ((t /= d / 2) < 1)
                return c / 2 * t * t * t + b;
            return c / 2 * ((t -= 2) * t * t + 2) + b;
        },
        Quart_EaseIn: function (t, b, c, d) {
            return c * (t /= d) * t * t * t + b;
        },
        Quart_EaseOut: function (t, b, c, d) {
            return -c * ((t = t / d - 1) * t * t * t - 1) + b;
        },
        Quart_EaseInOut: function (t, b, c, d) {
            if ((t /= d / 2) < 1)
                return c / 2 * t * t * t * t + b;
            return -c / 2 * ((t -= 2) * t * t * t - 2) + b;
        },
        Quint_EaseIn: function (t, b, c, d) {
            return c * (t /= d) * t * t * t * t + b;
        },
        Quint_EaseOut: function (t, b, c, d) {
            return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
        },
        Quint_EaseInOut: function (t, b, c, d) {
            if ((t /= d / 2) < 1)
                return c / 2 * t * t * t * t * t + b;
            return c / 2 * ((t -= 2) * t * t * t * t + 2) + b;
        },
        Sine_EaseIn: function (t, b, c, d) {
            return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;
        },
        Sine_EaseOut: function (t, b, c, d) {
            return c * Math.sin(t / d * (Math.PI / 2)) + b;
        },
        Sine_EaseInOut: function (t, b, c, d) {
            return -c / 2 * (Math.cos(Math.PI * t / d) - 1) + b;
        },
        Expo_EaseIn: function (t, b, c, d) {
            return (t == 0) ? b : c * Math.pow(2, 10 * (t / d - 1)) + b;
        },
        Expo_EaseOut: function (t, b, c, d) {
            return (t == d) ? b + c : c * (-Math.pow(2, -10 * t / d) + 1) + b;
        },
        Expo_EaseInOut: function (t, b, c, d) {
            if (t == 0)
                return b;
            if (t == d)
                return b + c;
            if ((t /= d / 2) < 1)
                return c / 2 * Math.pow(2, 10 * (t - 1)) + b;
            return c / 2 * (-Math.pow(2, -10 * --t) + 2) + b;
        },
        Circ_EaseIn: function (t, b, c, d) {
            return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b;
        },
        Circ_EaseOut: function (t, b, c, d) {
            return c * Math.sqrt(1 - (t = t / d - 1) * t) + b;
        },
        Circ_EaseInOut: function (t, b, c, d) {
            if ((t /= d / 2) < 1)
                return -c / 2 * (Math.sqrt(1 - t * t) - 1) + b;
            return c / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;
        },
        Elastic_EaseIn: function (t, b, c, d, a, p) {
            if (t == 0)
                return b;
            if ((t /= d) == 1)
                return b + c;
            if (!p)
                p = d * .3;
            if (!a || a < Math.abs(c)) {
                a = c;
                var s = p / 4;
            }
            else
                var s = p / (2 * Math.PI) * Math.asin(c / a);
            return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
        },
        Elastic_EaseOut: function (t, b, c, d, a, p) {
            if (t == 0)
                return b;
            if ((t /= d) == 1)
                return b + c;
            if (!p)
                p = d * .3;
            if (!a || a < Math.abs(c)) {
                a = c;
                var s = p / 4;
            }
            else
                var s = p / (2 * Math.PI) * Math.asin(c / a);
            return (a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * (2 * Math.PI) / p) + c + b);
        },
        Elastic_EaseInOut: function (t, b, c, d, a, p) {
            if (t == 0)
                return b;
            if ((t /= d / 2) == 2)
                return b + c;
            if (!p)
                p = d * (.3 * 1.5);
            if (!a || a < Math.abs(c)) {
                a = c;
                var s = p / 4;
            }
            else
                var s = p / (2 * Math.PI) * Math.asin(c / a);
            if (t < 1)
                return -.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
            return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p) * .5 + c + b;
        },
        Back_EaseIn: function (t, b, c, d, s = undefined) {
            if (s == undefined)
                s = 1.70158;
            return c * (t /= d) * t * ((s + 1) * t - s) + b;
        },
        Back_EaseOut: function (t, b, c, d, s = undefined) {
            if (s == undefined)
                s = 1.70158;
            return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
        },
        Back_EaseInOut: function (t, b, c, d, s = undefined) {
            if (s == undefined)
                s = 1.70158;
            if ((t /= d / 2) < 1)
                return c / 2 * (t * t * (((s *= (1.525)) + 1) * t - s)) + b;
            return c / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2) + b;
        },
        Bounce_EaseIn: function (t, b, c, d) {
            return c - AnimationClip2D.tween.Bounce_EaseOut(d - t, 0, c, d) + b;
        },
        Bounce_EaseOut: function (t, b, c, d) {
            if ((t /= d) < (1 / 2.75)) {
                return c * (7.5625 * t * t) + b;
            }
            else if (t < (2 / 2.75)) {
                return c * (7.5625 * (t -= (1.5 / 2.75)) * t + .75) + b;
            }
            else if (t < (2.5 / 2.75)) {
                return c * (7.5625 * (t -= (2.25 / 2.75)) * t + .9375) + b;
            }
            else {
                return c * (7.5625 * (t -= (2.625 / 2.75)) * t + .984375) + b;
            }
        },
        Bounce_EaseInOut: function (t, b, c, d) {
            if (t < d / 2)
                return AnimationClip2D.tween.Bounce_EaseIn(t * 2, 0, c, d) * .5 + b;
            else
                return AnimationClip2D.tween.Bounce_EaseOut(t * 2 - d, 0, c, d) * .5 + c * .5 + b;
        },
        hermiteInterpolate: function (outTangent, inTangent, startValue, endValue, t, dur) {
            if (Math.abs(outTangent) == Infinity || Math.abs(inTangent) == Infinity) {
                if (0 > outTangent || 0 < inTangent)
                    return startValue;
                return startValue;
            }
            var t2 = t * t;
            var t3 = t2 * t;
            var a = 2.0 * t3 - 3.0 * t2 + 1.0;
            var b = t3 - 2.0 * t2 + t;
            var c = t3 - t2;
            var d = -2.0 * t3 + 3.0 * t2;
            return a * startValue + b * outTangent * dur + c * inTangent * dur + d * endValue;
        }
    };

    class Animation2DParm {
    }

    exports.AniConditionType = void 0;
    (function (AniConditionType) {
        AniConditionType[AniConditionType["Greater"] = 0] = "Greater";
        AniConditionType[AniConditionType["Less"] = 1] = "Less";
        AniConditionType[AniConditionType["Equals"] = 2] = "Equals";
        AniConditionType[AniConditionType["NotEqual"] = 3] = "NotEqual";
    })(exports.AniConditionType || (exports.AniConditionType = {}));
    class Animation2DCondition {
    }

    class AnimatorStateCondition {
        constructor(name = null) {
            if (!name)
                return;
            this._id = AnimatorStateCondition.conditionNameToID(name);
            this._name = name;
        }
        static conditionNameToID(name) {
            if (AnimatorStateCondition._conditionNameMap[name] != null) {
                return AnimatorStateCondition._conditionNameMap[name];
            }
            else {
                var id = this._propertyNameCounter++;
                this._conditionNameMap[name] = id;
                this._conditionNameMap[id] = name;
                return id;
            }
        }
        static conditionIDToName(id) {
            return this._conditionNameMap[id];
        }
        get id() {
            return this._id;
        }
        get name() {
            return this._name;
        }
        set name(value) {
            this._id = AnimatorStateCondition.conditionNameToID(value);
            this._name = value;
        }
        get type() {
            return this._type;
        }
        checkState(value) {
            return false;
        }
    }
    AnimatorStateCondition._conditionNameMap = {};
    AnimatorStateCondition._propertyNameCounter = 0;
    class AnimatorStateNumberCondition extends AnimatorStateCondition {
        constructor(name) {
            super(name);
            this._numberValue = 0;
            this._numberCompareFlag = exports.AniStateConditionNumberCompressType.Greater;
            this._type = exports.AniStateConditionType.Number;
        }
        get numberValue() {
            return this._numberValue;
        }
        set numberValue(value) {
            this._numberValue = value;
        }
        get compareFlag() {
            return this._numberCompareFlag;
        }
        set compareFlag(value) {
            this._numberCompareFlag = value;
        }
        checkState(value) {
            if (exports.AniStateConditionNumberCompressType.Greater == this._numberCompareFlag)
                return value > this._numberValue;
            else
                return value < this._numberValue;
        }
    }
    class AnimatorStateBoolCondition extends AnimatorStateCondition {
        constructor(name) {
            super(name);
            this._compareFlag = true;
            this._type = exports.AniStateConditionType.Bool;
        }
        get compareFlag() {
            return this._compareFlag;
        }
        set compareFlag(value) {
            this._compareFlag = value;
        }
        checkState(value) {
            return this._compareFlag == value;
        }
    }
    class AnimatorStateTriggerCondition extends AnimatorStateCondition {
        constructor(name) {
            super(name);
            this._type = exports.AniStateConditionType.Trigger;
        }
        checkState(value) {
            return value;
        }
    }

    class AnimatorTransition2D {
        constructor() {
            this.conditions = [];
            this.exitByTime = true;
            this.exitTime = 1;
            this.transduration = 0;
            this.transstartoffset = 0;
            this.mute = false;
        }
        addCondition(condition) {
            if (this.conditions.indexOf(condition) == -1) {
                this.conditions.push(condition);
            }
        }
        removeCondition(condition) {
            let index = this.conditions.indexOf(condition);
            if (index != -1) {
                this.conditions.splice(index, 0);
            }
        }
        check(normalizeTime, paramsMap, isReplay) {
            if (this.mute) {
                return false;
            }
            if (this.exitByTime && (normalizeTime < this.exitTime && !isReplay)) {
                return false;
            }
            if (null == this.conditions || 0 == this.conditions.length) {
                return true;
            }
            for (var i = 0; i < this.conditions.length; i++) {
                let con = this.conditions[i];
                let out = con.checkState(paramsMap[con.name].value);
                if (out) {
                    if (con.type == exports.AniStateConditionType.Trigger) {
                        paramsMap[con.name].value = false;
                    }
                    return true;
                }
            }
            return false;
        }
    }

    class AnimatorController2D extends Resource {
        constructor(data) {
            super();
            let obj = AnimatorControllerParse.parse(data);
            this.data = obj.ret;
            this.clipsID = obj.clipsID;
        }
        getLayers() {
            let layers = this.data.controllerLayers;
            let lArr = [];
            for (let i = layers.length - 1; i >= 0; i--) {
                let l = layers[i];
                let acl = new AnimatorControllerLayer2D(l.name);
                lArr.unshift(acl);
                for (let k in l) {
                    if ("name" == k || "states" == k || null == l[k]) {
                        continue;
                    }
                    try {
                        acl[k] = l[k];
                    }
                    catch (err) { }
                }
                this.getState(l.states, acl, this.data);
            }
            return lArr;
        }
        createState(states, idCatch, acl) {
            if (!states)
                return null;
            let ret = {};
            let defID = null;
            for (let i = states.length - 1; i >= 0; i--) {
                let obj = states[i];
                let childStates = obj.states;
                if (childStates) {
                    let groupRet = this.createState(childStates, idCatch, acl);
                    if (groupRet) {
                        idCatch[obj.id] = groupRet.states[groupRet.id];
                    }
                    continue;
                }
                if (0 > Number(obj.id)) {
                    if ("-1" == obj.id) {
                        let transitions = obj.soloTransitions;
                        if (transitions && 0 < transitions.length) {
                            defID = transitions[0].id;
                        }
                    }
                    continue;
                }
                let state = new AnimatorState2D();
                idCatch[obj.id] = state;
                ret[obj.id] = state;
                for (let k in obj) {
                    try {
                        if ("scripts" == k) {
                            let scripts = obj[k];
                            if (scripts && Array.isArray(scripts)) {
                                for (let k = scripts.length - 1; k >= 0; k--) {
                                    let uuid = scripts[k];
                                    let c = ClassUtils.getClass(uuid);
                                    if (c) {
                                        state.addScript(c);
                                    }
                                }
                            }
                            continue;
                        }
                        else if ("soloTransitions" == k) {
                            continue;
                        }
                        else if (null != obj[k]) {
                            state[k] = obj[k];
                        }
                    }
                    catch (err) { }
                }
                acl.addState(state);
            }
            return { id: defID, states: ret };
        }
        getState(states, acl, data) {
            if (states) {
                let idCatch = {};
                this.createState(states, idCatch, acl);
                this.setTransitions(states, idCatch, acl, data);
            }
        }
        setExitTransition(exitRet, transitions, idCatch, data, pExitRet) {
            for (let id in exitRet) {
                let state = idCatch[id];
                if (state) {
                    let ats = state.transitions;
                    let sts = state.soloTransitions;
                    let linArr = exitRet[id];
                    for (let i = transitions.length - 1; i >= 0; i--) {
                        let t = transitions[i];
                        if ("-3" == t.id) {
                            if (null == pExitRet[id]) {
                                pExitRet[id] = [];
                            }
                            pExitRet[id].push(t);
                            continue;
                        }
                        for (let j = linArr.length - 1; j >= 0; j--) {
                            let t2 = linArr[j];
                            let ato = new AnimatorTransition2D();
                            ato.destState = idCatch[t.id];
                            if (t.conditions) {
                                this.addConditions(t.conditions, ato, data);
                            }
                            if (t2.conditions) {
                                this.addConditions(t2.conditions, ato, data);
                            }
                            for (let k in t) {
                                if ("solo" == k || "id" == k || "conditions" == k) {
                                    continue;
                                }
                                else {
                                    ato[k] = t[k];
                                }
                            }
                            if (t.solo) {
                                sts.unshift(ato);
                            }
                            else {
                                ats.unshift(ato);
                            }
                        }
                    }
                }
            }
        }
        setTransitions(states, idCatch, acl, data, pState) {
            if (!states)
                return null;
            let exitRet = {};
            for (let i = states.length - 1; i >= 0; i--) {
                let obj = states[i];
                if (obj.states) {
                    let exitTransition = this.setTransitions(obj.states, idCatch, acl, data, obj);
                    if (exitTransition) {
                        let transitions = obj.soloTransitions;
                        if (transitions) {
                            this.setExitTransition(exitTransition, transitions, idCatch, data, exitRet);
                        }
                    }
                }
            }
            for (let i = states.length - 1; i >= 0; i--) {
                let obj = states[i];
                if (obj.states) {
                    continue;
                }
                if ("-1" == obj.id) {
                    if (obj.soloTransitions && 0 < obj.soloTransitions.length) {
                        if (null == pState) {
                            acl.defaultState = idCatch[obj.soloTransitions[0].id];
                        }
                        else {
                            idCatch[pState.id] = idCatch[obj.soloTransitions[0].id];
                        }
                        continue;
                    }
                }
                else if ("-2" == obj.id) {
                    let transitions = obj.soloTransitions;
                    if (transitions) {
                        for (let j = transitions.length - 1; j >= 0; j--) {
                            let o = transitions[j];
                            let destState = idCatch[o.id];
                            if (destState) {
                                for (let idk in idCatch) {
                                    let state = idCatch[idk];
                                    let ato = new AnimatorTransition2D();
                                    ato.destState = destState;
                                    if (o.conditions) {
                                        this.addConditions(o.conditions, ato, data);
                                    }
                                    for (let k in o) {
                                        if ("solo" == k || "id" == k || "conditions" == k) {
                                            continue;
                                        }
                                        else {
                                            ato[k] = o[k];
                                        }
                                    }
                                    if (o.solo) {
                                        state.soloTransitions.unshift(ato);
                                    }
                                    else {
                                        state.transitions.unshift(ato);
                                    }
                                }
                            }
                        }
                    }
                    continue;
                }
                else if ("-3" == obj.id) {
                    continue;
                }
                let soloTransitions = obj.soloTransitions;
                if (soloTransitions && idCatch[obj.id]) {
                    let ats = idCatch[obj.id].transitions;
                    let sts = idCatch[obj.id].soloTransitions;
                    for (let j = soloTransitions.length - 1; j >= 0; j--) {
                        let o = soloTransitions[j];
                        if ("-3" == o.id) {
                            if (null == exitRet[obj.id]) {
                                exitRet[obj.id] = [];
                            }
                            exitRet[obj.id].push(o);
                            continue;
                        }
                        let ato = new AnimatorTransition2D();
                        if (idCatch[o.id]) {
                            ato.destState = idCatch[o.id];
                        }
                        if (o.conditions) {
                            this.addConditions(o.conditions, ato, data);
                        }
                        for (let k in o) {
                            if ("solo" == k || "id" == k || "conditions" == k) {
                                continue;
                            }
                            else {
                                ato[k] = o[k];
                            }
                        }
                        if (o.solo) {
                            sts.unshift(ato);
                        }
                        else {
                            ats.unshift(ato);
                        }
                    }
                }
            }
            return exitRet;
        }
        addConditions(arr, ato, data) {
            let parms = data.animatorParams;
            if (null == parms || 0 == parms.length)
                return;
            for (let i = 0, len = arr.length; i < len; i++) {
                let o = arr[i];
                let parm = null;
                for (let j = parms.length - 1; j >= 0; j--) {
                    if (parms[j].id == o.id) {
                        parm = parms[j];
                        break;
                    }
                }
                if (null == parm) {
                    return;
                }
                let c;
                if (parm.type == exports.AniParmType.Bool) {
                    let b = new AnimatorStateBoolCondition(o.name);
                    b.compareFlag = Boolean(o.checkValue);
                    c = b;
                }
                else if (parm.type == exports.AniParmType.Float) {
                    let n = new AnimatorStateNumberCondition(o.name);
                    n.numberValue = Number(o.checkValue);
                    n.compareFlag = o.type;
                    c = n;
                }
                else if (parm.type == exports.AniParmType.Trigger) {
                    let t = new AnimatorStateTriggerCondition(o.name);
                    c = t;
                }
                ato.addCondition(c);
            }
        }
        updateTo(a) {
            let currLayer = a._controllerLayers;
            for (let i = 0, len = currLayer.length; i < len; i++) {
                currLayer[i].destroy();
            }
            currLayer.length = 0;
            let layers = this.getLayers();
            for (let i = 0, len = layers.length; i < len; i++) {
                a.addControllerLayer(layers[i]);
            }
            let parms = this.data.animatorParams;
            if (parms) {
                let setParm = {};
                for (let i = parms.length - 1; i >= 0; i--) {
                    let p = parms[i];
                    let sp = new Animation2DParm();
                    sp.name = p.name;
                    sp.type = p.type;
                    sp.value = p.val;
                    setParm[p.name] = sp;
                }
                a.parameters = setParm;
            }
        }
    }

    exports.TextResourceFormat = void 0;
    (function (TextResourceFormat) {
        TextResourceFormat[TextResourceFormat["Buffer"] = 0] = "Buffer";
        TextResourceFormat[TextResourceFormat["Plain"] = 1] = "Plain";
        TextResourceFormat[TextResourceFormat["JSON"] = 2] = "JSON";
        TextResourceFormat[TextResourceFormat["XML"] = 3] = "XML";
    })(exports.TextResourceFormat || (exports.TextResourceFormat = {}));
    class TextResource extends Resource {
        constructor(data, format) {
            super();
            this.data = data;
            this.format = format;
        }
    }

    class TextAssetLoader {
        load(task) {
            return task.loader.fetch(task.url, "text", task.progress.createCallback(), task.options).then(data => {
                if (!data)
                    return null;
                return new TextResource(data, exports.TextResourceFormat.Plain);
            });
        }
    }
    class BytesAssetLoader {
        load(task) {
            return task.loader.fetch(task.url, "arraybuffer", task.progress.createCallback(), task.options).then(data => {
                if (!data)
                    return null;
                return new TextResource(data, exports.TextResourceFormat.Buffer);
            });
        }
    }
    class JsonAssetLoader {
        load(task) {
            return task.loader.fetch(task.url, "json", task.progress.createCallback(), task.options).then(data => {
                if (!data)
                    return null;
                return new TextResource(data, exports.TextResourceFormat.JSON);
            });
        }
    }
    class XMLAssetLoader {
        load(task) {
            return task.loader.fetch(task.url, "xml", task.progress.createCallback(), task.options).then(data => {
                if (!data)
                    return null;
                return new TextResource(data, exports.TextResourceFormat.XML);
            });
        }
    }
    Loader.registerLoader(["txt", "csv"], TextAssetLoader, Loader.TEXT);
    Loader.registerLoader(["bin", "bytes"], BytesAssetLoader, Loader.BUFFER);
    Loader.registerLoader(["json"], JsonAssetLoader, Loader.JSON);
    Loader.registerLoader(["xml", "fnt"], XMLAssetLoader, Loader.XML);

    class AtlasLoader {
        load(task) {
            return task.loader.fetch(task.url, "json", task.progress.createCallback(0.2), task.options).then(data => {
                if (!data)
                    return null;
                let toloadPics = [];
                if (data.meta && data.meta.image) {
                    let folderPath = "";
                    let i = task.url.lastIndexOf("/");
                    if (i != -1)
                        folderPath = task.url.substring(0, i + 1);
                    let query = "";
                    i = task.url.lastIndexOf("?");
                    if (i != -1)
                        query = task.url.substring(i);
                    let pics = data.meta.image.split(",");
                    for (let pic of pics)
                        toloadPics.push(task.loader.load(folderPath + pic + query, null, task.progress.createCallback()));
                }
                else {
                    toloadPics.push(task.loader.load(Utils.replaceFileExtension(task.url, "png"), null, task.progress.createCallback()));
                }
                return Promise.all(toloadPics).then(pics => {
                    let baseUrl = task.options.baseUrl || "";
                    let frames = data.frames;
                    let directory = (data.meta && data.meta.prefix != null) ? data.meta.prefix : task.url.substring(0, task.url.lastIndexOf(".")) + "/";
                    let subTextures = [];
                    let scaleRate = 1;
                    if (data.meta && data.meta.scale && data.meta.scale != 1)
                        scaleRate = parseFloat(data.meta.scale);
                    for (let tPic of pics) {
                        if (tPic) {
                            tPic._addReference();
                            tPic.scaleRate = scaleRate;
                        }
                    }
                    for (let name in frames) {
                        let obj = frames[name];
                        let tPic = pics[obj.frame.idx ? obj.frame.idx : 0];
                        if (!tPic)
                            continue;
                        let url = baseUrl + directory + name;
                        let tTexture = Texture.create(tPic, obj.frame.x, obj.frame.y, obj.frame.w, obj.frame.h, obj.spriteSourceSize.x, obj.spriteSourceSize.y, obj.sourceSize.w, obj.sourceSize.h);
                        tTexture.lock = true;
                        task.loader.cacheRes(url, tTexture);
                        tTexture.url = url;
                        subTextures.push(tTexture);
                    }
                    return new AtlasResource(directory, pics, subTextures);
                });
            });
        }
    }
    Loader.registerLoader(["atlas"], AtlasLoader, Loader.ATLAS);

    const TypedArrayClasses = {
        "Int8Array": Int8Array,
        "Uint8Array": Uint8Array,
        "Int16Array": Int16Array,
        "Uint16Array": Uint16Array,
        "Int32Array": Int32Array,
        "Uint32Array": Uint32Array,
        "Float32Array": Float32Array,
        "Float64Array": Float64Array
    };
    class SerializeUtil {
        static decodeObj(data, obj, type, nodeFinder, errors) {
            if (data == null)
                return null;
            else if (Array.isArray(data)) {
                let arr = [];
                for (let i = 0; i < data.length; i++) {
                    let v = data[i];
                    if (v != null) {
                        try {
                            arr[i] = this.decodeObj(v, null, null, nodeFinder, errors);
                        }
                        catch (error) {
                            if (errors)
                                errors.push(error);
                            arr[i] = null;
                        }
                    }
                    else
                        arr[i] = null;
                }
                return arr;
            }
            else if (typeof (data) === "object") {
                if (data._$uuid != null) {
                    let url = URL.getResURLByUUID(data._$uuid);
                    return ILaya.loader.getRes(url, SerializeUtil.getLoadTypeByEngineType(data._$type));
                }
                if (data._$ref != null) {
                    let node = nodeFinder === null || nodeFinder === void 0 ? void 0 : nodeFinder(data._$ref);
                    if (node && data._$type) {
                        let cls = ClassUtils.getClass(data._$type);
                        if (cls)
                            return node.getComponent(cls);
                        else
                            return null;
                    }
                    else
                        return node;
                }
                type = type || data._$type;
                if (type === "any") {
                    if (data._$type)
                        return data.value;
                    else
                        return data;
                }
                let typedArray = TypedArrayClasses[type];
                if (typedArray != null) {
                    if (data._$type)
                        return new typedArray(data.value);
                    else
                        return new typedArray(data);
                }
                if (!obj) {
                    let cls = ClassUtils.getClass(type);
                    if (!cls) {
                        return null;
                    }
                    obj = new cls();
                }
                for (let key in data) {
                    if (key.startsWith("_$"))
                        continue;
                    let v = data[key];
                    if (v == null || typeof (v) !== "object" || Array.isArray(v)
                        || v._$type || v._$uuid || v._$ref) {
                        try {
                            obj[key] = SerializeUtil.decodeObj(v, null, null, nodeFinder, errors);
                        }
                        catch (error) {
                            if (errors)
                                errors.push(error);
                        }
                    }
                    else {
                        let childObj = obj[key];
                        if (childObj) {
                            try {
                                SerializeUtil.decodeObj(v, childObj, null, nodeFinder, errors);
                            }
                            catch (error) {
                                if (errors)
                                    errors.push(error);
                            }
                        }
                    }
                }
                if (obj.onAfterDeserialize)
                    obj.onAfterDeserialize();
                return obj;
            }
            else
                return data;
        }
        static getLoadTypeByEngineType(type) {
            switch (type) {
                case "Texture2D":
                case "RenderTexture":
                    return Loader.TEXTURE2D;
                case "TextureCube":
                    return Loader.TEXTURECUBE;
                case "Prefab":
                    return Loader.HIERARCHY;
                default:
                    return null;
            }
        }
    }

    const errorList = [];
    class HierarchyParser {
        static parse(data, options, errors) {
            errors = errors || errorList;
            let nodeMap = {};
            let dataList = [];
            let allNodes = [];
            let outNodes = [];
            let scene;
            let inPrefab;
            let prefabNodeDict;
            let skinBaseUrl;
            if (options) {
                inPrefab = options.inPrefab;
                if (inPrefab)
                    prefabNodeDict = options.prefabNodeDict;
                skinBaseUrl = options.skinBaseUrl;
            }
            function createChildren(data, prefab) {
                for (let child of data._$child) {
                    if (child._$child) {
                        let node = createNode(child, prefab);
                        createChildren(child, child._$prefab ? node : prefab);
                        dataList.push(child);
                        allNodes.push(node);
                    }
                    else {
                        let node = createNode(child, prefab);
                        dataList.push(child);
                        allNodes.push(node);
                    }
                }
            }
            function createNode(nodeData, prefab, runtime) {
                let node;
                let pstr;
                if (pstr = nodeData._$override) {
                    if (prefab && prefabNodeDict) {
                        if (Array.isArray(pstr)) {
                            node = prefab;
                            for (let i = 0, n = pstr.length; i < n; i++) {
                                let map = prefabNodeDict.get(node);
                                node = map === null || map === void 0 ? void 0 : map[pstr[i]];
                                if (!node)
                                    break;
                            }
                        }
                        else {
                            let map = prefabNodeDict.get(prefab);
                            if (map)
                                node = map[nodeData._$override];
                        }
                    }
                }
                else {
                    if (pstr = nodeData._$prefab) {
                        let res = Loader.getRes(URL.getResURLByUUID(pstr), Loader.HIERARCHY);
                        if (res) {
                            if (!prefabNodeDict)
                                prefabNodeDict = new Map();
                            node = res.create({ inPrefab: true, prefabNodeDict: prefabNodeDict }, errors);
                        }
                    }
                    else if (pstr = nodeData._$type) {
                        let cls = runtime !== null && runtime !== void 0 ? runtime : ClassUtils.getClass(pstr);
                        if (cls) {
                            try {
                                node = new cls();
                            }
                            catch (err) {
                                errors.push(err);
                            }
                        }
                        else {
                            errors.push(new Error(`unknown type '${pstr}'`));
                        }
                    }
                    if (node)
                        nodeMap[nodeData._$id] = node;
                }
                return node;
            }
            function findNode(idPath) {
                if (Array.isArray(idPath)) {
                    let prefab = nodeMap[idPath[0]];
                    if (prefab && idPath.length > 1)
                        return findNodeInPrefab(prefab, idPath, 1);
                    else
                        return prefab;
                }
                else
                    return nodeMap[idPath];
            }
            function findNodeInPrefab(prefab, idPath, startIndex = 0) {
                if (!idPath)
                    return prefab;
                let map = prefabNodeDict === null || prefabNodeDict === void 0 ? void 0 : prefabNodeDict.get(prefab);
                if (!map)
                    return null;
                if (Array.isArray(idPath)) {
                    let node;
                    for (let i = startIndex, n = idPath.length; i < n; i++) {
                        if (!map)
                            return null;
                        node = map[idPath[i]];
                        if (!node)
                            break;
                        map = prefabNodeDict.get(node);
                    }
                    return node;
                }
                else
                    return map[idPath];
            }
            let runtime;
            if (data._$type || data._$prefab) {
                if (runtime = data._$runtime) {
                    if (runtime.startsWith("res://"))
                        runtime = runtime.substring(6);
                    let cls = ClassUtils.getClass(runtime);
                    if (cls)
                        runtime = cls;
                    else
                        errors.push(new Error(`unknown runtime '${runtime}'`));
                }
                let node = createNode(data, null, runtime);
                if (node) {
                    if (data._$child)
                        createChildren(data, data._$prefab ? node : null);
                    dataList.push(data);
                    allNodes.push(node);
                    if (node instanceof Scene)
                        scene = node;
                }
            }
            else {
                if (data._$child)
                    createChildren(data, null);
            }
            let cnt = dataList.length;
            let k = 0;
            for (let i = 0; i < cnt; i++) {
                let nodeData = dataList[i];
                let node = allNodes[i];
                let children = nodeData._$child;
                if (children) {
                    let num = children.length;
                    if (node) {
                        if (nodeData._$prefab) {
                            for (let j = 0; j < num; j++) {
                                let m = k - num + j;
                                let n = outNodes[m];
                                if (n && !n.parent) {
                                    let nodeData2 = dataList[i - num + j];
                                    let parentNode = findNodeInPrefab(node, nodeData2._$parent);
                                    if (parentNode) {
                                        let pos = nodeData2._$index;
                                        if (pos != null && pos < parentNode.numChildren)
                                            parentNode.addChildAt(n, pos);
                                        else
                                            parentNode.addChild(n);
                                    }
                                    else {
                                        node.addChildAt(n, 0);
                                    }
                                }
                            }
                        }
                        else {
                            for (let j = 0; j < num; j++) {
                                let n = outNodes[k - num + j];
                                if (n) {
                                    if (node === scene && n._is3D)
                                        scene._scene3D = n;
                                    else
                                        node.addChild(n);
                                }
                            }
                        }
                    }
                    k -= num;
                }
                outNodes[k] = node;
                k++;
            }
            outNodes.length = k;
            outNodes = outNodes.filter(n => n != null);
            let topNode = outNodes[0];
            let compInitList = [];
            for (let i = 0; i < cnt; i++) {
                let components = dataList[i]._$comp;
                if (!components)
                    continue;
                let node = allNodes[i];
                if (!node)
                    continue;
                for (let compData of components) {
                    let comp;
                    if (compData._$override) {
                        let cls = ClassUtils.getClass(compData._$override);
                        if (cls)
                            comp = node.getComponent(cls);
                    }
                    else {
                        let cls = ClassUtils.getClass(compData._$type);
                        if (cls) {
                            comp = node.getComponent(cls);
                            if (!comp) {
                                try {
                                    comp = node.addComponent(cls);
                                }
                                catch (err) {
                                    errors.push(err);
                                }
                            }
                        }
                    }
                    if (comp)
                        compInitList.push(compData, comp);
                }
            }
            for (let i = 0; i < cnt; i++) {
                let nodeData = dataList[i];
                let node = allNodes[i];
                if (node) {
                    if (skinBaseUrl != null && (node instanceof Sprite))
                        node._skinBaseUrl = skinBaseUrl;
                    SerializeUtil.decodeObj(nodeData, node, null, findNode, errors);
                    if (runtime && nodeData._$var && node.name) {
                        try {
                            topNode[node.name] = node;
                        }
                        catch (err) {
                            errors.push(err);
                        }
                    }
                }
            }
            cnt = compInitList.length;
            for (let i = 0; i < cnt; i += 2) {
                SerializeUtil.decodeObj(compInitList[i], compInitList[i + 1], null, findNode, errors);
            }
            if (inPrefab && prefabNodeDict && topNode)
                prefabNodeDict.set(topNode, nodeMap);
            if (errors == errorList)
                errorList.length = 0;
            return outNodes;
        }
        static collectResourceLinks(data, basePath) {
            let test = {};
            let innerUrls = [];
            function addInnerUrl(url, type) {
                if (!url)
                    return "";
                let entry = test[url];
                if (entry === undefined) {
                    let url2;
                    if (url.length >= 36 && url.charCodeAt(8) === 45 && url.charCodeAt(13) === 45)
                        url2 = "res://" + url;
                    else
                        url2 = URL.join(basePath, url);
                    innerUrls.push({ url: url2, type: type });
                    test[url] = entry = [url2, type];
                }
                else if (entry.indexOf(type) == -1) {
                    entry.push(type);
                    innerUrls.push({ url: entry[0], type: type });
                }
                return entry[0];
            }
            function check(data) {
                for (let key in data) {
                    let child = data[key];
                    if (child == null)
                        continue;
                    if (Array.isArray(child)) {
                        for (let item of child) {
                            if (item == null)
                                continue;
                            if (typeof (item) === "object") {
                                if (item._$uuid != null)
                                    item._$uuid = addInnerUrl(item._$uuid, SerializeUtil.getLoadTypeByEngineType(item._$type));
                                else if (item._$prefab != null) {
                                    item._$prefab = addInnerUrl(item._$prefab, Loader.HIERARCHY);
                                    check(item);
                                }
                                else
                                    check(item);
                            }
                        }
                    }
                    else if (typeof (child) === "object") {
                        if (child._$uuid != null)
                            child._$uuid = addInnerUrl(child._$uuid, SerializeUtil.getLoadTypeByEngineType(child._$type));
                        else if (child._$prefab != null) {
                            child._$prefab = addInnerUrl(child._$prefab, Loader.HIERARCHY);
                            check(child);
                        }
                        else
                            check(child);
                    }
                }
            }
            check(data);
            return innerUrls;
        }
    }

    class HierarchyLoader {
        load(task) {
            let url = task.url;
            let isModel = task.ext == "gltf" || task.ext == "fbx";
            if (isModel)
                url = AssetDb.inst.getSubAssetURL(url, task.uuid, "0", "lh");
            return task.loader.fetch(url, "json", task.progress.createCallback(0.2), task.options).then(data => {
                if (!data)
                    return null;
                if (data._$ver != null)
                    return this._load(HierarchyLoader.v3, task, data, 3);
                else if (task.ext == "ls" || task.ext == "lh")
                    return this._load(HierarchyLoader.v2, task, data, 2);
                else if (task.ext == "scene" || task.ext == "prefab")
                    return this._load(HierarchyLoader.legacySceneOrPrefab, task, data, 2);
                else
                    return null;
            });
        }
        _load(api, task, data, version) {
            let basePath = URL.getPath(task.url);
            let links = api.collectResourceLinks(data, basePath);
            return task.loader.load(links, null, task.progress.createCallback()).then((resArray) => {
                let res = new PrefabImpl(api, data, version);
                res.addDeps(resArray);
                return res;
            });
        }
    }
    HierarchyLoader.v3 = HierarchyParser;
    HierarchyLoader.v2 = null;
    HierarchyLoader.legacySceneOrPrefab = LegacyUIParser;
    Loader.registerLoader(["lh", "ls", "scene", "prefab"], HierarchyLoader, Loader.HIERARCHY);

    class HDRTextureInfo {
        constructor(source, byteOffset, decreaseX, decreaseY, width, height, format) {
            this.source = source;
            this.byteOffset = byteOffset;
            this.decreaseX = decreaseX;
            this.decreaseY = decreaseY;
            this.width = width;
            this.height = height;
            this.format = format;
        }
        static _parseHDRTexture(data, propertyParams = null, constructParams = null) {
            let hdrInfo = HDRTextureInfo.getHDRInfo(data);
            let texture = new Texture2D(hdrInfo.width, hdrInfo.height, hdrInfo.format, false, false, false);
            texture.setHDRData(hdrInfo);
            return texture;
        }
        static getHDRInfo(source) {
            let data = new Uint8Array(source);
            let readByteOffset = 0;
            const readLine = () => {
                let lineStr = HDRTextureInfo.getLineString(data, readByteOffset);
                readByteOffset += lineStr.length + 1;
                return lineStr;
            };
            let identifier = readLine();
            if (identifier != "#?RADIANCE") {
                throw "HDR image: identifier wrong.";
            }
            let commandsMap = new Map();
            let line = "";
            do {
                line = readLine();
                if (line[0] != "#") {
                    let commands = line.split("=");
                    commandsMap.set(commands[0], commands[1]);
                }
            } while (line != "");
            let hdrFormat = commandsMap.get("FORMAT");
            if (hdrFormat != "32-bit_rle_rgbe") {
                throw "HDR image: unsupported format.";
            }
            let resolutionStr = readLine();
            let resolutions = resolutionStr.split(" ");
            let decreaseY = resolutions[0] == "-Y";
            let decreaseX = resolutions[2] == "-X";
            let height = parseInt(resolutions[1]);
            let width = parseInt(resolutions[3]);
            let hdrInfo = new HDRTextureInfo(source, readByteOffset, decreaseX, decreaseY, width, height, exports.TextureFormat.R32G32B32);
            return hdrInfo;
        }
        static getLineString(data, readByteOffset) {
            let dataLength = data.length;
            let index = readByteOffset;
            let res = "";
            let char = "";
            while (index < dataLength && char != "\n") {
                res = `${res}${char}`;
                char = String.fromCharCode(data[index]);
                index++;
            }
            return res;
        }
        get_32_bit_rle_rgbe() {
            let width = this.width;
            let height = this.height;
            this.decreaseX;
            this.decreaseY;
            let data = new Uint8Array(this.source, this.byteOffset);
            let dataIndex = 0;
            let rgbeBuffer = new ArrayBuffer(width * 4);
            let rgbeArray = new Uint8Array(rgbeBuffer);
            let pixelBuffer = new ArrayBuffer(width * height * 4 * 3);
            let pixelArray = new Float32Array(pixelBuffer);
            for (let y = height; y > 0; y--) {
                data[dataIndex++];
                data[dataIndex++];
                let c = data[dataIndex++];
                let d = data[dataIndex++];
                let scanlineLength = (c << 8) | d;
                if (scanlineLength != width) {
                    throw "HDR info: scanlineLength wrong.";
                }
                let index = 0;
                for (let i = 0; i < 4; i++) {
                    let endIndex = (i + 1) * scanlineLength;
                    while (index < endIndex) {
                        let a = data[dataIndex++];
                        let b = data[dataIndex++];
                        if (a > 128) {
                            let count = a - 128;
                            if (count > endIndex - index) {
                                throw "HDR info: ??";
                            }
                            while (count-- > 0) {
                                rgbeArray[index++] = b;
                            }
                        }
                        else {
                            let count = a;
                            if (count == 0 || count > endIndex - index) {
                                throw "HDR info: ??";
                            }
                            rgbeArray[index++] = b;
                            if (--count > 0) {
                                for (let j = 0; j < count; j++) {
                                    rgbeArray[index++] = data[dataIndex++];
                                }
                            }
                        }
                    }
                }
                for (let i = 0; i < scanlineLength; i++) {
                    let r = rgbeArray[i];
                    let g = rgbeArray[i + scanlineLength];
                    let b = rgbeArray[i + 2 * scanlineLength];
                    let e = rgbeArray[i + 3 * scanlineLength];
                    let index = (height - y) * scanlineLength * 3 + i * 3;
                    const Ldexp = (mantissa, exponent) => {
                        if (exponent > 1023) {
                            return mantissa * Math.pow(2, 1023) * Math.pow(2, exponent - 1023);
                        }
                        if (exponent < -1074) {
                            return mantissa * Math.pow(2, -1074) * Math.pow(2, exponent + 1074);
                        }
                        return mantissa * Math.pow(2, exponent);
                    };
                    if (e > 0) {
                        let exponent = Ldexp(1.0, e - (128 + 8));
                        pixelArray[index] = r * exponent;
                        pixelArray[index + 1] = g * exponent;
                        pixelArray[index + 2] = b * exponent;
                    }
                    else {
                        pixelArray[index] = 0;
                        pixelArray[index + 1] = 0;
                        pixelArray[index + 2] = 0;
                    }
                }
            }
            return pixelArray;
        }
        readScanLine() {
            let width = this.width;
            let height = this.height;
            let decreaseX = this.decreaseX;
            let decreaseY = this.decreaseY;
            let pixelArray = new Float32Array(width * height * 3);
            let scanlineArray = new Uint8Array(width * 4);
            let data = new Uint8Array(this.source, this.byteOffset);
            let dataLength = data.length;
            let dataIndex = 0;
            const getc = () => {
                if (dataIndex >= dataLength) {
                    throw "HDR info: data wrong.";
                }
                return data[dataIndex++];
            };
            const wrong = () => {
                throw "HDR info: data wrong.";
            };
            for (let y = height - 1; y >= 0; y--) {
                this.readcolors(scanlineArray, getc, wrong);
                for (let i = 0; i < width; i++) {
                    let index = 4 * i;
                    let byter = scanlineArray[index];
                    let byteg = scanlineArray[index + 1];
                    let byteb = scanlineArray[index + 2];
                    let bytee = scanlineArray[index + 3];
                    let offsetY = y;
                    let offsetX = i;
                    if (decreaseY) {
                        offsetY = height - 1 - y;
                    }
                    if (decreaseX) {
                        offsetX = width - 1 - i;
                    }
                    let pixelIndex = offsetY * width * 3 + offsetX * 3;
                    if (bytee == 0) {
                        pixelArray[pixelIndex] = 0;
                        pixelArray[pixelIndex + 1] = 0;
                        pixelArray[pixelIndex + 2] = 0;
                    }
                    else {
                        let f = ldexp(1.0, bytee - (128 + 8));
                        pixelArray[pixelIndex] = (byter + 0.5) * f;
                        pixelArray[pixelIndex + 1] = (byteg + 0.5) * f;
                        pixelArray[pixelIndex + 2] = (byteb + 0.5) * f;
                    }
                }
            }
            return pixelArray;
        }
        readcolors(scanlineArray, getc, wrong) {
            const setScanLineData = (w, channel, value) => {
                scanlineArray[w * 4 + channel] = value;
            };
            let width = this.width;
            let unnormalizedr = getc();
            let unnormalizedg = getc();
            let unnormalizedb = getc();
            let unnormalizede = getc();
            if (width < 8 || width > 32767) {
                this.olddreadcolors(scanlineArray, getc);
            }
            if (unnormalizedr != 2 || unnormalizedg != 2 || unnormalizedb & 128) {
                this.olddreadcolors(scanlineArray, getc);
            }
            if ((unnormalizedb << 8 | unnormalizede) != width) {
                wrong();
            }
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < width;) {
                    let code = getc();
                    if (code > 128) {
                        code &= 127;
                        let val = getc();
                        if (j + code > width) {
                            wrong();
                        }
                        while (code--) {
                            setScanLineData(j++, i, val);
                        }
                    }
                    else {
                        if (j + code > width) {
                            wrong();
                        }
                        while (code--) {
                            let val = getc();
                            setScanLineData(j++, i, val);
                        }
                    }
                }
            }
        }
        olddreadcolors(scanlineArray, getc) {
            let rshift = 0;
            let len = this.width;
            for (let w = 0; w < len; w++) {
                let unnormalizedr = getc();
                let unnormalizedg = getc();
                let unnormalizedb = getc();
                let unnormalizede = getc();
                let scanIndex = w * 4;
                scanlineArray[scanIndex] = unnormalizedr;
                scanlineArray[scanIndex + 1] = unnormalizedg;
                scanlineArray[scanIndex + 2] = unnormalizedb;
                scanlineArray[scanIndex + 3] = unnormalizede;
                if (unnormalizedr == 1 && unnormalizedg == 1 && unnormalizedb == 1) {
                    let lastIndex = scanIndex - 4;
                    for (let i = unnormalizede << rshift; i > 0; i--) {
                        scanlineArray[scanIndex] = scanlineArray[lastIndex];
                        scanlineArray[scanIndex + 1] = scanlineArray[lastIndex + 1];
                        scanlineArray[scanIndex + 2] = scanlineArray[lastIndex + 2];
                        scanlineArray[scanIndex + 3] = scanlineArray[lastIndex + 3];
                        len--;
                    }
                    rshift += 8;
                }
                else {
                    len--;
                    rshift = 0;
                }
            }
        }
        color_color(col, clr) {
            let f = 0;
            if (clr.w == 0) {
                col.x = col.y = col.z = 0;
            }
            else {
                f = ldexp(1.0, clr.w - (128 + 8));
                col.x = (clr.x) * f;
                col.y = (clr.y) * f;
                col.z = (clr.z) * f;
            }
        }
    }
    HDRTextureInfo.HDRTEXTURE = "HDRTEXTURE";
    function ldexp(value, exponent) {
        return value * Math.pow(2, exponent);
    }

    const metaFetchingOptions = { noRetry: true, silent: true };
    var internalResources;
    class Texture2DLoader {
        constructor() {
            if (!internalResources) {
                internalResources = {
                    "WhiteTexture.png": Texture2D.whiteTexture,
                    "BlackTexture.png": Texture2D.blackTexture,
                    "GrayTexture.png": Texture2D.grayTexture,
                    "NormalTexture.png": Texture2D.normalTexture,
                };
            }
        }
        load(task) {
            if (task.url.indexOf("internal/") != -1) {
                let tex = internalResources[Utils.getBaseName(task.url)];
                if (tex)
                    return Promise.resolve(tex);
            }
            let meta = AssetDb.inst.getMeta(task.url, task.uuid);
            if (!meta || typeof (meta) === "object")
                return this.load2(task, meta);
            else if (!task.options.noMetaFile)
                return task.loader.fetch(meta, "json", task.progress.createCallback(0.1), metaFetchingOptions)
                    .then(meta => this.load2(task, meta));
            else
                return this.load2(task, null);
        }
        load2(task, meta) {
            var _a;
            let constructParams;
            let propertyParams;
            let ext = task.ext;
            let url = task.url;
            if (meta) {
                let platform = Browser.platform;
                let fileIndex = ((_a = meta.platforms) === null || _a === void 0 ? void 0 : _a[platform]) || 0;
                let fileInfo = meta.files[fileIndex];
                if (fileInfo.file) {
                    url = AssetDb.inst.getSubAssetURL(url, task.uuid, fileInfo.file, fileInfo.ext);
                    ext = fileInfo.ext;
                }
                constructParams = [0, 0, fileInfo.format, meta.mipmap, meta.readWrite, meta.sRGB];
                propertyParams = {
                    wrapModeU: meta.wrapMode,
                    wrapModeV: meta.wrapMode,
                    filterMode: meta.filterMode,
                    anisoLevel: meta.anisoLevel,
                    premultiplyAlpha: meta.pma,
                    hdrEncodeFormat: meta.hdrEncodeFormat,
                };
            }
            else {
                constructParams = task.options.constructParams;
                propertyParams = task.options.propertyParams;
            }
            let compress = compressedFormats.indexOf(ext) != -1 ? ext : null;
            if (compress != null) {
                return task.loader.fetch(url, "arraybuffer", task.progress.createCallback(), task.options).then(data => {
                    if (!data)
                        return null;
                    let tex;
                    switch (compress) {
                        case "dds":
                            tex = Texture2D._parseDDS(data, propertyParams, constructParams);
                            break;
                        case "ktx":
                            let ktxInfo = KTXTextureInfo.getKTXTextureInfo(data);
                            if (ktxInfo.dimension == exports.TextureDimension.Cube) {
                                let cls = ClassUtils.getClass("TextureCube");
                                if (cls) {
                                    let tc = new cls(ktxInfo.width, ktxInfo.format, ktxInfo.mipmapCount > 1, ktxInfo.sRGB);
                                    tc.setKTXData(ktxInfo);
                                    tex = tc;
                                }
                                else
                                    return null;
                            }
                            else if (ktxInfo.dimension == exports.TextureDimension.Tex2D) {
                                tex = Texture2D._parseKTX(data, propertyParams, constructParams);
                            }
                            break;
                        case "pvr":
                            tex = Texture2D._parsePVR(data, propertyParams, constructParams);
                            break;
                        case "hdr":
                            tex = HDRTextureInfo._parseHDRTexture(data, propertyParams, constructParams);
                            break;
                        case "lanit.ls":
                            tex = Texture2D._SimpleAnimatorTextureParse(data, propertyParams, constructParams);
                            break;
                    }
                    let obsoluteInst = task.obsoluteInst;
                    if (obsoluteInst && Object.getPrototypeOf(obsoluteInst) == Object.getPrototypeOf(tex))
                        tex = this.move(obsoluteInst, tex);
                    if (propertyParams && propertyParams.hdrEncodeFormat)
                        tex.hdrEncodeFormat = propertyParams.hdrEncodeFormat;
                    return tex;
                });
            }
            else {
                return task.loader.fetch(url, "image", task.progress.createCallback(), task.options).then(img => {
                    if (!img)
                        return null;
                    let tex = Texture2D._parseImage(img, propertyParams, constructParams);
                    let obsoluteInst = task.obsoluteInst;
                    if (obsoluteInst && Object.getPrototypeOf(obsoluteInst) == Object.getPrototypeOf(tex))
                        tex = this.move(obsoluteInst, tex);
                    return tex;
                });
            }
        }
        move(obsoluteInst, tex) {
            obsoluteInst._texture = tex._texture;
            obsoluteInst.width = tex.width;
            obsoluteInst.height = tex.height;
            obsoluteInst.obsolute = false;
            delete Resource._idResourcesMap[tex.id];
            return obsoluteInst;
        }
    }
    class RenderTextureLoader {
        load(task) {
            return task.loader.fetch(task.url, "json", task.progress.createCallback(), task.options).then(data => {
                if (!data)
                    return null;
                let obsoluteInst = task.obsoluteInst;
                if (obsoluteInst) {
                    obsoluteInst.recreate(data.width, data.height, data.colorFormat, data.depthFormat, data.generateMipmap, data.multiSamples, false, data.sRGB);
                    return obsoluteInst;
                }
                else
                    return new RenderTexture(data.width, data.height, data.colorFormat, data.depthFormat, data.generateMipmap, data.multiSamples, false, data.sRGB);
            });
        }
    }
    class VideoTextureLoader {
        load(task) {
            let inst = task.obsoluteInst || new VideoTexture();
            inst.source = task.url;
            return Promise.resolve(inst);
        }
    }
    const propertyParams2d = { premultiplyAlpha: true };
    const constructParams2d = [null, null, exports.TextureFormat.R8G8B8A8, false, false, true];
    class TextureLoader {
        wrapTex2D(task, tex2D) {
            if (!tex2D)
                return null;
            let tex = task.obsoluteInst;
            if (tex) {
                tex.setTo(tex2D);
                tex.obsolute = false;
            }
            else
                tex = new Texture(tex2D);
            return tex;
        }
        load(task) {
            let tex2D = task.loader.getRes(task.url, Loader.TEXTURE2D);
            if (!tex2D || tex2D.obsolute) {
                let url = { url: task.url, type: Loader.TEXTURE2D };
                if (!task.options.propertyParams)
                    url.propertyParams = propertyParams2d;
                else if (task.options.propertyParams.premultiplyAlpha == null)
                    url.propertyParams = Object.assign({}, propertyParams2d, task.options.propertyParams);
                if (!task.options.constructParams)
                    url.constructParams = constructParams2d;
                else if (task.options.constructParams[5] == null)
                    url.constructParams = Object.assign([], constructParams2d, task.options.constructParams);
                return task.loader.load(url, task.options, task.progress.createCallback()).then(tex2D => {
                    return this.wrapTex2D(task, tex2D);
                });
            }
            else
                return Promise.resolve(this.wrapTex2D(task, tex2D));
        }
    }
    const compressedFormats = ["ktx", "pvr", "dds", "hdr", "lanit.ls"];
    const videoFormats = ["mp4", "webm"];
    Loader.registerLoader(["png", "jpg", "jpeg", "rendertexture", ...videoFormats, ...compressedFormats], TextureLoader, Loader.IMAGE);
    Loader.registerLoader([], Texture2DLoader, Loader.TEXTURE2D);
    Loader.registerLoader(["rendertexture"], RenderTextureLoader, Loader.TEXTURE2D);
    Loader.registerLoader(videoFormats, VideoTextureLoader, Loader.TEXTURE2D);

    class AnimationClip2DLoader {
        load(task) {
            return task.loader.fetch(task.url, "arraybuffer", task.progress.createCallback(), task.options).then(data => {
                if (!data)
                    return null;
                return AnimationClip2D._parse(data);
            });
        }
    }
    Loader.registerLoader(["mc"], AnimationClip2DLoader, "ANIMATIONCLIP2D");

    class NullLoader {
        load(task) {
            return Promise.resolve(null);
        }
    }
    Loader.registerLoader(["lighting"], NullLoader);

    class WebAudioLoader {
        load(task) {
            return task.loader.fetch(task.url, "arraybuffer", task.progress.createCallback(), task.options).then(data => {
                if (!data)
                    return null;
                return WebAudioSound.ctx.decodeAudioData(data);
            });
        }
    }
    Loader.registerLoader(["mp3", "wav", "ogg"], WebAudioLoader, Loader.SOUND);

    let c = ClassUtils.regClass;
    c("Record", Object);
    c("Node", Node);
    c("Sprite", Sprite);
    c("Widget", Widget);
    c("Text", Text);
    c("Input", Input);
    c("AnimationBase", AnimationBase);
    c("Animation", Animation);
    c("FrameAnimation", FrameAnimation);
    c("EffectAnimation", EffectAnimation);
    c("SoundNode", SoundNode);
    c("VideoNode", VideoNode);
    c("Scene", Scene);
    c("Stage", Stage);
    c("Component", Component);
    c("BitmapFont", BitmapFont);
    c("BlurFilter", BlurFilter);
    c("ColorFilter", ColorFilter);
    c("GlowFilter", GlowFilter);
    c("Point", Point);
    c("Rectangle", Rectangle);
    c("Texture", Texture);
    c("Texture2D", Texture2D);
    c("Prefab", Prefab);
    c("Animator2D", Animator2D);
    c("AnimatorControllerLayer2D", AnimatorControllerLayer2D);
    c("AnimatorState2D", AnimatorState2D);
    c("AnimationClip2D", AnimationClip2D);
    c("AnimatorController2D", AnimatorController2D);
    c("Animation2DParm", Animation2DParm);
    c("Animation2DCondition", Animation2DCondition);
    c("Vector2", Vector2);
    c("Vector3", Vector3);
    c("Vector4", Vector4);
    c("Quaternion", Quaternion);
    c("Color", Color);

    class AnimatorState2DScript {
        onStateEnter() {
        }
        onStateUpdate() {
        }
        onStateExit() {
        }
    }

    class Script extends Component {
        _isScript() {
            return true;
        }
        setupScript() {
            let owner = this.owner;
            let func;
            if (func = this.onTriggerEnter)
                owner.on(Event.TRIGGER_ENTER, this, func);
            if (func = this.onTriggerStay)
                owner.on(Event.TRIGGER_STAY, this, func);
            if (func = this.onTriggerExit)
                owner.on(Event.TRIGGER_EXIT, this, func);
            if (func = this.onCollisionEnter)
                owner.on(Event.COLLISION_ENTER, this, func);
            if (func = this.onCollisionStay)
                owner.on(Event.COLLISION_STAY, this, func);
            if (func = this.onCollisionExit)
                owner.on(Event.COLLISION_EXIT, this, func);
            if (func = this.onJointBreak)
                owner.on(Event.JOINT_BREAK, this, func);
            if (func = this.onMouseDown)
                owner.on(Event.MOUSE_DOWN, this, func);
            if (func = this.onMouseUp)
                owner.on(Event.MOUSE_UP, this, func);
            if (func = this.onRightMouseDown)
                owner.on(Event.RIGHT_MOUSE_DOWN, this, func);
            if (func = this.onRightMouseUp)
                owner.on(Event.RIGHT_MOUSE_UP, this, func);
            if (func = this.onMouseMove)
                owner.on(Event.MOUSE_MOVE, this, func);
            if (func = this.onMouseDrag)
                owner.on(Event.MOUSE_DRAG, this, func);
            if (func = this.onMouseDragEnd)
                owner.on(Event.MOUSE_DRAG_END, this, func);
            if (func = this.onMouseOver)
                owner.on(Event.MOUSE_OVER, this, func);
            if (func = this.onMouseOut)
                owner.on(Event.MOUSE_OUT, this, func);
            if (func = this.onMouseClick)
                owner.on(Event.CLICK, this, func);
            if (func = this.onMouseDoubleClick)
                owner.on(Event.DOUBLE_CLICK, this, func);
            if (func = this.onMouseRightClick)
                owner.on(Event.RIGHT_CLICK, this, func);
            if (func = this.onKeyDown)
                owner.on(Event.KEY_DOWN, this, func);
            if (func = this.onKeyPress)
                owner.on(Event.KEY_PRESS, this, func);
            if (func = this.onKeyUp)
                owner.on(Event.KEY_UP, this, func);
        }
    }

    class ButtonEffect {
        constructor() {
            this._curState = 0;
            this.effectScale = 1.5;
            this.tweenTime = 300;
        }
        set target(tar) {
            this._tar = tar;
            tar.on(Event.MOUSE_DOWN, this, this.toChangedState);
            tar.on(Event.MOUSE_UP, this, this.toInitState);
            tar.on(Event.MOUSE_OUT, this, this.toInitState);
        }
        toChangedState() {
            this._curState = 1;
            if (this._curTween)
                Tween.clear(this._curTween);
            this._curTween = Tween.to(this._tar, { scaleX: this.effectScale, scaleY: this.effectScale }, this.tweenTime, Ease[this.effectEase], Handler.create(this, this.tweenComplete));
        }
        toInitState() {
            if (this._curState == 2)
                return;
            if (this._curTween)
                Tween.clear(this._curTween);
            this._curState = 2;
            this._curTween = Tween.to(this._tar, { scaleX: 1, scaleY: 1 }, this.tweenTime, Ease[this.backEase], Handler.create(this, this.tweenComplete));
        }
        tweenComplete() {
            this._curState = 0;
            this._curTween = null;
        }
    }

    class EffectBase extends Component {
        constructor() {
            super(...arguments);
            this.duration = 1000;
            this.delay = 0;
            this.repeat = 0;
            this.autoDestroyAtComplete = true;
        }
        _onAwake() {
            this.target = this.target || this.owner;
            if (this.autoDestroyAtComplete)
                this._comlete = Handler.create(this.target, this.target.destroy, null, false);
            if (this.eventName)
                this.owner.on(this.eventName, this, this._exeTween);
            else
                this._exeTween();
        }
        _exeTween() {
            this._tween = this._doTween();
            this._tween.repeat = this.repeat;
        }
        _doTween() {
            return null;
        }
        onReset() {
            this.duration = 1000;
            this.delay = 0;
            this.repeat = 0;
            this.ease = null;
            this.target = null;
            if (this.eventName) {
                this.owner.off(this.eventName, this, this._exeTween);
                this.eventName = null;
            }
            if (this._comlete) {
                this._comlete.recover();
                this._comlete = null;
            }
            if (this._tween) {
                this._tween.clear();
                this._tween = null;
            }
        }
    }

    class FadeIn extends EffectBase {
        _doTween() {
            this.target.alpha = 0;
            return Tween.to(this.target, { alpha: 1 }, this.duration, Ease[this.ease], this._comlete, this.delay);
        }
    }

    class FadeOut extends EffectBase {
        _doTween() {
            this.target.alpha = 1;
            return Tween.to(this.target, { alpha: 0 }, this.duration, Ease[this.ease], this._comlete, this.delay);
        }
    }

    class Keyboard {
    }
    Keyboard.NUMBER_0 = 48;
    Keyboard.NUMBER_1 = 49;
    Keyboard.NUMBER_2 = 50;
    Keyboard.NUMBER_3 = 51;
    Keyboard.NUMBER_4 = 52;
    Keyboard.NUMBER_5 = 53;
    Keyboard.NUMBER_6 = 54;
    Keyboard.NUMBER_7 = 55;
    Keyboard.NUMBER_8 = 56;
    Keyboard.NUMBER_9 = 57;
    Keyboard.A = 65;
    Keyboard.B = 66;
    Keyboard.C = 67;
    Keyboard.D = 68;
    Keyboard.E = 69;
    Keyboard.F = 70;
    Keyboard.G = 71;
    Keyboard.H = 72;
    Keyboard.I = 73;
    Keyboard.J = 74;
    Keyboard.K = 75;
    Keyboard.L = 76;
    Keyboard.M = 77;
    Keyboard.N = 78;
    Keyboard.O = 79;
    Keyboard.P = 80;
    Keyboard.Q = 81;
    Keyboard.R = 82;
    Keyboard.S = 83;
    Keyboard.T = 84;
    Keyboard.U = 85;
    Keyboard.V = 86;
    Keyboard.W = 87;
    Keyboard.X = 88;
    Keyboard.Y = 89;
    Keyboard.Z = 90;
    Keyboard.F1 = 112;
    Keyboard.F2 = 113;
    Keyboard.F3 = 114;
    Keyboard.F4 = 115;
    Keyboard.F5 = 116;
    Keyboard.F6 = 117;
    Keyboard.F7 = 118;
    Keyboard.F8 = 119;
    Keyboard.F9 = 120;
    Keyboard.F10 = 121;
    Keyboard.F11 = 122;
    Keyboard.F12 = 123;
    Keyboard.F13 = 124;
    Keyboard.F14 = 125;
    Keyboard.F15 = 126;
    Keyboard.NUMPAD = 21;
    Keyboard.NUMPAD_0 = 96;
    Keyboard.NUMPAD_1 = 97;
    Keyboard.NUMPAD_2 = 98;
    Keyboard.NUMPAD_3 = 99;
    Keyboard.NUMPAD_4 = 100;
    Keyboard.NUMPAD_5 = 101;
    Keyboard.NUMPAD_6 = 102;
    Keyboard.NUMPAD_7 = 103;
    Keyboard.NUMPAD_8 = 104;
    Keyboard.NUMPAD_9 = 105;
    Keyboard.NUMPAD_ADD = 107;
    Keyboard.NUMPAD_DECIMAL = 110;
    Keyboard.NUMPAD_DIVIDE = 111;
    Keyboard.NUMPAD_ENTER = 108;
    Keyboard.NUMPAD_MULTIPLY = 106;
    Keyboard.NUMPAD_SUBTRACT = 109;
    Keyboard.SEMICOLON = 186;
    Keyboard.EQUAL = 187;
    Keyboard.COMMA = 188;
    Keyboard.MINUS = 189;
    Keyboard.PERIOD = 190;
    Keyboard.SLASH = 191;
    Keyboard.BACKQUOTE = 192;
    Keyboard.LEFTBRACKET = 219;
    Keyboard.BACKSLASH = 220;
    Keyboard.RIGHTBRACKET = 221;
    Keyboard.QUOTE = 222;
    Keyboard.ALTERNATE = 18;
    Keyboard.BACKSPACE = 8;
    Keyboard.CAPS_LOCK = 20;
    Keyboard.COMMAND = 15;
    Keyboard.CONTROL = 17;
    Keyboard.DELETE = 46;
    Keyboard.ENTER = 13;
    Keyboard.ESCAPE = 27;
    Keyboard.PAGE_UP = 33;
    Keyboard.PAGE_DOWN = 34;
    Keyboard.END = 35;
    Keyboard.HOME = 36;
    Keyboard.LEFT = 37;
    Keyboard.UP = 38;
    Keyboard.RIGHT = 39;
    Keyboard.DOWN = 40;
    Keyboard.SHIFT = 16;
    Keyboard.SPACE = 32;
    Keyboard.TAB = 9;
    Keyboard.INSERT = 45;

    class KeyLocation {
    }
    KeyLocation.STANDARD = 0;
    KeyLocation.LEFT = 1;
    KeyLocation.RIGHT = 2;
    KeyLocation.NUM_PAD = 3;

    class CommandEncoder {
        constructor() {
            this._idata = [];
        }
        getArrayData() {
            return this._idata;
        }
        getCount() {
            return this._idata.length;
        }
        addShaderUniform(variable) {
            this._idata.push(variable);
        }
    }

    class QuickTestTool {
        constructor() {
        }
        static getMCDName(type) {
            return QuickTestTool._typeToNameDic[type];
        }
        static showRenderTypeInfo(type, force = false) {
            if (!force && QuickTestTool.showedDic[type])
                return;
            QuickTestTool.showedDic[type] = true;
            if (!QuickTestTool._rendertypeToStrDic[type]) {
                var arr = [];
                var tType;
                tType = 1;
                while (tType <= type) {
                    if (tType & type) {
                        arr.push(QuickTestTool.getMCDName(tType & type));
                    }
                    tType = tType << 1;
                }
                QuickTestTool._rendertypeToStrDic[type] = arr.join(",");
            }
            console.log("cmd:", QuickTestTool._rendertypeToStrDic[type]);
        }
        static __init__() {
            QuickTestTool._typeToNameDic[SpriteConst.ALPHA] = "ALPHA";
            QuickTestTool._typeToNameDic[SpriteConst.TRANSFORM] = "TRANSFORM";
            QuickTestTool._typeToNameDic[SpriteConst.TEXTURE] = "TEXTURE";
            QuickTestTool._typeToNameDic[SpriteConst.GRAPHICS] = "GRAPHICS";
            QuickTestTool._typeToNameDic[SpriteConst.ONECHILD] = "ONECHILD";
            QuickTestTool._typeToNameDic[SpriteConst.CHILDS] = "CHILDS";
            QuickTestTool._typeToNameDic[SpriteConst.TRANSFORM | SpriteConst.ALPHA] = "TRANSFORM|ALPHA";
            QuickTestTool._typeToNameDic[SpriteConst.CANVAS] = "CANVAS";
            QuickTestTool._typeToNameDic[SpriteConst.BLEND] = "BLEND";
            QuickTestTool._typeToNameDic[SpriteConst.FILTERS] = "FILTERS";
            QuickTestTool._typeToNameDic[SpriteConst.MASK] = "MASK";
            QuickTestTool._typeToNameDic[SpriteConst.CLIP] = "CLIP";
            QuickTestTool._typeToNameDic[SpriteConst.LAYAGL3D] = "LAYAGL3D";
        }
        render(context, x, y) {
            QuickTestTool._addType(this._renderType);
            QuickTestTool.showRenderTypeInfo(this._renderType);
            RenderSprite.renders[this._renderType]._fun(this, context, x + this._x, y + this._y);
            this._repaint = 0;
        }
        _stageRender(context, x, y) {
            QuickTestTool._countStart();
            QuickTestTool._PreStageRender.call(ILaya.stage, context, x, y);
            QuickTestTool._countEnd();
        }
        static _countStart() {
            var key;
            for (key in QuickTestTool._countDic) {
                QuickTestTool._countDic[key] = 0;
            }
        }
        static _countEnd() {
            QuickTestTool._i++;
            if (QuickTestTool._i > 60) {
                QuickTestTool.showCountInfo();
                QuickTestTool._i = 0;
            }
        }
        static _addType(type) {
            if (!QuickTestTool._countDic[type]) {
                QuickTestTool._countDic[type] = 1;
            }
            else {
                QuickTestTool._countDic[type] += 1;
            }
        }
        static showCountInfo() {
            console.log("===================");
            var key;
            for (key in QuickTestTool._countDic) {
                console.log("count:" + QuickTestTool._countDic[key]);
                QuickTestTool.showRenderTypeInfo(key, true);
            }
        }
        static enableQuickTest() {
            QuickTestTool.__init__();
            Sprite["prototype"]["render"] = QuickTestTool["prototype"]["render"];
            QuickTestTool._PreStageRender = Stage["prototype"]["render"];
            Stage["prototype"]["render"] = QuickTestTool["prototype"]["_stageRender"];
        }
    }
    QuickTestTool.showedDic = {};
    QuickTestTool._rendertypeToStrDic = {};
    QuickTestTool._typeToNameDic = {};
    QuickTestTool._countDic = {};
    QuickTestTool._i = 0;

    class TTFLoader {
        load(fontPath) {
            this._url = fontPath;
            var tArr = fontPath.toLowerCase().split(".ttf")[0].split("/");
            this.fontName = tArr[tArr.length - 1];
            if (LayaEnv.isConch) {
                ILaya.loader.fetch(this._url, "arraybuffer").then(data => {
                    if (data)
                        window["conchTextCanvas"].setFontFaceFromBuffer(this.fontName, data);
                    this._complete();
                });
            }
            else if (window.FontFace) {
                this._loadWithFontFace();
            }
            else {
                this._loadWithCSS();
            }
        }
        _complete() {
            ILaya.systemTimer.clear(this, this._complete);
            ILaya.systemTimer.clear(this, this._checkComplete);
            if (this._div && this._div.parentNode) {
                this._div.parentNode.removeChild(this._div);
                this._div = null;
            }
            if (this.complete) {
                this.complete.runWith(this);
                this.complete = null;
            }
        }
        _checkComplete() {
            if (ILaya.Browser.measureText(TTFLoader._testString, this._fontTxt).width != this._txtWidth) {
                this._complete();
            }
        }
        _loadWithFontFace() {
            var fontFace = new window.FontFace(this.fontName, "url('" + this._url + "')");
            document.fonts.add(fontFace);
            var self = this;
            fontFace.loaded.then((function () {
                self._complete();
            }));
            fontFace.load();
        }
        _createDiv() {
            this._div = Browser.createElement("div");
            this._div.innerHTML = "laya";
            var _style = this._div.style;
            _style.fontFamily = this.fontName;
            _style.position = "absolute";
            _style.left = "-100px";
            _style.top = "-100px";
            document.body.appendChild(this._div);
        }
        _loadWithCSS() {
            var fontStyle = Browser.createElement("style");
            fontStyle.type = "text/css";
            document.body.appendChild(fontStyle);
            fontStyle.textContent = "@font-face { font-family:'" + this.fontName + "'; src:url('" + this._url + "');}";
            this._fontTxt = "40px " + this.fontName;
            this._txtWidth = Browser.measureText(TTFLoader._testString, this._fontTxt).width;
            var self = this;
            fontStyle.onload = function () {
                ILaya.systemTimer.once(10000, self, self._complete);
            };
            ILaya.systemTimer.loop(20, this, this._checkComplete);
            this._createDiv();
        }
    }
    TTFLoader._testString = "LayaTTFFont";

    class ResourceVersion {
        static enable(manifestFile, callback, type = 2) {
            ResourceVersion.type = type;
            ILaya.loader.fetch(manifestFile, "json").then(data => {
                if (!data) {
                    console.warn("资源版本清单文件不存在，不使用资源版本管理。忽略ERR_FILE_NOT_FOUND错误。");
                    return;
                }
                ResourceVersion.manifest = data;
                URL.customFormat = ResourceVersion.addVersionPrefix;
                callback.run();
            });
        }
        static addVersionPrefix(originURL) {
            if (ResourceVersion.manifest && ResourceVersion.manifest[originURL]) {
                if (ResourceVersion.type == ResourceVersion.FILENAME_VERSION)
                    return ResourceVersion.manifest[originURL];
                return ResourceVersion.manifest[originURL] + "/" + originURL;
            }
            return originURL;
        }
    }
    ResourceVersion.FOLDER_VERSION = 1;
    ResourceVersion.FILENAME_VERSION = 2;
    ResourceVersion.type = ResourceVersion.FOLDER_VERSION;

    class Socket extends EventDispatcher {
        constructor(host = null, port = 0, byteClass = null, protocols = null) {
            super();
            this.disableInput = false;
            this.protocols = [];
            this._byteClass = byteClass ? byteClass : Byte;
            this.protocols = protocols;
            this.endian = Socket.BIG_ENDIAN;
            if (host && port > 0 && port < 65535)
                this.connect(host, port);
        }
        get input() {
            return this._input;
        }
        get output() {
            return this._output;
        }
        get connected() {
            return this._connected;
        }
        get endian() {
            return this._endian;
        }
        set endian(value) {
            this._endian = value;
            if (this._input != null)
                this._input.endian = value;
            if (this._output != null)
                this._output.endian = value;
        }
        connect(host, port) {
            var url = "ws://" + host + ":" + port;
            this.connectByUrl(url);
        }
        connectByUrl(url) {
            if (this._socket != null)
                this.close();
            this._socket && this.cleanSocket();
            if (!this.protocols || this.protocols.length == 0) {
                this._socket = new Browser.window.WebSocket(url);
            }
            else {
                this._socket = new Browser.window.WebSocket(url, this.protocols);
            }
            this._socket.binaryType = "arraybuffer";
            this._output = new this._byteClass();
            this._output.endian = this.endian;
            this._input = new this._byteClass();
            this._input.endian = this.endian;
            this._addInputPosition = 0;
            this._socket.onopen = (e) => {
                this._onOpen(e);
            };
            this._socket.onmessage = (msg) => {
                this._onMessage(msg);
            };
            this._socket.onclose = (e) => {
                this._onClose(e);
            };
            this._socket.onerror = (e) => {
                this._onError(e);
            };
        }
        cleanSocket() {
            this.close();
            this._connected = false;
            this._socket.onopen = null;
            this._socket.onmessage = null;
            this._socket.onclose = null;
            this._socket.onerror = null;
            this._socket = null;
        }
        close() {
            if (this._socket != null) {
                try {
                    this._socket.close();
                }
                catch (e) {
                }
            }
        }
        _onOpen(e) {
            this._connected = true;
            this.event(Event.OPEN, e);
        }
        _onMessage(msg) {
            if (!msg || !msg.data)
                return;
            var data = msg.data;
            if (this.disableInput && data) {
                this.event(Event.MESSAGE, data);
                return;
            }
            if (this._input.length > 0 && this._input.bytesAvailable < 1) {
                this._input.clear();
                this._addInputPosition = 0;
            }
            var pre = this._input.pos;
            !this._addInputPosition && (this._addInputPosition = 0);
            this._input.pos = this._addInputPosition;
            if (data) {
                if (typeof (data) == 'string') {
                    this._input.writeUTFBytes(data);
                }
                else {
                    this._input.writeArrayBuffer(data);
                }
                this._addInputPosition = this._input.pos;
                this._input.pos = pre;
            }
            this.event(Event.MESSAGE, data);
        }
        _onClose(e) {
            this._connected = false;
            this.event(Event.CLOSE, e);
        }
        _onError(e) {
            this.event(Event.ERROR, e);
        }
        send(data) {
            this._socket.send(data);
        }
        flush() {
            if (this._output && this._output.length > 0) {
                var evt;
                try {
                    this._socket && this._socket.send(this._output.__getBuffer().slice(0, this._output.length));
                }
                catch (e) {
                    evt = e;
                }
                this._output.endian = this.endian;
                this._output.clear();
                if (evt)
                    this.event(Event.ERROR, evt);
            }
        }
    }
    Socket.LITTLE_ENDIAN = "littleEndian";
    Socket.BIG_ENDIAN = "bigEndian";

    class System {
        static changeDefinition(name, classObj) {
            window.Laya[name] = classObj;
            var str = name + "=classObj";
            window['eval'](str);
        }
    }

    class Base64Tool {
        static init() {
            if (Base64Tool.lookup)
                return;
            Base64Tool.lookup = new Uint8Array(256);
            for (var i = 0; i < Base64Tool.chars.length; i++) {
                Base64Tool.lookup[Base64Tool.chars.charCodeAt(i)] = i;
            }
        }
        static isBase64String(str) {
            return Base64Tool.reg.test(str);
        }
        static encode(arraybuffer) {
            var bytes = new Uint8Array(arraybuffer), i, len = bytes["length"], base64 = "";
            for (i = 0; i < len; i += 3) {
                base64 += Base64Tool.chars[bytes[i] >> 2];
                base64 += Base64Tool.chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
                base64 += Base64Tool.chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
                base64 += Base64Tool.chars[bytes[i + 2] & 63];
            }
            if ((len % 3) === 2) {
                base64 = base64.substring(0, base64.length - 1) + "=";
            }
            else if (len % 3 === 1) {
                base64 = base64.substring(0, base64.length - 2) + "==";
            }
            return base64;
        }
        static decode(base64) {
            Base64Tool.init();
            var bufferLength = base64.length * 0.75, len = base64.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;
            if (base64[base64.length - 1] === "=") {
                bufferLength--;
                if (base64[base64.length - 2] === "=") {
                    bufferLength--;
                }
            }
            var arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);
            for (i = 0; i < len; i += 4) {
                encoded1 = Base64Tool.lookup[base64.charCodeAt(i)];
                encoded2 = Base64Tool.lookup[base64.charCodeAt(i + 1)];
                encoded3 = Base64Tool.lookup[base64.charCodeAt(i + 2)];
                encoded4 = Base64Tool.lookup[base64.charCodeAt(i + 3)];
                bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
                bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
                bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
            }
            return arraybuffer;
        }
    }
    Base64Tool.chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    Base64Tool.reg = /^\s*data:([a-z]+\/[a-z0-9-+.]+(;[a-z-]+=[a-z0-9-]+)?)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s]*?)\s*$/i;
    Base64Tool.reghead = /^\s*data:([a-z]+\/[a-z0-9-+.]+(;[a-z-]+=[a-z0-9-]+)?)?(;base64)?,/i;
    Base64Tool.lookup = null;

    class HTMLChar {
        constructor() {
            this.reset();
        }
        setData(char, w, h, style) {
            this.char = char;
            this.charNum = char.charCodeAt(0);
            this.x = this.y = 0;
            this.width = w;
            this.height = h;
            this.style = style;
            this.isWord = !HTMLChar._isWordRegExp.test(char);
            return this;
        }
        reset() {
            this.x = this.y = this.width = this.height = 0;
            this.isWord = false;
            this.char = null;
            this.charNum = 0;
            this.style = null;
            return this;
        }
        recover() {
            Pool.recover("HTMLChar", this.reset());
        }
        static create() {
            return Pool.getItemByClass("HTMLChar", HTMLChar);
        }
        _isChar() {
            return true;
        }
        _getCSSStyle() {
            return this.style;
        }
    }
    HTMLChar._isWordRegExp = new RegExp("[\\w\.]", "");

    class Log {
        static enable() {
            if (!Log._logdiv) {
                Log._logdiv = Browser.createElement('div');
                Log._logdiv.style.cssText = "border:white;padding:4px;overflow-y:auto;z-index:1000000;background:rgba(100,100,100,0.6);color:white;position: absolute;left:0px;top:0px;width:50%;height:50%;";
                Browser.document.body.appendChild(Log._logdiv);
                Log._btn = Browser.createElement("button");
                Log._btn.innerText = "Hide";
                Log._btn.style.cssText = "z-index:1000001;position: absolute;left:10px;top:10px;";
                Log._btn.onclick = Log.toggle;
                Browser.document.body.appendChild(Log._btn);
            }
        }
        static toggle() {
            var style = Log._logdiv.style;
            if (style.display === "") {
                Log._btn.innerText = "Show";
                style.display = "none";
            }
            else {
                Log._btn.innerText = "Hide";
                style.display = "";
            }
        }
        static print(value) {
            if (Log._logdiv) {
                if (Log._count >= Log.maxCount)
                    Log.clear();
                Log._count++;
                Log._logdiv.innerText += value + "\n";
                if (Log.autoScrollToBottom) {
                    if (Log._logdiv.scrollHeight - Log._logdiv.scrollTop - Log._logdiv.clientHeight < 50) {
                        Log._logdiv.scrollTop = Log._logdiv.scrollHeight;
                    }
                }
            }
        }
        static clear() {
            Log._logdiv.innerText = "";
            Log._count = 0;
        }
    }
    Log._count = 0;
    Log.maxCount = 50;
    Log.autoScrollToBottom = true;

    let DATANUM = 300;
    class PerfData {
        constructor(id, color, name, scale) {
            this.scale = 1.0;
            this.datas = new Array(DATANUM);
            this.datapos = 0;
            this.id = id;
            this.color = color;
            this.name = name;
            this.scale = scale;
        }
        addData(v) {
            this.datas[this.datapos] = v;
            this.datapos++;
            this.datapos %= DATANUM;
        }
    }

    class PerfHUD extends Sprite {
        constructor() {
            super();
            this.datas = [];
            this.xdata = new Array(PerfHUD.DATANUM);
            this.ydata = new Array(PerfHUD.DATANUM);
            this.hud_width = 800;
            this.hud_height = 200;
            this.gMinV = 0;
            this.gMaxV = 100;
            this.textSpace = 40;
            this.sttm = 0;
            PerfHUD.inst = this;
            this._renderType |= SpriteConst.CUSTOM;
            this._setRenderType(this._renderType);
            this._setCustomRender();
            this.addDataDef(0, 0xffffff, 'frame', 1.0);
            this.addDataDef(1, 0x00ff00, 'update', 1.0);
            this.addDataDef(2, 0xff0000, 'flush', 1.0);
            PerfHUD._now = performance ? performance.now.bind(performance) : Date.now;
        }
        now() {
            return PerfHUD._now();
        }
        start() {
            this.sttm = PerfHUD._now();
        }
        end(i) {
            var dt = PerfHUD._now() - this.sttm;
            this.updateValue(i, dt);
        }
        config(w, h) {
            this.hud_width = w;
            this.hud_height = h;
        }
        addDataDef(id, color, name, scale) {
            this.datas[id] = new PerfData(id, color, name, scale);
        }
        updateValue(id, v) {
            this.datas[id].addData(v);
        }
        v2y(v) {
            this._y + this.hud_height * (1 - (v - this.gMinV) / this.gMaxV);
            return this._y + this.hud_height * (1 - (v - this.gMinV) / this.gMaxV);
        }
        drawHLine(ctx, v, color, text) {
            var sx = this._x;
            this._x + this.hud_width;
            var sy = this.v2y(v);
            ctx.fillText(text, sx, sy - 6, null, 'green', null);
            sx += this.textSpace;
            ctx.fillStyle = color;
            ctx.fillRect(sx, sy, this._x + this.hud_width, 1, null);
        }
        customRender(ctx, x, y) {
            var now = performance.now();
            if (PerfHUD._lastTm <= 0)
                PerfHUD._lastTm = now;
            this.updateValue(0, now - PerfHUD._lastTm);
            PerfHUD._lastTm = now;
            ctx.save();
            ctx.fillRect(this._x, this._y, this.hud_width, this.hud_height + 4, '#000000cc');
            ctx.globalAlpha = 0.9;
            this.drawHLine(ctx, 0, 'green', '    0');
            this.drawHLine(ctx, 10, 'green', '  10');
            this.drawHLine(ctx, 16.667, 'red', ' ');
            this.drawHLine(ctx, 20, 'green', '50|20');
            this.drawHLine(ctx, 16.667 * 2, 'yellow', '');
            this.drawHLine(ctx, 16.667 * 3, 'yellow', '');
            this.drawHLine(ctx, 16.667 * 4, 'yellow', '');
            this.drawHLine(ctx, 50, 'green', '20|50');
            this.drawHLine(ctx, 100, 'green', '10|100');
            for (var di = 0, sz = this.datas.length; di < sz; di++) {
                var cd = this.datas[di];
                if (!cd)
                    continue;
                var dtlen = cd.datas.length;
                var dx = (this.hud_width - this.textSpace) / dtlen;
                var cx = cd.datapos;
                var _cx = this._x + this.textSpace;
                ctx.fillStyle = cd.color;
                for (var dtsz = dtlen; cx < dtsz; cx++) {
                    var sty = this.v2y(cd.datas[cx] * cd.scale);
                    ctx.fillRect(_cx, sty, dx, this.hud_height + this._y - sty, null);
                    _cx += dx;
                }
                for (cx = 0; cx < cd.datapos; cx++) {
                    sty = this.v2y(cd.datas[cx] * cd.scale);
                    ctx.fillRect(_cx, sty, dx, this.hud_height + this._y - sty, null);
                    _cx += dx;
                }
            }
            ctx.restore();
        }
    }
    PerfHUD._lastTm = 0;
    PerfHUD._now = null;
    PerfHUD.DATANUM = 300;
    PerfHUD.drawTexTm = 0;

    class PoolCache {
        constructor() {
            this.maxCount = 1000;
        }
        getCacheList() {
            return Pool.getPoolBySign(this.sign);
        }
        tryDispose(force) {
            var list;
            list = Pool.getPoolBySign(this.sign);
            if (list.length > this.maxCount) {
                list.splice(this.maxCount, list.length - this.maxCount);
            }
        }
        static addPoolCacheManager(sign, maxCount = 100) {
            var cache;
            cache = new PoolCache();
            cache.sign = sign;
            cache.maxCount = maxCount;
            CacheManger.regCacheByFunction(cache.tryDispose.bind(cache), cache.getCacheList.bind(cache));
        }
    }

    class SingletonList {
        constructor() {
            this.elements = [];
            this.length = 0;
        }
        _add(element) {
            if (this.length === this.elements.length)
                this.elements.push(element);
            else
                this.elements[this.length] = element;
        }
        add(element) {
            let index = this.elements.indexOf(element);
            if ((typeof (element) != "number") && index != -1 && index < this.length)
                return;
            if (this.length === this.elements.length)
                this.elements.push(element);
            else
                this.elements[this.length] = element;
            this.length++;
        }
        indexof(element) {
            let index = this.elements.indexOf(element);
            if (index != -1 && index < this.length)
                return index;
            return -1;
        }
        remove(element) {
            let index = this.elements.indexOf(element);
            if (index != -1 && index < this.length) {
                this.elements[index] = this.elements[this.length - 1];
                this.length--;
            }
        }
        clear() {
            this.elements = [];
            this.length = 0;
        }
        destroy() {
            this.elements = null;
        }
    }

    class TimeLine extends EventDispatcher {
        constructor() {
            super(...arguments);
            this._tweenDic = {};
            this._tweenDataList = [];
            this._currTime = 0;
            this._lastTime = 0;
            this._startTime = 0;
            this._index = 0;
            this._gidIndex = 0;
            this._firstTweenDic = {};
            this._startTimeSort = false;
            this._endTimeSort = false;
            this._loopKey = false;
            this.scale = 1;
            this._frameRate = 60;
            this._frameIndex = 0;
            this._total = 0;
        }
        static to(target, props, duration, ease = null, offset = 0) {
            return (new TimeLine()).to(target, props, duration, ease, offset);
        }
        static from(target, props, duration, ease = null, offset = 0) {
            return (new TimeLine()).from(target, props, duration, ease, offset);
        }
        to(target, props, duration, ease = null, offset = 0) {
            return this._create(target, props, duration, ease, offset, true);
        }
        from(target, props, duration, ease = null, offset = 0) {
            return this._create(target, props, duration, ease, offset, false);
        }
        _create(target, props, duration, ease, offset, isTo) {
            var tTweenData = Pool.getItemByClass("tweenData", tweenData);
            tTweenData.isTo = isTo;
            tTweenData.type = 0;
            tTweenData.target = target;
            tTweenData.duration = duration;
            tTweenData.data = props;
            tTweenData.startTime = this._startTime + offset;
            tTweenData.endTime = tTweenData.startTime + tTweenData.duration;
            tTweenData.ease = ease;
            this._startTime = Math.max(tTweenData.endTime, this._startTime);
            this._tweenDataList.push(tTweenData);
            this._startTimeSort = true;
            this._endTimeSort = true;
            return this;
        }
        addLabel(label, offset) {
            var tTweenData = Pool.getItemByClass("tweenData", tweenData);
            tTweenData.type = 1;
            tTweenData.data = label;
            tTweenData.endTime = tTweenData.startTime = this._startTime + offset;
            this._labelDic || (this._labelDic = {});
            this._labelDic[label] = tTweenData;
            this._tweenDataList.push(tTweenData);
            return this;
        }
        removeLabel(label) {
            if (this._labelDic && this._labelDic[label]) {
                var tTweenData = this._labelDic[label];
                if (tTweenData) {
                    var tIndex = this._tweenDataList.indexOf(tTweenData);
                    if (tIndex > -1) {
                        this._tweenDataList.splice(tIndex, 1);
                    }
                }
                delete this._labelDic[label];
            }
        }
        gotoTime(time) {
            if (this._tweenDataList == null || this._tweenDataList.length == 0)
                return;
            var tTween;
            var tObject;
            for (var p in this._firstTweenDic) {
                tObject = this._firstTweenDic[p];
                if (tObject) {
                    for (var tDataP in tObject) {
                        if (tDataP in tObject.diyTarget) {
                            tObject.diyTarget[tDataP] = tObject[tDataP];
                        }
                    }
                }
            }
            for (p in this._tweenDic) {
                tTween = this._tweenDic[p];
                tTween.clear();
                delete this._tweenDic[p];
            }
            this._index = 0;
            this._gidIndex = 0;
            this._currTime = time;
            this._lastTime = Browser.now();
            var tTweenDataCopyList;
            if (this._endTweenDataList == null || this._endTimeSort) {
                this._endTimeSort = false;
                this._endTweenDataList = tTweenDataCopyList = this._tweenDataList.concat();
                function Compare(paraA, paraB) {
                    if (paraA.endTime > paraB.endTime) {
                        return 1;
                    }
                    else if (paraA.endTime < paraB.endTime) {
                        return -1;
                    }
                    else {
                        return 0;
                    }
                }
                tTweenDataCopyList.sort(Compare);
            }
            else {
                tTweenDataCopyList = this._endTweenDataList;
            }
            var tTweenData;
            for (var i = 0, n = tTweenDataCopyList.length; i < n; i++) {
                tTweenData = tTweenDataCopyList[i];
                if (tTweenData.type == 0) {
                    if (time >= tTweenData.endTime) {
                        this._index = Math.max(this._index, i + 1);
                        var props = tTweenData.data;
                        if (tTweenData.isTo) {
                            for (var tP in props) {
                                tTweenData.target[tP] = props[tP];
                            }
                        }
                    }
                    else {
                        break;
                    }
                }
            }
            for (i = 0, n = this._tweenDataList.length; i < n; i++) {
                tTweenData = this._tweenDataList[i];
                if (tTweenData.type == 0) {
                    if (time >= tTweenData.startTime && time < tTweenData.endTime) {
                        this._index = Math.max(this._index, i + 1);
                        this._gidIndex++;
                        tTween = Pool.getItemByClass("tween", Tween);
                        tTween._create(tTweenData.target, tTweenData.data, tTweenData.duration, tTweenData.ease, Handler.create(this, this._animComplete, [this._gidIndex]), 0, false, tTweenData.isTo, true, false);
                        tTween.setStartTime(this._currTime - (time - tTweenData.startTime));
                        tTween._updateEase(this._currTime);
                        tTween.gid = this._gidIndex;
                        this._tweenDic[this._gidIndex] = tTween;
                    }
                }
            }
        }
        gotoLabel(Label) {
            if (this._labelDic == null)
                return;
            var tLabelData = this._labelDic[Label];
            if (tLabelData)
                this.gotoTime(tLabelData.startTime);
        }
        pause() {
            ILaya.timer.clear(this, this._update);
        }
        resume() {
            this.play(this._currTime, this._loopKey);
        }
        play(timeOrLabel = 0, loop = false) {
            if (!this._tweenDataList)
                return;
            if (this._startTimeSort) {
                this._startTimeSort = false;
                function Compare(paraA, paraB) {
                    if (paraA.startTime > paraB.startTime) {
                        return 1;
                    }
                    else if (paraA.startTime < paraB.startTime) {
                        return -1;
                    }
                    else {
                        return 0;
                    }
                }
                this._tweenDataList.sort(Compare);
                for (var i = 0, n = this._tweenDataList.length; i < n; i++) {
                    var tTweenData = this._tweenDataList[i];
                    if (tTweenData != null && tTweenData.type == 0) {
                        var tTarget = tTweenData.target;
                        var gid = (tTarget.$_GID || (tTarget.$_GID = Utils.getGID()));
                        var tSrcData = null;
                        if (this._firstTweenDic[gid] == null) {
                            tSrcData = {};
                            tSrcData.diyTarget = tTarget;
                            this._firstTweenDic[gid] = tSrcData;
                        }
                        else {
                            tSrcData = this._firstTweenDic[gid];
                        }
                        for (var p in tTweenData.data) {
                            if (tSrcData[p] == null) {
                                tSrcData[p] = tTarget[p];
                            }
                        }
                    }
                }
            }
            if (typeof (timeOrLabel) == 'string') {
                this.gotoLabel(timeOrLabel);
            }
            else {
                this.gotoTime(timeOrLabel);
            }
            this._loopKey = loop;
            this._lastTime = Browser.now();
            ILaya.timer.frameLoop(1, this, this._update);
        }
        _update() {
            if (this._currTime >= this._startTime) {
                if (this._loopKey) {
                    this._complete();
                    if (!this._tweenDataList)
                        return;
                    this.gotoTime(0);
                }
                else {
                    for (var p in this._tweenDic) {
                        tTween = this._tweenDic[p];
                        tTween.complete();
                    }
                    this.pause();
                    this._complete();
                    return;
                }
            }
            var tNow = Browser.now();
            var tFrameTime = tNow - this._lastTime;
            var tCurrTime = this._currTime += tFrameTime * this.scale;
            this._lastTime = tNow;
            for (p in this._tweenDic) {
                tTween = this._tweenDic[p];
                tTween._updateEase(tCurrTime);
            }
            var tTween;
            if (this._tweenDataList.length != 0 && this._index < this._tweenDataList.length) {
                var tTweenData = this._tweenDataList[this._index];
                if (tCurrTime >= tTweenData.startTime) {
                    this._index++;
                    if (tTweenData.type == 0) {
                        this._gidIndex++;
                        tTween = Pool.getItemByClass("tween", Tween);
                        tTween._create(tTweenData.target, tTweenData.data, tTweenData.duration, tTweenData.ease, Handler.create(this, this._animComplete, [this._gidIndex]), 0, false, tTweenData.isTo, true, false);
                        tTween.setStartTime(tCurrTime);
                        tTween.gid = this._gidIndex;
                        this._tweenDic[this._gidIndex] = tTween;
                        tTween._updateEase(tCurrTime);
                    }
                    else {
                        this.event(Event.LABEL, tTweenData.data);
                    }
                }
            }
        }
        _animComplete(index) {
            var tTween = this._tweenDic[index];
            if (tTween)
                delete this._tweenDic[index];
        }
        _complete() {
            this.event(Event.COMPLETE);
        }
        get index() {
            return this._frameIndex;
        }
        set index(value) {
            this._frameIndex = value;
            this.gotoTime(this._frameIndex / this._frameRate * 1000);
        }
        get total() {
            this._total = Math.floor(this._startTime / 1000 * this._frameRate);
            return this._total;
        }
        reset() {
            var p;
            if (this._labelDic) {
                for (p in this._labelDic) {
                    delete this._labelDic[p];
                }
            }
            var tTween;
            for (p in this._tweenDic) {
                tTween = this._tweenDic[p];
                tTween.clear();
                delete this._tweenDic[p];
            }
            for (p in this._firstTweenDic) {
                delete this._firstTweenDic[p];
            }
            this._endTweenDataList = null;
            if (this._tweenDataList && this._tweenDataList.length) {
                var i, len;
                len = this._tweenDataList.length;
                for (i = 0; i < len; i++) {
                    if (this._tweenDataList[i])
                        this._tweenDataList[i].destroy();
                }
            }
            this._tweenDataList.length = 0;
            this._currTime = 0;
            this._lastTime = 0;
            this._startTime = 0;
            this._index = 0;
            this._gidIndex = 0;
            this.scale = 1;
            ILaya.timer.clear(this, this._update);
        }
        destroy() {
            this.reset();
            this._labelDic = null;
            this._tweenDic = null;
            this._tweenDataList = null;
            this._firstTweenDic = null;
        }
    }
    class tweenData {
        constructor() {
            this.type = 0;
            this.isTo = true;
        }
        destroy() {
            this.target = null;
            this.ease = null;
            this.data = null;
            this.isTo = true;
            this.type = 0;
            Pool.recover("tweenData", this);
        }
    }

    class DrawParticleCmd {
        static create(_temp) {
            var cmd = Pool.getItemByClass("DrawParticleCmd", DrawParticleCmd);
            cmd._templ = _temp;
            return cmd;
        }
        recover() {
            this._templ = null;
            Pool.recover("DrawParticleCmd", this);
        }
        run(context, gx, gy) {
            context.drawParticle(gx, gy, this._templ);
        }
        get cmdID() {
            return DrawParticleCmd.ID;
        }
    }
    DrawParticleCmd.ID = "DrawParticleCmd";

    class Sound extends EventDispatcher {
        load(url) {
        }
        play(startTime = 0, loops = 0) {
            return null;
        }
        get duration() {
            return 0;
        }
        dispose() {
        }
    }

    class BlendState {
        constructor(blendType) {
            this.blendType = 0;
        }
        static create(blendType, colorBlendhash, alphaBlendComponent) {
        }
    }
    BlendState._blend_All_pool = {};
    BlendState._blend_seperate_pool = {};
    class BlendComponent {
        constructor(blendOperationGLData, sourceBlendFactor, destinationFactor, hashindex) {
            this._hashIndex = 0;
            this._hashIndex = hashindex;
            this._blendOperationGLData = blendOperationGLData;
            this._sourceBlendFactor = sourceBlendFactor;
            this._destinationFactor = destinationFactor;
        }
        static getHash(blendOperationGLData, sourceBlendFactor, destinationFactor) {
            return (blendOperationGLData) + (sourceBlendFactor << 3) + (destinationFactor << 7);
        }
        static getBlendComponent(blendOperationGLData, sourceBlendFactor, destinationFactor) {
            let index = BlendComponent.getHash(blendOperationGLData, sourceBlendFactor, destinationFactor);
            if (!BlendComponent._pool[index])
                BlendComponent._pool[index] = new BlendComponent(blendOperationGLData, sourceBlendFactor, destinationFactor, index);
            return BlendComponent._pool[index];
        }
    }
    BlendComponent._pool = {};

    class CommandUniformMap {
        constructor(stateName) {
            this._idata = {};
            this._stateName = stateName;
        }
        hasPtrID(propertyID) {
            return !!(this._idata[propertyID] != null);
        }
        getMap() {
            return this._idata;
        }
        addShaderUniform(propertyID, propertyKey) {
            this._idata[propertyID] = propertyKey;
        }
    }

    class DepthState {
    }

    exports.AttributeType = void 0;
    (function (AttributeType) {
        AttributeType["box2i"] = "box2i";
        AttributeType["box2f"] = "box2f";
        AttributeType["chlist"] = "chlist";
        AttributeType["chromaticities"] = "chromaticities";
        AttributeType["compression"] = "compression";
        AttributeType["double"] = "double";
        AttributeType["envmap"] = "envmap";
        AttributeType["float"] = "float";
        AttributeType["int"] = "int";
        AttributeType["keycode"] = "keycode";
        AttributeType["lineOrder"] = "lineOrder";
        AttributeType["m33f"] = "m33f";
        AttributeType["m44f"] = "m44f";
        AttributeType["preview"] = "preview";
        AttributeType["rational"] = "rational";
        AttributeType["string"] = "string";
        AttributeType["stringvector"] = "stringvector";
        AttributeType["titledesc"] = "titledesc";
        AttributeType["timecode"] = "timecode";
        AttributeType["v2i"] = "v2i";
        AttributeType["v2f"] = "v2f";
        AttributeType["v3i"] = "v3i";
        AttributeType["v3f"] = "v3f";
    })(exports.AttributeType || (exports.AttributeType = {}));
    class EXRTextureInfo {
        static getEXRInfo(buffer) {
            const wrong = () => {
                throw "EXR info: data wrong.";
            };
            const todo = () => {
                console.log("EXR info: todo");
            };
            let littleEndian = true;
            let dataView = new DataView(buffer);
            let viewOffset = 0;
            const getString = (length = 0) => {
                let res = "";
                let charCode;
                let charCount = 0;
                while ((charCode = dataView.getUint8(viewOffset++)) != 0x00) {
                    res = `${res}${String.fromCharCode(charCode)}`;
                    charCount++;
                    if (charCount == length) {
                        viewOffset++;
                        break;
                    }
                }
                return res;
            };
            const getUnsignedChar = () => {
                return dataView.getUint8(viewOffset++);
            };
            const getInt = () => {
                let res = dataView.getInt32(viewOffset, littleEndian);
                viewOffset += 4;
                return res;
            };
            const getUnsignedlong = () => {
                let long = dataView.getBigUint64(viewOffset, littleEndian);
                viewOffset += 8;
                return long;
            };
            const getFloat = () => {
                let res = dataView.getFloat32(viewOffset, littleEndian);
                viewOffset += 4;
                return res;
            };
            const readBox2i = (size) => {
                let xMin = getInt();
                let yMin = getInt();
                let xMax = getInt();
                let yMax = getInt();
                return {
                    xMin: xMin,
                    yMin: yMin,
                    xMax: xMax,
                    yMax: yMax
                };
            };
            const readChlist = (size) => {
                let res = [];
                let endOffset = viewOffset + size;
                while (viewOffset < endOffset - 1) {
                    let name = getString();
                    let pixelType = getInt();
                    let pLinear = getUnsignedChar();
                    let reserved = `${getUnsignedChar()}${getUnsignedChar()}${getUnsignedChar()}`;
                    let xSampling = getInt();
                    let ySampling = getInt();
                    let channel = {
                        name: name,
                        pixelType: pixelType,
                        pLinear: pLinear,
                        reserved: reserved,
                        xSampling: xSampling,
                        ySampling: ySampling
                    };
                    res.push(channel);
                }
                let nullByte = getUnsignedChar();
                if (nullByte != 0x00) {
                    wrong();
                }
                return res;
            };
            const readCompression = (size) => {
                return getUnsignedChar();
            };
            const readLineOrder = (size) => {
                return getUnsignedChar();
            };
            const readv2f = (size) => {
                let num0 = getFloat();
                let num1 = getFloat();
                return [num0, num1];
            };
            let magicNumber = dataView.getInt32(viewOffset, littleEndian);
            viewOffset += 4;
            if (magicNumber != 20000630) {
                wrong();
            }
            let version = getInt();
            version &= 0xff;
            let bit9 = version &= 0x200;
            version &= 0x400;
            let bit11 = version &= 0x800;
            let bit12 = version &= 0x1000;
            if (bit9 == 0 && bit11 == 0 && bit12 == 0) ;
            else if (bit9 == 1 && bit11 == 0 && bit12 == 0) {
                todo();
                wrong();
            }
            else if (bit9 == 0 && bit11 == 0 && bit12 == 1) {
                todo();
                wrong();
            }
            else if (bit9 == 0 && bit11 == 1 && bit12 == 0) {
                todo();
                wrong();
            }
            else if (bit9 == 0 && bit11 == 1 && bit12 == 1) {
                todo();
                wrong();
            }
            let attributeMap = new Map();
            let attributeName;
            while ((attributeName = getString()) != "") {
                let attribute = { name: attributeName, value: null };
                let attributeType = getString();
                let attributeSize = getInt();
                switch (attributeType) {
                    case exports.AttributeType.chlist:
                        let chlist = readChlist(attributeSize);
                        attribute.value = chlist;
                        break;
                    case exports.AttributeType.compression:
                        let compression = readCompression();
                        attribute.value = compression;
                        break;
                    case exports.AttributeType.box2i:
                        let box2i = readBox2i();
                        attribute.value = box2i;
                        break;
                    case exports.AttributeType.lineOrder:
                        let lineorder = readLineOrder();
                        attribute.value = lineorder;
                        break;
                    case exports.AttributeType.float:
                        attribute.value = getFloat();
                        break;
                    case exports.AttributeType.v2f:
                        attribute.value = readv2f();
                        break;
                    default:
                        wrong();
                }
                console.log(attribute);
                attributeMap.set(attribute.name, attribute.value);
            }
            let blockSize = 0;
            if (bit12 == 0 && !attributeMap.has("chunkCount")) {
                let dataWindow = attributeMap.get("dataWindow");
                blockSize = dataWindow.yMax - dataWindow.yMin + 1;
                let compression = attributeMap.get("compression");
                switch (compression) {
                    case 4:
                        blockSize /= 32;
                        break;
                    default:
                        wrong();
                        break;
                }
                blockSize = Math.ceil(blockSize);
            }
            for (let index = 0; index < blockSize; index++) {
                getUnsignedlong();
            }
            for (let index = 0; index < blockSize; index++) {
                getInt();
                let pixelDataByteSize = getInt();
                viewOffset += pixelDataByteSize;
            }
            if (viewOffset != buffer.byteLength) {
                wrong();
            }
            debugger;
        }
    }

    class StencilState {
    }

    class SubUniformBufferData extends UnifromBufferData {
        constructor(uniformParamsStat, bufferOffset) {
            super(uniformParamsStat);
            this._isInPool = false;
            this._needUpdate = false;
            this._realByte = 0;
            this._offset = bufferOffset;
            this._realByte = this._bytelength;
            this._bytelength = Math.ceil(this._bytelength / 256) * 256;
        }
    }

    class UniformBufferBase {
        constructor(name, pointer, single) {
            this._mapArray = [];
            this._blockName = name;
            this._singgle = single;
            this._glPointerID = pointer;
        }
        add(buffer) {
            let index = this._mapArray.indexOf(buffer);
            if (index == -1)
                this._mapArray.push(buffer);
        }
        splitBuffer(buffer) {
            let index = this._mapArray.indexOf(buffer);
            if (index != -1)
                this._mapArray.splice(index, 1);
        }
    }

    class UniformBufferObject extends Buffer {
        constructor(glPointer, name, bufferUsage, byteLength, isSingle) {
            super(exports.BufferTargetType.UNIFORM_BUFFER, bufferUsage);
            this._isSingle = false;
            this._glPointer = glPointer;
            this.byteLength = byteLength;
            this._name = name;
            this._isSingle = isSingle;
            this.bind();
            if (this._isSingle)
                this._bindUniformBufferBase();
            this._glBuffer.setDataLength(this.byteLength);
        }
        static create(name, bufferUsage, bytelength, isSingle = false) {
            if (!UniformBufferObject._Map.get(name)) {
                UniformBufferObject._Map.set(name, new UniformBufferBase(name, LayaGL.renderEngine.getUBOPointer(name), isSingle));
            }
            let bufferBase = UniformBufferObject._Map.get(name);
            if (bufferBase._singgle && bufferBase._mapArray.length > 0) {
                return null;
            }
            else {
                let ubo = LayaGL.renderOBJCreate.createUniformBufferObject(bufferBase._glPointerID, name, bufferUsage, bytelength, isSingle);
                if (bufferBase._singgle)
                    bufferBase.add(ubo);
                return ubo;
            }
        }
        static getBuffer(name, index) {
            let base = UniformBufferObject._Map.get(name);
            if (!base)
                return null;
            return base._mapArray[index];
        }
        _bindUniformBufferBase() {
            this._glBuffer.bindBufferBase(this._glPointer);
        }
        _bindBufferRange(offset, byteCount) {
            this.bind();
            this._glBuffer.bindBufferRange(this._glPointer, offset, byteCount);
        }
        _reset(bytelength) {
            if (this._glBuffer) {
                this._glBuffer.destroy();
                this._glBuffer = null;
            }
            this._byteLength = this.byteLength = bytelength;
            this._glBuffer = LayaGL.renderEngine.createBuffer(this._bufferType, this._bufferUsage);
            if (this._isSingle)
                this._bindUniformBufferBase();
            this._glBuffer.setDataLength(this.byteLength);
        }
        bind() {
            return this._glBuffer.bindBuffer();
        }
        setData(buffer, bufferOffset = 0, byteCount = Number.MAX_SAFE_INTEGER) {
            if (byteCount < 0)
                return;
            this.bind();
            var needSubData = !(bufferOffset == 0 && byteCount == this.byteLength);
            if (needSubData) {
                var subData = new Uint8Array(buffer.buffer, bufferOffset, byteCount);
                this._glBuffer.setData(subData, bufferOffset);
            }
            else {
                this._glBuffer.setDataEx(buffer, bufferOffset, buffer.length);
            }
        }
        setDataByUniformBufferData(bufferData) {
            if (this._updateDataInfo == bufferData) {
                this.setData(bufferData._buffer, bufferData._updateFlag.x * 4, (bufferData._updateFlag.y - bufferData._updateFlag.x) * 4);
                bufferData._resetUpdateFlag();
            }
            else {
                this.setData(bufferData._buffer, 0, this.byteLength);
                bufferData._resetUpdateFlag();
                this._updateDataInfo = bufferData;
            }
        }
        setDataByByUniformBufferDataOffset(bufferData, offset) {
            let datalength = bufferData.getbyteLength();
            let reallength = bufferData._realByte;
            bufferData._resetUpdateFlag();
            this.bind();
            this._glBuffer.setDataEx(bufferData._buffer, offset * datalength, reallength / 4);
        }
        destroy() {
            super.destroy();
        }
    }
    UniformBufferObject.UBONAME_SCENE = "SceneUniformBlock";
    UniformBufferObject.UBONAME_CAMERA = "CameraUniformBlock";
    UniformBufferObject.UBONAME_SPRITE3D = "SpriteUniformBlock";
    UniformBufferObject.UBONAME_SHADOW = "ShadowUniformBlock";
    UniformBufferObject.commonMap = ["CameraUniformBlock", "SceneUniformBlock", "SpriteUniformBlock", "ShadowUniformBlock"];
    UniformBufferObject._Map = new Map();

    exports.RenderDrawMode = void 0;
    (function (RenderDrawMode) {
        RenderDrawMode[RenderDrawMode["TRIANGLES"] = 0] = "TRIANGLES";
        RenderDrawMode[RenderDrawMode["POINTS"] = 1] = "POINTS";
        RenderDrawMode[RenderDrawMode["LINES"] = 2] = "LINES";
    })(exports.RenderDrawMode || (exports.RenderDrawMode = {}));

    exports.RenderIndexMode = void 0;
    (function (RenderIndexMode) {
        RenderIndexMode[RenderIndexMode["UNSIGNED_BYTE"] = 0] = "UNSIGNED_BYTE";
        RenderIndexMode[RenderIndexMode["UNSIGNED_SHORT"] = 1] = "UNSIGNED_SHORT";
        RenderIndexMode[RenderIndexMode["UNSIGNED_INT"] = 2] = "UNSIGNED_INT";
    })(exports.RenderIndexMode || (exports.RenderIndexMode = {}));

    exports.TextureDecodeFormat = void 0;
    (function (TextureDecodeFormat) {
        TextureDecodeFormat[TextureDecodeFormat["Normal"] = 0] = "Normal";
        TextureDecodeFormat[TextureDecodeFormat["RGBM"] = 1] = "RGBM";
    })(exports.TextureDecodeFormat || (exports.TextureDecodeFormat = {}));

    class RenderState {
        constructor() {
            this.cull = RenderState.CULL_BACK;
            this.blend = RenderState.BLEND_DISABLE;
            this.srcBlend = RenderState.BLENDPARAM_ONE;
            this.dstBlend = RenderState.BLENDPARAM_ZERO;
            this.srcBlendRGB = RenderState.BLENDPARAM_ONE;
            this.dstBlendRGB = RenderState.BLENDPARAM_ZERO;
            this.srcBlendAlpha = RenderState.BLENDPARAM_ONE;
            this.dstBlendAlpha = RenderState.BLENDPARAM_ZERO;
            this.blendEquation = RenderState.BLENDEQUATION_ADD;
            this.blendEquationRGB = RenderState.BLENDEQUATION_ADD;
            this.blendEquationAlpha = RenderState.BLENDEQUATION_ADD;
            this.depthTest = RenderState.DEPTHTEST_LEQUAL;
            this.depthWrite = true;
            this.stencilRef = 1;
            this.stencilTest = RenderState.STENCILTEST_OFF;
            this.stencilWrite = false;
            this.stencilOp = new Vector3(RenderState.STENCILOP_KEEP, RenderState.STENCILOP_KEEP, RenderState.STENCILOP_REPLACE);
        }
        setNull() {
            this.cull = null;
            this.blend = null;
            this.srcBlend = null;
            this.dstBlend = null;
            this.srcBlendRGB = null;
            this.dstBlendRGB = null;
            this.srcBlendAlpha = null;
            this.dstBlendAlpha = null;
            this.blendEquation = null;
            this.blendEquationRGB = null;
            this.blendEquationAlpha = null;
            this.depthTest = null;
            this.depthWrite = null;
            this.stencilRef = null;
            this.stencilTest = null;
            this.stencilWrite = null;
            this.stencilOp = null;
        }
    }
    RenderState.CULL_NONE = exports.CullMode.Off;
    RenderState.CULL_FRONT = exports.CullMode.Front;
    RenderState.CULL_BACK = exports.CullMode.Back;
    RenderState.BLEND_DISABLE = exports.BlendType.BLEND_DISABLE;
    RenderState.BLEND_ENABLE_ALL = exports.BlendType.BLEND_ENABLE_ALL;
    RenderState.BLEND_ENABLE_SEPERATE = exports.BlendType.BLEND_ENABLE_SEPERATE;
    RenderState.BLENDPARAM_ZERO = exports.BlendFactor.Zero;
    RenderState.BLENDPARAM_ONE = exports.BlendFactor.One;
    RenderState.BLENDPARAM_SRC_COLOR = exports.BlendFactor.SourceColor;
    RenderState.BLENDPARAM_ONE_MINUS_SRC_COLOR = exports.BlendFactor.OneMinusSourceColor;
    RenderState.BLENDPARAM_DST_COLOR = exports.BlendFactor.DestinationColor;
    RenderState.BLENDPARAM_ONE_MINUS_DST_COLOR = exports.BlendFactor.OneMinusDestinationColor;
    RenderState.BLENDPARAM_SRC_ALPHA = exports.BlendFactor.SourceAlpha;
    RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA = exports.BlendFactor.OneMinusSourceAlpha;
    RenderState.BLENDPARAM_DST_ALPHA = exports.BlendFactor.DestinationAlpha;
    RenderState.BLENDPARAM_ONE_MINUS_DST_ALPHA = exports.BlendFactor.OneMinusDestinationAlpha;
    RenderState.BLENDPARAM_SRC_ALPHA_SATURATE = exports.BlendFactor.SourceAlphaSaturate;
    RenderState.BLENDPARAM_BLENDCOLOR = exports.BlendFactor.BlendColor;
    RenderState.BLENDPARAM_BLEND_ONEMINUS_COLOR = exports.BlendFactor.OneMinusBlendColor;
    RenderState.BLENDEQUATION_ADD = exports.BlendEquationSeparate.ADD;
    RenderState.BLENDEQUATION_SUBTRACT = exports.BlendEquationSeparate.SUBTRACT;
    RenderState.BLENDEQUATION_REVERSE_SUBTRACT = exports.BlendEquationSeparate.REVERSE_SUBTRACT;
    RenderState.BLENDEQUATION_MIN = exports.BlendEquationSeparate.MIN;
    RenderState.BLENDEQUATION_MAX = exports.BlendEquationSeparate.MAX;
    RenderState.DEPTHTEST_OFF = 0;
    RenderState.DEPTHTEST_NEVER = exports.CompareFunction.Never;
    RenderState.DEPTHTEST_LESS = exports.CompareFunction.Less;
    RenderState.DEPTHTEST_EQUAL = exports.CompareFunction.Equal;
    RenderState.DEPTHTEST_LEQUAL = exports.CompareFunction.LessEqual;
    RenderState.DEPTHTEST_GREATER = exports.CompareFunction.Greater;
    RenderState.DEPTHTEST_NOTEQUAL = exports.CompareFunction.NotEqual;
    RenderState.DEPTHTEST_GEQUAL = exports.CompareFunction.GreaterEqual;
    RenderState.DEPTHTEST_ALWAYS = exports.CompareFunction.Always;
    RenderState.STENCILTEST_OFF = 0;
    RenderState.STENCILTEST_NEVER = exports.CompareFunction.Never;
    RenderState.STENCILTEST_LESS = exports.CompareFunction.Less;
    RenderState.STENCILTEST_EQUAL = exports.CompareFunction.Equal;
    RenderState.STENCILTEST_LEQUAL = exports.CompareFunction.LessEqual;
    RenderState.STENCILTEST_GREATER = exports.CompareFunction.Greater;
    RenderState.STENCILTEST_NOTEQUAL = exports.CompareFunction.NotEqual;
    RenderState.STENCILTEST_GEQUAL = exports.CompareFunction.GreaterEqual;
    RenderState.STENCILTEST_ALWAYS = exports.CompareFunction.Always;
    RenderState.STENCILOP_KEEP = exports.StencilOperation.Keep;
    RenderState.STENCILOP_ZERO = exports.StencilOperation.Zero;
    RenderState.STENCILOP_REPLACE = exports.StencilOperation.Replace;
    RenderState.STENCILOP_INCR = exports.StencilOperation.IncrementSaturate;
    RenderState.STENCILOP_INCR_WRAP = exports.StencilOperation.IncrementWrap;
    RenderState.STENCILOP_DECR = exports.StencilOperation.DecrementSaturate;
    RenderState.STENCILOP_DECR_WRAP = exports.StencilOperation.DecrementWrap;
    RenderState.STENCILOP_INVERT = exports.StencilOperation.Invert;
    RenderState.Default = new RenderState();

    class ShaderInstance {
        constructor(vs, ps, attributeMap, shaderPass) {
            this._customUniformParamsMap = [];
            this._uploadMark = -1;
            this._uploadRenderType = -1;
            this._cullStateCMD = LayaGL.renderOBJCreate.createRenderStateComand();
            this._renderShaderInstance = LayaGL.renderEngine.createShaderInstance(vs, ps, attributeMap);
            if (this._renderShaderInstance._complete) {
                this._shaderPass = shaderPass;
                this._create();
            }
        }
        get complete() {
            return this._renderShaderInstance._complete;
        }
        _create() {
            this._sceneUniformParamsMap = new CommandEncoder();
            this._cameraUniformParamsMap = new CommandEncoder();
            this._spriteUniformParamsMap = new CommandEncoder();
            this._materialUniformParamsMap = new CommandEncoder();
            const sceneParams = LayaGL.renderOBJCreate.createGlobalUniformMap("Scene3D");
            const spriteParms = LayaGL.renderOBJCreate.createGlobalUniformMap("Sprite3D");
            const cameraParams = LayaGL.renderOBJCreate.createGlobalUniformMap("BaseCamera");
            const customParams = LayaGL.renderOBJCreate.createGlobalUniformMap("Custom");
            let i, n;
            let data = this._renderShaderInstance.getUniformMap();
            for (i = 0, n = data.length; i < n; i++) {
                let one = data[i];
                if (sceneParams.hasPtrID(one.dataOffset)) {
                    this._sceneUniformParamsMap.addShaderUniform(one);
                }
                else if (cameraParams.hasPtrID(one.dataOffset)) {
                    this._cameraUniformParamsMap.addShaderUniform(one);
                }
                else if (spriteParms.hasPtrID(one.dataOffset)) {
                    this._spriteUniformParamsMap.addShaderUniform(one);
                }
                else if (customParams.hasPtrID(one.dataOffset)) {
                    this._customUniformParamsMap || (this._customUniformParamsMap = []);
                    this._customUniformParamsMap[one.dataOffset] = one;
                }
                else {
                    this._materialUniformParamsMap.addShaderUniform(one);
                }
            }
        }
        _disposeResource() {
            this._renderShaderInstance.destroy();
            this._sceneUniformParamsMap = null;
            this._cameraUniformParamsMap = null;
            this._spriteUniformParamsMap = null;
            this._materialUniformParamsMap = null;
            this._customUniformParamsMap = null;
            this._uploadMaterial = null;
            this._uploadRender = null;
            this._uploadCameraShaderValue = null;
            this._uploadScene = null;
        }
        _getRenderState(shaderDatas, stateIndex) {
            var stateID = SubShader.StateParamsMap[stateIndex];
            return shaderDatas[stateID];
        }
        bind() {
            return this._renderShaderInstance.bind();
        }
        uploadUniforms(shaderUniform, shaderDatas, uploadUnTexture) {
            LayaGL.renderEngine.uploadUniforms(this._renderShaderInstance, shaderUniform, shaderDatas, uploadUnTexture);
        }
        uploadRenderStateBlendDepth(shaderDatas) {
            var renderState = this._shaderPass.renderState;
            var datas = shaderDatas.getData();
            var depthWrite = this._getRenderState(datas, Shader3D.RENDER_STATE_DEPTH_WRITE);
            var depthTest = this._getRenderState(datas, Shader3D.RENDER_STATE_DEPTH_TEST);
            var blend = this._getRenderState(datas, Shader3D.RENDER_STATE_BLEND);
            var stencilRef = this._getRenderState(datas, Shader3D.RENDER_STATE_STENCIL_REF);
            var stencilTest = this._getRenderState(datas, Shader3D.RENDER_STATE_STENCIL_TEST);
            var stencilWrite = this._getRenderState(datas, Shader3D.RENDER_STATE_STENCIL_WRITE);
            var stencilOp = this._getRenderState(datas, Shader3D.RENDER_STATE_STENCIL_OP);
            if (this._shaderPass.statefirst) {
                renderState.depthWrite != null ? depthWrite = renderState.depthWrite : 0;
                renderState.depthTest != null ? depthTest = renderState.depthTest : 0;
                renderState.blend != null ? blend = renderState.blend : 0;
                renderState.stencilRef != null ? stencilRef = renderState.stencilRef : 0;
                renderState.stencilTest != null ? stencilTest = renderState.stencilTest : 0;
                renderState.stencilWrite != null ? stencilWrite = renderState.stencilWrite : 0;
                renderState.stencilOp != null ? stencilOp = renderState.stencilOp : 0;
            }
            else {
                depthWrite = depthWrite !== null && depthWrite !== void 0 ? depthWrite : renderState.depthWrite;
                depthTest = depthTest !== null && depthTest !== void 0 ? depthTest : renderState.depthTest;
                blend = blend !== null && blend !== void 0 ? blend : renderState.blend;
                stencilRef = stencilRef !== null && stencilRef !== void 0 ? stencilRef : renderState.stencilRef;
                stencilTest = stencilTest !== null && stencilTest !== void 0 ? stencilTest : renderState.stencilTest;
                stencilWrite = stencilWrite !== null && stencilWrite !== void 0 ? stencilWrite : renderState.stencilWrite;
                stencilOp = stencilOp !== null && stencilOp !== void 0 ? stencilOp : renderState.stencilOp;
            }
            depthWrite = depthWrite !== null && depthWrite !== void 0 ? depthWrite : RenderState.Default.depthWrite;
            depthTest = depthTest !== null && depthTest !== void 0 ? depthTest : RenderState.Default.depthTest;
            blend = blend !== null && blend !== void 0 ? blend : RenderState.Default.blend;
            stencilRef = stencilRef !== null && stencilRef !== void 0 ? stencilRef : RenderState.Default.stencilRef;
            stencilTest = stencilTest !== null && stencilTest !== void 0 ? stencilTest : RenderState.Default.stencilTest;
            stencilWrite = stencilWrite !== null && stencilWrite !== void 0 ? stencilWrite : RenderState.Default.stencilWrite;
            stencilOp = stencilOp !== null && stencilOp !== void 0 ? stencilOp : RenderState.Default.stencilOp;
            RenderStateContext.setDepthMask(depthWrite);
            if (depthTest === RenderState.DEPTHTEST_OFF)
                RenderStateContext.setDepthTest(false);
            else {
                RenderStateContext.setDepthTest(true);
                RenderStateContext.setDepthFunc(depthTest);
            }
            switch (blend) {
                case RenderState.BLEND_DISABLE:
                    RenderStateContext.setBlend(false);
                    break;
                case RenderState.BLEND_ENABLE_ALL:
                    var blendEquation = this._getRenderState(datas, Shader3D.RENDER_STATE_BLEND_EQUATION);
                    var srcBlend = this._getRenderState(datas, Shader3D.RENDER_STATE_BLEND_SRC);
                    var dstBlend = this._getRenderState(datas, Shader3D.RENDER_STATE_BLEND_DST);
                    if (this._shaderPass.statefirst) {
                        renderState.blendEquation != null ? blendEquation = renderState.blendEquation : 0;
                        renderState.srcBlend != null ? srcBlend = renderState.srcBlend : 0;
                        renderState.dstBlend != null ? dstBlend = renderState.dstBlend : 0;
                    }
                    else {
                        blendEquation = blendEquation !== null && blendEquation !== void 0 ? blendEquation : renderState.blendEquation;
                        srcBlend = srcBlend !== null && srcBlend !== void 0 ? srcBlend : renderState.srcBlend;
                        dstBlend = dstBlend !== null && dstBlend !== void 0 ? dstBlend : renderState.dstBlend;
                    }
                    blendEquation = blendEquation !== null && blendEquation !== void 0 ? blendEquation : RenderState.Default.blendEquation;
                    srcBlend = srcBlend !== null && srcBlend !== void 0 ? srcBlend : RenderState.Default.srcBlend;
                    dstBlend = dstBlend !== null && dstBlend !== void 0 ? dstBlend : RenderState.Default.dstBlend;
                    RenderStateContext.setBlend(true);
                    RenderStateContext.setBlendEquation(blendEquation);
                    RenderStateContext.setBlendFunc(srcBlend, dstBlend);
                    break;
                case RenderState.BLEND_ENABLE_SEPERATE:
                    var blendEquationRGB = this._getRenderState(datas, Shader3D.RENDER_STATE_BLEND_EQUATION_RGB);
                    var blendEquationAlpha = this._getRenderState(datas, Shader3D.RENDER_STATE_BLEND_EQUATION_ALPHA);
                    var srcRGB = this._getRenderState(datas, Shader3D.RENDER_STATE_BLEND_SRC_RGB);
                    var dstRGB = this._getRenderState(datas, Shader3D.RENDER_STATE_BLEND_DST_RGB);
                    var srcAlpha = this._getRenderState(datas, Shader3D.RENDER_STATE_BLEND_SRC_ALPHA);
                    var dstAlpha = this._getRenderState(datas, Shader3D.RENDER_STATE_BLEND_DST_ALPHA);
                    if (this._shaderPass.statefirst) {
                        renderState.blendEquationRGB != null ? blendEquationRGB = renderState.blendEquationRGB : 0;
                        renderState.blendEquationAlpha != null ? blendEquationAlpha = renderState.blendEquationAlpha : 0;
                        renderState.srcBlendRGB != null ? srcRGB = renderState.srcBlendRGB : 0;
                        renderState.dstBlendRGB != null ? dstRGB = renderState.dstBlendRGB : 0;
                        renderState.srcBlendAlpha != null ? srcAlpha = renderState.srcBlendAlpha : 0;
                        renderState.dstBlendAlpha != null ? dstAlpha = renderState.dstBlendAlpha : 0;
                    }
                    else {
                        blendEquationRGB = blendEquationRGB !== null && blendEquationRGB !== void 0 ? blendEquationRGB : renderState.blendEquationRGB;
                        blendEquationAlpha = blendEquationAlpha !== null && blendEquationAlpha !== void 0 ? blendEquationAlpha : renderState.blendEquationAlpha;
                        srcRGB = srcRGB !== null && srcRGB !== void 0 ? srcRGB : renderState.srcBlendRGB;
                        dstRGB = dstRGB !== null && dstRGB !== void 0 ? dstRGB : renderState.dstBlendRGB;
                        srcAlpha = srcAlpha !== null && srcAlpha !== void 0 ? srcAlpha : renderState.srcBlendAlpha;
                        dstAlpha = dstAlpha !== null && dstAlpha !== void 0 ? dstAlpha : renderState.dstBlendAlpha;
                    }
                    blendEquationRGB = blendEquationRGB !== null && blendEquationRGB !== void 0 ? blendEquationRGB : RenderState.Default.blendEquationRGB;
                    blendEquationAlpha = blendEquationAlpha !== null && blendEquationAlpha !== void 0 ? blendEquationAlpha : RenderState.Default.blendEquationAlpha;
                    srcRGB = srcRGB !== null && srcRGB !== void 0 ? srcRGB : RenderState.Default.srcBlendRGB;
                    dstRGB = dstRGB !== null && dstRGB !== void 0 ? dstRGB : RenderState.Default.dstBlendRGB;
                    srcAlpha = srcAlpha !== null && srcAlpha !== void 0 ? srcAlpha : RenderState.Default.srcBlendAlpha;
                    dstAlpha = dstAlpha !== null && dstAlpha !== void 0 ? dstAlpha : RenderState.Default.dstBlendAlpha;
                    RenderStateContext.setBlend(true);
                    RenderStateContext.setBlendEquationSeparate(blendEquationRGB, blendEquationAlpha);
                    RenderStateContext.setBlendFuncSeperate(srcRGB, dstRGB, srcAlpha, dstAlpha);
                    break;
            }
            RenderStateContext.setStencilMask(stencilWrite);
            if (stencilTest == RenderState.STENCILTEST_OFF) {
                RenderStateContext.setStencilTest(false);
            }
            else {
                RenderStateContext.setStencilTest(true);
                RenderStateContext.setStencilFunc(stencilTest, stencilRef);
            }
            RenderStateContext.setstencilOp(stencilOp.x, stencilOp.y, stencilOp.z);
        }
        uploadRenderStateFrontFace(shaderDatas, isTarget, invertFront) {
            var _a;
            this._cullStateCMD.clear();
            var renderState = this._shaderPass.renderState;
            var datas = shaderDatas.getData();
            var cull = this._getRenderState(datas, Shader3D.RENDER_STATE_CULL);
            if (this._shaderPass.statefirst) {
                cull = (_a = renderState.cull) !== null && _a !== void 0 ? _a : cull;
            }
            cull = cull !== null && cull !== void 0 ? cull : RenderState.Default.cull;
            var forntFace;
            switch (cull) {
                case RenderState.CULL_NONE:
                    this._cullStateCMD.addCMD(exports.RenderStateType.CullFace, false);
                    break;
                case RenderState.CULL_FRONT:
                    this._cullStateCMD.addCMD(exports.RenderStateType.CullFace, true);
                    if (isTarget == invertFront)
                        forntFace = exports.CullMode.Front;
                    else
                        forntFace = exports.CullMode.Back;
                    this._cullStateCMD.addCMD(exports.RenderStateType.FrontFace, forntFace);
                    break;
                case RenderState.CULL_BACK:
                    this._cullStateCMD.addCMD(exports.RenderStateType.CullFace, true);
                    if (isTarget != invertFront)
                        forntFace = exports.CullMode.Front;
                    else
                        forntFace = exports.CullMode.Back;
                    this._cullStateCMD.addCMD(exports.RenderStateType.FrontFace, forntFace);
                    break;
            }
            this._cullStateCMD.applyCMD();
        }
        uploadCustomUniform(index, data) {
            LayaGL.renderEngine.uploadCustomUniforms(this._renderShaderInstance, this._customUniformParamsMap, index, data);
        }
    }

    class NativeGLRender2DContext extends NativeGLObject {
        constructor(engine) {
            super(engine);
        }
        activeTexture(textureID) {
        }
        bindTexture(target, texture) {
        }
        bindUseProgram(webglProgram) {
            return true;
        }
    }

    class WebGlConfig {
    }

    class CommonMemoryAllocater {
        static creatBlock(size) {
            const buffer = new ArrayBuffer(size);
            return buffer;
        }
        static freeMemoryBlock(buffer) {
        }
    }

    exports.MemoryDataType = void 0;
    (function (MemoryDataType) {
        MemoryDataType[MemoryDataType["ShaderData"] = 0] = "ShaderData";
        MemoryDataType[MemoryDataType["TextureData"] = 1] = "TextureData";
        MemoryDataType[MemoryDataType["VertexData"] = 2] = "VertexData";
        MemoryDataType[MemoryDataType["IndexData"] = 3] = "IndexData";
        MemoryDataType[MemoryDataType["BaseRenderData"] = 4] = "BaseRenderData";
    })(exports.MemoryDataType || (exports.MemoryDataType = {}));

    class NativeMemory {
        constructor(size, shared) {
            if (shared) {
                if (size > NativeMemory._sharedBuffer.byteLength) {
                    throw new Error("NativeMemory:shared buffer not enough");
                }
                this._buffer = NativeMemory._sharedBuffer;
            }
            else {
                this._buffer = CommonMemoryAllocater.creatBlock(size);
            }
            this._idata = new Int32Array(this._buffer);
            this._fdata = new Float32Array(this._buffer);
            this._f64data = new Float64Array(this._buffer);
            this._byteArray = new Uint8Array(this._buffer);
            this._byteLength = size;
        }
        get float32Array() {
            return this._fdata;
        }
        get float64Array() {
            return this._f64data;
        }
        get uint8Array() {
            return this._byteArray;
        }
        get int32Array() {
            return this._idata;
        }
        destroy() {
            if (this._destroyed)
                return;
            this.clear();
            CommonMemoryAllocater.freeMemoryBlock(this._buffer);
            this._destroyed = true;
        }
        clear() {
            this._idata = null;
            this._fdata = null;
            this._byteArray = null;
        }
    }
    NativeMemory.NativeSourceID = 0;
    NativeMemory._sharedBuffer = new ArrayBuffer(256);

    class UploadMemory extends NativeMemory {
        constructor(size) {
            super(size, false);
            this._currentOffsetInByte = 0;
        }
        addBlockCell(node, dataSizeInByte) {
            if (node.uploadDataTOShareMemory(this, this._currentOffsetInByte)) {
                this._currentOffsetInByte += dataSizeInByte;
            }
        }
        check(size) {
            return this._currentOffsetInByte + size < this._byteLength;
        }
        clear() {
            this._currentOffsetInByte = 0;
        }
    }

    class UploadMemoryManager {
        constructor() {
            this._dataNodeList = new SingletonList();
            this._commandNums = 0;
            this._currentBlock = new UploadMemory(UploadMemoryManager.UploadMemorySize);
            this._conchUploadMemoryManager = new window.conchUploadMemoryManager();
        }
        static getInstance() {
            if (!UploadMemoryManager._instance) {
                UploadMemoryManager._instance = new UploadMemoryManager();
            }
            return UploadMemoryManager._instance;
        }
        _addNodeCommand(node, sizeInByte) {
            this._currentBlock.addBlockCell(node, sizeInByte);
            this._commandNums++;
        }
        static syncRenderMemory() {
            UploadMemoryManager.getInstance()._serialiseData();
            UploadMemoryManager.getInstance().clear();
        }
        _serialiseData() {
            const elements = this._dataNodeList.elements;
            for (let i = 0; i < this._dataNodeList.length; i++) {
                let node = elements[i];
                let dataSizeInByte = node.getUploadMemoryLength();
                if (dataSizeInByte > UploadMemoryManager.UploadMemorySize)
                    throw "dataSize is too large, greater than UploadMemorySize,";
                if (this._currentBlock.check(dataSizeInByte)) {
                    this.uploadData();
                    this._addNodeCommand(node, dataSizeInByte);
                }
                else {
                    this._addNodeCommand(node, dataSizeInByte);
                }
            }
            this.uploadData();
        }
        uploadData() {
            if (this._commandNums > 0) {
                this._conchUploadMemoryManager.uploadData(this._currentBlock._buffer, this._commandNums);
                this._commandNums = 0;
                this._currentBlock.clear();
            }
        }
        clear() {
            this._dataNodeList.length = 0;
        }
    }
    UploadMemoryManager.UploadMemorySize = 1024 * 1024;
    UploadMemoryManager._instance = null;

    class ArabicReshaper {
        characterMapContains(c) {
            for (var i = 0; i < ArabicReshaper.charsMap.length; ++i) {
                if (ArabicReshaper.charsMap[i][0] === c) {
                    return true;
                }
            }
            return false;
        }
        getCharRep(c) {
            for (var i = 0; i < ArabicReshaper.charsMap.length; ++i) {
                if (ArabicReshaper.charsMap[i][0] === c) {
                    return ArabicReshaper.charsMap[i];
                }
            }
            return false;
        }
        getCombCharRep(c1, c2) {
            for (var i = 0; i < ArabicReshaper.combCharsMap.length; ++i) {
                if (ArabicReshaper.combCharsMap[i][0][0] === c1 && ArabicReshaper.combCharsMap[i][0][1] === c2) {
                    return ArabicReshaper.combCharsMap[i];
                }
            }
            return false;
        }
        isTransparent(c) {
            for (var i = 0; i < ArabicReshaper.transChars.length; ++i) {
                if (ArabicReshaper.transChars[i] === c) {
                    return true;
                }
            }
            return false;
        }
        getOriginalCharsFromCode(code) {
            var j;
            for (j = 0; j < ArabicReshaper.charsMap.length; ++j) {
                if (ArabicReshaper.charsMap[j].indexOf(code) > -1) {
                    return String.fromCharCode(ArabicReshaper.charsMap[j][0]);
                }
            }
            for (j = 0; j < ArabicReshaper.combCharsMap.length; ++j) {
                if (ArabicReshaper.combCharsMap[j].indexOf(code) > -1) {
                    return String.fromCharCode(ArabicReshaper.combCharsMap[j][0][0]) +
                        String.fromCharCode(ArabicReshaper.combCharsMap[j][0][1]);
                }
            }
            return String.fromCharCode(code);
        }
        convertArabic(normal) {
            var crep, combcrep, shaped = '';
            for (var i = 0; i < normal.length; ++i) {
                var current = normal.charCodeAt(i);
                if (this.characterMapContains(current)) {
                    var prev = null, next = null, prevID = i - 1, nextID = i + 1;
                    for (; prevID >= 0; --prevID) {
                        if (!this.isTransparent(normal.charCodeAt(prevID))) {
                            break;
                        }
                    }
                    prev = (prevID >= 0) ? normal.charCodeAt(prevID) : null;
                    crep = prev ? this.getCharRep(prev) : false;
                    if (!crep || crep[2] == null && crep[3] == null) {
                        prev = null;
                    }
                    for (; nextID < normal.length; ++nextID) {
                        if (!this.isTransparent(normal.charCodeAt(nextID))) {
                            break;
                        }
                    }
                    next = (nextID < normal.length) ? normal.charCodeAt(nextID) : null;
                    crep = next ? this.getCharRep(next) : false;
                    if (!crep || crep[3] == null && crep[4] == null) {
                        next = null;
                    }
                    if (current === 0x0644 && next != null &&
                        (next === 0x0622 || next === 0x0623 || next === 0x0625 || next === 0x0627)) {
                        combcrep = this.getCombCharRep(current, next);
                        if (prev != null) {
                            shaped += String.fromCharCode(combcrep[4]);
                        }
                        else {
                            shaped += String.fromCharCode(combcrep[1]);
                        }
                        ++i;
                        continue;
                    }
                    crep = this.getCharRep(current);
                    if (prev != null && next != null && crep[3] != null) {
                        shaped += String.fromCharCode(crep[3]);
                        continue;
                    }
                    else if (prev != null && crep[4] != null) {
                        shaped += String.fromCharCode(crep[4]);
                        continue;
                    }
                    else if (next != null && crep[2] != null) {
                        shaped += String.fromCharCode(crep[2]);
                        continue;
                    }
                    else {
                        shaped += String.fromCharCode(crep[1]);
                    }
                }
                else {
                    shaped += String.fromCharCode(current);
                }
            }
            return shaped;
        }
        convertArabicBack(apfb) {
            var toReturn = '', selectedChar;
            var i;
            for (i = 0; i < apfb.length; ++i) {
                selectedChar = apfb.charCodeAt(i);
                toReturn += this.getOriginalCharsFromCode(selectedChar);
            }
            return toReturn;
        }
    }
    ArabicReshaper.charsMap = [[0x0621, 0xFE80, null, null, null],
        [0x0622, 0xFE81, null, null, 0xFE82],
        [0x0623, 0xFE83, null, null, 0xFE84],
        [0x0624, 0xFE85, null, null, 0xFE86],
        [0x0625, 0xFE87, null, null, 0xFE88],
        [0x0626, 0xFE89, 0xFE8B, 0xFE8C, 0xFE8A],
        [0x0627, 0xFE8D, null, null, 0xFE8E],
        [0x0628, 0xFE8F, 0xFE91, 0xFE92, 0xFE90],
        [0x0629, 0xFE93, null, null, 0xFE94],
        [0x062A, 0xFE95, 0xFE97, 0xFE98, 0xFE96],
        [0x062B, 0xFE99, 0xFE9B, 0xFE9C, 0xFE9A],
        [0x062C, 0xFE9D, 0xFE9F, 0xFEA0, 0xFE9E],
        [0x062D, 0xFEA1, 0xFEA3, 0xFEA4, 0xFEA2],
        [0x062E, 0xFEA5, 0xFEA7, 0xFEA8, 0xFEA6],
        [0x062F, 0xFEA9, null, null, 0xFEAA],
        [0x0630, 0xFEAB, null, null, 0xFEAC],
        [0x0631, 0xFEAD, null, null, 0xFEAE],
        [0x0632, 0xFEAF, null, null, 0xFEB0],
        [0x0633, 0xFEB1, 0xFEB3, 0xFEB4, 0xFEB2],
        [0x0634, 0xFEB5, 0xFEB7, 0xFEB8, 0xFEB6],
        [0x0635, 0xFEB9, 0xFEBB, 0xFEBC, 0xFEBA],
        [0x0636, 0xFEBD, 0xFEBF, 0xFEC0, 0xFEBE],
        [0x0637, 0xFEC1, 0xFEC3, 0xFEC4, 0xFEC2],
        [0x0638, 0xFEC5, 0xFEC7, 0xFEC8, 0xFEC6],
        [0x0639, 0xFEC9, 0xFECB, 0xFECC, 0xFECA],
        [0x063A, 0xFECD, 0xFECF, 0xFED0, 0xFECE],
        [0x0640, 0x0640, 0x0640, 0x0640, 0x0640],
        [0x0641, 0xFED1, 0xFED3, 0xFED4, 0xFED2],
        [0x0642, 0xFED5, 0xFED7, 0xFED8, 0xFED6],
        [0x0643, 0xFED9, 0xFEDB, 0xFEDC, 0xFEDA],
        [0x0644, 0xFEDD, 0xFEDF, 0xFEE0, 0xFEDE],
        [0x0645, 0xFEE1, 0xFEE3, 0xFEE4, 0xFEE2],
        [0x0646, 0xFEE5, 0xFEE7, 0xFEE8, 0xFEE6],
        [0x0647, 0xFEE9, 0xFEEB, 0xFEEC, 0xFEEA],
        [0x0648, 0xFEED, null, null, 0xFEEE],
        [0x0649, 0xFEEF, null, null, 0xFEF0],
        [0x064A, 0xFEF1, 0xFEF3, 0xFEF4, 0xFEF2],
        [0x067E, 0xFB56, 0xFB58, 0xFB59, 0xFB57],
        [0x06CC, 0xFBFC, 0xFBFE, 0xFBFF, 0xFBFD],
        [0x0686, 0xFB7A, 0xFB7C, 0xFB7D, 0xFB7B],
        [0x06A9, 0xFB8E, 0xFB90, 0xFB91, 0xFB8F],
        [0x06AF, 0xFB92, 0xFB94, 0xFB95, 0xFB93],
        [0x0698, 0xFB8A, null, null, 0xFB8B]];
    ArabicReshaper.combCharsMap = [[[0x0644, 0x0622], 0xFEF5, null, null, 0xFEF6],
        [[0x0644, 0x0623], 0xFEF7, null, null, 0xFEF8],
        [[0x0644, 0x0625], 0xFEF9, null, null, 0xFEFA],
        [[0x0644, 0x0627], 0xFEFB, null, null, 0xFEFC]];
    ArabicReshaper.transChars = [0x0610,
        0x0612,
        0x0613,
        0x0614,
        0x0615,
        0x064B,
        0x064C,
        0x064D,
        0x064E,
        0x064F,
        0x0650,
        0x0651,
        0x0652,
        0x0653,
        0x0654,
        0x0655,
        0x0656,
        0x0657,
        0x0658,
        0x0670,
        0x06D6,
        0x06D7,
        0x06D8,
        0x06D9,
        0x06DA,
        0x06DB,
        0x06DC,
        0x06DF,
        0x06E0,
        0x06E1,
        0x06E2,
        0x06E3,
        0x06E4,
        0x06E7,
        0x06E8,
        0x06EA,
        0x06EB,
        0x06EC,
        0x06ED];

    class ShaderValue {
        constructor() {
        }
    }

    class MatirxArray {
        static ArrayMul(a, b, o) {
            if (!a) {
                MatirxArray.copyArray(b, o);
                return;
            }
            if (!b) {
                MatirxArray.copyArray(a, o);
                return;
            }
            var ai0, ai1, ai2, ai3;
            for (var i = 0; i < 4; i++) {
                ai0 = a[i];
                ai1 = a[i + 4];
                ai2 = a[i + 8];
                ai3 = a[i + 12];
                o[i] = ai0 * b[0] + ai1 * b[1] + ai2 * b[2] + ai3 * b[3];
                o[i + 4] = ai0 * b[4] + ai1 * b[5] + ai2 * b[6] + ai3 * b[7];
                o[i + 8] = ai0 * b[8] + ai1 * b[9] + ai2 * b[10] + ai3 * b[11];
                o[i + 12] = ai0 * b[12] + ai1 * b[13] + ai2 * b[14] + ai3 * b[15];
            }
        }
        static copyArray(f, t) {
            if (!f)
                return;
            if (!t)
                return;
            for (var i = 0; i < f.length; i++) {
                t[i] = f[i];
            }
        }
    }

    exports.AlphaCmd = AlphaCmd;
    exports.Animation = Animation;
    exports.Animation2DCondition = Animation2DCondition;
    exports.Animation2DEvent = Animation2DEvent;
    exports.Animation2DParm = Animation2DParm;
    exports.AnimationBase = AnimationBase;
    exports.AnimationClip2D = AnimationClip2D;
    exports.AnimationClip2DParse01 = AnimationClip2DParse01;
    exports.Animator2D = Animator2D;
    exports.AnimatorController2D = AnimatorController2D;
    exports.AnimatorControllerLayer2D = AnimatorControllerLayer2D;
    exports.AnimatorControllerParse = AnimatorControllerParse;
    exports.AnimatorPlayState2D = AnimatorPlayState2D;
    exports.AnimatorState2D = AnimatorState2D;
    exports.AnimatorState2DScript = AnimatorState2DScript;
    exports.AnimatorStateBoolCondition = AnimatorStateBoolCondition;
    exports.AnimatorStateCondition = AnimatorStateCondition;
    exports.AnimatorStateNumberCondition = AnimatorStateNumberCondition;
    exports.AnimatorStateTriggerCondition = AnimatorStateTriggerCondition;
    exports.AnimatorTransition2D = AnimatorTransition2D;
    exports.ArabicReshaper = ArabicReshaper;
    exports.AssetDb = AssetDb;
    exports.AtlasGrid = AtlasGrid;
    exports.AtlasInfoManager = AtlasInfoManager;
    exports.AtlasResource = AtlasResource;
    exports.AudioSound = AudioSound;
    exports.AudioSoundChannel = AudioSoundChannel;
    exports.Base64Tool = Base64Tool;
    exports.BasePoly = BasePoly;
    exports.BaseShader = BaseShader;
    exports.BaseTexture = BaseTexture;
    exports.BatchProgress = BatchProgress;
    exports.Bezier = Bezier;
    exports.BitmapFont = BitmapFont;
    exports.BlendComponent = BlendComponent;
    exports.BlendMode = BlendMode;
    exports.BlendState = BlendState;
    exports.BlurFilter = BlurFilter;
    exports.BlurFilterGLRender = BlurFilterGLRender;
    exports.BoundsStyle = BoundsStyle;
    exports.Browser = Browser;
    exports.Buffer = Buffer;
    exports.Buffer2D = Buffer2D;
    exports.BufferState = BufferState;
    exports.ButtonEffect = ButtonEffect;
    exports.Byte = Byte;
    exports.CacheManger = CacheManger;
    exports.CacheStyle = CacheStyle;
    exports.CallLater = CallLater;
    exports.CharRenderInfo = CharRenderInfo;
    exports.CharRender_Canvas = CharRender_Canvas;
    exports.CharRender_Native = CharRender_Native;
    exports.CharSubmitCache = CharSubmitCache;
    exports.ClassUtils = ClassUtils;
    exports.ClipRectCmd = ClipRectCmd;
    exports.Color = Color;
    exports.ColorFilter = ColorFilter;
    exports.ColorUtils = ColorUtils;
    exports.CommandEncoder = CommandEncoder;
    exports.CommandUniformMap = CommandUniformMap;
    exports.CommonMemoryAllocater = CommonMemoryAllocater;
    exports.Component = Component;
    exports.ComponentDriver = ComponentDriver;
    exports.Config = Config;
    exports.Config3D = Config3D;
    exports.Const = Const;
    exports.Context = Context;
    exports.DDSTextureInfo = DDSTextureInfo;
    exports.DefineDatas = DefineDatas;
    exports.Delegate = Delegate;
    exports.DepthState = DepthState;
    exports.Downloader = Downloader;
    exports.Dragging = Dragging;
    exports.Draw9GridTextureCmd = Draw9GridTextureCmd;
    exports.DrawCircleCmd = DrawCircleCmd;
    exports.DrawCurvesCmd = DrawCurvesCmd;
    exports.DrawImageCmd = DrawImageCmd;
    exports.DrawLineCmd = DrawLineCmd;
    exports.DrawLinesCmd = DrawLinesCmd;
    exports.DrawParticleCmd = DrawParticleCmd;
    exports.DrawPathCmd = DrawPathCmd;
    exports.DrawPieCmd = DrawPieCmd;
    exports.DrawPolyCmd = DrawPolyCmd;
    exports.DrawRectCmd = DrawRectCmd;
    exports.DrawStyle = DrawStyle;
    exports.DrawTextureCmd = DrawTextureCmd;
    exports.DrawTexturesCmd = DrawTexturesCmd;
    exports.DrawTrianglesCmd = DrawTrianglesCmd;
    exports.EXRTextureInfo = EXRTextureInfo;
    exports.Earcut = Earcut;
    exports.EarcutNode = EarcutNode;
    exports.Ease = Ease;
    exports.EffectAnimation = EffectAnimation;
    exports.EffectBase = EffectBase;
    exports.Event = Event;
    exports.EventDispatcher = EventDispatcher;
    exports.FadeIn = FadeIn;
    exports.FadeOut = FadeOut;
    exports.FillTextCmd = FillTextCmd;
    exports.FillTextureCmd = FillTextureCmd;
    exports.Filter = Filter;
    exports.FontInfo = FontInfo;
    exports.FrameAnimation = FrameAnimation;
    exports.GL2TextureContext = GL2TextureContext;
    exports.GLBuffer = GLBuffer;
    exports.GLObject = GLObject;
    exports.GLParams = GLParams;
    exports.GLRender2DContext = GLRender2DContext;
    exports.GLRenderDrawContext = GLRenderDrawContext;
    exports.GLRenderState = GLRenderState;
    exports.GLSLCodeGenerator = GLSLCodeGenerator;
    exports.GLShaderInstance = GLShaderInstance;
    exports.GLTextureContext = GLTextureContext;
    exports.GLVertexState = GLVertexState;
    exports.GlCapable = GlCapable;
    exports.GlowFilter = GlowFilter;
    exports.GlowFilterGLRender = GlowFilterGLRender;
    exports.GrahamScan = GrahamScan;
    exports.GraphicAnimation = GraphicAnimation;
    exports.Graphics = Graphics;
    exports.GraphicsBounds = GraphicsBounds;
    exports.HDRTextureInfo = HDRTextureInfo;
    exports.HTMLCanvas = HTMLCanvas;
    exports.HTMLChar = HTMLChar;
    exports.HalfFloatUtils = HalfFloatUtils;
    exports.Handler = Handler;
    exports.HideFlags = HideFlags;
    exports.HierarchyLoader = HierarchyLoader;
    exports.HierarchyParser = HierarchyParser;
    exports.HierarchyResource = HierarchyResource;
    exports.HitArea = HitArea;
    exports.HttpRequest = HttpRequest;
    exports.ICharRender = ICharRender;
    exports.ILaya = ILaya;
    exports.IStatRender = IStatRender;
    exports.ImgUtils = ImgUtils;
    exports.IncludeFile = IncludeFile;
    exports.IndexBuffer = IndexBuffer;
    exports.IndexBuffer2D = IndexBuffer2D;
    exports.Input = Input;
    exports.InputManager = InputManager;
    exports.KTXTextureInfo = KTXTextureInfo;
    exports.KeyLocation = KeyLocation;
    exports.Keyboard = Keyboard;
    exports.Keyframe2D = Keyframe2D;
    exports.KeyframeNode2D = KeyframeNode2D;
    exports.KeyframeNodeList2D = KeyframeNodeList2D;
    exports.Laya = Laya;
    exports.LayaEnv = LayaEnv;
    exports.LayaGL = LayaGL;
    exports.LayaGLQuickRunner = LayaGLQuickRunner;
    exports.LegacyUIParser = LegacyUIParser;
    exports.Loader = Loader;
    exports.LocalStorage = LocalStorage;
    exports.Log = Log;
    exports.MathUtil = MathUtil;
    exports.MathUtils3D = MathUtils3D;
    exports.MatirxArray = MatirxArray;
    exports.Matrix = Matrix;
    exports.Matrix3x3 = Matrix3x3;
    exports.Matrix4x4 = Matrix4x4;
    exports.Mesh2D = Mesh2D;
    exports.MeshParticle2D = MeshParticle2D;
    exports.MeshQuadTexture = MeshQuadTexture;
    exports.MeshTexture = MeshTexture;
    exports.MeshVG = MeshVG;
    exports.Mouse = Mouse;
    exports.NativeContext = NativeContext;
    exports.NativeFilter = NativeFilter;
    exports.NativeGL2TextureContext = NativeGL2TextureContext;
    exports.NativeGLObject = NativeGLObject;
    exports.NativeGLRender2DContext = NativeGLRender2DContext;
    exports.NativeGLRenderDrawContext = NativeGLRenderDrawContext;
    exports.NativeGLTextureContext = NativeGLTextureContext;
    exports.NativeGLVertexState = NativeGLVertexState;
    exports.NativeMemory = NativeMemory;
    exports.NativeRenderStateCommand = NativeRenderStateCommand;
    exports.NativeRenderTexture2D = NativeRenderTexture2D;
    exports.NativeWebGLCacheAsNormalCanvas = NativeWebGLCacheAsNormalCanvas;
    exports.NativeWebGLEngine = NativeWebGLEngine;
    exports.NativeWordText = NativeWordText;
    exports.Node = Node;
    exports.NodeFlags = NodeFlags;
    exports.NullLoader = NullLoader;
    exports.Path = Path;
    exports.PerfData = PerfData;
    exports.PerfHUD = PerfHUD;
    exports.Point = Point;
    exports.Pool = Pool;
    exports.PoolCache = PoolCache;
    exports.Prefab = Prefab;
    exports.PrefabImpl = PrefabImpl;
    exports.PrimitiveSV = PrimitiveSV;
    exports.Quaternion = Quaternion;
    exports.QuickTestTool = QuickTestTool;
    exports.Rectangle = Rectangle;
    exports.Render = Render;
    exports.RenderInfo = RenderInfo;
    exports.RenderSprite = RenderSprite;
    exports.RenderState = RenderState;
    exports.RenderState2D = RenderState2D;
    exports.RenderStateCommand = RenderStateCommand;
    exports.RenderStateContext = RenderStateContext;
    exports.RenderTexture = RenderTexture;
    exports.RenderTexture2D = RenderTexture2D;
    exports.Resource = Resource;
    exports.ResourceVersion = ResourceVersion;
    exports.RestoreCmd = RestoreCmd;
    exports.RotateCmd = RotateCmd;
    exports.RunDriver = RunDriver;
    exports.SaveBase = SaveBase;
    exports.SaveClipRect = SaveClipRect;
    exports.SaveCmd = SaveCmd;
    exports.SaveMark = SaveMark;
    exports.SaveTransform = SaveTransform;
    exports.SaveTranslate = SaveTranslate;
    exports.ScaleCmd = ScaleCmd;
    exports.Scene = Scene;
    exports.Script = Script;
    exports.SerializeUtil = SerializeUtil;
    exports.Shader = Shader;
    exports.Shader2D = Shader2D;
    exports.Shader2X = Shader2X;
    exports.Shader3D = Shader3D;
    exports.ShaderCompile = ShaderCompile;
    exports.ShaderCompileDefineBase = ShaderCompileDefineBase;
    exports.ShaderData = ShaderData;
    exports.ShaderDataDefaultValue = ShaderDataDefaultValue;
    exports.ShaderDefine = ShaderDefine;
    exports.ShaderDefines2D = ShaderDefines2D;
    exports.ShaderDefinesBase = ShaderDefinesBase;
    exports.ShaderInstance = ShaderInstance;
    exports.ShaderNode = ShaderNode;
    exports.ShaderPass = ShaderPass;
    exports.ShaderValue = ShaderValue;
    exports.ShaderVariable = ShaderVariable;
    exports.ShaderVariant = ShaderVariant;
    exports.ShaderVariantCollection = ShaderVariantCollection;
    exports.SingletonList = SingletonList;
    exports.SkinMeshBuffer = SkinMeshBuffer;
    exports.SkinSV = SkinSV;
    exports.Socket = Socket;
    exports.Sound = Sound;
    exports.SoundChannel = SoundChannel;
    exports.SoundManager = SoundManager;
    exports.SoundNode = SoundNode;
    exports.Sprite = Sprite;
    exports.SpriteConst = SpriteConst;
    exports.SpriteStyle = SpriteStyle;
    exports.SpriteUtils = SpriteUtils;
    exports.Stage = Stage;
    exports.Stat = Stat;
    exports.StatUI = StatUI;
    exports.StencilState = StencilState;
    exports.StringKey = StringKey;
    exports.SubShader = SubShader;
    exports.SubUniformBufferData = SubUniformBufferData;
    exports.Submit = Submit;
    exports.SubmitBase = SubmitBase;
    exports.SubmitCMD = SubmitCMD;
    exports.SubmitCanvas = SubmitCanvas;
    exports.SubmitKey = SubmitKey;
    exports.SubmitTarget = SubmitTarget;
    exports.SubmitTexture = SubmitTexture;
    exports.System = System;
    exports.TTFLoader = TTFLoader;
    exports.Text = Text;
    exports.TextAtlas = TextAtlas;
    exports.TextRender = TextRender;
    exports.TextResource = TextResource;
    exports.TextStyle = TextStyle;
    exports.TextTexture = TextTexture;
    exports.Texture = Texture;
    exports.Texture2D = Texture2D;
    exports.TextureSV = TextureSV;
    exports.TimeLine = TimeLine;
    exports.Timer = Timer;
    exports.TransformCmd = TransformCmd;
    exports.TranslateCmd = TranslateCmd;
    exports.Tween = Tween;
    exports.TypedArrayClasses = TypedArrayClasses;
    exports.URL = URL;
    exports.UniformBufferBase = UniformBufferBase;
    exports.UniformBufferObject = UniformBufferObject;
    exports.UnifromBufferData = UnifromBufferData;
    exports.UploadMemory = UploadMemory;
    exports.UploadMemoryManager = UploadMemoryManager;
    exports.Utils = Utils;
    exports.Value2D = Value2D;
    exports.Vector2 = Vector2;
    exports.Vector3 = Vector3;
    exports.Vector4 = Vector4;
    exports.VectorGraphManager = VectorGraphManager;
    exports.VertexArrayObject = VertexArrayObject;
    exports.VertexBuffer = VertexBuffer;
    exports.VertexBuffer2D = VertexBuffer2D;
    exports.VertexDeclaration = VertexDeclaration;
    exports.VertexElement = VertexElement;
    exports.VertexElementFormat = VertexElementFormat;
    exports.VertexMesh = VertexMesh;
    exports.VideoNode = VideoNode;
    exports.VideoTexture = VideoTexture;
    exports.WeakObject = WeakObject;
    exports.WebAudioSound = WebAudioSound;
    exports.WebAudioSoundChannel = WebAudioSoundChannel;
    exports.WebGL = WebGL;
    exports.WebGLCacheAsNormalCanvas = WebGLCacheAsNormalCanvas;
    exports.WebGLEngine = WebGLEngine;
    exports.WebGLInternalRT = WebGLInternalRT;
    exports.WebGLInternalTex = WebGLInternalTex;
    exports.WebGLRTMgr = WebGLRTMgr;
    exports.WebGlConfig = WebGlConfig;
    exports.Widget = Widget;
    exports.WordText = WordText;
    exports.WorkerLoader = WorkerLoader;
    exports.alertGlobalError = alertGlobalError;
    exports.classInfo = classInfo;
    exports.enableDebugPanel = enableDebugPanel;
    exports.init = init;
    exports.isWXOpenDataContext = isWXOpenDataContext;
    exports.isWXPosMsg = isWXPosMsg;
    exports.lateTimer = lateTimer;
    exports.property = property;
    exports.regClass = regClass;
    exports.runInEditor = runInEditor;
    exports.startTimer = startTimer;
    exports.updateTimer = updateTimer;

    return exports;

})({});
//# sourceMappingURL=laya.core.js.map
