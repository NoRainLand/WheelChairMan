(function (exports, Laya) {
    'use strict';

    class DepthCasterData {
        static createDepthCasterUniformBlock() {
            if (!DepthCasterData.DepthCasterUBOData) {
                let uniformpara = new Map();
                uniformpara.set(Laya.Shader3D.propertyNameToID("u_ShadowBias"), Laya.UniformBufferParamsType.Vector4);
                uniformpara.set(Laya.Shader3D.propertyNameToID("u_ShadowLightDirection"), Laya.UniformBufferParamsType.Vector3);
                DepthCasterData.DepthCasterUBOData = new Laya.UnifromBufferData(uniformpara);
            }
            return DepthCasterData.DepthCasterUBOData;
        }
    }

    exports.DepthTextureMode = void 0;
    (function (DepthTextureMode) {
        DepthTextureMode[DepthTextureMode["None"] = 0] = "None";
        DepthTextureMode[DepthTextureMode["Depth"] = 1] = "Depth";
        DepthTextureMode[DepthTextureMode["DepthNormals"] = 2] = "DepthNormals";
        DepthTextureMode[DepthTextureMode["DepthAndDepthNormals"] = 3] = "DepthAndDepthNormals";
        DepthTextureMode[DepthTextureMode["MotionVectors"] = 4] = "MotionVectors";
    })(exports.DepthTextureMode || (exports.DepthTextureMode = {}));
    class DepthPass {
        constructor() {
            this._defaultNormalDepthColor = new Laya.Color(0.5, 0.5, 1.0, 0.0);
            this._zBufferParams = new Laya.Vector4();
            if (Laya.Config3D._uniformBlock) {
                this._castDepthData = DepthCasterData.createDepthCasterUniformBlock();
                this._castDepthUBO = Laya.UniformBufferObject.getBuffer(Laya.UniformBufferObject.UBONAME_SHADOW, 0);
                if (!this._castDepthUBO) {
                    this._castDepthUBO = Laya.UniformBufferObject.create(Laya.UniformBufferObject.UBONAME_SHADOW, Laya.BufferUsage.Dynamic, this._castDepthData.getbyteLength(), true);
                }
            }
        }
        static __init__() {
            DepthPass.DEPTHPASS = Laya.Shader3D.getDefineByName("DEPTHPASS");
            DepthPass.DEFINE_SHADOW_BIAS = Laya.Shader3D.propertyNameToID("u_ShadowBias");
            DepthPass.DEPTHTEXTURE = Laya.Shader3D.propertyNameToID("u_CameraDepthTexture");
            DepthPass.DEPTHNORMALSTEXTURE = Laya.Shader3D.propertyNameToID("u_CameraDepthNormalsTexture");
            DepthPass.DEPTHZBUFFERPARAMS = Laya.Shader3D.propertyNameToID("u_ZBufferParams");
            DepthPass.SHADOWUNIFORMBLOCK = Laya.Shader3D.propertyNameToID(Laya.UniformBufferObject.UBONAME_SHADOW);
        }
        update(camera, depthType, depthTextureFormat) {
            this._viewPort = camera.viewport;
            this._camera = camera;
            switch (depthType) {
                case exports.DepthTextureMode.Depth:
                    camera.depthTexture = this._depthTexture = Laya.RenderTexture.createFromPool(this._viewPort.width, this._viewPort.height, depthTextureFormat, Laya.RenderTargetFormat.None, false, 1);
                    break;
                case exports.DepthTextureMode.DepthNormals:
                    camera.depthNormalTexture = this._depthNormalsTexture = Laya.RenderTexture.createFromPool(this._viewPort.width, this._viewPort.height, Laya.RenderTargetFormat.R8G8B8A8, depthTextureFormat, false, 1);
                    break;
                case exports.DepthTextureMode.MotionVectors:
                    break;
                default:
                    throw ("there is UnDefined type of DepthTextureMode");
            }
        }
        render(context, depthType) {
            var scene = context.scene;
            var shaderValues = scene._shaderValues;
            switch (depthType) {
                case exports.DepthTextureMode.Depth:
                    context.pipelineMode = "ShadowCaster";
                    shaderValues.addDefine(DepthPass.DEPTHPASS);
                    shaderValues.setVector(DepthPass.DEFINE_SHADOW_BIAS, DepthPass.SHADOW_BIAS);
                    var offsetX = this._viewPort.x;
                    var offsetY = this._viewPort.y;
                    this._depthTexture._start();
                    Laya.LayaGL.renderEngine.viewport(offsetX, offsetY, this._viewPort.width, this._viewPort.height);
                    Laya.LayaGL.renderEngine.scissor(offsetX, offsetY, this._viewPort.width, this._viewPort.height);
                    Laya.LayaGL.renderEngine.clearRenderTexture(Laya.RenderClearFlag.Depth, null, 1);
                    context.changeViewport(offsetX, offsetY, this._viewPort.width, this._viewPort.height);
                    context.changeScissor(offsetX, offsetY, this._viewPort.width, this._viewPort.height);
                    context.destTarget = this._depthTexture;
                    Laya.Stat.depthCastDrawCall += scene._opaqueQueue.renderQueue(context);
                    this._depthTexture._end();
                    this._setupDepthModeShaderValue(depthType, this._camera);
                    context.pipelineMode = context.configPipeLineMode;
                    shaderValues.removeDefine(DepthPass.DEPTHPASS);
                    break;
                case exports.DepthTextureMode.DepthNormals:
                    context.pipelineMode = "DepthNormal";
                    this._depthNormalsTexture._start();
                    var offsetX = this._viewPort.x;
                    var offsetY = this._viewPort.y;
                    Laya.LayaGL.renderEngine.viewport(offsetX, offsetY, this._viewPort.width, this._viewPort.height);
                    Laya.LayaGL.renderEngine.scissor(offsetX, offsetY, this._viewPort.width, this._viewPort.height);
                    Laya.LayaGL.renderEngine.clearRenderTexture(Laya.RenderClearFlag.Color | Laya.RenderClearFlag.Depth, this._defaultNormalDepthColor, 1);
                    context.destTarget = this._depthNormalsTexture;
                    context.changeViewport(offsetX, offsetY, this._viewPort.width, this._viewPort.height);
                    context.changeScissor(offsetX, offsetY, this._viewPort.width, this._viewPort.height);
                    Laya.Stat.depthCastDrawCall += scene._opaqueQueue.renderQueue(context);
                    this._depthNormalsTexture._end();
                    this._setupDepthModeShaderValue(depthType, this._camera);
                    context.pipelineMode = context.configPipeLineMode;
                    break;
                case exports.DepthTextureMode.MotionVectors:
                    break;
                default:
                    throw ("there is UnDefined type of DepthTextureMode");
            }
        }
        _setupDepthModeShaderValue(depthType, camera) {
            switch (depthType) {
                case exports.DepthTextureMode.Depth:
                    var far = camera.farPlane;
                    var near = camera.nearPlane;
                    this._zBufferParams.setValue(1.0 - far / near, far / near, (near - far) / (near * far), 1 / near);
                    camera._shaderValues.setVector(DepthPass.DEFINE_SHADOW_BIAS, DepthPass.SHADOW_BIAS);
                    camera._shaderValues.setTexture(DepthPass.DEPTHTEXTURE, this._depthTexture);
                    camera._shaderValues.setVector(DepthPass.DEPTHZBUFFERPARAMS, this._zBufferParams);
                    break;
                case exports.DepthTextureMode.DepthNormals:
                    camera._shaderValues.setTexture(DepthPass.DEPTHNORMALSTEXTURE, this._depthNormalsTexture);
                    break;
                case exports.DepthTextureMode.MotionVectors:
                    break;
                default:
                    throw ("there is UnDefined type of DepthTextureMode");
            }
        }
        cleanUp() {
            (this._depthTexture instanceof Laya.RenderTexture) && this._depthTexture && Laya.RenderTexture.recoverToPool(this._depthTexture);
            this._depthNormalsTexture && Laya.RenderTexture.recoverToPool(this._depthNormalsTexture);
            this._depthTexture = null;
            this._depthNormalsTexture = null;
        }
    }
    DepthPass.SHADOW_BIAS = new Laya.Vector4();

    class Physics3DUtils {
        constructor() {
        }
        static setColliderCollision(collider1, collider2, collsion) {
        }
        static getIColliderCollision(collider1, collider2) {
            return false;
        }
    }
    Physics3DUtils.COLLISIONFILTERGROUP_DEFAULTFILTER = 0x1;
    Physics3DUtils.COLLISIONFILTERGROUP_STATICFILTER = 0x2;
    Physics3DUtils.COLLISIONFILTERGROUP_KINEMATICFILTER = 0x4;
    Physics3DUtils.COLLISIONFILTERGROUP_DEBRISFILTER = 0x8;
    Physics3DUtils.COLLISIONFILTERGROUP_SENSORTRIGGER = 0x10;
    Physics3DUtils.COLLISIONFILTERGROUP_CHARACTERFILTER = 0x20;
    Physics3DUtils.COLLISIONFILTERGROUP_CUSTOMFILTER1 = 0x40;
    Physics3DUtils.COLLISIONFILTERGROUP_CUSTOMFILTER2 = 0x80;
    Physics3DUtils.COLLISIONFILTERGROUP_CUSTOMFILTER3 = 0x100;
    Physics3DUtils.COLLISIONFILTERGROUP_CUSTOMFILTER4 = 0x200;
    Physics3DUtils.COLLISIONFILTERGROUP_CUSTOMFILTER5 = 0x400;
    Physics3DUtils.COLLISIONFILTERGROUP_CUSTOMFILTER6 = 0x800;
    Physics3DUtils.COLLISIONFILTERGROUP_CUSTOMFILTER7 = 0x1000;
    Physics3DUtils.COLLISIONFILTERGROUP_CUSTOMFILTER8 = 0x2000;
    Physics3DUtils.COLLISIONFILTERGROUP_CUSTOMFILTER9 = 0x4000;
    Physics3DUtils.COLLISIONFILTERGROUP_CUSTOMFILTER10 = 0x8000;
    Physics3DUtils.COLLISIONFILTERGROUP_ALLFILTER = -1;
    Physics3DUtils.gravity = new Laya.Vector3(0, -9.81, 0);

    class TextureGenerator {
        constructor() {
        }
        static lightAttenTexture(x, y, maxX, maxY, index, data) {
            var sqrRange = x / maxX;
            var atten = 1.0 / (1.0 + 25.0 * sqrRange);
            if (sqrRange >= 0.64) {
                if (sqrRange > 1.0) {
                    atten = 0;
                }
                else {
                    atten *= 1 - (sqrRange - 0.64) / (1 - 0.64);
                }
            }
            data[index] = Math.floor(atten * 255.0 + 0.5);
        }
        static haloTexture(x, y, maxX, maxY, index, data) {
            maxX >>= 1;
            maxY >>= 1;
            var xFac = (x - maxX) / maxX;
            var yFac = (y - maxY) / maxY;
            var sqrRange = xFac * xFac + yFac * yFac;
            if (sqrRange > 1.0) {
                sqrRange = 1.0;
            }
            data[index] = Math.floor((1.0 - sqrRange) * 255.0 + 0.5);
        }
        static _generateTexture2D(texture, textureWidth, textureHeight, func) {
            var index = 0;
            var size = 0;
            switch (texture.format) {
                case Laya.TextureFormat.R8G8B8:
                    size = 3;
                    break;
                case Laya.TextureFormat.R8G8B8A8:
                    size = 4;
                    break;
                case Laya.TextureFormat.Alpha8:
                    size = 1;
                    break;
                default:
                    throw "GeneratedTexture._generateTexture: unkonw texture format.";
            }
            var data = new Uint8Array(textureWidth * textureHeight * size);
            for (var y = 0; y < textureHeight; y++) {
                for (var x = 0; x < textureWidth; x++) {
                    func(x, y, textureWidth, textureHeight, index, data);
                    index += size;
                }
            }
            texture.setPixelsData(data, false, false);
        }
    }

    class ILaya3D {
    }
    ILaya3D.Scene3D = null;
    ILaya3D.Laya3D = null;
    ILaya3D.Physics3D = null;

    class Utils3D {
        static _createFloatTextureBuffer(width, height) {
            var floatTex = new Laya.Texture2D(width, height, Laya.TextureFormat.R32G32B32A32, false, false);
            floatTex.setPixelsData(null, false, false);
            floatTex.filterMode = Laya.FilterMode.Point;
            floatTex.wrapModeU = Laya.WrapMode.Clamp;
            floatTex.wrapModeV = Laya.WrapMode.Clamp;
            floatTex.anisoLevel = 0;
            return floatTex;
        }
        static _convertToLayaVec3(bVector, out) {
            var bullet = ILaya3D.Physics3D._bullet;
            out.x = bullet.btVector3_x(bVector);
            out.y = bullet.btVector3_y(bVector);
            out.z = bullet.btVector3_z(bVector);
        }
        static _convertToBulletVec3(lVector, out) {
            ILaya3D.Physics3D._bullet.btVector3_setValue(out, lVector.x, lVector.y, lVector.z);
        }
        static _rotationTransformScaleSkinAnimation(tx, ty, tz, qx, qy, qz, qw, sx, sy, sz, outArray, outOffset) {
            var re = Utils3D._tempArray16_0;
            var se = Utils3D._tempArray16_1;
            var tse = Utils3D._tempArray16_2;
            var x2 = qx + qx;
            var y2 = qy + qy;
            var z2 = qz + qz;
            var xx = qx * x2;
            var yx = qy * x2;
            var yy = qy * y2;
            var zx = qz * x2;
            var zy = qz * y2;
            var zz = qz * z2;
            var wx = qw * x2;
            var wy = qw * y2;
            var wz = qw * z2;
            re[15] = 1;
            re[0] = 1 - yy - zz;
            re[1] = yx + wz;
            re[2] = zx - wy;
            re[4] = yx - wz;
            re[5] = 1 - xx - zz;
            re[6] = zy + wx;
            re[8] = zx + wy;
            re[9] = zy - wx;
            re[10] = 1 - xx - yy;
            se[15] = 1;
            se[0] = sx;
            se[5] = sy;
            se[10] = sz;
            var i, ai0, ai1, ai2, ai3;
            for (i = 0; i < 4; i++) {
                ai0 = re[i];
                ai1 = re[i + 4];
                ai2 = re[i + 8];
                ai3 = re[i + 12];
                tse[i] = ai0;
                tse[i + 4] = ai1;
                tse[i + 8] = ai2;
                tse[i + 12] = ai0 * tx + ai1 * ty + ai2 * tz + ai3;
            }
            for (i = 0; i < 4; i++) {
                ai0 = tse[i];
                ai1 = tse[i + 4];
                ai2 = tse[i + 8];
                ai3 = tse[i + 12];
                outArray[i + outOffset] = ai0 * se[0] + ai1 * se[1] + ai2 * se[2] + ai3 * se[3];
                outArray[i + outOffset + 4] = ai0 * se[4] + ai1 * se[5] + ai2 * se[6] + ai3 * se[7];
                outArray[i + outOffset + 8] = ai0 * se[8] + ai1 * se[9] + ai2 * se[10] + ai3 * se[11];
                outArray[i + outOffset + 12] = ai0 * se[12] + ai1 * se[13] + ai2 * se[14] + ai3 * se[15];
            }
        }
        static _computeBoneAndAnimationDatasByBindPoseMatrxix(bones, curData, inverGlobalBindPose, outBonesDatas, outAnimationDatas, boneIndexToMesh) {
            var offset = 0;
            var matOffset = 0;
            var i;
            var parentOffset;
            var boneLength = bones.length;
            for (i = 0; i < boneLength; offset += bones[i].keyframeWidth, matOffset += 16, i++) {
                Utils3D._rotationTransformScaleSkinAnimation(curData[offset + 0], curData[offset + 1], curData[offset + 2], curData[offset + 3], curData[offset + 4], curData[offset + 5], curData[offset + 6], curData[offset + 7], curData[offset + 8], curData[offset + 9], outBonesDatas, matOffset);
                if (i != 0) {
                    parentOffset = bones[i].parentIndex * 16;
                    Utils3D.mulMatrixByArray(outBonesDatas, parentOffset, outBonesDatas, matOffset, outBonesDatas, matOffset);
                }
            }
            var n = inverGlobalBindPose.length;
            for (i = 0; i < n; i++) {
                Utils3D.mulMatrixByArrayAndMatrixFast(outBonesDatas, boneIndexToMesh[i] * 16, inverGlobalBindPose[i], outAnimationDatas, i * 16);
            }
        }
        static _computeAnimationDatasByArrayAndMatrixFast(inverGlobalBindPose, bonesDatas, outAnimationDatas, boneIndexToMesh) {
            for (var i = 0, n = inverGlobalBindPose.length; i < n; i++)
                Utils3D.mulMatrixByArrayAndMatrixFast(bonesDatas, boneIndexToMesh[i] * 16, inverGlobalBindPose[i], outAnimationDatas, i * 16);
        }
        static _computeBoneAndAnimationDatasByBindPoseMatrxixOld(bones, curData, inverGlobalBindPose, outBonesDatas, outAnimationDatas) {
            var offset = 0;
            var matOffset = 0;
            var i;
            var parentOffset;
            var boneLength = bones.length;
            for (i = 0; i < boneLength; offset += bones[i].keyframeWidth, matOffset += 16, i++) {
                Utils3D._rotationTransformScaleSkinAnimation(curData[offset + 7], curData[offset + 8], curData[offset + 9], curData[offset + 3], curData[offset + 4], curData[offset + 5], curData[offset + 6], curData[offset + 0], curData[offset + 1], curData[offset + 2], outBonesDatas, matOffset);
                if (i != 0) {
                    parentOffset = bones[i].parentIndex * 16;
                    Utils3D.mulMatrixByArray(outBonesDatas, parentOffset, outBonesDatas, matOffset, outBonesDatas, matOffset);
                }
            }
            var n = inverGlobalBindPose.length;
            for (i = 0; i < n; i++) {
                var arrayOffset = i * 16;
                Utils3D.mulMatrixByArrayAndMatrixFast(outBonesDatas, arrayOffset, inverGlobalBindPose[i], outAnimationDatas, arrayOffset);
            }
        }
        static _computeAnimationDatasByArrayAndMatrixFastOld(inverGlobalBindPose, bonesDatas, outAnimationDatas) {
            var n = inverGlobalBindPose.length;
            for (var i = 0; i < n; i++) {
                var arrayOffset = i * 16;
                Utils3D.mulMatrixByArrayAndMatrixFast(bonesDatas, arrayOffset, inverGlobalBindPose[i], outAnimationDatas, arrayOffset);
            }
        }
        static _computeRootAnimationData(bones, curData, animationDatas) {
            for (var i = 0, offset = 0, matOffset = 0, boneLength = bones.length; i < boneLength; offset += bones[i].keyframeWidth, matOffset += 16, i++)
                Utils3D.createAffineTransformationArray(curData[offset + 0], curData[offset + 1], curData[offset + 2], curData[offset + 3], curData[offset + 4], curData[offset + 5], curData[offset + 6], curData[offset + 7], curData[offset + 8], curData[offset + 9], animationDatas, matOffset);
        }
        static transformVector3ArrayByQuat(sourceArray, sourceOffset, rotation, outArray, outOffset) {
            var x = sourceArray[sourceOffset], y = sourceArray[sourceOffset + 1], z = sourceArray[sourceOffset + 2], qx = rotation.x, qy = rotation.y, qz = rotation.z, qw = rotation.w, ix = qw * x + qy * z - qz * y, iy = qw * y + qz * x - qx * z, iz = qw * z + qx * y - qy * x, iw = -qx * x - qy * y - qz * z;
            outArray[outOffset] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
            outArray[outOffset + 1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
            outArray[outOffset + 2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
        }
        static mulMatrixByArray(leftArray, leftOffset, rightArray, rightOffset, outArray, outOffset) {
            var i, ai0, ai1, ai2, ai3;
            if (outArray === rightArray) {
                rightArray = Utils3D._tempArray16_3;
                for (i = 0; i < 16; ++i) {
                    rightArray[i] = outArray[outOffset + i];
                }
                rightOffset = 0;
            }
            for (i = 0; i < 4; i++) {
                ai0 = leftArray[leftOffset + i];
                ai1 = leftArray[leftOffset + i + 4];
                ai2 = leftArray[leftOffset + i + 8];
                ai3 = leftArray[leftOffset + i + 12];
                outArray[outOffset + i] = ai0 * rightArray[rightOffset + 0] + ai1 * rightArray[rightOffset + 1] + ai2 * rightArray[rightOffset + 2] + ai3 * rightArray[rightOffset + 3];
                outArray[outOffset + i + 4] = ai0 * rightArray[rightOffset + 4] + ai1 * rightArray[rightOffset + 5] + ai2 * rightArray[rightOffset + 6] + ai3 * rightArray[rightOffset + 7];
                outArray[outOffset + i + 8] = ai0 * rightArray[rightOffset + 8] + ai1 * rightArray[rightOffset + 9] + ai2 * rightArray[rightOffset + 10] + ai3 * rightArray[rightOffset + 11];
                outArray[outOffset + i + 12] = ai0 * rightArray[rightOffset + 12] + ai1 * rightArray[rightOffset + 13] + ai2 * rightArray[rightOffset + 14] + ai3 * rightArray[rightOffset + 15];
            }
        }
        static mulMatrixByArrayFast(leftArray, leftOffset, rightArray, rightOffset, outArray, outOffset) {
            var i, ai0, ai1, ai2, ai3;
            for (i = 0; i < 4; i++) {
                ai0 = leftArray[leftOffset + i];
                ai1 = leftArray[leftOffset + i + 4];
                ai2 = leftArray[leftOffset + i + 8];
                ai3 = leftArray[leftOffset + i + 12];
                outArray[outOffset + i] = ai0 * rightArray[rightOffset + 0] + ai1 * rightArray[rightOffset + 1] + ai2 * rightArray[rightOffset + 2] + ai3 * rightArray[rightOffset + 3];
                outArray[outOffset + i + 4] = ai0 * rightArray[rightOffset + 4] + ai1 * rightArray[rightOffset + 5] + ai2 * rightArray[rightOffset + 6] + ai3 * rightArray[rightOffset + 7];
                outArray[outOffset + i + 8] = ai0 * rightArray[rightOffset + 8] + ai1 * rightArray[rightOffset + 9] + ai2 * rightArray[rightOffset + 10] + ai3 * rightArray[rightOffset + 11];
                outArray[outOffset + i + 12] = ai0 * rightArray[rightOffset + 12] + ai1 * rightArray[rightOffset + 13] + ai2 * rightArray[rightOffset + 14] + ai3 * rightArray[rightOffset + 15];
            }
        }
        static mulMatrixByArrayAndMatrixFast(leftArray, leftOffset, rightMatrix, outArray, outOffset) {
            var i, ai0, ai1, ai2, ai3;
            var rightMatrixE = rightMatrix.elements;
            var m11 = rightMatrixE[0], m12 = rightMatrixE[1], m13 = rightMatrixE[2], m14 = rightMatrixE[3];
            var m21 = rightMatrixE[4], m22 = rightMatrixE[5], m23 = rightMatrixE[6], m24 = rightMatrixE[7];
            var m31 = rightMatrixE[8], m32 = rightMatrixE[9], m33 = rightMatrixE[10], m34 = rightMatrixE[11];
            var m41 = rightMatrixE[12], m42 = rightMatrixE[13], m43 = rightMatrixE[14], m44 = rightMatrixE[15];
            var ai0LeftOffset = leftOffset;
            var ai1LeftOffset = leftOffset + 4;
            var ai2LeftOffset = leftOffset + 8;
            var ai3LeftOffset = leftOffset + 12;
            var ai0OutOffset = outOffset;
            var ai1OutOffset = outOffset + 4;
            var ai2OutOffset = outOffset + 8;
            var ai3OutOffset = outOffset + 12;
            for (i = 0; i < 4; i++) {
                ai0 = leftArray[ai0LeftOffset + i];
                ai1 = leftArray[ai1LeftOffset + i];
                ai2 = leftArray[ai2LeftOffset + i];
                ai3 = leftArray[ai3LeftOffset + i];
                outArray[ai0OutOffset + i] = ai0 * m11 + ai1 * m12 + ai2 * m13 + ai3 * m14;
                outArray[ai1OutOffset + i] = ai0 * m21 + ai1 * m22 + ai2 * m23 + ai3 * m24;
                outArray[ai2OutOffset + i] = ai0 * m31 + ai1 * m32 + ai2 * m33 + ai3 * m34;
                outArray[ai3OutOffset + i] = ai0 * m41 + ai1 * m42 + ai2 * m43 + ai3 * m44;
            }
        }
        static createAffineTransformationArray(tX, tY, tZ, rX, rY, rZ, rW, sX, sY, sZ, outArray, outOffset) {
            var x2 = rX + rX, y2 = rY + rY, z2 = rZ + rZ;
            var xx = rX * x2, xy = rX * y2, xz = rX * z2, yy = rY * y2, yz = rY * z2, zz = rZ * z2;
            var wx = rW * x2, wy = rW * y2, wz = rW * z2;
            outArray[outOffset + 0] = (1 - (yy + zz)) * sX;
            outArray[outOffset + 1] = (xy + wz) * sX;
            outArray[outOffset + 2] = (xz - wy) * sX;
            outArray[outOffset + 3] = 0;
            outArray[outOffset + 4] = (xy - wz) * sY;
            outArray[outOffset + 5] = (1 - (xx + zz)) * sY;
            outArray[outOffset + 6] = (yz + wx) * sY;
            outArray[outOffset + 7] = 0;
            outArray[outOffset + 8] = (xz + wy) * sZ;
            outArray[outOffset + 9] = (yz - wx) * sZ;
            outArray[outOffset + 10] = (1 - (xx + yy)) * sZ;
            outArray[outOffset + 11] = 0;
            outArray[outOffset + 12] = tX;
            outArray[outOffset + 13] = tY;
            outArray[outOffset + 14] = tZ;
            outArray[outOffset + 15] = 1;
        }
        static transformVector3ArrayToVector3ArrayCoordinate(source, sourceOffset, transform, result, resultOffset) {
            var coordinateX = source[sourceOffset + 0];
            var coordinateY = source[sourceOffset + 1];
            var coordinateZ = source[sourceOffset + 2];
            var transformElem = transform.elements;
            var w = ((coordinateX * transformElem[3]) + (coordinateY * transformElem[7]) + (coordinateZ * transformElem[11]) + transformElem[15]);
            result[resultOffset] = (coordinateX * transformElem[0]) + (coordinateY * transformElem[4]) + (coordinateZ * transformElem[8]) + transformElem[12] / w;
            result[resultOffset + 1] = (coordinateX * transformElem[1]) + (coordinateY * transformElem[5]) + (coordinateZ * transformElem[9]) + transformElem[13] / w;
            result[resultOffset + 2] = (coordinateX * transformElem[2]) + (coordinateY * transformElem[6]) + (coordinateZ * transformElem[10]) + transformElem[14] / w;
        }
        static transformVector3ArrayToVector3ArrayNormal(source, sourceOffset, transform, result, resultOffset) {
            var coordinateX = source[sourceOffset + 0];
            var coordinateY = source[sourceOffset + 1];
            var coordinateZ = source[sourceOffset + 2];
            var transformElem = transform.elements;
            result[resultOffset] = coordinateX * transformElem[0] + coordinateY * transformElem[4] + coordinateZ * transformElem[8];
            result[resultOffset + 1] = coordinateX * transformElem[1] + coordinateY * transformElem[5] + coordinateZ * transformElem[9];
            result[resultOffset + 2] = coordinateX * transformElem[2] + coordinateY * transformElem[6] + coordinateZ * transformElem[10];
        }
        static transformLightingMapTexcoordArray(source, sourceOffset, lightingMapScaleOffset, result, resultOffset) {
            result[resultOffset + 0] = source[sourceOffset + 0] * lightingMapScaleOffset.x + lightingMapScaleOffset.z;
            result[resultOffset + 1] = 1.0 - ((1.0 - source[sourceOffset + 1]) * lightingMapScaleOffset.y + lightingMapScaleOffset.w);
        }
        static getURLVerion(url) {
            var index = url.indexOf("?");
            return index >= 0 ? url.substr(index) : null;
        }
        static _createAffineTransformationArray(trans, rot, scale, outE) {
            var x = rot.x, y = rot.y, z = rot.z, w = rot.w, x2 = x + x, y2 = y + y, z2 = z + z;
            var xx = x * x2, xy = x * y2, xz = x * z2, yy = y * y2, yz = y * z2, zz = z * z2;
            var wx = w * x2, wy = w * y2, wz = w * z2, sx = scale.x, sy = scale.y, sz = scale.z;
            outE[0] = (1 - (yy + zz)) * sx;
            outE[1] = (xy + wz) * sx;
            outE[2] = (xz - wy) * sx;
            outE[3] = 0;
            outE[4] = (xy - wz) * sy;
            outE[5] = (1 - (xx + zz)) * sy;
            outE[6] = (yz + wx) * sy;
            outE[7] = 0;
            outE[8] = (xz + wy) * sz;
            outE[9] = (yz - wx) * sz;
            outE[10] = (1 - (xx + yy)) * sz;
            outE[11] = 0;
            outE[12] = trans.x;
            outE[13] = trans.y;
            outE[14] = trans.z;
            outE[15] = 1;
        }
        static _mulMatrixArray(left, right, rightOffset, outArray, outOffset) {
            var l = right;
            var r = left;
            var e = outArray;
            var l11 = l[rightOffset], l12 = l[rightOffset + 1], l13 = l[rightOffset + 2], l14 = l[rightOffset + 3];
            var l21 = l[rightOffset + 4], l22 = l[rightOffset + 5], l23 = l[rightOffset + 6], l24 = l[rightOffset + 7];
            var l31 = l[rightOffset + 8], l32 = l[rightOffset + 9], l33 = l[rightOffset + 10], l34 = l[rightOffset + 11];
            var l41 = l[rightOffset + 12], l42 = l[rightOffset + 13], l43 = l[rightOffset + 14], l44 = l[rightOffset + 15];
            var r11 = r[0], r12 = r[1], r13 = r[2], r14 = r[3];
            var r21 = r[4], r22 = r[5], r23 = r[6], r24 = r[7];
            var r31 = r[8], r32 = r[9], r33 = r[10], r34 = r[11];
            var r41 = r[12], r42 = r[13], r43 = r[14], r44 = r[15];
            e[outOffset] = (l11 * r11) + (l12 * r21) + (l13 * r31) + (l14 * r41);
            e[outOffset + 1] = (l11 * r12) + (l12 * r22) + (l13 * r32) + (l14 * r42);
            e[outOffset + 2] = (l11 * r13) + (l12 * r23) + (l13 * r33) + (l14 * r43);
            e[outOffset + 3] = (l11 * r14) + (l12 * r24) + (l13 * r34) + (l14 * r44);
            e[outOffset + 4] = (l21 * r11) + (l22 * r21) + (l23 * r31) + (l24 * r41);
            e[outOffset + 5] = (l21 * r12) + (l22 * r22) + (l23 * r32) + (l24 * r42);
            e[outOffset + 6] = (l21 * r13) + (l22 * r23) + (l23 * r33) + (l24 * r43);
            e[outOffset + 7] = (l21 * r14) + (l22 * r24) + (l23 * r34) + (l24 * r44);
            e[outOffset + 8] = (l31 * r11) + (l32 * r21) + (l33 * r31) + (l34 * r41);
            e[outOffset + 9] = (l31 * r12) + (l32 * r22) + (l33 * r32) + (l34 * r42);
            e[outOffset + 10] = (l31 * r13) + (l32 * r23) + (l33 * r33) + (l34 * r43);
            e[outOffset + 11] = (l31 * r14) + (l32 * r24) + (l33 * r34) + (l34 * r44);
            e[outOffset + 12] = (l41 * r11) + (l42 * r21) + (l43 * r31) + (l44 * r41);
            e[outOffset + 13] = (l41 * r12) + (l42 * r22) + (l43 * r32) + (l44 * r42);
            e[outOffset + 14] = (l41 * r13) + (l42 * r23) + (l43 * r33) + (l44 * r43);
            e[outOffset + 15] = (l41 * r14) + (l42 * r24) + (l43 * r34) + (l44 * r44);
        }
        static arcTanAngle(x, y) {
            if (x == 0) {
                if (y == 1)
                    return Math.PI / 2;
                return -Math.PI / 2;
            }
            if (x > 0)
                return Math.atan(y / x);
            if (x < 0) {
                if (y > 0)
                    return Math.atan(y / x) + Math.PI;
                return Math.atan(y / x) - Math.PI;
            }
            return 0;
        }
        static angleTo(from, location, angle) {
            Laya.Vector3.subtract(location, from, TEMPVector30);
            Laya.Vector3.normalize(TEMPVector30, TEMPVector30);
            angle.x = Math.asin(TEMPVector30.y);
            angle.y = Utils3D.arcTanAngle(-TEMPVector30.z, -TEMPVector30.x);
        }
        static transformQuat(source, rotation, out) {
            var re = rotation;
            var x = source.x, y = source.y, z = source.z, qx = re[0], qy = re[1], qz = re[2], qw = re[3], ix = qw * x + qy * z - qz * y, iy = qw * y + qz * x - qx * z, iz = qw * z + qx * y - qy * x, iw = -qx * x - qy * y - qz * z;
            out.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
            out.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
            out.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
        }
        static quaternionWeight(f, weight, e) {
            e.x = f.x * weight;
            e.y = f.y * weight;
            e.z = f.z * weight;
            e.w = f.w;
        }
        static quaternionConjugate(value, result) {
            result.x = -value.x;
            result.y = -value.y;
            result.z = -value.z;
            result.w = value.w;
        }
        static scaleWeight(s, w, out) {
            var sX = s.x, sY = s.y, sZ = s.z;
            out.x = sX > 0 ? Math.pow(Math.abs(sX), w) : -Math.pow(Math.abs(sX), w);
            out.y = sY > 0 ? Math.pow(Math.abs(sY), w) : -Math.pow(Math.abs(sY), w);
            out.z = sZ > 0 ? Math.pow(Math.abs(sZ), w) : -Math.pow(Math.abs(sZ), w);
        }
        static scaleBlend(sa, sb, w, out) {
            var saw = Utils3D._tempVector3_0;
            var sbw = Utils3D._tempVector3_1;
            Utils3D.scaleWeight(sa, 1.0 - w, saw);
            Utils3D.scaleWeight(sb, w, sbw);
            var sng = w > 0.5 ? sb : sa;
            out.x = sng.x > 0 ? Math.abs(saw.x * sbw.x) : -Math.abs(saw.x * sbw.x);
            out.y = sng.y > 0 ? Math.abs(saw.y * sbw.y) : -Math.abs(saw.y * sbw.y);
            out.z = sng.z > 0 ? Math.abs(saw.z * sbw.z) : -Math.abs(saw.z * sbw.z);
        }
        static matrix4x4MultiplyFFF(a, b, e) {
            var i, ai0, ai1, ai2, ai3;
            if (e === b) {
                b = new Float32Array(16);
                for (i = 0; i < 16; ++i) {
                    b[i] = e[i];
                }
            }
            var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
            var b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7];
            var b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11];
            var b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
            for (i = 0; i < 4; i++) {
                ai0 = a[i];
                ai1 = a[i + 4];
                ai2 = a[i + 8];
                ai3 = a[i + 12];
                e[i] = ai0 * b0 + ai1 * b1 + ai2 * b2 + ai3 * b3;
                e[i + 4] = ai0 * b4 + ai1 * b5 + ai2 * b6 + ai3 * b7;
                e[i + 8] = ai0 * b8 + ai1 * b9 + ai2 * b10 + ai3 * b11;
                e[i + 12] = ai0 * b12 + ai1 * b13 + ai2 * b14 + ai3 * b15;
            }
        }
        static matrix4x4MultiplyMFM(left, right, out) {
            Utils3D.matrix4x4MultiplyFFF(left.elements, right, out.elements);
        }
        static _buildTexture2D(width, height, format, colorFunc, mipmaps = false) {
            var texture = new Laya.Texture2D(width, height, format, mipmaps, true);
            texture.anisoLevel = 1;
            texture.filterMode = Laya.FilterMode.Point;
            TextureGenerator._generateTexture2D(texture, width, height, colorFunc);
            return texture;
        }
        static _drawBound(debugLine, boundBox, color) {
            if (debugLine.lineCount + 12 > debugLine.maxLineCount)
                debugLine.maxLineCount += 12;
            var start = Utils3D._tempVector3_0;
            var end = Utils3D._tempVector3_1;
            var min = boundBox.min;
            var max = boundBox.max;
            start.setValue(min.x, min.y, min.z);
            end.setValue(max.x, min.y, min.z);
            debugLine.addLine(start, end, color, color);
            start.setValue(min.x, min.y, min.z);
            end.setValue(min.x, min.y, max.z);
            debugLine.addLine(start, end, color, color);
            start.setValue(max.x, min.y, min.z);
            end.setValue(max.x, min.y, max.z);
            debugLine.addLine(start, end, color, color);
            start.setValue(min.x, min.y, max.z);
            end.setValue(max.x, min.y, max.z);
            debugLine.addLine(start, end, color, color);
            start.setValue(min.x, min.y, min.z);
            end.setValue(min.x, max.y, min.z);
            debugLine.addLine(start, end, color, color);
            start.setValue(min.x, min.y, max.z);
            end.setValue(min.x, max.y, max.z);
            debugLine.addLine(start, end, color, color);
            start.setValue(max.x, min.y, min.z);
            end.setValue(max.x, max.y, min.z);
            debugLine.addLine(start, end, color, color);
            start.setValue(max.x, min.y, max.z);
            end.setValue(max.x, max.y, max.z);
            debugLine.addLine(start, end, color, color);
            start.setValue(min.x, max.y, min.z);
            end.setValue(max.x, max.y, min.z);
            debugLine.addLine(start, end, color, color);
            start.setValue(min.x, max.y, min.z);
            end.setValue(min.x, max.y, max.z);
            debugLine.addLine(start, end, color, color);
            start.setValue(max.x, max.y, min.z);
            end.setValue(max.x, max.y, max.z);
            debugLine.addLine(start, end, color, color);
            start.setValue(min.x, max.y, max.z);
            end.setValue(max.x, max.y, max.z);
            debugLine.addLine(start, end, color, color);
        }
        static _getHierarchyPath(rootSprite, checkSprite, path) {
            path.length = 0;
            var sprite = checkSprite;
            while (sprite !== rootSprite) {
                var parent = sprite._parent;
                if (parent)
                    path.push(parent.getChildIndex(sprite));
                else
                    return null;
                sprite = parent;
            }
            return path;
        }
        static _getNodeByHierarchyPath(rootSprite, invPath) {
            var sprite = rootSprite;
            for (var i = invPath.length - 1; i >= 0; i--) {
                sprite = sprite.getChildAt(invPath[i]);
            }
            return sprite;
        }
        static _getParentNodeByHierarchyPath(rootSprite, path) {
            let pathlength = path.length;
            let node = rootSprite;
            for (let i = 0; i < pathlength; i++) {
                if (node)
                    node = rootSprite.parent;
                else
                    return null;
            }
            return node;
        }
        static uint8ArrayToArrayBuffer(rendertexture) {
            let pixelArray;
            let width = rendertexture.width;
            let height = rendertexture.height;
            switch (rendertexture.colorFormat) {
                case Laya.RenderTargetFormat.R8G8B8:
                    pixelArray = new Uint8Array(width * height * 4);
                    break;
                case Laya.RenderTargetFormat.R8G8B8A8:
                    pixelArray = new Uint8Array(width * height * 4);
                    break;
                case Laya.RenderTargetFormat.R16G16B16A16:
                    pixelArray = new Float32Array(width * height * 4);
                    break;
                default:
                    throw "this function is not surpprt " + rendertexture.format.toString() + "format Material";
            }
            rendertexture.getData(0, 0, rendertexture.width, rendertexture.height, pixelArray);
            switch (rendertexture.colorFormat) {
                case Laya.RenderTargetFormat.R16G16B16A16:
                    let ori = pixelArray;
                    let trans = new Uint8Array(width * height * 4);
                    for (let i = 0, n = ori.length; i < n; i++) {
                        trans[i] = Math.min(Math.floor(ori[i] * 255), 255);
                    }
                    pixelArray = trans;
                    break;
            }
            let pixels = pixelArray;
            var bs;
            if (Laya.LayaEnv.isConch) ;
            else {
                var canv = new Laya.HTMLCanvas(true);
                canv.lock = true;
                canv.size(width, height);
                var ctx2d = canv.getContext('2d');
                var imgdata = ctx2d.createImageData(width, height);
                imgdata.data.set(new Uint8ClampedArray(pixels));
                ctx2d.putImageData(imgdata, 0, 0);
                bs = canv.source.toDataURL();
                canv.destroy();
            }
            return bs;
        }
    }
    Utils3D._tempVector3_0 = new Laya.Vector3();
    Utils3D._tempVector3_1 = new Laya.Vector3();
    Utils3D._tempArray16_0 = new Float32Array(16);
    Utils3D._tempArray16_1 = new Float32Array(16);
    Utils3D._tempArray16_2 = new Float32Array(16);
    Utils3D._tempArray16_3 = new Float32Array(16);
    Utils3D._compIdToNode = new Object();
    window.getRTBase64 = Utils3D.uint8ArrayToArrayBuffer;
    const TEMPVector30 = new Laya.Vector3();

    class Transform3D extends Laya.EventDispatcher {
        constructor(owner) {
            super();
            this._localPosition = new Laya.Vector3(0, 0, 0);
            this._localRotation = new Laya.Quaternion(0, 0, 0, 1);
            this._localScale = new Laya.Vector3(1, 1, 1);
            this._localRotationEuler = new Laya.Vector3(0, 0, 0);
            this._localMatrix = new Laya.Matrix4x4();
            this._position = new Laya.Vector3(0, 0, 0);
            this._rotation = new Laya.Quaternion(0, 0, 0, 1);
            this._scale = new Laya.Vector3(1, 1, 1);
            this._rotationEuler = new Laya.Vector3(0, 0, 0);
            this._worldMatrix = new Laya.Matrix4x4();
            this._children = null;
            this._isDefaultMatrix = false;
            this._parent = null;
            this._transformFlag = 0;
            this._owner = owner;
            this._children = [];
            this._setTransformFlag(Transform3D.TRANSFORM_LOCALQUATERNION | Transform3D.TRANSFORM_LOCALEULER | Transform3D.TRANSFORM_LOCALMATRIX, false);
            this._setTransformFlag(Transform3D.TRANSFORM_WORLDPOSITION | Transform3D.TRANSFORM_WORLDQUATERNION | Transform3D.TRANSFORM_WORLDEULER | Transform3D.TRANSFORM_WORLDSCALE | Transform3D.TRANSFORM_WORLDMATRIX, true);
        }
        get isDefaultMatrix() {
            if (this._getTransformFlag(Transform3D.TRANSFORM_LOCALMATRIX)) {
                this.localMatrix;
            }
            return this._isDefaultMatrix;
        }
        get _isFrontFaceInvert() {
            var scale = this.getWorldLossyScale();
            var isInvert = scale.x < 0;
            (scale.y < 0) && (isInvert = !isInvert);
            (scale.z < 0) && (isInvert = !isInvert);
            return isInvert;
        }
        get owner() {
            return this._owner;
        }
        get worldNeedUpdate() {
            return this._getTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX);
        }
        get localPositionX() {
            return this._localPosition.x;
        }
        set localPositionX(x) {
            this._localPosition.x = x;
            this.localPosition = this._localPosition;
        }
        get localPositionY() {
            return this._localPosition.y;
        }
        set localPositionY(y) {
            this._localPosition.y = y;
            this.localPosition = this._localPosition;
        }
        get localPositionZ() {
            return this._localPosition.z;
        }
        set localPositionZ(z) {
            this._localPosition.z = z;
            this.localPosition = this._localPosition;
        }
        get localPosition() {
            return this._localPosition;
        }
        set localPosition(value) {
            if (this._localPosition !== value)
                value.cloneTo(this._localPosition);
            this._setTransformFlag(Transform3D.TRANSFORM_LOCALMATRIX, true);
            this._onWorldPositionTransform();
        }
        get localRotationX() {
            return this.localRotation.x;
        }
        set localRotationX(x) {
            let rot = this.localRotation;
            rot.x = x;
            this.localRotation = rot;
        }
        get localRotationY() {
            return this.localRotation.y;
        }
        set localRotationY(y) {
            let rot = this.localRotation;
            rot.y = y;
            this.localRotation = rot;
        }
        get localRotationZ() {
            return this.localRotation.z;
        }
        set localRotationZ(z) {
            let rot = this.localRotation;
            rot.z = z;
            this.localRotation = rot;
        }
        get localRotationW() {
            return this.localRotation.w;
        }
        set localRotationW(w) {
            let rot = this.localRotation;
            rot.w = w;
            this.localRotation = rot;
        }
        get localRotation() {
            if (this._getTransformFlag(Transform3D.TRANSFORM_LOCALQUATERNION)) {
                var eulerE = this._localRotationEuler;
                Laya.Quaternion.createFromYawPitchRoll(eulerE.y / Transform3D._angleToRandin, eulerE.x / Transform3D._angleToRandin, eulerE.z / Transform3D._angleToRandin, this._localRotation);
                this._setTransformFlag(Transform3D.TRANSFORM_LOCALQUATERNION, false);
            }
            return this._localRotation;
        }
        set localRotation(value) {
            if (this._localRotation !== value)
                value.cloneTo(this._localRotation);
            this._localRotation.normalize(this._localRotation);
            this._setTransformFlag(Transform3D.TRANSFORM_LOCALEULER | Transform3D.TRANSFORM_LOCALMATRIX, true);
            this._setTransformFlag(Transform3D.TRANSFORM_LOCALQUATERNION, false);
            this._onWorldRotationTransform();
        }
        get localScaleX() {
            return this._localScale.x;
        }
        set localScaleX(value) {
            this._localScale.x = value;
            this.localScale = this._localScale;
        }
        get localScaleY() {
            return this._localScale.y;
        }
        set localScaleY(value) {
            this._localScale.y = value;
            this.localScale = this._localScale;
        }
        get localScaleZ() {
            return this._localScale.z;
        }
        set localScaleZ(value) {
            this._localScale.z = value;
            this.localScale = this._localScale;
        }
        get localScale() {
            return this._localScale;
        }
        set localScale(value) {
            if (this._localScale !== value)
                value.cloneTo(this._localScale);
            this._setTransformFlag(Transform3D.TRANSFORM_LOCALMATRIX, true);
            this._onWorldScaleTransform();
        }
        get localRotationEulerX() {
            return this.localRotationEuler.x;
        }
        set localRotationEulerX(value) {
            let rot = this.localRotationEuler;
            rot.x = value;
            this.localRotationEuler = rot;
        }
        get localRotationEulerY() {
            return this.localRotationEuler.y;
        }
        set localRotationEulerY(value) {
            let rot = this.localRotationEuler;
            rot.y = value;
            this.localRotationEuler = rot;
        }
        get localRotationEulerZ() {
            return this.localRotationEuler.z;
        }
        set localRotationEulerZ(value) {
            let rot = this.localRotationEuler;
            rot.z = value;
            this.localRotationEuler = rot;
        }
        get localRotationEuler() {
            if (this._getTransformFlag(Transform3D.TRANSFORM_LOCALEULER)) {
                this._localRotation.getYawPitchRoll(Transform3D._tempVector30);
                var euler = Transform3D._tempVector30;
                var localRotationEuler = this._localRotationEuler;
                localRotationEuler.x = euler.y * Transform3D._angleToRandin;
                localRotationEuler.y = euler.x * Transform3D._angleToRandin;
                localRotationEuler.z = euler.z * Transform3D._angleToRandin;
                this._setTransformFlag(Transform3D.TRANSFORM_LOCALEULER, false);
            }
            return this._localRotationEuler;
        }
        set localRotationEuler(value) {
            if (this._localRotationEuler !== value)
                value.cloneTo(this._localRotationEuler);
            this._setTransformFlag(Transform3D.TRANSFORM_LOCALEULER, false);
            this._setTransformFlag(Transform3D.TRANSFORM_LOCALQUATERNION | Transform3D.TRANSFORM_LOCALMATRIX, true);
            this._onWorldRotationTransform();
        }
        get localMatrix() {
            if (this._getTransformFlag(Transform3D.TRANSFORM_LOCALMATRIX)) {
                Laya.Matrix4x4.createAffineTransformation(this._localPosition, this.localRotation, this._localScale, this._localMatrix);
                this._isDefaultMatrix = this._localMatrix.isIdentity();
                this._setTransformFlag(Transform3D.TRANSFORM_LOCALMATRIX, false);
            }
            return this._localMatrix;
        }
        set localMatrix(value) {
            if (this._localMatrix !== value)
                value.cloneTo(this._localMatrix);
            this._isDefaultMatrix = this._localMatrix.isIdentity();
            this._localMatrix.decomposeTransRotScale(this._localPosition, this._localRotation, this._localScale);
            this._setTransformFlag(Transform3D.TRANSFORM_LOCALEULER, true);
            this._setTransformFlag(Transform3D.TRANSFORM_LOCALMATRIX, false);
            this._onWorldTransform();
        }
        get position() {
            if (this._getTransformFlag(Transform3D.TRANSFORM_WORLDPOSITION)) {
                if (this._parent != null) {
                    var worldMatE = this.worldMatrix.elements;
                    this._position.x = worldMatE[12];
                    this._position.y = worldMatE[13];
                    this._position.z = worldMatE[14];
                }
                else {
                    this._localPosition.cloneTo(this._position);
                }
                this._setTransformFlag(Transform3D.TRANSFORM_WORLDPOSITION, false);
            }
            return this._position;
        }
        set position(value) {
            if (this._parent != null) {
                var parentInvMat = Transform3D._tempMatrix0;
                this._parent.worldMatrix.invert(parentInvMat);
                Laya.Vector3.transformCoordinate(value, parentInvMat, this._localPosition);
            }
            else {
                value.cloneTo(this._localPosition);
            }
            this.localPosition = this._localPosition;
            if (this._position !== value)
                value.cloneTo(this._position);
            this._setTransformFlag(Transform3D.TRANSFORM_WORLDPOSITION, false);
        }
        get rotation() {
            if (this._getTransformFlag(Transform3D.TRANSFORM_WORLDQUATERNION)) {
                if (this._parent != null)
                    Laya.Quaternion.multiply(this._parent.rotation, this.localRotation, this._rotation);
                else
                    this.localRotation.cloneTo(this._rotation);
                this._setTransformFlag(Transform3D.TRANSFORM_WORLDQUATERNION, false);
            }
            return this._rotation;
        }
        set rotation(value) {
            if (this._parent != null) {
                this._parent.rotation.invert(Transform3D._tempQuaternion0);
                Laya.Quaternion.multiply(Transform3D._tempQuaternion0, value, this._localRotation);
            }
            else {
                value.cloneTo(this._localRotation);
            }
            this.localRotation = this._localRotation;
            if (value !== this._rotation)
                value.cloneTo(this._rotation);
            this._setTransformFlag(Transform3D.TRANSFORM_WORLDQUATERNION, false);
        }
        get rotationEuler() {
            if (this._getTransformFlag(Transform3D.TRANSFORM_WORLDEULER)) {
                this.rotation.getYawPitchRoll(Transform3D._tempVector30);
                var eulerE = Transform3D._tempVector30;
                var rotationEulerE = this._rotationEuler;
                rotationEulerE.x = eulerE.y * Transform3D._angleToRandin;
                rotationEulerE.y = eulerE.x * Transform3D._angleToRandin;
                rotationEulerE.z = eulerE.z * Transform3D._angleToRandin;
                this._setTransformFlag(Transform3D.TRANSFORM_WORLDEULER, false);
            }
            return this._rotationEuler;
        }
        set rotationEuler(value) {
            Laya.Quaternion.createFromYawPitchRoll(value.y / Transform3D._angleToRandin, value.x / Transform3D._angleToRandin, value.z / Transform3D._angleToRandin, this._rotation);
            this.rotation = this._rotation;
            if (this._rotationEuler !== value)
                value.cloneTo(this._rotationEuler);
            this._setTransformFlag(Transform3D.TRANSFORM_WORLDEULER, false);
        }
        get worldMatrix() {
            if (this._getTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX)) {
                if (this._parent != null) {
                    let effectiveTrans = this._parent;
                    while (effectiveTrans._parent && effectiveTrans.isDefaultMatrix) {
                        effectiveTrans = effectiveTrans._parent;
                    }
                    Laya.Matrix4x4.multiply(effectiveTrans.worldMatrix, this.localMatrix, this._worldMatrix);
                }
                else
                    this.localMatrix.cloneTo(this._worldMatrix);
                this._setTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX, false);
            }
            return this._worldMatrix;
        }
        set worldMatrix(value) {
            if (this._parent === null) {
                value.cloneTo(this._localMatrix);
            }
            else {
                this._parent.worldMatrix.invert(this._localMatrix);
                Laya.Matrix4x4.multiply(this._localMatrix, value, this._localMatrix);
            }
            this.localMatrix = this._localMatrix;
            if (this._worldMatrix !== value)
                value.cloneTo(this._worldMatrix);
            this._setTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX, false);
        }
        _getScaleMatrix() {
            var invRotation = Transform3D._tempQuaternion0;
            var invRotationMat = Transform3D._tempMatrix3x30;
            var worldRotScaMat = Transform3D._tempMatrix3x31;
            var scaMat = Transform3D._tempMatrix3x32;
            Laya.Matrix3x3.createFromMatrix4x4(this.worldMatrix, worldRotScaMat);
            this.rotation.invert(invRotation);
            Laya.Matrix3x3.createRotationQuaternion(invRotation, invRotationMat);
            Laya.Matrix3x3.multiply(invRotationMat, worldRotScaMat, scaMat);
            return scaMat;
        }
        _setTransformFlag(type, value) {
            if (value)
                this._transformFlag |= type;
            else
                this._transformFlag &= ~type;
        }
        _getTransformFlag(type) {
            return (this._transformFlag & type) != 0;
        }
        _setParent(value) {
            if (this._parent !== value) {
                if (this._parent) {
                    var parentChilds = this._parent._children;
                    var index = parentChilds.indexOf(this);
                    parentChilds.splice(index, 1);
                }
                if (value) {
                    value._children.push(this);
                    (value) && (this._onWorldTransform());
                }
                this._parent = value;
            }
        }
        _onWorldPositionRotationTransform() {
            if (!this._getTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX) || !this._getTransformFlag(Transform3D.TRANSFORM_WORLDPOSITION) || !this._getTransformFlag(Transform3D.TRANSFORM_WORLDQUATERNION) || !this._getTransformFlag(Transform3D.TRANSFORM_WORLDEULER)) {
                this._setTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX | Transform3D.TRANSFORM_WORLDPOSITION | Transform3D.TRANSFORM_WORLDQUATERNION | Transform3D.TRANSFORM_WORLDEULER, true);
                this.event(Laya.Event.TRANSFORM_CHANGED, this._transformFlag);
            }
            for (var i = 0, n = this._children.length; i < n; i++)
                this._children[i]._onWorldPositionRotationTransform();
        }
        _onWorldPositionScaleTransform() {
            if (!this._getTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX) || !this._getTransformFlag(Transform3D.TRANSFORM_WORLDPOSITION) || !this._getTransformFlag(Transform3D.TRANSFORM_WORLDSCALE)) {
                this._setTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX | Transform3D.TRANSFORM_WORLDPOSITION | Transform3D.TRANSFORM_WORLDSCALE, true);
                this.event(Laya.Event.TRANSFORM_CHANGED, this._transformFlag);
            }
            for (var i = 0, n = this._children.length; i < n; i++)
                this._children[i]._onWorldPositionScaleTransform();
        }
        _onWorldPositionTransform() {
            if (!this._getTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX) || !this._getTransformFlag(Transform3D.TRANSFORM_WORLDPOSITION)) {
                this._setTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX | Transform3D.TRANSFORM_WORLDPOSITION, true);
                this.event(Laya.Event.TRANSFORM_CHANGED, this._transformFlag);
            }
            for (var i = 0, n = this._children.length; i < n; i++)
                this._children[i]._onWorldPositionTransform();
        }
        _onWorldRotationTransform() {
            if (!this._getTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX) || !this._getTransformFlag(Transform3D.TRANSFORM_WORLDQUATERNION) || !this._getTransformFlag(Transform3D.TRANSFORM_WORLDEULER)) {
                this._setTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX | Transform3D.TRANSFORM_WORLDQUATERNION | Transform3D.TRANSFORM_WORLDEULER, true);
                this.event(Laya.Event.TRANSFORM_CHANGED, this._transformFlag);
            }
            for (var i = 0, n = this._children.length; i < n; i++)
                this._children[i]._onWorldPositionRotationTransform();
        }
        _onWorldScaleTransform() {
            if (!this._getTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX) || !this._getTransformFlag(Transform3D.TRANSFORM_WORLDSCALE)) {
                this._setTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX | Transform3D.TRANSFORM_WORLDSCALE, true);
                this.event(Laya.Event.TRANSFORM_CHANGED, this._transformFlag);
            }
            for (var i = 0, n = this._children.length; i < n; i++)
                this._children[i]._onWorldPositionScaleTransform();
        }
        _onWorldTransform() {
            if (!this._getTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX) || !this._getTransformFlag(Transform3D.TRANSFORM_WORLDPOSITION) || !this._getTransformFlag(Transform3D.TRANSFORM_WORLDQUATERNION) || !this._getTransformFlag(Transform3D.TRANSFORM_WORLDEULER) || !this._getTransformFlag(Transform3D.TRANSFORM_WORLDSCALE)) {
                this._setTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX | Transform3D.TRANSFORM_WORLDPOSITION | Transform3D.TRANSFORM_WORLDQUATERNION | Transform3D.TRANSFORM_WORLDEULER | Transform3D.TRANSFORM_WORLDSCALE, true);
                this.event(Laya.Event.TRANSFORM_CHANGED, this._transformFlag);
            }
            for (var i = 0, n = this._children.length; i < n; i++)
                this._children[i]._onWorldTransform();
        }
        translate(translation, isLocal = true) {
            if (isLocal) {
                Laya.Matrix4x4.createFromQuaternion(this.localRotation, Transform3D._tempMatrix0);
                Laya.Vector3.transformCoordinate(translation, Transform3D._tempMatrix0, Transform3D._tempVector30);
                Laya.Vector3.add(this.localPosition, Transform3D._tempVector30, this._localPosition);
                this.localPosition = this._localPosition;
            }
            else {
                Laya.Vector3.add(this.position, translation, this._position);
                this.position = this._position;
            }
        }
        rotate(rotation, isLocal = true, isRadian = true) {
            var rot;
            if (isRadian) {
                rot = rotation;
            }
            else {
                Laya.Vector3.scale(rotation, Math.PI / 180.0, Transform3D._tempVector30);
                rot = Transform3D._tempVector30;
            }
            Laya.Quaternion.createFromYawPitchRoll(rot.y, rot.x, rot.z, Transform3D._tempQuaternion0);
            if (isLocal) {
                Laya.Quaternion.multiply(this._localRotation, Transform3D._tempQuaternion0, this._localRotation);
                this.localRotation = this._localRotation;
            }
            else {
                Laya.Quaternion.multiply(Transform3D._tempQuaternion0, this.rotation, this._rotation);
                this.rotation = this._rotation;
            }
        }
        getForward(forward) {
            var worldMatElem = this.worldMatrix.elements;
            forward.x = -worldMatElem[8];
            forward.y = -worldMatElem[9];
            forward.z = -worldMatElem[10];
        }
        getUp(up) {
            var worldMatElem = this.worldMatrix.elements;
            up.x = worldMatElem[4];
            up.y = worldMatElem[5];
            up.z = worldMatElem[6];
        }
        getRight(right) {
            var worldMatElem = this.worldMatrix.elements;
            right.x = worldMatElem[0];
            right.y = worldMatElem[1];
            right.z = worldMatElem[2];
        }
        lookAt(target, up, isLocal = false, isCamera = true) {
            var eye;
            if (isLocal) {
                eye = this._localPosition;
                if (Math.abs(eye.x - target.x) < Laya.MathUtils3D.zeroTolerance && Math.abs(eye.y - target.y) < Laya.MathUtils3D.zeroTolerance && Math.abs(eye.z - target.z) < Laya.MathUtils3D.zeroTolerance)
                    return;
                if (isCamera) {
                    Laya.Quaternion.lookAt(this._localPosition, target, up, this._localRotation);
                    this._localRotation.invert(this._localRotation);
                }
                else {
                    Laya.Vector3.subtract(this.localPosition, target, Transform3D._tempVector30);
                    Laya.Quaternion.rotationLookAt(Transform3D._tempVector30, up, this.localRotation);
                    this._localRotation.invert(this._localRotation);
                }
                this.localRotation = this._localRotation;
            }
            else {
                var worldPosition = this.position;
                eye = worldPosition;
                if (Math.abs(eye.x - target.x) < Laya.MathUtils3D.zeroTolerance && Math.abs(eye.y - target.y) < Laya.MathUtils3D.zeroTolerance && Math.abs(eye.z - target.z) < Laya.MathUtils3D.zeroTolerance)
                    return;
                if (isCamera) {
                    Laya.Quaternion.lookAt(worldPosition, target, up, this._rotation);
                    this._rotation.invert(this._rotation);
                }
                else {
                    Laya.Vector3.subtract(this.position, target, Transform3D._tempVector30);
                    Laya.Quaternion.rotationLookAt(Transform3D._tempVector30, up, this._rotation);
                    this._rotation.invert(this._rotation);
                }
                this.rotation = this._rotation;
            }
        }
        objLookat(target, up, isLocal = false) {
        }
        getWorldLossyScale() {
            if (this._getTransformFlag(Transform3D.TRANSFORM_WORLDSCALE)) {
                if (this._parent !== null) {
                    var scaMatE = this._getScaleMatrix().elements;
                    this._scale.x = scaMatE[0];
                    this._scale.y = scaMatE[4];
                    this._scale.z = scaMatE[8];
                }
                else {
                    this._localScale.cloneTo(this._scale);
                }
                this._setTransformFlag(Transform3D.TRANSFORM_WORLDSCALE, false);
            }
            return this._scale;
        }
        setWorldLossyScale(value) {
            if (this._parent !== null) {
                var scaleMat = Transform3D._tempMatrix3x33;
                var localScaleMat = Transform3D._tempMatrix3x33;
                var localScaleMatE = localScaleMat.elements;
                var parInvScaleMat = this._parent._getScaleMatrix();
                parInvScaleMat.invert(parInvScaleMat);
                Laya.Matrix3x3.createFromScaling(value, scaleMat);
                Laya.Matrix3x3.multiply(parInvScaleMat, scaleMat, localScaleMat);
                this._localScale.x = localScaleMatE[0];
                this._localScale.y = localScaleMatE[4];
                this._localScale.z = localScaleMatE[8];
            }
            else {
                value.cloneTo(this._localScale);
            }
            this.localScale = this._localScale;
            if (this._scale !== value)
                value.cloneTo(this._scale);
            this._setTransformFlag(Transform3D.TRANSFORM_WORLDSCALE, false);
        }
        get scale() {
            console.warn("Transfrm3D: discard function,please use getWorldLossyScale instead.");
            return this.getWorldLossyScale();
        }
        set scale(value) {
            console.warn("Transfrm3D: discard function,please use setWorldLossyScale instead.");
            this.setWorldLossyScale(value);
        }
        localToGlobal(value, out) {
            Laya.Vector3.transformV3ToV3(value, this.worldMatrix, out);
        }
        globalToLocal(pos, out) {
            this.worldMatrix.invert(Transform3D._tempMatrix0);
            Laya.Vector3.transformV3ToV3(pos, Transform3D._tempMatrix0, out);
        }
        toLocalNormal(pos, out) {
            this.worldMatrix.invert(Transform3D._tempMatrix0);
            Laya.Vector3.TransformNormal(pos, Transform3D._tempMatrix0, out);
        }
        toDir(forward, dir) {
            this.worldMatrix;
            this.rotationTo(this.rotation, forward, dir);
            this.rotation = this.rotation;
        }
        rotationTo(out, a, b) {
            var dot = Laya.Vector3.dot(a, b);
            Laya.Vector3.Up;
            if (dot < -0.999999) {
                Laya.Vector3.cross(Laya.Vector3.UnitX, a, Transform3D.tmpVec3);
                if (Laya.Vector3.scalarLength(Transform3D.tmpVec3) < 0.000001)
                    Laya.Vector3.cross(Laya.Vector3.UnitY, a, Transform3D.tmpVec3);
                Laya.Vector3.normalize(Transform3D.tmpVec3, Transform3D.tmpVec3);
                Laya.Quaternion.createFromAxisAngle(Transform3D.tmpVec3, Math.PI, out);
                return true;
            }
            else if (dot > 0.999999) {
                out.x = 0;
                out.y = 0;
                out.z = 0;
                out.w = 1;
                return false;
            }
            else {
                Laya.Vector3.cross(a, b, Transform3D.tmpVec3);
                out.x = Transform3D.tmpVec3.x;
                out.y = Transform3D.tmpVec3.y;
                out.z = Transform3D.tmpVec3.z;
                out.w = 1 + dot;
                out.normalize(out);
                return true;
            }
        }
    }
    Transform3D._tempVector30 = new Laya.Vector3();
    Transform3D._tempQuaternion0 = new Laya.Quaternion();
    Transform3D._tempMatrix0 = new Laya.Matrix4x4();
    Transform3D._tempMatrix3x30 = new Laya.Matrix3x3();
    Transform3D._tempMatrix3x31 = new Laya.Matrix3x3();
    Transform3D._tempMatrix3x32 = new Laya.Matrix3x3();
    Transform3D._tempMatrix3x33 = new Laya.Matrix3x3();
    Transform3D.TRANSFORM_LOCALQUATERNION = 0x01;
    Transform3D.TRANSFORM_LOCALEULER = 0x02;
    Transform3D.TRANSFORM_LOCALMATRIX = 0x04;
    Transform3D.TRANSFORM_WORLDPOSITION = 0x08;
    Transform3D.TRANSFORM_WORLDQUATERNION = 0x10;
    Transform3D.TRANSFORM_WORLDSCALE = 0x20;
    Transform3D.TRANSFORM_WORLDMATRIX = 0x40;
    Transform3D.TRANSFORM_WORLDEULER = 0x80;
    Transform3D._angleToRandin = 180 / Math.PI;
    Transform3D.tmpVec3 = new Laya.Vector3();

    class ColliderShape {
        constructor() {
            this._scale = new Laya.Vector3(1, 1, 1);
            this._centerMatrix = new Laya.Matrix4x4();
            this._attatched = false;
            this._indexInCompound = -1;
            this._compoundParent = null;
            this._attatchedCollisionObject = null;
            this._referenceCount = 0;
            this._localOffset = new Laya.Vector3(0, 0, 0);
            this._localRotation = new Laya.Quaternion(0, 0, 0, 1);
            this.needsCustomCollisionCallback = false;
        }
        static __init__() {
            var bt = ILaya3D.Physics3D._bullet;
            ColliderShape._btScale = bt.btVector3_create(1, 1, 1);
            ColliderShape._btVector30 = bt.btVector3_create(0, 0, 0);
            ColliderShape._btQuaternion0 = bt.btQuaternion_create(0, 0, 0, 1);
            ColliderShape._btTransform0 = bt.btTransform_create();
        }
        static _createAffineTransformation(trans, rot, outE) {
            var x = rot.x, y = rot.y, z = rot.z, w = rot.w, x2 = x + x, y2 = y + y, z2 = z + z;
            var xx = x * x2, xy = x * y2, xz = x * z2, yy = y * y2, yz = y * z2, zz = z * z2;
            var wx = w * x2, wy = w * y2, wz = w * z2;
            outE[0] = (1 - (yy + zz));
            outE[1] = (xy + wz);
            outE[2] = (xz - wy);
            outE[3] = 0;
            outE[4] = (xy - wz);
            outE[5] = (1 - (xx + zz));
            outE[6] = (yz + wx);
            outE[7] = 0;
            outE[8] = (xz + wy);
            outE[9] = (yz - wx);
            outE[10] = (1 - (xx + yy));
            outE[11] = 0;
            outE[12] = trans.x;
            outE[13] = trans.y;
            outE[14] = trans.z;
            outE[15] = 1;
        }
        get type() {
            return this._type;
        }
        get localOffset() {
            return this._localOffset;
        }
        set localOffset(value) {
            this._localOffset = value;
            if (this._compoundParent)
                this._compoundParent._updateChildTransform(this);
        }
        get localRotation() {
            return this._localRotation;
        }
        set localRotation(value) {
            this._localRotation = value;
            if (this._compoundParent)
                this._compoundParent._updateChildTransform(this);
        }
        _setScale(value) {
            if (this._compoundParent) {
                this.updateLocalTransformations();
            }
            else {
                var bt = ILaya3D.Physics3D._bullet;
                bt.btVector3_setValue(ColliderShape._btScale, value.x, value.y, value.z);
                bt.btCollisionShape_setLocalScaling(this._btShape, ColliderShape._btScale);
            }
        }
        updateLocalTransformations() {
            if (this._compoundParent) {
                var offset = ColliderShape._tempVector30;
                Laya.Vector3.multiply(this.localOffset, this._scale, offset);
                ColliderShape._createAffineTransformation(offset, this.localRotation, this._centerMatrix.elements);
            }
            else {
                ColliderShape._createAffineTransformation(this.localOffset, this.localRotation, this._centerMatrix.elements);
            }
        }
        cloneTo(destObject) {
            var destColliderShape = destObject;
            this._localOffset.cloneTo(destColliderShape.localOffset);
            this._localRotation.cloneTo(destColliderShape.localRotation);
            destColliderShape.localOffset = destColliderShape.localOffset;
            destColliderShape.localRotation = destColliderShape.localRotation;
        }
        clone() {
            return null;
        }
        destroy() {
            if (this._btShape) {
                ILaya3D.Physics3D._bullet.btCollisionShape_destroy(this._btShape);
                this._btShape = null;
            }
        }
    }
    ColliderShape.SHAPEORIENTATION_UPX = 0;
    ColliderShape.SHAPEORIENTATION_UPY = 1;
    ColliderShape.SHAPEORIENTATION_UPZ = 2;
    ColliderShape.SHAPETYPES_BOX = 0;
    ColliderShape.SHAPETYPES_SPHERE = 1;
    ColliderShape.SHAPETYPES_CYLINDER = 2;
    ColliderShape.SHAPETYPES_CAPSULE = 3;
    ColliderShape.SHAPETYPES_CONVEXHULL = 4;
    ColliderShape.SHAPETYPES_COMPOUND = 5;
    ColliderShape.SHAPETYPES_STATICPLANE = 6;
    ColliderShape.SHAPETYPES_CONE = 7;
    ColliderShape.SHAPETYPES_HEIGHTFIELDTERRAIN = 8;
    ColliderShape._tempVector30 = new Laya.Vector3();

    class BoxColliderShape extends ColliderShape {
        constructor(sizeX = 1.0, sizeY = 1.0, sizeZ = 1.0) {
            super();
            this._sizeX = sizeX;
            this._sizeY = sizeY;
            this._sizeZ = sizeZ;
            this._type = ColliderShape.SHAPETYPES_BOX;
            var bt = ILaya3D.Physics3D._bullet;
            bt.btVector3_setValue(BoxColliderShape._btSize, sizeX / 2, sizeY / 2, sizeZ / 2);
            this._btShape = bt.btBoxShape_create(BoxColliderShape._btSize);
        }
        static __init__() {
            BoxColliderShape._btSize = ILaya3D.Physics3D._bullet.btVector3_create(0, 0, 0);
        }
        get sizeX() {
            return this._sizeX;
        }
        set sizeX(value) {
            this._sizeX = value;
            if (Laya.LayaEnv.isPlaying) {
                this.changeBoxShape();
            }
        }
        get sizeY() {
            return this._sizeY;
        }
        set sizeY(value) {
            this._sizeY = value;
            if (Laya.LayaEnv.isPlaying) {
                this.changeBoxShape();
            }
        }
        get sizeZ() {
            return this._sizeZ;
        }
        set sizeZ(value) {
            this._sizeZ = value;
            if (Laya.LayaEnv.isPlaying) {
                this.changeBoxShape();
            }
        }
        changeBoxShape() {
            var bt = ILaya3D.Physics3D._bullet;
            if (this._btShape) {
                bt.btCollisionShape_destroy(this._btShape);
            }
            bt.btVector3_setValue(BoxColliderShape._btSize, this._sizeX / 2, this._sizeY / 2, this._sizeZ / 2);
            this._btShape = bt.btBoxShape_create(BoxColliderShape._btSize);
        }
        clone() {
            var dest = new BoxColliderShape(this._sizeX, this._sizeY, this._sizeZ);
            this.cloneTo(dest);
            return dest;
        }
    }

    class CapsuleColliderShape extends ColliderShape {
        constructor(radius = 0.5, length = 2, orientation = ColliderShape.SHAPEORIENTATION_UPY) {
            super();
            this._radius = radius;
            this._length = length;
            this._orientation = orientation;
            this._type = ColliderShape.SHAPETYPES_CAPSULE;
            var bt = ILaya3D.Physics3D._bullet;
            switch (orientation) {
                case ColliderShape.SHAPEORIENTATION_UPX:
                    this._btShape = bt.btCapsuleShapeX_create(radius, length - radius * 2);
                    break;
                case ColliderShape.SHAPEORIENTATION_UPY:
                    this._btShape = bt.btCapsuleShape_create(radius, length - radius * 2);
                    break;
                case ColliderShape.SHAPEORIENTATION_UPZ:
                    this._btShape = bt.btCapsuleShapeZ_create(radius, length - radius * 2);
                    break;
                default:
                    throw "CapsuleColliderShape:unknown orientation.";
            }
        }
        get radius() {
            return this._radius;
        }
        set radius(value) {
            this._radius = value;
            if (Laya.LayaEnv.isPlaying) {
                this.changeCapsuleShape();
            }
        }
        get length() {
            return this._length;
        }
        set length(value) {
            this._length = value;
            if (Laya.LayaEnv.isPlaying) {
                this.changeCapsuleShape();
            }
        }
        get orientation() {
            return this._orientation;
        }
        set orientation(value) {
            this._orientation = value;
            if (Laya.LayaEnv.isPlaying) {
                this.changeCapsuleShape();
            }
        }
        changeCapsuleShape() {
            var bt = ILaya3D.Physics3D._bullet;
            if (this._btShape) {
                bt.btCollisionShape_destroy(this._btShape);
            }
            switch (this._orientation) {
                case ColliderShape.SHAPEORIENTATION_UPX:
                    this._btShape = bt.btCapsuleShapeX_create(this._radius, this._length - this._radius * 2);
                    break;
                case ColliderShape.SHAPEORIENTATION_UPY:
                    this._btShape = bt.btCapsuleShape_create(this._radius, this._length - this._radius * 2);
                    break;
                case ColliderShape.SHAPEORIENTATION_UPZ:
                    this._btShape = bt.btCapsuleShapeZ_create(this._radius, this._length - this._radius * 2);
                    break;
                default:
                    throw "CapsuleColliderShape:unknown orientation.";
            }
        }
        _setScale(value) {
            var fixScale = CapsuleColliderShape._tempVector30;
            switch (this.orientation) {
                case ColliderShape.SHAPEORIENTATION_UPX:
                    fixScale.x = value.x;
                    fixScale.y = fixScale.z = Math.max(value.y, value.z);
                    break;
                case ColliderShape.SHAPEORIENTATION_UPY:
                    fixScale.y = value.y;
                    fixScale.x = fixScale.z = Math.max(value.x, value.z);
                    break;
                case ColliderShape.SHAPEORIENTATION_UPZ:
                    fixScale.z = value.z;
                    fixScale.x = fixScale.y = Math.max(value.x, value.y);
                    break;
                default:
                    throw "CapsuleColliderShape:unknown orientation.";
            }
            super._setScale(fixScale);
        }
        clone() {
            var dest = new CapsuleColliderShape(this._radius, this._length, this._orientation);
            this.cloneTo(dest);
            return dest;
        }
    }
    CapsuleColliderShape._tempVector30 = new Laya.Vector3();

    class CompoundColliderShape extends ColliderShape {
        constructor() {
            super();
            this._childColliderShapes = [];
            this._type = ColliderShape.SHAPETYPES_COMPOUND;
            this._btShape = ILaya3D.Physics3D._bullet.btCompoundShape_create();
        }
        static __init__() {
            var bt = ILaya3D.Physics3D._bullet;
            CompoundColliderShape._btVector3One = bt.btVector3_create(1, 1, 1);
            CompoundColliderShape._btTransform = bt.btTransform_create();
            CompoundColliderShape._btOffset = bt.btVector3_create(0, 0, 0);
            CompoundColliderShape._btRotation = bt.btQuaternion_create(0, 0, 0, 1);
        }
        _clearChildShape(shape) {
            shape._attatched = false;
            shape._compoundParent = null;
            shape._indexInCompound = -1;
        }
        _updateChildTransform(shape) {
            var bt = ILaya3D.Physics3D._bullet;
            var offset = shape.localOffset;
            var rotation = shape.localRotation;
            var btOffset = ColliderShape._btVector30;
            var btQuaternion = ColliderShape._btQuaternion0;
            var btTransform = ColliderShape._btTransform0;
            bt.btVector3_setValue(btOffset, offset.x, offset.y, offset.z);
            bt.btQuaternion_setValue(btQuaternion, rotation.x, rotation.y, rotation.z, rotation.w);
            bt.btTransform_setOrigin(btTransform, btOffset);
            bt.btTransform_setRotation(btTransform, btQuaternion);
            bt.btCompoundShape_updateChildTransform(this._btShape, shape._indexInCompound, btTransform, true);
        }
        set shapes(value) {
            for (var i = this._childColliderShapes.length - 1; i >= 0; i--) {
                this.removeChildShape(this._childColliderShapes[i]);
            }
            for (var i = 0; i < value.length; i++) {
                this.addChildShape(value[i]);
            }
        }
        get shapes() {
            return this._childColliderShapes;
        }
        addChildShape(shape) {
            if (shape._attatched)
                throw "CompoundColliderShape: this shape has attatched to other entity.";
            shape._attatched = true;
            shape._compoundParent = this;
            shape._indexInCompound = this._childColliderShapes.length;
            this._childColliderShapes.push(shape);
            var offset = shape.localOffset;
            var rotation = shape.localRotation;
            var bt = ILaya3D.Physics3D._bullet;
            bt.btVector3_setValue(CompoundColliderShape._btOffset, offset.x, offset.y, offset.z);
            bt.btQuaternion_setValue(CompoundColliderShape._btRotation, rotation.x, rotation.y, rotation.z, rotation.w);
            bt.btTransform_setOrigin(CompoundColliderShape._btTransform, CompoundColliderShape._btOffset);
            bt.btTransform_setRotation(CompoundColliderShape._btTransform, CompoundColliderShape._btRotation);
            var btScale = bt.btCollisionShape_getLocalScaling(this._btShape);
            bt.btCollisionShape_setLocalScaling(this._btShape, CompoundColliderShape._btVector3One);
            bt.btCompoundShape_addChildShape(this._btShape, CompoundColliderShape._btTransform, shape._btShape);
            bt.btCollisionShape_setLocalScaling(this._btShape, btScale);
            (this._attatchedCollisionObject) && (this._attatchedCollisionObject.colliderShape = this);
        }
        removeChildShape(shape) {
            if (shape._compoundParent === this) {
                var index = shape._indexInCompound;
                this._clearChildShape(shape);
                var endShape = this._childColliderShapes[this._childColliderShapes.length - 1];
                endShape._indexInCompound = index;
                this._childColliderShapes[index] = endShape;
                this._childColliderShapes.pop();
                ILaya3D.Physics3D._bullet.btCompoundShape_removeChildShapeByIndex(this._btShape, index);
            }
        }
        clearChildShape() {
            for (var i = 0, n = this._childColliderShapes.length; i < n; i++) {
                this._clearChildShape(this._childColliderShapes[i]);
                ILaya3D.Physics3D._bullet.btCompoundShape_removeChildShapeByIndex(this._btShape, 0);
            }
            this._childColliderShapes.length = 0;
        }
        getChildShapeCount() {
            return this._childColliderShapes.length;
        }
        cloneTo(destObject) {
            var destCompoundColliderShape = destObject;
            destCompoundColliderShape.clearChildShape();
            for (var i = 0, n = this._childColliderShapes.length; i < n; i++)
                destCompoundColliderShape.addChildShape(this._childColliderShapes[i].clone());
        }
        clone() {
            var dest = new CompoundColliderShape();
            this.cloneTo(dest);
            return dest;
        }
        destroy() {
            super.destroy();
            for (var i = 0, n = this._childColliderShapes.length; i < n; i++) {
                var childShape = this._childColliderShapes[i];
                if (childShape._referenceCount === 0)
                    childShape.destroy();
            }
        }
    }

    class ConeColliderShape extends ColliderShape {
        constructor(radius = 0.5, height = 1.0, orientation = ColliderShape.SHAPEORIENTATION_UPY) {
            super();
            this._radius = 1;
            this._height = 0.5;
            this._radius = radius;
            this._height = height;
            this._orientation = orientation;
            this._type = ColliderShape.SHAPETYPES_CYLINDER;
            var bt = ILaya3D.Physics3D._bullet;
            switch (orientation) {
                case ColliderShape.SHAPEORIENTATION_UPX:
                    this._btShape = bt.btConeShapeX_create(radius, height);
                    break;
                case ColliderShape.SHAPEORIENTATION_UPY:
                    this._btShape = bt.btConeShape_create(radius, height);
                    break;
                case ColliderShape.SHAPEORIENTATION_UPZ:
                    this._btShape = bt.btConeShapeZ_create(radius, height);
                    break;
                default:
                    throw "ConeColliderShape:unknown orientation.";
            }
        }
        get radius() {
            return this._radius;
        }
        set radius(value) {
            this._radius = value;
            if (Laya.LayaEnv.isPlaying)
                this.changeConeShape();
        }
        get height() {
            return this._height;
        }
        set height(value) {
            this._height = value;
            if (Laya.LayaEnv.isPlaying)
                this.changeConeShape();
        }
        get orientation() {
            return this._orientation;
        }
        set orientation(value) {
            this._orientation = value;
            if (Laya.LayaEnv.isPlaying)
                this.changeConeShape();
        }
        changeConeShape() {
            var bt = ILaya3D.Physics3D._bullet;
            if (this._btShape) {
                bt.btCollisionShape_destroy(this._btShape);
            }
            switch (this._orientation) {
                case ColliderShape.SHAPEORIENTATION_UPX:
                    this._btShape = bt.btConeShapeX_create(this._radius, this._height);
                    break;
                case ColliderShape.SHAPEORIENTATION_UPY:
                    this._btShape = bt.btConeShape_create(this._radius, this._height);
                    break;
                case ColliderShape.SHAPEORIENTATION_UPZ:
                    this._btShape = bt.btConeShapeZ_create(this._radius, this._height);
                    break;
                default:
                    throw "ConeColliderShape:unknown orientation.";
            }
        }
        clone() {
            var dest = new ConeColliderShape(this._radius, this._height, this._orientation);
            this.cloneTo(dest);
            return dest;
        }
    }

    class CylinderColliderShape extends ColliderShape {
        constructor(radius = 0.5, height = 1.0, orientation = ColliderShape.SHAPEORIENTATION_UPY) {
            super();
            this._radius = 1;
            this._height = 0.5;
            this._radius = radius;
            this._height = height;
            this._orientation = orientation;
            this._type = ColliderShape.SHAPETYPES_CYLINDER;
            var bt = ILaya3D.Physics3D._bullet;
            switch (orientation) {
                case ColliderShape.SHAPEORIENTATION_UPX:
                    bt.btVector3_setValue(CylinderColliderShape._btSize, height / 2, radius, radius);
                    this._btShape = bt.btCylinderShapeX_create(CylinderColliderShape._btSize);
                    break;
                case ColliderShape.SHAPEORIENTATION_UPY:
                    bt.btVector3_setValue(CylinderColliderShape._btSize, radius, height / 2, radius);
                    this._btShape = bt.btCylinderShape_create(CylinderColliderShape._btSize);
                    break;
                case ColliderShape.SHAPEORIENTATION_UPZ:
                    bt.btVector3_setValue(CylinderColliderShape._btSize, radius, radius, height / 2);
                    this._btShape = bt.btCylinderShapeZ_create(CylinderColliderShape._btSize);
                    break;
                default:
                    throw "CapsuleColliderShape:unknown orientation.";
            }
        }
        static __init__() {
            CylinderColliderShape._btSize = ILaya3D.Physics3D._bullet.btVector3_create(0, 0, 0);
        }
        get radius() {
            return this._radius;
        }
        set radius(value) {
            this._radius = value;
            if (Laya.LayaEnv.isPlaying)
                this.changeCylinder();
        }
        get height() {
            return this._height;
        }
        set height(value) {
            this._height = value;
            if (Laya.LayaEnv.isPlaying)
                this.changeCylinder();
        }
        get orientation() {
            return this._orientation;
        }
        set orientation(value) {
            this._orientation = value;
            if (Laya.LayaEnv.isPlaying)
                this.changeCylinder();
        }
        changeCylinder() {
            var bt = ILaya3D.Physics3D._bullet;
            if (this._btShape) {
                bt.btCollisionShape_destroy(this._btShape);
            }
            switch (this._orientation) {
                case ColliderShape.SHAPEORIENTATION_UPX:
                    bt.btVector3_setValue(CylinderColliderShape._btSize, this._height / 2, this._radius, this._radius);
                    this._btShape = bt.btCylinderShapeX_create(CylinderColliderShape._btSize);
                    break;
                case ColliderShape.SHAPEORIENTATION_UPY:
                    bt.btVector3_setValue(CylinderColliderShape._btSize, this._radius, this._height / 2, this._radius);
                    this._btShape = bt.btCylinderShape_create(CylinderColliderShape._btSize);
                    break;
                case ColliderShape.SHAPEORIENTATION_UPZ:
                    bt.btVector3_setValue(CylinderColliderShape._btSize, this._radius, this._radius, this._height / 2);
                    this._btShape = bt.btCylinderShapeZ_create(CylinderColliderShape._btSize);
                    break;
                default:
                    throw "CapsuleColliderShape:unknown orientation.";
            }
        }
        clone() {
            var dest = new CylinderColliderShape(this._radius, this._height, this._orientation);
            this.cloneTo(dest);
            return dest;
        }
    }

    class MeshColliderShape extends ColliderShape {
        constructor() {
            super();
            this._mesh = null;
            this._convex = false;
        }
        get mesh() {
            return this._mesh;
        }
        set mesh(value) {
            if (!value)
                return;
            if (this._mesh !== value) {
                var bt = ILaya3D.Physics3D._bullet;
                this._physicMesh = value._getPhysicMesh();
                if (this._mesh) {
                    bt.btCollisionShape_destroy(this._btShape);
                }
                this._setPhysicsMesh();
                this._mesh = value;
            }
        }
        get convex() {
            return this._convex;
        }
        set convex(value) {
            this._convex = value;
        }
        _setPhysicsMesh() {
            {
                this._createBvhTriangleCollider();
            }
        }
        _createDynamicMeshCollider() {
            var bt = ILaya3D.Physics3D._bullet;
            if (this._physicMesh) {
                this._btShape = bt.btGImpactMeshShape_create(this._physicMesh);
                bt.btGImpactShapeInterface_updateBound(this._btShape);
            }
        }
        _createBvhTriangleCollider() {
            var bt = ILaya3D.Physics3D._bullet;
            if (this._physicMesh)
                this._btShape = bt.btBvhTriangleMeshShape_create(this._physicMesh);
        }
        _setScale(value) {
            if (this._compoundParent) {
                this.updateLocalTransformations();
            }
            else {
                var bt = ILaya3D.Physics3D._bullet;
                bt.btVector3_setValue(ColliderShape._btScale, value.x, value.y, value.z);
                bt.btCollisionShape_setLocalScaling(this._btShape, ColliderShape._btScale);
                if (this._attatchedCollisionObject && this._attatchedCollisionObject._enableProcessCollisions) {
                    bt.btGImpactShapeInterface_updateBound(this._btShape);
                }
            }
        }
        cloneTo(destObject) {
            var destMeshCollider = destObject;
            destMeshCollider.convex = this._convex;
            destMeshCollider.mesh = this._mesh;
            super.cloneTo(destObject);
        }
        clone() {
            var dest = new MeshColliderShape();
            this.cloneTo(dest);
            return dest;
        }
        destroy() {
            if (this._btShape) {
                ILaya3D.Physics3D._bullet.btCollisionShape_destroy(this._btShape);
                this._btShape = null;
            }
        }
    }

    class SphereColliderShape extends ColliderShape {
        constructor(radius = 0.5) {
            super();
            this._radius = radius;
            this._type = ColliderShape.SHAPETYPES_SPHERE;
            this._btShape = ILaya3D.Physics3D._bullet.btSphereShape_create(radius);
        }
        get radius() {
            return this._radius;
        }
        set radius(value) {
            this._radius = value;
            if (Laya.LayaEnv.isPlaying)
                this.changeSphere();
        }
        changeSphere() {
            var bt = ILaya3D.Physics3D._bullet;
            if (this._btShape) {
                bt.btCollisionShape_destroy(this._btShape);
            }
            this._btShape = ILaya3D.Physics3D._bullet.btSphereShape_create(this._radius);
        }
        clone() {
            var dest = new SphereColliderShape(this._radius);
            this.cloneTo(dest);
            return dest;
        }
    }

    class PhysicsComponent extends Laya.Component {
        constructor(collisionGroup, canCollideWith) {
            super();
            this._restitution = 0.0;
            this._friction = 0.5;
            this._rollingFriction = 0.0;
            this._ccdMotionThreshold = 0.0;
            this._ccdSweptSphereRadius = 0.0;
            this._collisionGroup = Physics3DUtils.COLLISIONFILTERGROUP_DEFAULTFILTER;
            this._canCollideWith = Physics3DUtils.COLLISIONFILTERGROUP_ALLFILTER;
            this._colliderShape = null;
            this._transformFlag = 2147483647;
            this._controlBySimulation = false;
            this._enableProcessCollisions = true;
            this._inPhysicUpdateListIndex = -1;
            this.canScaleShape = true;
            this._collisionGroup = collisionGroup;
            this._canCollideWith = canCollideWith;
            PhysicsComponent._physicObjectsMap[this.id] = this;
        }
        static __init__() {
            var bt = ILaya3D.Physics3D._bullet;
            PhysicsComponent._btVector30 = bt.btVector3_create(0, 0, 0);
            PhysicsComponent._btQuaternion0 = bt.btQuaternion_create(0, 0, 0, 1);
        }
        static _createAffineTransformationArray(tranX, tranY, tranZ, rotX, rotY, rotZ, rotW, scale, outE) {
            var x2 = rotX + rotX, y2 = rotY + rotY, z2 = rotZ + rotZ;
            var xx = rotX * x2, xy = rotX * y2, xz = rotX * z2, yy = rotY * y2, yz = rotY * z2, zz = rotZ * z2;
            var wx = rotW * x2, wy = rotW * y2, wz = rotW * z2, sx = scale[0], sy = scale[1], sz = scale[2];
            outE[0] = (1 - (yy + zz)) * sx;
            outE[1] = (xy + wz) * sx;
            outE[2] = (xz - wy) * sx;
            outE[3] = 0;
            outE[4] = (xy - wz) * sy;
            outE[5] = (1 - (xx + zz)) * sy;
            outE[6] = (yz + wx) * sy;
            outE[7] = 0;
            outE[8] = (xz + wy) * sz;
            outE[9] = (yz - wx) * sz;
            outE[10] = (1 - (xx + yy)) * sz;
            outE[11] = 0;
            outE[12] = tranX;
            outE[13] = tranY;
            outE[14] = tranZ;
            outE[15] = 1;
        }
        static _creatShape(shapeData) {
            var colliderShape;
            switch (shapeData.type) {
                case "BoxColliderShape":
                    var sizeData = shapeData.size;
                    colliderShape = sizeData ? new BoxColliderShape(sizeData[0], sizeData[1], sizeData[2]) : new BoxColliderShape();
                    break;
                case "SphereColliderShape":
                    colliderShape = new SphereColliderShape(shapeData.radius);
                    break;
                case "CapsuleColliderShape":
                    colliderShape = new CapsuleColliderShape(shapeData.radius, shapeData.height, shapeData.orientation);
                    break;
                case "MeshColliderShape":
                    var meshCollider = new MeshColliderShape();
                    shapeData.mesh && (meshCollider.mesh = Laya.Loader.getRes(shapeData.mesh));
                    colliderShape = meshCollider;
                    break;
                case "ConeColliderShape":
                    colliderShape = new ConeColliderShape(shapeData.radius, shapeData.height, shapeData.orientation);
                    break;
                case "CylinderColliderShape":
                    colliderShape = new CylinderColliderShape(shapeData.radius, shapeData.height, shapeData.orientation);
                    break;
                default:
                    throw "unknown shape type.";
            }
            if (shapeData.center) {
                var localOffset = colliderShape.localOffset;
                localOffset.fromArray(shapeData.center);
                colliderShape.localOffset = localOffset;
            }
            return colliderShape;
        }
        static physicVector3TransformQuat(source, qx, qy, qz, qw, out) {
            var x = source.x, y = source.y, z = source.z, ix = qw * x + qy * z - qz * y, iy = qw * y + qz * x - qx * z, iz = qw * z + qx * y - qy * x, iw = -qx * x - qy * y - qz * z;
            out.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
            out.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
            out.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
        }
        static physicQuaternionMultiply(lx, ly, lz, lw, right, out) {
            var rx = right.x;
            var ry = right.y;
            var rz = right.z;
            var rw = right.w;
            var a = (ly * rz - lz * ry);
            var b = (lz * rx - lx * rz);
            var c = (lx * ry - ly * rx);
            var d = (lx * rx + ly * ry + lz * rz);
            out.x = (lx * rw + rx * lw) + a;
            out.y = (ly * rw + ry * lw) + b;
            out.z = (lz * rw + rz * lw) + c;
            out.w = lw * rw - d;
        }
        get restitution() {
            return this._restitution;
        }
        set restitution(value) {
            this._restitution = value;
            this._btColliderObject && ILaya3D.Physics3D._bullet.btCollisionObject_setRestitution(this._btColliderObject, value);
        }
        get friction() {
            return this._friction;
        }
        set friction(value) {
            this._friction = value;
            this._btColliderObject && ILaya3D.Physics3D._bullet.btCollisionObject_setFriction(this._btColliderObject, value);
        }
        get rollingFriction() {
            return this._rollingFriction;
        }
        set rollingFriction(value) {
            this._rollingFriction = value;
            this._btColliderObject && ILaya3D.Physics3D._bullet.btCollisionObject_setRollingFriction(this._btColliderObject, value);
        }
        get ccdMotionThreshold() {
            return this._ccdMotionThreshold;
        }
        set ccdMotionThreshold(value) {
            this._ccdMotionThreshold = value;
            this._btColliderObject && ILaya3D.Physics3D._bullet.btCollisionObject_setCcdMotionThreshold(this._btColliderObject, value);
        }
        get ccdSweptSphereRadius() {
            return this._ccdSweptSphereRadius;
        }
        set ccdSweptSphereRadius(value) {
            this._ccdSweptSphereRadius = value;
            this._btColliderObject && ILaya3D.Physics3D._bullet.btCollisionObject_setCcdSweptSphereRadius(this._btColliderObject, value);
        }
        get isActive() {
            return this._btColliderObject ? ILaya3D.Physics3D._bullet.btCollisionObject_isActive(this._btColliderObject) : false;
        }
        get colliderShape() {
            return this._colliderShape;
        }
        set colliderShape(value) {
            var lastColliderShape = this._colliderShape;
            if (lastColliderShape) {
                lastColliderShape._attatched = false;
                lastColliderShape._attatchedCollisionObject = null;
            }
            this._colliderShape = value;
            if (value) {
                if (value._attatched) {
                    throw "PhysicsComponent: this shape has attatched to other entity.";
                }
                else {
                    value._attatched = true;
                    value._attatchedCollisionObject = this;
                }
                if (this._btColliderObject) {
                    ILaya3D.Physics3D._bullet.btCollisionObject_setCollisionShape(this._btColliderObject, value._btShape);
                    var canInSimulation = this._simulation && this._enabled;
                    (canInSimulation && lastColliderShape) && (this._removeFromSimulation());
                    this._onShapeChange(value);
                    if (canInSimulation) {
                        this._derivePhysicsTransformation(true);
                        this._addToSimulation();
                    }
                }
            }
            else {
                if (this._simulation && this._enabled)
                    lastColliderShape && this._removeFromSimulation();
            }
        }
        get simulation() {
            return this._simulation;
        }
        get collisionGroup() {
            return this._collisionGroup;
        }
        set collisionGroup(value) {
            if (this._collisionGroup !== value) {
                this._collisionGroup = value;
                if (this._simulation && this._colliderShape && this._enabled) {
                    this._removeFromSimulation();
                    this._addToSimulation();
                }
            }
        }
        get canCollideWith() {
            return this._canCollideWith;
        }
        set canCollideWith(value) {
            if (this._canCollideWith !== value) {
                this._canCollideWith = value;
                if (this._simulation && this._colliderShape && this._enabled) {
                    this._removeFromSimulation();
                    this._addToSimulation();
                }
            }
        }
        _parseShape(shapesData) {
            var shapeCount = shapesData.length;
            if (shapeCount === 1) {
                var shape = PhysicsComponent._creatShape(shapesData[0]);
                this.colliderShape = shape;
            }
            else {
                var compoundShape = new CompoundColliderShape();
                for (var i = 0; i < shapeCount; i++) {
                    shape = PhysicsComponent._creatShape(shapesData[i]);
                    compoundShape.addChildShape(shape);
                }
                this.colliderShape = compoundShape;
            }
        }
        _onScaleChange(scale) {
            this._colliderShape._setScale(scale);
        }
        _onAdded() {
            this.restitution = this._restitution;
            this.friction = this._friction;
            this.rollingFriction = this._rollingFriction;
            this.ccdMotionThreshold = this._ccdMotionThreshold;
            this.ccdSweptSphereRadius = this._ccdSweptSphereRadius;
        }
        _onEnable() {
            this.owner.transform.on(Laya.Event.TRANSFORM_CHANGED, this, this._onTransformChanged);
            this._simulation = this.owner._scene.physicsSimulation;
            ILaya3D.Physics3D._bullet.btCollisionObject_setContactProcessingThreshold(this._btColliderObject, 0);
            if (this._colliderShape) {
                this._derivePhysicsTransformation(true);
                this._addToSimulation();
            }
        }
        _onDisable() {
            this.owner.transform.off(Laya.Event.TRANSFORM_CHANGED, this, this._onTransformChanged);
            if (this._colliderShape) {
                this._removeFromSimulation();
                (this._inPhysicUpdateListIndex !== -1) && (this._simulation._physicsUpdateList.remove(this));
            }
            this._simulation = null;
        }
        _onDestroy() {
            delete PhysicsComponent._physicObjectsMap[this.id];
            ILaya3D.Physics3D._bullet.btCollisionObject_destroy(this._btColliderObject);
            this._colliderShape && this._colliderShape.destroy();
            this._btColliderObject = null;
            this._colliderShape = null;
            this._simulation = null;
        }
        getPhysicsPosition() {
            var bt = ILaya3D.Physics3D._bullet;
            var btColliderObject = this._btColliderObject;
            var btTransform = bt.btCollisionObject_getWorldTransform(btColliderObject);
            var btPosition = bt.btTransform_getOrigin(btTransform);
            let x = bt.btVector3_x(btPosition);
            let y = bt.btVector3_y(btPosition);
            let z = bt.btVector3_z(btPosition);
            PhysicsComponent._tempVector30.setValue(x, y, z);
            return PhysicsComponent._tempVector30;
        }
        getPhysicsOrientation() {
            var bt = ILaya3D.Physics3D._bullet;
            var btColliderObject = this._btColliderObject;
            var btTransform = bt.btCollisionObject_getWorldTransform(btColliderObject);
            var btRotation = bt.btTransform_getRotation(btTransform);
            var qx = bt.btQuaternion_x(btRotation);
            var qy = bt.btQuaternion_y(btRotation);
            var qz = bt.btQuaternion_z(btRotation);
            var qw = bt.btQuaternion_w(btRotation);
            PhysicsComponent._tempQuaternion0.setValue(qx, qy, qz, qw);
            return PhysicsComponent._tempQuaternion0;
        }
        _isValid() {
            return this._simulation && this._colliderShape && this._enabled;
        }
        _parse(data) {
            (data.collisionGroup != null) && (this.collisionGroup = data.collisionGroup);
            (data.canCollideWith != null) && (this.canCollideWith = data.canCollideWith);
            (data.ccdMotionThreshold != null) && (this.ccdMotionThreshold = data.ccdMotionThreshold);
            (data.ccdSweptSphereRadius != null) && (this.ccdSweptSphereRadius = data.ccdSweptSphereRadius);
        }
        _setTransformFlag(type, value) {
            if (value)
                this._transformFlag |= type;
            else
                this._transformFlag &= ~type;
        }
        _getTransformFlag(type) {
            return (this._transformFlag & type) != 0;
        }
        _addToSimulation() {
        }
        _removeFromSimulation() {
        }
        _derivePhysicsTransformation(force) {
            var bt = ILaya3D.Physics3D._bullet;
            var btColliderObject = this._btColliderObject;
            var btTransform = bt.btCollisionObject_getWorldTransform(btColliderObject);
            this._innerDerivePhysicsTransformation(btTransform, force);
            bt.btCollisionObject_setWorldTransform(btColliderObject, btTransform);
        }
        _innerDerivePhysicsTransformation(physicTransformPtr, force) {
            var bt = ILaya3D.Physics3D._bullet;
            var transform = this.owner._transform;
            let pxoff = 0;
            let pyoff = 0;
            let pzoff = 0;
            if (force || this._getTransformFlag(Transform3D.TRANSFORM_WORLDPOSITION)) {
                var shapeOffset = this._colliderShape.localOffset;
                var position = transform.position;
                var btPosition = PhysicsComponent._btVector30;
                if (shapeOffset.x !== 0 || shapeOffset.y !== 0 || shapeOffset.z !== 0) {
                    var physicPosition = PhysicsComponent._tempVector30;
                    var worldMat = transform.worldMatrix;
                    Laya.Vector3.transformCoordinate(shapeOffset, worldMat, physicPosition);
                    bt.btVector3_setValue(btPosition, physicPosition.x, physicPosition.y, physicPosition.z);
                }
                else {
                    bt.btVector3_setValue(btPosition, position.x - pxoff, position.y - pyoff, position.z - pzoff);
                }
                bt.btTransform_setOrigin(physicTransformPtr, btPosition);
                this._setTransformFlag(Transform3D.TRANSFORM_WORLDPOSITION, false);
            }
            if (force || this._getTransformFlag(Transform3D.TRANSFORM_WORLDQUATERNION)) {
                var shapeRotation = this._colliderShape.localRotation;
                var btRotation = PhysicsComponent._btQuaternion0;
                var rotation = transform.rotation;
                if (shapeRotation.x !== 0 || shapeRotation.y !== 0 || shapeRotation.z !== 0 || shapeRotation.w !== 1) {
                    var physicRotation = PhysicsComponent._tempQuaternion0;
                    PhysicsComponent.physicQuaternionMultiply(rotation.x, rotation.y, rotation.z, rotation.w, shapeRotation, physicRotation);
                    bt.btQuaternion_setValue(btRotation, physicRotation.x, physicRotation.y, physicRotation.z, physicRotation.w);
                }
                else {
                    bt.btQuaternion_setValue(btRotation, rotation.x, rotation.y, rotation.z, rotation.w);
                }
                bt.btTransform_setRotation(physicTransformPtr, btRotation);
                this._setTransformFlag(Transform3D.TRANSFORM_WORLDQUATERNION, false);
            }
            if (force || this._getTransformFlag(Transform3D.TRANSFORM_WORLDSCALE)) {
                this._onScaleChange(transform.getWorldLossyScale());
                this._setTransformFlag(Transform3D.TRANSFORM_WORLDSCALE, false);
            }
        }
        _updateTransformComponent(physicsTransform, syncRot = true, addmargin = 0) {
            var bt = ILaya3D.Physics3D._bullet;
            var colliderShape = this._colliderShape;
            var localOffset = colliderShape.localOffset;
            var localRotation = colliderShape.localRotation;
            var transform = this.owner._transform;
            if (!transform)
                return;
            var position = transform.position;
            var rotation = transform.rotation;
            var btPosition = bt.btTransform_getOrigin(physicsTransform);
            if (syncRot) {
                var btRotation = bt.btTransform_getRotation(physicsTransform);
                var btRotX = bt.btQuaternion_x(btRotation);
                var btRotY = bt.btQuaternion_y(btRotation);
                var btRotZ = bt.btQuaternion_z(btRotation);
                var btRotW = bt.btQuaternion_w(btRotation);
                if (localRotation.x !== 0 || localRotation.y !== 0 || localRotation.z !== 0 || localRotation.w !== 1) {
                    var invertShapeRotaion = PhysicsComponent._tempQuaternion0;
                    localRotation.invert(invertShapeRotaion);
                    PhysicsComponent.physicQuaternionMultiply(btRotX, btRotY, btRotZ, btRotW, invertShapeRotaion, rotation);
                }
                else {
                    rotation.x = btRotX;
                    rotation.y = btRotY;
                    rotation.z = btRotZ;
                    rotation.w = btRotW;
                }
                transform.rotation = rotation;
            }
            if (localOffset.x !== 0 || localOffset.y !== 0 || localOffset.z !== 0) {
                var btScale = bt.btCollisionShape_getLocalScaling(colliderShape._btShape);
                var rotShapePosition = PhysicsComponent._tempVector30;
                rotShapePosition.x = localOffset.x * bt.btVector3_x(btScale);
                rotShapePosition.y = localOffset.y * bt.btVector3_y(btScale);
                rotShapePosition.z = localOffset.z * bt.btVector3_z(btScale);
                Laya.Vector3.transformQuat(rotShapePosition, rotation, rotShapePosition);
                position.x = bt.btVector3_x(btPosition) - rotShapePosition.x;
                position.y = bt.btVector3_y(btPosition) - rotShapePosition.y + addmargin;
                position.z = bt.btVector3_z(btPosition) - rotShapePosition.z;
            }
            else {
                position.x = bt.btVector3_x(btPosition);
                position.y = bt.btVector3_y(btPosition);
                position.z = bt.btVector3_z(btPosition);
            }
            transform.position = position;
        }
        _onShapeChange(colShape) {
            var btColObj = this._btColliderObject;
            var bt = ILaya3D.Physics3D._bullet;
            var flags = bt.btCollisionObject_getCollisionFlags(btColObj);
            if (colShape.needsCustomCollisionCallback) {
                if ((flags & PhysicsComponent.COLLISIONFLAGS_CUSTOM_MATERIAL_CALLBACK) === 0)
                    bt.btCollisionObject_setCollisionFlags(btColObj, flags | PhysicsComponent.COLLISIONFLAGS_CUSTOM_MATERIAL_CALLBACK);
            }
            else {
                if ((flags & PhysicsComponent.COLLISIONFLAGS_CUSTOM_MATERIAL_CALLBACK) > 0)
                    bt.btCollisionObject_setCollisionFlags(btColObj, flags ^ PhysicsComponent.COLLISIONFLAGS_CUSTOM_MATERIAL_CALLBACK);
            }
        }
        _onTransformChanged(flag) {
            if (PhysicsComponent._addUpdateList || !this._controlBySimulation) {
                flag &= Transform3D.TRANSFORM_WORLDPOSITION | Transform3D.TRANSFORM_WORLDQUATERNION | Transform3D.TRANSFORM_WORLDSCALE;
                if (flag) {
                    this._transformFlag |= flag;
                    if (this._isValid() && this._inPhysicUpdateListIndex === -1)
                        this._simulation._physicsUpdateList.add(this);
                }
            }
        }
        _cloneTo(dest) {
            var destPhysicsComponent = dest;
            destPhysicsComponent.restitution = this._restitution;
            destPhysicsComponent.friction = this._friction;
            destPhysicsComponent.rollingFriction = this._rollingFriction;
            destPhysicsComponent.ccdMotionThreshold = this._ccdMotionThreshold;
            destPhysicsComponent.ccdSweptSphereRadius = this._ccdSweptSphereRadius;
            destPhysicsComponent.collisionGroup = this._collisionGroup;
            destPhysicsComponent.canCollideWith = this._canCollideWith;
            destPhysicsComponent.canScaleShape = this.canScaleShape;
            (this._colliderShape) && (destPhysicsComponent.colliderShape = this._colliderShape.clone());
        }
    }
    PhysicsComponent.ACTIVATIONSTATE_ACTIVE_TAG = 1;
    PhysicsComponent.ACTIVATIONSTATE_ISLAND_SLEEPING = 2;
    PhysicsComponent.ACTIVATIONSTATE_WANTS_DEACTIVATION = 3;
    PhysicsComponent.ACTIVATIONSTATE_DISABLE_DEACTIVATION = 4;
    PhysicsComponent.ACTIVATIONSTATE_DISABLE_SIMULATION = 5;
    PhysicsComponent.COLLISIONFLAGS_STATIC_OBJECT = 1;
    PhysicsComponent.COLLISIONFLAGS_KINEMATIC_OBJECT = 2;
    PhysicsComponent.COLLISIONFLAGS_NO_CONTACT_RESPONSE = 4;
    PhysicsComponent.COLLISIONFLAGS_CUSTOM_MATERIAL_CALLBACK = 8;
    PhysicsComponent.COLLISIONFLAGS_CHARACTER_OBJECT = 16;
    PhysicsComponent.COLLISIONFLAGS_DISABLE_VISUALIZE_OBJECT = 32;
    PhysicsComponent.COLLISIONFLAGS_DISABLE_SPU_COLLISION_PROCESSING = 64;
    PhysicsComponent._tempVector30 = new Laya.Vector3();
    PhysicsComponent._tempQuaternion0 = new Laya.Quaternion();
    PhysicsComponent._tempQuaternion1 = new Laya.Quaternion();
    PhysicsComponent._tempMatrix4x40 = new Laya.Matrix4x4();
    PhysicsComponent._physicObjectsMap = {};
    PhysicsComponent._addUpdateList = true;

    class CharacterController extends PhysicsComponent {
        constructor(stepheight = 0.1, upAxis = null, collisionGroup = Physics3DUtils.COLLISIONFILTERGROUP_DEFAULTFILTER, canCollideWith = Physics3DUtils.COLLISIONFILTERGROUP_ALLFILTER) {
            super(collisionGroup, canCollideWith);
            this._upAxis = new Laya.Vector3(0, 1, 0);
            this._maxSlope = 90.0;
            this._jumpSpeed = 10.0;
            this._fallSpeed = 55.0;
            this._gravity = new Laya.Vector3(0, -9.8 * 3, 0);
            this._btKinematicCharacter = null;
            this._pushForce = 1;
            this._stepHeight = stepheight;
            (upAxis) && (this._upAxis = upAxis);
            this._controlBySimulation = true;
        }
        static __init__() {
            CharacterController._btTempVector30 = ILaya3D.Physics3D._bullet.btVector3_create(0, 0, 0);
        }
        set colliderShape(value) {
            if (value instanceof MeshColliderShape) {
                value = null;
                console.error("CharacterController is not support MeshColliderShape");
            }
            super.colliderShape = value;
        }
        get colliderShape() {
            return this._colliderShape;
        }
        get fallSpeed() {
            return this._fallSpeed;
        }
        set fallSpeed(value) {
            this._fallSpeed = value;
            ILaya3D.Physics3D._bullet.btKinematicCharacterController_setFallSpeed(this._btKinematicCharacter, value);
        }
        set pushForce(v) {
            this._pushForce = v;
            if (this._btKinematicCharacter) {
                var bt = ILaya3D.Physics3D._bullet;
                bt.btKinematicCharacterController_setPushForce(this._btKinematicCharacter, v);
            }
        }
        get pushForce() {
            return this._pushForce;
        }
        get jumpSpeed() {
            return this._jumpSpeed;
        }
        set jumpSpeed(value) {
            this._jumpSpeed = value;
            ILaya3D.Physics3D._bullet.btKinematicCharacterController_setJumpSpeed(this._btKinematicCharacter, value);
        }
        get gravity() {
            return this._gravity;
        }
        set gravity(value) {
            this._gravity = value;
            var bt = ILaya3D.Physics3D._bullet;
            var btGravity = CharacterController._btTempVector30;
            bt.btVector3_setValue(btGravity, value.x, value.y, value.z);
            bt.btKinematicCharacterController_setGravity(this._btKinematicCharacter, btGravity);
        }
        get maxSlope() {
            return this._maxSlope;
        }
        set maxSlope(value) {
            this._maxSlope = value;
            ILaya3D.Physics3D._bullet.btKinematicCharacterController_setMaxSlope(this._btKinematicCharacter, (value / 180) * Math.PI);
        }
        get isGrounded() {
            return ILaya3D.Physics3D._bullet.btKinematicCharacterController_onGround(this._btKinematicCharacter);
        }
        get stepHeight() {
            return this._stepHeight;
        }
        set stepHeight(value) {
            this._stepHeight = value;
            ILaya3D.Physics3D._bullet.btKinematicCharacterController_setStepHeight(this._btKinematicCharacter, value);
        }
        get upAxis() {
            return this._upAxis;
        }
        set upAxis(value) {
            this._upAxis = value;
            var btUpAxis = CharacterController._btTempVector30;
            Utils3D._convertToBulletVec3(value, btUpAxis);
            ILaya3D.Physics3D._bullet.btKinematicCharacterController_setUp(this._btKinematicCharacter, btUpAxis);
        }
        get position() {
            let bt = ILaya3D.Physics3D._bullet;
            let pPos = bt.btKinematicCharacterController_getCurrentPosition(this._btKinematicCharacter);
            CharacterController.tmpPosition.setValue(bt.btVector3_x(pPos), bt.btVector3_y(pPos), bt.btVector3_z(pPos));
            return CharacterController.tmpPosition;
        }
        set position(v) {
            var bt = ILaya3D.Physics3D._bullet;
            bt.btKinematicCharacterController_setCurrentPosition(this._btKinematicCharacter, v.x, v.y, v.z);
        }
        get orientation() {
            let bt = ILaya3D.Physics3D._bullet;
            let pQuat = bt.btKinematicCharacterController_getCurrentOrientation(this._btKinematicCharacter);
            CharacterController.tmpOrientation.setValue(bt.btQuaternion_x(pQuat), bt.btQuaternion_y(pQuat), bt.btQuaternion_z(pQuat), bt.btQuaternion_w(pQuat));
            return CharacterController.tmpOrientation;
        }
        set orientation(v) {
            ILaya3D.Physics3D._bullet;
            this._btColliderObject;
        }
        setJumpAxis(x, y, z) {
            ILaya3D.Physics3D._bullet.btKinematicCharacterController_setJumpAxis(this._btKinematicCharacter, x, y, z);
        }
        _onAdded() {
            var bt = ILaya3D.Physics3D._bullet;
            var ghostObject = bt.btPairCachingGhostObject_create();
            bt.btCollisionObject_setUserIndex(ghostObject, this.id);
            bt.btCollisionObject_setCollisionFlags(ghostObject, PhysicsComponent.COLLISIONFLAGS_CHARACTER_OBJECT);
            this._btColliderObject = ghostObject;
            (this._colliderShape) && (this._constructCharacter());
            super._onAdded();
        }
        _onDestroy() {
            ILaya3D.Physics3D._bullet.btKinematicCharacterController_destroy(this._btKinematicCharacter);
            super._onDestroy();
            this._btKinematicCharacter = null;
        }
        _constructCharacter() {
            var bt = ILaya3D.Physics3D._bullet;
            if (this._btKinematicCharacter)
                bt.btKinematicCharacterController_destroy(this._btKinematicCharacter);
            var btUpAxis = CharacterController._btTempVector30;
            bt.btVector3_setValue(btUpAxis, this._upAxis.x, this._upAxis.y, this._upAxis.z);
            this._btKinematicCharacter = bt.btKinematicCharacterController_create(this._btColliderObject, this._colliderShape._btShape, this._stepHeight, btUpAxis);
            this.fallSpeed = this._fallSpeed;
            this.maxSlope = this._maxSlope;
            this.jumpSpeed = this._jumpSpeed;
            this.gravity = this._gravity;
            this.setJumpAxis(0, 1, 0);
            this.pushForce = this._pushForce;
        }
        _onShapeChange(colShape) {
            super._onShapeChange(colShape);
            this._constructCharacter();
        }
        _addToSimulation() {
            this._simulation._characters.push(this);
            this._simulation._addCharacter(this, this._collisionGroup, this._canCollideWith);
        }
        _removeFromSimulation() {
            this._simulation._removeCharacter(this);
            var characters = this._simulation._characters;
            characters.splice(characters.indexOf(this), 1);
        }
        getHitFlag() {
            return ILaya3D.Physics3D._bullet.btKinematicCharacterController_getHitFlag(this._btKinematicCharacter);
        }
        getVerticalVel() {
            return ILaya3D.Physics3D._bullet.btKinematicCharacterController_getVerticalVelocity(this._btKinematicCharacter);
        }
        getOverlappingObj(cb) {
            var bt = ILaya3D.Physics3D._bullet;
            let ghost = this._btColliderObject;
            let num = bt.btCollisionObject_getNumOverlappingObjects(ghost);
            for (let i = 0; i < num; i++) {
                let obj = bt.btCollisionObject_getOverlappingObject(ghost, i);
                let comp = PhysicsComponent._physicObjectsMap[bt.btCollisionObject_getUserIndex(obj)];
                if (comp) {
                    cb(comp);
                }
            }
        }
        move(movement) {
            var btMovement = CharacterController._btVector30;
            var bt = ILaya3D.Physics3D._bullet;
            bt.btVector3_setValue(btMovement, movement.x, movement.y, movement.z);
            bt.btKinematicCharacterController_setWalkDirection(this._btKinematicCharacter, btMovement);
        }
        jump(velocity = null) {
            var bt = ILaya3D.Physics3D._bullet;
            var btVelocity = CharacterController._btVector30;
            if (velocity) {
                Utils3D._convertToBulletVec3(velocity, btVelocity);
                bt.btKinematicCharacterController_jump(this._btKinematicCharacter, btVelocity);
            }
            else {
                bt.btVector3_setValue(btVelocity, 0, this._jumpSpeed, 0);
                bt.btKinematicCharacterController_jump(this._btKinematicCharacter, btVelocity);
            }
        }
        get btColliderObject() {
            return this._btColliderObject;
        }
        _cloneTo(dest) {
            super._cloneTo(dest);
            var destCharacterController = dest;
            destCharacterController.stepHeight = this._stepHeight;
            destCharacterController.upAxis = this._upAxis;
            destCharacterController.maxSlope = this._maxSlope;
            destCharacterController.jumpSpeed = this._jumpSpeed;
            destCharacterController.fallSpeed = this._fallSpeed;
            destCharacterController.gravity = this._gravity;
        }
    }
    CharacterController.tmpPosition = new Laya.Vector3();
    CharacterController.tmpOrientation = new Laya.Quaternion();
    CharacterController.UPAXIS_X = 0;
    CharacterController.UPAXIS_Y = 1;
    CharacterController.UPAXIS_Z = 2;

    class PhysicsUpdateList extends Laya.SingletonList {
        constructor() {
            super();
        }
        add(element) {
            var index = element._inPhysicUpdateListIndex;
            if (index !== -1)
                throw "PhysicsUpdateList:element has  in  PhysicsUpdateList.";
            this._add(element);
            element._inPhysicUpdateListIndex = this.length++;
        }
        remove(element) {
            var index = element._inPhysicUpdateListIndex;
            this.length--;
            if (index !== this.length) {
                var end = this.elements[this.length];
                this.elements[index] = end;
                end._inPhysicUpdateListIndex = index;
            }
            element._inPhysicUpdateListIndex = -1;
        }
    }

    class ContactPoint {
        constructor() {
            this._idCounter = 0;
            this.colliderA = null;
            this.colliderB = null;
            this.distance = 0;
            this.normal = new Laya.Vector3();
            this.positionOnA = new Laya.Vector3();
            this.positionOnB = new Laya.Vector3();
            this._id = ++this._idCounter;
        }
    }

    class HitResult {
        constructor() {
            this.succeeded = false;
            this.collider = null;
            this.point = new Laya.Vector3();
            this.normal = new Laya.Vector3();
            this.hitFraction = 0;
        }
    }

    class Collision {
        constructor() {
            this._lastUpdateFrame = -2147483648;
            this._updateFrame = -2147483648;
            this._isTrigger = false;
            this.contacts = [];
        }
        _setUpdateFrame(farme) {
            this._lastUpdateFrame = this._updateFrame;
            this._updateFrame = farme;
        }
    }

    class CollisionTool {
        constructor() {
            this._hitResultsPoolIndex = 0;
            this._hitResultsPool = [];
            this._contactPonintsPoolIndex = 0;
            this._contactPointsPool = [];
            this._collisionsPool = [];
            this._collisions = {};
        }
        getHitResult() {
            var hitResult = this._hitResultsPool[this._hitResultsPoolIndex++];
            if (!hitResult) {
                hitResult = new HitResult();
                this._hitResultsPool.push(hitResult);
            }
            return hitResult;
        }
        recoverAllHitResultsPool() {
            this._hitResultsPoolIndex = 0;
        }
        getContactPoints() {
            var contactPoint = this._contactPointsPool[this._contactPonintsPoolIndex++];
            if (!contactPoint) {
                contactPoint = new ContactPoint();
                this._contactPointsPool.push(contactPoint);
            }
            return contactPoint;
        }
        recoverAllContactPointsPool() {
            this._contactPonintsPoolIndex = 0;
        }
        getCollision(physicComponentA, physicComponentB) {
            var collision;
            var idA = physicComponentA.id;
            var idB = physicComponentB.id;
            var subCollisionFirst = this._collisions[idA];
            if (subCollisionFirst)
                collision = subCollisionFirst[idB];
            if (!collision) {
                if (!subCollisionFirst) {
                    subCollisionFirst = {};
                    this._collisions[idA] = subCollisionFirst;
                }
                collision = this._collisionsPool.length === 0 ? new Collision() : this._collisionsPool.pop();
                collision._colliderA = physicComponentA;
                collision._colliderB = physicComponentB;
                subCollisionFirst[idB] = collision;
            }
            return collision;
        }
        recoverCollision(collision) {
            var idA = collision._colliderA.id;
            var idB = collision._colliderB.id;
            this._collisions[idA][idB] = null;
            this._collisionsPool.push(collision);
        }
        garbageCollection() {
            this._hitResultsPoolIndex = 0;
            this._hitResultsPool.length = 0;
            this._contactPonintsPoolIndex = 0;
            this._contactPointsPool.length = 0;
            this._collisionsPool.length = 0;
            for (var subCollisionsKey in this._collisionsPool) {
                var subCollisions = this._collisionsPool[subCollisionsKey];
                var wholeDelete = true;
                for (var collisionKey in subCollisions) {
                    if (subCollisions[collisionKey])
                        wholeDelete = false;
                    else
                        delete subCollisions[collisionKey];
                }
                if (wholeDelete)
                    delete this._collisionsPool[subCollisionsKey];
            }
        }
    }

    class RaycastWheel {
        constructor(ptr) {
            var _a;
            this.worldPos = new Laya.Vector3();
            this.worldQuat = new Laya.Quaternion();
            this.worldMat = new Laya.Matrix4x4();
            this.btWheelPtr = ptr;
            this.bt = ILaya3D.Physics3D._bullet;
            this.btMemory = (_a = Laya.ILaya.Laya.WasmModules['bullet']) === null || _a === void 0 ? void 0 : _a.memory;
        }
        set engineForce(force) {
            this.bt.btWheelInfo_setEengineForce(this.btWheelPtr, force);
        }
        get engineForce() {
            return this.bt.btWheelInfo_getEengineForce(this.btWheelPtr);
        }
        set steeringValue(v) {
            this.bt.btWheelInfo_setSteeringValue(this.btWheelPtr, v);
        }
        get steeringValue() {
            return this.bt.btWheelInfo_getSteeringValue(this.btWheelPtr);
        }
        set brake(v) {
            this.bt.btWheelInfo_setBrake(this.btWheelPtr, v);
        }
        get brake() {
            return this.bt.btWheelInfo_getBrake(this.btWheelPtr);
        }
        get rotation() {
            let bt = this.bt;
            return bt.btWheelInfo_getRrotation(this.btWheelPtr);
        }
        get deltaRotation() {
            let bt = this.bt;
            return bt.btWheelInfo_getDeltaRotation(this.btWheelPtr);
        }
        get transform() {
            let bt = this.bt;
            let btrans = bt.btWheelInfo_getWorldTransform(this.btWheelPtr);
            let ret = this.worldMat;
            let retarr = ret.elements;
            if (window.conch) {
                let o = bt.btTransform_getOrigin(btrans);
                let basisptr = bt.btTransform_getBasis(btrans);
                let r0 = bt.btMatrix3x3_getRow(basisptr, 0);
                let r1 = bt.btMatrix3x3_getRow(basisptr, 1);
                let r2 = bt.btMatrix3x3_getRow(basisptr, 2);
                retarr[0] = bt.btVector3_x(r0);
                retarr[1] = bt.btVector3_x(r1);
                retarr[2] = bt.btVector3_x(r2);
                retarr[3] = 0;
                retarr[4] = bt.btVector3_y(r0);
                retarr[5] = bt.btVector3_y(r1);
                retarr[6] = bt.btVector3_y(r2);
                retarr[7] = 0;
                retarr[8] = bt.btVector3_z(r0);
                retarr[9] = bt.btVector3_z(r1);
                retarr[10] = bt.btVector3_z(r2);
                retarr[11] = 0;
                retarr[12] = bt.btVector3_x(o);
                retarr[13] = bt.btVector3_y(o);
                retarr[14] = bt.btVector3_z(o);
                retarr[15] = 1;
            }
            else {
                let mem = this.btMemory;
                let fbuff = new Float64Array(mem.buffer, btrans, 16);
                retarr[0] = fbuff[0];
                retarr[1] = fbuff[4];
                retarr[2] = fbuff[8];
                retarr[3] = 0;
                retarr[4] = fbuff[1];
                retarr[5] = fbuff[5];
                retarr[6] = fbuff[9];
                retarr[7] = 0;
                retarr[8] = fbuff[2];
                retarr[9] = fbuff[6];
                retarr[10] = fbuff[10];
                retarr[11] = 0;
                retarr[12] = fbuff[12];
                retarr[13] = fbuff[13];
                retarr[14] = fbuff[14];
                retarr[15] = 1;
            }
            return ret;
        }
        getWorldTransform() {
            let bt = this.bt;
            let btrans = bt.btWheelInfo_getWorldTransform(this.btWheelPtr);
            let btOri = bt.btTransform_getOrigin(btrans);
            let btRot = bt.btTransform_getRotation(btrans);
            this.worldPos.set(bt.btVector3_x(btOri), bt.btVector3_y(btOri), bt.btVector3_z(btOri));
            this.worldQuat.set(bt.btQuaternion_x(btRot), bt.btQuaternion_y(btRot), bt.btQuaternion_z(btRot), bt.btQuaternion_w(btRot));
        }
    }

    class btVehicleTuning {
        constructor() {
            this.suspensionStiffness = 15.88;
            this.suspensionCompression = 0.83;
            this.suspensionDamping = 0.88;
            this.maxSuspensionTravelCm = 500;
            this.frictionSlip = 10.5;
            this.maxSuspensionForce = 6000;
        }
    }
    class btWheelInfo {
    }
    class RaycastVehicle {
        constructor(btObj) {
            this.tuing = new btVehicleTuning();
            this.wheels = [];
            this.btVehiclePtr = btObj;
        }
        addWheel(connectionPointCS0, wheelDirectionCS0, wheelAxleCS, wheelRadius, suspensionRestLength, suspensionMaxTravel, suspensionStiffness, suspensionDamping, frictionSlip, isFrontWheel) {
            let bt = ILaya3D.Physics3D._bullet;
            let tuing = this.tuing;
            this.getNumWheels();
            let wheelinfo = bt.btRaycastVehicle_addWheel(this.btVehiclePtr, connectionPointCS0.x, connectionPointCS0.y, connectionPointCS0.z, wheelDirectionCS0.x, wheelDirectionCS0.y, wheelDirectionCS0.z, wheelAxleCS.x, wheelAxleCS.y, wheelAxleCS.z, suspensionRestLength, wheelRadius, suspensionStiffness || tuing.suspensionStiffness, tuing.suspensionCompression, suspensionDamping || tuing.suspensionDamping, frictionSlip || tuing.frictionSlip, (suspensionMaxTravel ? suspensionMaxTravel * 100 : tuing.maxSuspensionTravelCm), tuing.maxSuspensionForce, isFrontWheel);
            let wheel = new RaycastWheel(wheelinfo);
            this.wheels.push(wheel);
            for (let i = 0, n = this.wheels.length; i < n; i++) {
                let cwheel = this.wheels[i];
                cwheel.btWheelPtr = this.getWheelInfo(i);
            }
            return wheel;
        }
        getNumWheels() {
            let bt = ILaya3D.Physics3D._bullet;
            return bt.btRaycastVehicle_getNumWheels(this.btVehiclePtr);
        }
        getWheelInfo(i) {
            let bt = ILaya3D.Physics3D._bullet;
            return bt.btRaycastVehicle_getWheelInfo(this.btVehiclePtr, i);
        }
    }

    class PhysicsSimulation {
        constructor(configuration) {
            this._updateCount = 0;
            this._gravity = new Laya.Vector3(0, -10, 0);
            this._btVector3Zero = ILaya3D.Physics3D._bullet.btVector3_create(0, 0, 0);
            this._btDefaultQuaternion = ILaya3D.Physics3D._bullet.btQuaternion_create(0, 0, 0, -1);
            this._collisionsUtils = new CollisionTool();
            this._previousFrameCollisions = [];
            this._currentFrameCollisions = [];
            this._currentConstraint = {};
            this._physicsUpdateList = new PhysicsUpdateList();
            this._characters = [];
            this._updatedRigidbodies = 0;
            this.maxSubSteps = 1;
            this.fixedTimeStep = 1.0 / 60.0;
            this.dt = 1 / 60;
            this.maxSubSteps = configuration.maxSubSteps;
            this.fixedTimeStep = configuration.fixedTimeStep;
            var bt = ILaya3D.Physics3D._bullet;
            this._btCollisionConfiguration = bt.btDefaultCollisionConfiguration_create();
            this._btDispatcher = bt.btCollisionDispatcher_create(this._btCollisionConfiguration);
            this._btBroadphase = bt.btDbvtBroadphase_create();
            bt.btOverlappingPairCache_setInternalGhostPairCallback(bt.btDbvtBroadphase_getOverlappingPairCache(this._btBroadphase), bt.btGhostPairCallback_create());
            var conFlags = configuration.flags;
            if (conFlags & PhysicsSimulation.PHYSICSENGINEFLAGS_COLLISIONSONLY) {
                this._btCollisionWorld = new bt.btCollisionWorld(this._btDispatcher, this._btBroadphase, this._btCollisionConfiguration);
            }
            else if (conFlags & PhysicsSimulation.PHYSICSENGINEFLAGS_SOFTBODYSUPPORT) {
                throw "PhysicsSimulation:SoftBody processing is not yet available";
            }
            else {
                var solver = bt.btSequentialImpulseConstraintSolver_create();
                this._btDiscreteDynamicsWorld = bt.btDiscreteDynamicsWorld_create(this._btDispatcher, this._btBroadphase, solver, this._btCollisionConfiguration);
                this._btCollisionWorld = this._btDiscreteDynamicsWorld;
            }
            if (this._btDiscreteDynamicsWorld) {
                this._btSolverInfo = bt.btDynamicsWorld_getSolverInfo(this._btDiscreteDynamicsWorld);
                this._btDispatchInfo = bt.btCollisionWorld_getDispatchInfo(this._btDiscreteDynamicsWorld);
            }
            this._btClosestRayResultCallback = bt.ClosestRayResultCallback_create(this._btVector3Zero, this._btVector3Zero);
            this._btAllHitsRayResultCallback = bt.AllHitsRayResultCallback_create(this._btVector3Zero, this._btVector3Zero);
            this._btClosestConvexResultCallback = bt.ClosestConvexResultCallback_create(this._btVector3Zero, this._btVector3Zero);
            this._btAllConvexResultCallback = bt.AllConvexResultCallback_create(this._btVector3Zero, this._btVector3Zero);
            bt.btGImpactCollisionAlgorithm_RegisterAlgorithm(this._btDispatcher);
        }
        static __init__() {
            var bt = ILaya3D.Physics3D._bullet;
            PhysicsSimulation._btTempVector30 = bt.btVector3_create(0, 0, 0);
            PhysicsSimulation._btTempVector31 = bt.btVector3_create(0, 0, 0);
            PhysicsSimulation._btTempQuaternion0 = bt.btQuaternion_create(0, 0, 0, 1);
            PhysicsSimulation._btTempQuaternion1 = bt.btQuaternion_create(0, 0, 0, 1);
            PhysicsSimulation._btTempTransform0 = bt.btTransform_create();
            PhysicsSimulation._btTempTransform1 = bt.btTransform_create();
        }
        static createConstraint() {
        }
        get continuousCollisionDetection() {
            return ILaya3D.Physics3D._bullet.btCollisionWorld_get_m_useContinuous(this._btDispatchInfo);
        }
        set continuousCollisionDetection(value) {
            ILaya3D.Physics3D._bullet.btCollisionWorld_set_m_useContinuous(this._btDispatchInfo, value);
        }
        get gravity() {
            if (!this._btDiscreteDynamicsWorld)
                throw "Simulation:Cannot perform this action when the physics engine is set to CollisionsOnly";
            return this._gravity;
        }
        set gravity(value) {
            if (!this._btDiscreteDynamicsWorld)
                throw "Simulation:Cannot perform this action when the physics engine is set to CollisionsOnly";
            this._gravity = value;
            var bt = ILaya3D.Physics3D._bullet;
            var btGravity = PhysicsSimulation._btTempVector30;
            bt.btVector3_setValue(btGravity, value.x, value.y, value.z);
            bt.btDiscreteDynamicsWorld_setGravity(this._btDiscreteDynamicsWorld, btGravity);
        }
        get speculativeContactRestitution() {
            if (!this._btDiscreteDynamicsWorld)
                throw "Simulation:Cannot Cannot perform this action when the physics engine is set to CollisionsOnly";
            return ILaya3D.Physics3D._bullet.btDiscreteDynamicsWorld_getApplySpeculativeContactRestitution(this._btDiscreteDynamicsWorld);
        }
        set speculativeContactRestitution(value) {
            if (!this._btDiscreteDynamicsWorld)
                throw "Simulation:Cannot Cannot perform this action when the physics engine is set to CollisionsOnly";
            ILaya3D.Physics3D._bullet.btDiscreteDynamicsWorld_setApplySpeculativeContactRestitution(this._btDiscreteDynamicsWorld, value);
        }
        enableDebugDrawer(b) {
            var bt = ILaya3D.Physics3D._bullet;
            bt.btDynamicsWorld_enableDebugDrawer(this._btDiscreteDynamicsWorld, b);
        }
        _simulate(deltaTime) {
            this._updatedRigidbodies = 0;
            this.dt = deltaTime;
            var bt = ILaya3D.Physics3D._bullet;
            if (this._btDiscreteDynamicsWorld)
                bt.btDiscreteDynamicsWorld_stepSimulation(this._btDiscreteDynamicsWorld, deltaTime, this.maxSubSteps, this.fixedTimeStep);
            else
                bt.PerformDiscreteCollisionDetection(this._btCollisionWorld);
            this._updateCount++;
        }
        _destroy() {
            var bt = ILaya3D.Physics3D._bullet;
            if (this._btDiscreteDynamicsWorld) {
                bt.btCollisionWorld_destroy(this._btDiscreteDynamicsWorld);
                this._btDiscreteDynamicsWorld = null;
            }
            else {
                bt.btCollisionWorld_destroy(this._btCollisionWorld);
                this._btCollisionWorld = null;
            }
            bt.btDbvtBroadphase_destroy(this._btBroadphase);
            this._btBroadphase = null;
            bt.btCollisionDispatcher_destroy(this._btDispatcher);
            this._btDispatcher = null;
            bt.btDefaultCollisionConfiguration_destroy(this._btCollisionConfiguration);
            this._btCollisionConfiguration = null;
        }
        _addPhysicsCollider(component, group, mask) {
            ILaya3D.Physics3D._bullet.btCollisionWorld_addCollisionObject(this._btCollisionWorld, component._btColliderObject, group, mask);
        }
        _removePhysicsCollider(component) {
            ILaya3D.Physics3D._bullet.btCollisionWorld_removeCollisionObject(this._btCollisionWorld, component._btColliderObject);
        }
        _addRigidBody(rigidBody, group, mask) {
            if (!this._btDiscreteDynamicsWorld)
                throw "Simulation:Cannot perform this action when the physics engine is set to CollisionsOnly";
            ILaya3D.Physics3D._bullet.btDiscreteDynamicsWorld_addRigidBody(this._btCollisionWorld, rigidBody._btColliderObject, group, mask);
        }
        _removeRigidBody(rigidBody) {
            if (!this._btDiscreteDynamicsWorld)
                throw "Simulation:Cannot perform this action when the physics engine is set to CollisionsOnly";
            ILaya3D.Physics3D._bullet.btDiscreteDynamicsWorld_removeRigidBody(this._btCollisionWorld, rigidBody._btColliderObject);
        }
        _addCharacter(character, group, mask) {
            if (!this._btDiscreteDynamicsWorld)
                throw "Simulation:Cannot perform this action when the physics engine is set to CollisionsOnly";
            var bt = ILaya3D.Physics3D._bullet;
            bt.btCollisionWorld_addCollisionObject(this._btCollisionWorld, character._btColliderObject, group, mask);
            bt.btDynamicsWorld_addAction(this._btCollisionWorld, character._btKinematicCharacter);
        }
        _removeCharacter(character) {
            if (!this._btDiscreteDynamicsWorld)
                throw "Simulation:Cannot perform this action when the physics engine is set to CollisionsOnly";
            var bt = ILaya3D.Physics3D._bullet;
            bt.btCollisionWorld_removeCollisionObject(this._btCollisionWorld, character._btColliderObject);
            bt.btDynamicsWorld_removeAction(this._btCollisionWorld, character._btKinematicCharacter);
        }
        raycastFromTo(from, to, out = null, collisonGroup = Physics3DUtils.COLLISIONFILTERGROUP_ALLFILTER, collisionMask = Physics3DUtils.COLLISIONFILTERGROUP_ALLFILTER) {
            var bt = ILaya3D.Physics3D._bullet;
            var rayResultCall = this._btClosestRayResultCallback;
            var rayFrom = PhysicsSimulation._btTempVector30;
            var rayTo = PhysicsSimulation._btTempVector31;
            bt.btVector3_setValue(rayFrom, from.x, from.y, from.z);
            bt.btVector3_setValue(rayTo, to.x, to.y, to.z);
            bt.ClosestRayResultCallback_set_m_rayFromWorld(rayResultCall, rayFrom);
            bt.ClosestRayResultCallback_set_m_rayToWorld(rayResultCall, rayTo);
            bt.RayResultCallback_set_m_collisionFilterGroup(rayResultCall, collisonGroup);
            bt.RayResultCallback_set_m_collisionFilterMask(rayResultCall, collisionMask);
            bt.RayResultCallback_set_m_collisionObject(rayResultCall, null);
            bt.RayResultCallback_set_m_closestHitFraction(rayResultCall, 1);
            bt.btCollisionWorld_rayTest(this._btCollisionWorld, rayFrom, rayTo, rayResultCall);
            if (bt.RayResultCallback_hasHit(rayResultCall)) {
                if (out) {
                    out.succeeded = true;
                    out.collider = PhysicsComponent._physicObjectsMap[bt.btCollisionObject_getUserIndex(bt.RayResultCallback_get_m_collisionObject(rayResultCall))];
                    out.hitFraction = bt.RayResultCallback_get_m_closestHitFraction(rayResultCall);
                    var btPoint = bt.ClosestRayResultCallback_get_m_hitPointWorld(rayResultCall);
                    var point = out.point;
                    point.x = bt.btVector3_x(btPoint);
                    point.y = bt.btVector3_y(btPoint);
                    point.z = bt.btVector3_z(btPoint);
                    var btNormal = bt.ClosestRayResultCallback_get_m_hitNormalWorld(rayResultCall);
                    var normal = out.normal;
                    normal.x = bt.btVector3_x(btNormal);
                    normal.y = bt.btVector3_y(btNormal);
                    normal.z = bt.btVector3_z(btNormal);
                }
                return true;
            }
            else {
                if (out)
                    out.succeeded = false;
                return false;
            }
        }
        raycastAllFromTo(from, to, out, collisonGroup = Physics3DUtils.COLLISIONFILTERGROUP_ALLFILTER, collisionMask = Physics3DUtils.COLLISIONFILTERGROUP_ALLFILTER) {
            var bt = ILaya3D.Physics3D._bullet;
            var rayResultCall = this._btAllHitsRayResultCallback;
            var rayFrom = PhysicsSimulation._btTempVector30;
            var rayTo = PhysicsSimulation._btTempVector31;
            out.length = 0;
            bt.btVector3_setValue(rayFrom, from.x, from.y, from.z);
            bt.btVector3_setValue(rayTo, to.x, to.y, to.z);
            bt.AllHitsRayResultCallback_set_m_rayFromWorld(rayResultCall, rayFrom);
            bt.AllHitsRayResultCallback_set_m_rayToWorld(rayResultCall, rayTo);
            bt.RayResultCallback_set_m_collisionFilterGroup(rayResultCall, collisonGroup);
            bt.RayResultCallback_set_m_collisionFilterMask(rayResultCall, collisionMask);
            var collisionObjects = bt.AllHitsRayResultCallback_get_m_collisionObjects(rayResultCall);
            var btPoints = bt.AllHitsRayResultCallback_get_m_hitPointWorld(rayResultCall);
            var btNormals = bt.AllHitsRayResultCallback_get_m_hitNormalWorld(rayResultCall);
            var btFractions = bt.AllHitsRayResultCallback_get_m_hitFractions(rayResultCall);
            bt.tBtCollisionObjectArray_clear(collisionObjects);
            bt.tVector3Array_clear(btPoints);
            bt.tVector3Array_clear(btNormals);
            bt.tScalarArray_clear(btFractions);
            bt.btCollisionWorld_rayTest(this._btCollisionWorld, rayFrom, rayTo, rayResultCall);
            var count = bt.tBtCollisionObjectArray_size(collisionObjects);
            if (count > 0) {
                this._collisionsUtils.recoverAllHitResultsPool();
                for (var i = 0; i < count; i++) {
                    var hitResult = this._collisionsUtils.getHitResult();
                    out.push(hitResult);
                    hitResult.succeeded = true;
                    hitResult.collider = PhysicsComponent._physicObjectsMap[bt.btCollisionObject_getUserIndex(bt.tBtCollisionObjectArray_at(collisionObjects, i))];
                    hitResult.hitFraction = bt.tScalarArray_at(btFractions, i);
                    var btPoint = bt.tVector3Array_at(btPoints, i);
                    var pointE = hitResult.point;
                    pointE.x = bt.btVector3_x(btPoint);
                    pointE.y = bt.btVector3_y(btPoint);
                    pointE.z = bt.btVector3_z(btPoint);
                    var btNormal = bt.tVector3Array_at(btNormals, i);
                    var normal = hitResult.normal;
                    normal.x = bt.btVector3_x(btNormal);
                    normal.y = bt.btVector3_y(btNormal);
                    normal.z = bt.btVector3_z(btNormal);
                }
                return true;
            }
            else {
                return false;
            }
        }
        rayCast(ray, outHitResult = null, distance = 2147483647, collisonGroup = Physics3DUtils.COLLISIONFILTERGROUP_ALLFILTER, collisionMask = Physics3DUtils.COLLISIONFILTERGROUP_ALLFILTER) {
            var from = ray.origin;
            var to = PhysicsSimulation._tempVector30;
            Laya.Vector3.normalize(ray.direction, to);
            Laya.Vector3.scale(to, distance, to);
            Laya.Vector3.add(from, to, to);
            return this.raycastFromTo(from, to, outHitResult, collisonGroup, collisionMask);
        }
        rayCastAll(ray, out, distance = 2147483647, collisonGroup = Physics3DUtils.COLLISIONFILTERGROUP_ALLFILTER, collisionMask = Physics3DUtils.COLLISIONFILTERGROUP_ALLFILTER) {
            var from = ray.origin;
            var to = PhysicsSimulation._tempVector30;
            Laya.Vector3.normalize(ray.direction, to);
            Laya.Vector3.scale(to, distance, to);
            Laya.Vector3.add(from, to, to);
            return this.raycastAllFromTo(from, to, out, collisonGroup, collisionMask);
        }
        shapeCast(shape, fromPosition, toPosition, out = null, fromRotation = null, toRotation = null, collisonGroup = Physics3DUtils.COLLISIONFILTERGROUP_ALLFILTER, collisionMask = Physics3DUtils.COLLISIONFILTERGROUP_ALLFILTER, allowedCcdPenetration = 0.0) {
            var bt = ILaya3D.Physics3D._bullet;
            var convexResultCall = this._btClosestConvexResultCallback;
            var convexPosFrom = PhysicsSimulation._btTempVector30;
            var convexPosTo = PhysicsSimulation._btTempVector31;
            var convexRotFrom = PhysicsSimulation._btTempQuaternion0;
            var convexRotTo = PhysicsSimulation._btTempQuaternion1;
            var convexTransform = PhysicsSimulation._btTempTransform0;
            var convexTransTo = PhysicsSimulation._btTempTransform1;
            var sweepShape = shape._btShape;
            bt.btVector3_setValue(convexPosFrom, fromPosition.x, fromPosition.y, fromPosition.z);
            bt.btVector3_setValue(convexPosTo, toPosition.x, toPosition.y, toPosition.z);
            bt.ConvexResultCallback_set_m_collisionFilterGroup(convexResultCall, collisonGroup);
            bt.ConvexResultCallback_set_m_collisionFilterMask(convexResultCall, collisionMask);
            bt.btTransform_setOrigin(convexTransform, convexPosFrom);
            bt.btTransform_setOrigin(convexTransTo, convexPosTo);
            if (fromRotation) {
                bt.btQuaternion_setValue(convexRotFrom, fromRotation.x, fromRotation.y, fromRotation.z, fromRotation.w);
                bt.btTransform_setRotation(convexTransform, convexRotFrom);
            }
            else {
                bt.btTransform_setRotation(convexTransform, this._btDefaultQuaternion);
            }
            if (toRotation) {
                bt.btQuaternion_setValue(convexRotTo, toRotation.x, toRotation.y, toRotation.z, toRotation.w);
                bt.btTransform_setRotation(convexTransTo, convexRotTo);
            }
            else {
                bt.btTransform_setRotation(convexTransTo, this._btDefaultQuaternion);
            }
            bt.ClosestConvexResultCallback_set_m_hitCollisionObject(convexResultCall, null);
            bt.ConvexResultCallback_set_m_closestHitFraction(convexResultCall, 1);
            bt.btCollisionWorld_convexSweepTest(this._btCollisionWorld, sweepShape, convexTransform, convexTransTo, convexResultCall, allowedCcdPenetration);
            if (bt.ConvexResultCallback_hasHit(convexResultCall)) {
                if (out) {
                    out.succeeded = true;
                    out.collider = PhysicsComponent._physicObjectsMap[bt.btCollisionObject_getUserIndex(bt.ClosestConvexResultCallback_get_m_hitCollisionObject(convexResultCall))];
                    out.hitFraction = bt.ConvexResultCallback_get_m_closestHitFraction(convexResultCall);
                    var btPoint = bt.ClosestConvexResultCallback_get_m_hitPointWorld(convexResultCall);
                    var btNormal = bt.ClosestConvexResultCallback_get_m_hitNormalWorld(convexResultCall);
                    var point = out.point;
                    var normal = out.normal;
                    point.x = bt.btVector3_x(btPoint);
                    point.y = bt.btVector3_y(btPoint);
                    point.z = bt.btVector3_z(btPoint);
                    normal.x = bt.btVector3_x(btNormal);
                    normal.y = bt.btVector3_y(btNormal);
                    normal.z = bt.btVector3_z(btNormal);
                }
                return true;
            }
            else {
                if (out)
                    out.succeeded = false;
                return false;
            }
        }
        shapeCastAll(shape, fromPosition, toPosition, out, fromRotation = null, toRotation = null, collisonGroup = Physics3DUtils.COLLISIONFILTERGROUP_ALLFILTER, collisionMask = Physics3DUtils.COLLISIONFILTERGROUP_ALLFILTER, allowedCcdPenetration = 0.0) {
            var bt = ILaya3D.Physics3D._bullet;
            var convexResultCall = this._btAllConvexResultCallback;
            var convexPosFrom = PhysicsSimulation._btTempVector30;
            var convexPosTo = PhysicsSimulation._btTempVector31;
            var convexRotFrom = PhysicsSimulation._btTempQuaternion0;
            var convexRotTo = PhysicsSimulation._btTempQuaternion1;
            var convexTransform = PhysicsSimulation._btTempTransform0;
            var convexTransTo = PhysicsSimulation._btTempTransform1;
            var sweepShape = shape._btShape;
            out.length = 0;
            bt.btVector3_setValue(convexPosFrom, fromPosition.x, fromPosition.y, fromPosition.z);
            bt.btVector3_setValue(convexPosTo, toPosition.x, toPosition.y, toPosition.z);
            bt.ConvexResultCallback_set_m_collisionFilterGroup(convexResultCall, collisonGroup);
            bt.ConvexResultCallback_set_m_collisionFilterMask(convexResultCall, collisionMask);
            bt.btTransform_setOrigin(convexTransform, convexPosFrom);
            bt.btTransform_setOrigin(convexTransTo, convexPosTo);
            if (fromRotation) {
                bt.btQuaternion_setValue(convexRotFrom, fromRotation.x, fromRotation.y, fromRotation.z, fromRotation.w);
                bt.btTransform_setRotation(convexTransform, convexRotFrom);
            }
            else {
                bt.btTransform_setRotation(convexTransform, this._btDefaultQuaternion);
            }
            if (toRotation) {
                bt.btQuaternion_setValue(convexRotTo, toRotation.x, toRotation.y, toRotation.z, toRotation.w);
                bt.btTransform_setRotation(convexTransTo, convexRotTo);
            }
            else {
                bt.btTransform_setRotation(convexTransTo, this._btDefaultQuaternion);
            }
            var collisionObjects = bt.AllConvexResultCallback_get_m_collisionObjects(convexResultCall);
            var btPoints = bt.AllConvexResultCallback_get_m_hitPointWorld(convexResultCall);
            var btNormals = bt.AllConvexResultCallback_get_m_hitNormalWorld(convexResultCall);
            var btFractions = bt.AllConvexResultCallback_get_m_hitFractions(convexResultCall);
            bt.tVector3Array_clear(btPoints);
            bt.tVector3Array_clear(btNormals);
            bt.tScalarArray_clear(btFractions);
            bt.tBtCollisionObjectArray_clear(collisionObjects);
            bt.btCollisionWorld_convexSweepTest(this._btCollisionWorld, sweepShape, convexTransform, convexTransTo, convexResultCall, allowedCcdPenetration);
            var count = bt.tBtCollisionObjectArray_size(collisionObjects);
            if (count > 0) {
                this._collisionsUtils.recoverAllHitResultsPool();
                for (var i = 0; i < count; i++) {
                    var hitResult = this._collisionsUtils.getHitResult();
                    out.push(hitResult);
                    hitResult.succeeded = true;
                    hitResult.collider = PhysicsComponent._physicObjectsMap[bt.btCollisionObject_getUserIndex(bt.tBtCollisionObjectArray_at(collisionObjects, i))];
                    hitResult.hitFraction = bt.tScalarArray_at(btFractions, i);
                    var btPoint = bt.tVector3Array_at(btPoints, i);
                    var point = hitResult.point;
                    point.x = bt.btVector3_x(btPoint);
                    point.y = bt.btVector3_y(btPoint);
                    point.z = bt.btVector3_z(btPoint);
                    var btNormal = bt.tVector3Array_at(btNormals, i);
                    var normal = hitResult.normal;
                    normal.x = bt.btVector3_x(btNormal);
                    normal.y = bt.btVector3_y(btNormal);
                    normal.z = bt.btVector3_z(btNormal);
                }
                return true;
            }
            else {
                return false;
            }
        }
        addConstraint(constraint, disableCollisionsBetweenLinkedBodies = false) {
            if (!this._btDiscreteDynamicsWorld)
                throw "Cannot perform this action when the physics engine is set to CollisionsOnly";
            ILaya3D.Physics3D._bullet.btCollisionWorld_addConstraint(this._btDiscreteDynamicsWorld, constraint._btConstraint, disableCollisionsBetweenLinkedBodies);
            this._currentConstraint[constraint.id] = constraint;
        }
        removeConstraint(constraint) {
            if (!this._btDiscreteDynamicsWorld)
                throw "Cannot perform this action when the physics engine is set to CollisionsOnly";
            ILaya3D.Physics3D._bullet.btCollisionWorld_removeConstraint(this._btDiscreteDynamicsWorld, constraint._btConstraint);
            delete this._currentConstraint[constraint.id];
        }
        setHitsRayResultCallbackFlag(flag = 1) {
            var bt = ILaya3D.Physics3D._bullet;
            bt.RayResultCallback_set_m_flags(this._btAllHitsRayResultCallback, flag);
            bt.RayResultCallback_set_m_flags(this._btClosestRayResultCallback, flag);
        }
        _updatePhysicsTransformFromRender() {
            var elements = this._physicsUpdateList.elements;
            for (var i = 0, n = this._physicsUpdateList.length; i < n; i++) {
                var physicCollider = elements[i];
                physicCollider._derivePhysicsTransformation(false);
                physicCollider._inPhysicUpdateListIndex = -1;
            }
            this._physicsUpdateList.length = 0;
        }
        _updateCharacters() {
            let bt = ILaya3D.Physics3D._bullet;
            for (var i = 0, n = this._characters.length; i < n; i++) {
                var character = this._characters[i];
                character._updateTransformComponent(bt.btCollisionObject_getWorldTransform(character._btColliderObject), false, 0.04);
            }
        }
        _updateCollisions() {
            this._collisionsUtils.recoverAllContactPointsPool();
            var previous = this._currentFrameCollisions;
            this._currentFrameCollisions = this._previousFrameCollisions;
            this._currentFrameCollisions.length = 0;
            this._previousFrameCollisions = previous;
            var loopCount = this._updateCount;
            var bt = ILaya3D.Physics3D._bullet;
            var numManifolds = bt.btDispatcher_getNumManifolds(this._btDispatcher);
            for (let i = 0; i < numManifolds; i++) {
                var contactManifold = bt.btDispatcher_getManifoldByIndexInternal(this._btDispatcher, i);
                var componentA = PhysicsComponent._physicObjectsMap[bt.btCollisionObject_getUserIndex(bt.btPersistentManifold_getBody0(contactManifold))];
                var componentB = PhysicsComponent._physicObjectsMap[bt.btCollisionObject_getUserIndex(bt.btPersistentManifold_getBody1(contactManifold))];
                if (componentA.id > componentB.id) {
                    let tt = componentA;
                    componentA = componentB;
                    componentB = tt;
                }
                var collision = null;
                var isFirstCollision;
                var contacts = null;
                var isTrigger = componentA.isTrigger || componentB.isTrigger;
                if (isTrigger) {
                    if (componentA.owner._getBit(Laya.NodeFlags.PROCESS_TRIGGERS) || componentB.owner._getBit(Laya.NodeFlags.PROCESS_TRIGGERS)) {
                        var numContacts = bt.btPersistentManifold_getNumContacts(contactManifold);
                        for (let j = 0; j < numContacts; j++) {
                            var pt = bt.btPersistentManifold_getContactPoint(contactManifold, j);
                            var distance = bt.btManifoldPoint_getDistance(pt);
                            if (distance <= 0) {
                                collision = this._collisionsUtils.getCollision(componentA, componentB);
                                contacts = collision.contacts;
                                isFirstCollision = collision._updateFrame !== loopCount;
                                if (isFirstCollision) {
                                    collision._isTrigger = true;
                                    contacts.length = 0;
                                }
                                break;
                            }
                        }
                    }
                }
                else if (componentA.owner._getBit(Laya.NodeFlags.PROCESS_COLLISIONS) || componentB.owner._getBit(Laya.NodeFlags.PROCESS_COLLISIONS)) {
                    if (componentA._enableProcessCollisions || componentB._enableProcessCollisions) {
                        numContacts = bt.btPersistentManifold_getNumContacts(contactManifold);
                        for (let j = 0; j < numContacts; j++) {
                            pt = bt.btPersistentManifold_getContactPoint(contactManifold, j);
                            distance = bt.btManifoldPoint_getDistance(pt);
                            if (distance <= 0) {
                                var contactPoint = this._collisionsUtils.getContactPoints();
                                contactPoint.colliderA = componentA;
                                contactPoint.colliderB = componentB;
                                contactPoint.distance = distance;
                                var btNormal = bt.btManifoldPoint_get_m_normalWorldOnB(pt);
                                var normal = contactPoint.normal;
                                normal.x = bt.btVector3_x(btNormal);
                                normal.y = bt.btVector3_y(btNormal);
                                normal.z = bt.btVector3_z(btNormal);
                                var btPostionA = bt.btManifoldPoint_get_m_positionWorldOnA(pt);
                                var positionOnA = contactPoint.positionOnA;
                                positionOnA.x = bt.btVector3_x(btPostionA);
                                positionOnA.y = bt.btVector3_y(btPostionA);
                                positionOnA.z = bt.btVector3_z(btPostionA);
                                var btPostionB = bt.btManifoldPoint_get_m_positionWorldOnB(pt);
                                var positionOnB = contactPoint.positionOnB;
                                positionOnB.x = bt.btVector3_x(btPostionB);
                                positionOnB.y = bt.btVector3_y(btPostionB);
                                positionOnB.z = bt.btVector3_z(btPostionB);
                                if (!collision) {
                                    collision = this._collisionsUtils.getCollision(componentA, componentB);
                                    contacts = collision.contacts;
                                    isFirstCollision = collision._updateFrame !== loopCount;
                                    if (isFirstCollision) {
                                        collision._isTrigger = false;
                                        contacts.length = 0;
                                    }
                                }
                                contacts.push(contactPoint);
                            }
                        }
                    }
                }
                if (collision && isFirstCollision) {
                    this._currentFrameCollisions.push(collision);
                    collision._setUpdateFrame(loopCount);
                }
            }
            for (var i = 0, n = this._characters.length; i < n; i++) {
                var character = this._characters[i];
                character.getOverlappingObj(body => {
                    if (body instanceof CharacterController)
                        return;
                    let compa = character;
                    let compb = body;
                    if (character.id > body.id) {
                        compa = body;
                        compb = character;
                    }
                    let collision = this._collisionsUtils.getCollision(compa, compb);
                    if (collision._updateFrame === loopCount)
                        return;
                    let contacts = collision.contacts;
                    contacts.length = 1;
                    collision._setUpdateFrame(loopCount);
                    var contactPoint = this._collisionsUtils.getContactPoints();
                    contactPoint.colliderA = compa;
                    contactPoint.colliderB = compb;
                    contactPoint.distance = 0;
                    contacts[0] = contactPoint;
                    this._currentFrameCollisions.push(collision);
                });
            }
        }
        dispatchCollideEvent() {
            let loopCount = this._updateCount;
            for (let i = 0, n = this._currentFrameCollisions.length; i < n; i++) {
                let curFrameCol = this._currentFrameCollisions[i];
                let colliderA = curFrameCol._colliderA;
                let colliderB = curFrameCol._colliderB;
                if (colliderA.destroyed || colliderB.destroyed)
                    continue;
                let ownerA = colliderA.owner;
                let ownerB = colliderB.owner;
                if (loopCount - curFrameCol._lastUpdateFrame === 1) {
                    if (curFrameCol._isTrigger) {
                        ownerA.event(Laya.Event.TRIGGER_STAY, colliderB);
                        ownerB.event(Laya.Event.TRIGGER_STAY, colliderA);
                    }
                    else {
                        curFrameCol.other = colliderB;
                        ownerA.event(Laya.Event.COLLISION_STAY, curFrameCol);
                        curFrameCol.other = colliderA;
                        ownerB.event(Laya.Event.COLLISION_STAY, curFrameCol);
                    }
                }
                else {
                    if (curFrameCol._isTrigger) {
                        ownerA.event(Laya.Event.TRIGGER_ENTER, colliderB);
                        ownerB.event(Laya.Event.TRIGGER_ENTER, colliderA);
                    }
                    else {
                        curFrameCol.other = colliderB;
                        ownerA.event(Laya.Event.COLLISION_ENTER, curFrameCol);
                        curFrameCol.other = colliderA;
                        ownerB.event(Laya.Event.COLLISION_ENTER, curFrameCol);
                    }
                }
            }
            for (let i = 0, n = this._previousFrameCollisions.length; i < n; i++) {
                let preFrameCol = this._previousFrameCollisions[i];
                let preColliderA = preFrameCol._colliderA;
                let preColliderB = preFrameCol._colliderB;
                if (preColliderA.destroyed || preColliderB.destroyed)
                    continue;
                let ownerA = preColliderA.owner;
                let ownerB = preColliderB.owner;
                if (loopCount - preFrameCol._updateFrame === 1) {
                    this._collisionsUtils.recoverCollision(preFrameCol);
                    if (preFrameCol._isTrigger) {
                        ownerA.event(Laya.Event.TRIGGER_EXIT, preColliderB);
                        ownerB.event(Laya.Event.TRIGGER_EXIT, preColliderA);
                    }
                    else {
                        preFrameCol.other = preColliderB;
                        ownerA.event(Laya.Event.COLLISION_EXIT, preFrameCol);
                        preFrameCol.other = preColliderA;
                        ownerB.event(Laya.Event.COLLISION_EXIT, preFrameCol);
                    }
                }
            }
            for (let id in this._currentConstraint) {
                let constraintObj = this._currentConstraint[id];
                if (constraintObj.enabled && constraintObj._isBreakConstrained()) {
                    let bodya = constraintObj.ownBody.owner;
                    let bodyb = constraintObj.connectedBody.owner;
                    bodya.event(Laya.Event.JOINT_BREAK);
                    bodyb.event(Laya.Event.JOINT_BREAK);
                }
            }
        }
        clearForces() {
            if (!this._btDiscreteDynamicsWorld)
                throw "Cannot perform this action when the physics engine is set to CollisionsOnly";
            ILaya3D.Physics3D._bullet.btDiscreteDynamicsWorld_clearForces(this._btDiscreteDynamicsWorld);
        }
        createRaycastVehicle(body) {
            let bt = ILaya3D.Physics3D._bullet;
            let btVehiclePtr = bt.btRaycastVehicle_create(this._btDiscreteDynamicsWorld, body._btColliderObject);
            bt.btCollisionObject_forceActivationState(body._btColliderObject, PhysicsComponent.ACTIVATIONSTATE_DISABLE_DEACTIVATION);
            let ret = new RaycastVehicle(btVehiclePtr);
            return ret;
        }
        addVehicle(v) {
            let bt = ILaya3D.Physics3D._bullet;
            bt.btDynamicsWorld_addAction(this._btDiscreteDynamicsWorld, v.btVehiclePtr);
        }
        removeVehicle(v) {
            let bt = ILaya3D.Physics3D._bullet;
            bt.btDynamicsWorld_removeAction(v.btVehiclePtr);
        }
        sphereQuery(pos, radius, result, collisionmask = Physics3DUtils.COLLISIONFILTERGROUP_ALLFILTER) {
            let bt = ILaya3D.Physics3D._bullet;
            if (!this._btPairCachingGhost) {
                this._btPairCachingGhost = bt.btPairCachingGhostObject_create();
                this._btTransform = bt.btTransform_create();
                this._btVec = bt.btVector3_create(0, 0, 0);
                this._btSphereShape = bt.btSphereShape_create(1);
            }
            result.length = 0;
            let sphere = this._btSphereShape;
            bt.btSphereShpae_setUnscaledRadius(sphere, radius);
            let ghost = this._btPairCachingGhost;
            let xform = this._btTransform;
            let vpos = this._btVec;
            bt.btVector3_setValue(vpos, pos.x, pos.y, pos.z);
            bt.btTransform_setIdentity(xform);
            bt.btTransform_setOrigin(xform, vpos);
            bt.btCollisionObject_setCollisionShape(ghost, sphere);
            bt.btCollisionObject_setWorldTransform(ghost, xform);
            bt.btCollisionWorld_addCollisionObject(this._btDiscreteDynamicsWorld, ghost, -1, -1);
            let num = bt.btCollisionObject_getNumOverlappingObjects(ghost);
            for (let i = 0; i < num; i++) {
                let obj = bt.btCollisionObject_getOverlappingObject(ghost, i);
                let comp = PhysicsComponent._physicObjectsMap[bt.btCollisionObject_getUserIndex(obj)];
                if (comp.collisionGroup & collisionmask)
                    result.push(comp);
            }
            bt.btCollisionWorld_removeCollisionObject(this._btDiscreteDynamicsWorld, ghost);
        }
    }
    PhysicsSimulation.PHYSICSENGINEFLAGS_NONE = 0x0;
    PhysicsSimulation.PHYSICSENGINEFLAGS_COLLISIONSONLY = 0x1;
    PhysicsSimulation.PHYSICSENGINEFLAGS_SOFTBODYSUPPORT = 0x2;
    PhysicsSimulation.PHYSICSENGINEFLAGS_MULTITHREADED = 0x4;
    PhysicsSimulation.PHYSICSENGINEFLAGS_USEHARDWAREWHENPOSSIBLE = 0x8;
    PhysicsSimulation.SOLVERMODE_RANDMIZE_ORDER = 1;
    PhysicsSimulation.SOLVERMODE_FRICTION_SEPARATE = 2;
    PhysicsSimulation.SOLVERMODE_USE_WARMSTARTING = 4;
    PhysicsSimulation.SOLVERMODE_USE_2_FRICTION_DIRECTIONS = 16;
    PhysicsSimulation.SOLVERMODE_ENABLE_FRICTION_DIRECTION_CACHING = 32;
    PhysicsSimulation.SOLVERMODE_DISABLE_VELOCITY_DEPENDENT_FRICTION_DIRECTION = 64;
    PhysicsSimulation.SOLVERMODE_CACHE_FRIENDLY = 128;
    PhysicsSimulation.SOLVERMODE_SIMD = 256;
    PhysicsSimulation.SOLVERMODE_INTERLEAVE_CONTACT_AND_FRICTION_CONSTRAINTS = 512;
    PhysicsSimulation.SOLVERMODE_ALLOW_ZERO_LENGTH_FRICTION_DIRECTIONS = 1024;
    PhysicsSimulation.HITSRAYRESULTCALLBACK_FLAG_NONE = 0;
    PhysicsSimulation.HITSRAYRESULTCALLBACK_FLAG_FILTERBACKFACESS = 1;
    PhysicsSimulation.HITSRAYRESULTCALLBACK_FLAG_KEEPUNFILIPPEDNORMAL = 2;
    PhysicsSimulation.HITSRAYRESULTCALLBACK_FLAG_USESUBSIMPLEXCONVEXCASTRAYTEST = 4;
    PhysicsSimulation.HITSRAYRESULTCALLBACK_FLAG_USEGJKCONVEXCASTRAYTEST = 8;
    PhysicsSimulation.HITSRAYRESULTCALLBACK_FLAG_TERMINATOR = 0xffffffff;
    PhysicsSimulation._tempVector30 = new Laya.Vector3();
    PhysicsSimulation.disableSimulation = false;

    class PhysicsTriggerComponent extends PhysicsComponent {
        constructor(collisionGroup, canCollideWith) {
            super(collisionGroup, canCollideWith);
            this._isTrigger = false;
        }
        get isTrigger() {
            return this._isTrigger;
        }
        set isTrigger(value) {
            this._isTrigger = value;
            var bt = ILaya3D.Physics3D._bullet;
            if (this._btColliderObject) {
                var flags = bt.btCollisionObject_getCollisionFlags(this._btColliderObject);
                if (value) {
                    if ((flags & PhysicsComponent.COLLISIONFLAGS_NO_CONTACT_RESPONSE) === 0)
                        bt.btCollisionObject_setCollisionFlags(this._btColliderObject, flags | PhysicsComponent.COLLISIONFLAGS_NO_CONTACT_RESPONSE);
                }
                else {
                    if ((flags & PhysicsComponent.COLLISIONFLAGS_NO_CONTACT_RESPONSE) !== 0)
                        bt.btCollisionObject_setCollisionFlags(this._btColliderObject, flags ^ PhysicsComponent.COLLISIONFLAGS_NO_CONTACT_RESPONSE);
                }
            }
        }
        _onAdded() {
            super._onAdded();
            this.isTrigger = this._isTrigger;
        }
        _cloneTo(dest) {
            super._cloneTo(dest);
            dest.isTrigger = this._isTrigger;
        }
    }

    class Rigidbody3D extends PhysicsTriggerComponent {
        constructor(collisionGroup = Physics3DUtils.COLLISIONFILTERGROUP_DEFAULTFILTER, canCollideWith = Physics3DUtils.COLLISIONFILTERGROUP_ALLFILTER) {
            super(collisionGroup, canCollideWith);
            this._isKinematic = false;
            this._mass = 1.0;
            this._gravity = new Laya.Vector3(0, -10, 0);
            this._angularDamping = 0.0;
            this._linearDamping = 0.0;
            this._overrideGravity = false;
            this._totalTorque = new Laya.Vector3(0, 0, 0);
            this._totalForce = new Laya.Vector3(0, 0, 0);
            this._linearVelocity = new Laya.Vector3();
            this._angularVelocity = new Laya.Vector3();
            this._linearFactor = new Laya.Vector3(1, 1, 1);
            this._angularFactor = new Laya.Vector3(1, 1, 1);
            this._detectCollisions = true;
            this._controlBySimulation = true;
        }
        static __init__() {
            var bt = ILaya3D.Physics3D._bullet;
            Rigidbody3D._btTempVector30 = bt.btVector3_create(0, 0, 0);
            Rigidbody3D._btTempVector31 = bt.btVector3_create(0, 0, 0);
            Rigidbody3D._btVector3Zero = bt.btVector3_create(0, 0, 0);
            Rigidbody3D._btInertia = bt.btVector3_create(0, 0, 0);
            Rigidbody3D._btImpulse = bt.btVector3_create(0, 0, 0);
            Rigidbody3D._btImpulseOffset = bt.btVector3_create(0, 0, 0);
            Rigidbody3D._btGravity = bt.btVector3_create(0, 0, 0);
            Rigidbody3D._btTransform0 = bt.btTransform_create();
        }
        get mass() {
            return this._mass;
        }
        set mass(value) {
            value = Math.max(value, 1e-07);
            this._mass = value;
            (this._isKinematic) || (this._updateMass(value));
        }
        getCollisionFlags() {
            var bt = ILaya3D.Physics3D._bullet;
            if (!this._btColliderObject)
                return 0;
            return bt.btCollisionObject_getCollisionFlags(this._btColliderObject);
        }
        get isKinematic() {
            return this._isKinematic;
        }
        set isKinematic(value) {
            this._isKinematic = value;
            this._controlBySimulation = !value;
            var bt = ILaya3D.Physics3D._bullet;
            var canInSimulation = !!(this._simulation && this._enabled && this._colliderShape);
            canInSimulation && this._removeFromSimulation();
            var natColObj = this._btColliderObject;
            var flags = bt.btCollisionObject_getCollisionFlags(natColObj);
            if (value) {
                flags = flags | PhysicsComponent.COLLISIONFLAGS_KINEMATIC_OBJECT;
                bt.btCollisionObject_setCollisionFlags(natColObj, flags);
                bt.btCollisionObject_forceActivationState(this._btColliderObject, PhysicsComponent.ACTIVATIONSTATE_DISABLE_DEACTIVATION);
                this._enableProcessCollisions = false;
                this._updateMass(0);
            }
            else {
                if ((flags & PhysicsComponent.COLLISIONFLAGS_KINEMATIC_OBJECT) > 0)
                    flags = flags ^ PhysicsComponent.COLLISIONFLAGS_KINEMATIC_OBJECT;
                bt.btCollisionObject_setCollisionFlags(natColObj, flags);
                bt.btCollisionObject_setActivationState(this._btColliderObject, PhysicsComponent.ACTIVATIONSTATE_ACTIVE_TAG);
                this._enableProcessCollisions = true;
                this._updateMass(this._mass);
            }
            var btZero = Rigidbody3D._btVector3Zero;
            bt.btCollisionObject_setInterpolationLinearVelocity(natColObj, btZero);
            bt.btRigidBody_setLinearVelocity(natColObj, btZero);
            bt.btCollisionObject_setInterpolationAngularVelocity(natColObj, btZero);
            bt.btRigidBody_setAngularVelocity(natColObj, btZero);
            canInSimulation && this._addToSimulation();
        }
        get linearDamping() {
            return this._linearDamping;
        }
        set linearDamping(value) {
            this._linearDamping = value;
            if (this._btColliderObject)
                ILaya3D.Physics3D._bullet.btRigidBody_setDamping(this._btColliderObject, value, this._angularDamping);
        }
        get angularDamping() {
            return this._angularDamping;
        }
        set angularDamping(value) {
            this._angularDamping = value;
            if (this._btColliderObject)
                ILaya3D.Physics3D._bullet.btRigidBody_setDamping(this._btColliderObject, this._linearDamping, value);
        }
        get overrideGravity() {
            return this._overrideGravity;
        }
        set overrideGravity(value) {
            this._overrideGravity = value;
            var bt = ILaya3D.Physics3D._bullet;
            if (this._btColliderObject) {
                var flag = bt.btRigidBody_getFlags(this._btColliderObject);
                if (value) {
                    if ((flag & Rigidbody3D._BT_DISABLE_WORLD_GRAVITY) === 0)
                        bt.btRigidBody_setFlags(this._btColliderObject, flag | Rigidbody3D._BT_DISABLE_WORLD_GRAVITY);
                }
                else {
                    if ((flag & Rigidbody3D._BT_DISABLE_WORLD_GRAVITY) > 0)
                        bt.btRigidBody_setFlags(this._btColliderObject, flag ^ Rigidbody3D._BT_DISABLE_WORLD_GRAVITY);
                }
            }
        }
        get gravity() {
            var bt = ILaya3D.Physics3D._bullet;
            Rigidbody3D._btGravity = bt.btRigidBody_getGravity(this._btColliderObject);
            Utils3D._convertToLayaVec3(Rigidbody3D._btGravity, this._gravity);
            return this._gravity;
        }
        set gravity(value) {
            this._gravity = value;
            var bt = ILaya3D.Physics3D._bullet;
            bt.btVector3_setValue(Rigidbody3D._btGravity, value.x, value.y, value.z);
            bt.btRigidBody_setGravity(this._btColliderObject, Rigidbody3D._btGravity);
        }
        get totalForce() {
            if (this._btColliderObject) {
                var btTotalForce = ILaya3D.Physics3D._bullet.btRigidBody_getTotalForce(this._btColliderObject);
                Utils3D._convertToLayaVec3(btTotalForce, this._totalForce);
                return this._totalForce;
            }
            return null;
        }
        get linearFactor() {
            return this._linearFactor;
        }
        set linearFactor(value) {
            this._linearFactor = value;
            var btValue = Rigidbody3D._btTempVector30;
            Utils3D._convertToBulletVec3(value, btValue);
            ILaya3D.Physics3D._bullet.btRigidBody_setLinearFactor(this._btColliderObject, btValue);
        }
        get linearVelocity() {
            if (this._btColliderObject)
                Utils3D._convertToLayaVec3(ILaya3D.Physics3D._bullet.btRigidBody_getLinearVelocity(this._btColliderObject), this._linearVelocity);
            return this._linearVelocity;
        }
        set linearVelocity(value) {
            this._linearVelocity = value;
            if (this._btColliderObject) {
                var btValue = Rigidbody3D._btTempVector30;
                Utils3D._convertToBulletVec3(value, btValue);
                (this.isSleeping) && (this.wakeUp());
                ILaya3D.Physics3D._bullet.btRigidBody_setLinearVelocity(this._btColliderObject, btValue);
            }
        }
        get angularFactor() {
            return this._angularFactor;
        }
        set angularFactor(value) {
            this._angularFactor = value;
            var btValue = Rigidbody3D._btTempVector30;
            Utils3D._convertToBulletVec3(value, btValue);
            ILaya3D.Physics3D._bullet.btRigidBody_setAngularFactor(this._btColliderObject, btValue);
        }
        get angularVelocity() {
            if (this._btColliderObject)
                Utils3D._convertToLayaVec3(ILaya3D.Physics3D._bullet.btRigidBody_getAngularVelocity(this._btColliderObject), this._angularVelocity);
            return this._angularVelocity;
        }
        set angularVelocity(value) {
            this._angularVelocity = value;
            if (this._btColliderObject) {
                var btValue = Rigidbody3D._btTempVector30;
                Utils3D._convertToBulletVec3(value, btValue);
                (this.isSleeping) && (this.wakeUp());
                ILaya3D.Physics3D._bullet.btRigidBody_setAngularVelocity(this._btColliderObject, btValue);
            }
        }
        get totalTorque() {
            if (this._btColliderObject) {
                var btTotalTorque = ILaya3D.Physics3D._bullet.btRigidBody_getTotalTorque(this._btColliderObject);
                Utils3D._convertToLayaVec3(btTotalTorque, this._totalTorque);
                return this._totalTorque;
            }
            return null;
        }
        get detectCollisions() {
            return this._detectCollisions;
        }
        set detectCollisions(value) {
            if (this._detectCollisions !== value) {
                this._detectCollisions = value;
                if (this._colliderShape && this._enabled && this._simulation) {
                    this._simulation._removeRigidBody(this);
                    this._simulation._addRigidBody(this, this._collisionGroup, value ? this._canCollideWith : 0);
                }
            }
        }
        get isSleeping() {
            if (this._btColliderObject)
                return ILaya3D.Physics3D._bullet.btCollisionObject_getActivationState(this._btColliderObject) === PhysicsComponent.ACTIVATIONSTATE_ISLAND_SLEEPING;
            return false;
        }
        get sleepLinearVelocity() {
            return ILaya3D.Physics3D._bullet.btRigidBody_getLinearSleepingThreshold(this._btColliderObject);
        }
        set sleepLinearVelocity(value) {
            var bt = ILaya3D.Physics3D._bullet;
            bt.btRigidBody_setSleepingThresholds(this._btColliderObject, value, bt.btRigidBody_getAngularSleepingThreshold(this._btColliderObject));
        }
        get sleepAngularVelocity() {
            return ILaya3D.Physics3D._bullet.btRigidBody_getAngularSleepingThreshold(this._btColliderObject);
        }
        set sleepAngularVelocity(value) {
            var bt = ILaya3D.Physics3D._bullet;
            bt.btRigidBody_setSleepingThresholds(this._btColliderObject, bt.btRigidBody_getLinearSleepingThreshold(this._btColliderObject), value);
        }
        get btColliderObject() {
            return this._btColliderObject;
        }
        set position(pos) {
            var bt = ILaya3D.Physics3D._bullet;
            var btColliderObject = this._btColliderObject;
            bt.btRigidBody_setCenterOfMassPos(btColliderObject, pos.x, pos.y, pos.z);
        }
        get position() {
            return this.getPhysicsPosition();
        }
        set orientation(q) {
            var bt = ILaya3D.Physics3D._bullet;
            var btColliderObject = this._btColliderObject;
            bt.btRigidBody_setCenterOfMassOrientation(btColliderObject, q.x, q.y, q.z, q.w);
        }
        get orientation() {
            return this.getPhysicsOrientation();
        }
        _updateMass(mass) {
            if (this._btColliderObject && this._colliderShape && this._colliderShape._btShape) {
                var bt = ILaya3D.Physics3D._bullet;
                bt.btCollisionShape_calculateLocalInertia(this._colliderShape._btShape, mass, Rigidbody3D._btInertia);
                bt.btRigidBody_setMassProps(this._btColliderObject, mass, Rigidbody3D._btInertia);
                bt.btRigidBody_updateInertiaTensor(this._btColliderObject);
            }
        }
        _onScaleChange(scale) {
            super._onScaleChange(scale);
            this._updateMass(this._isKinematic ? 0 : this._mass);
        }
        _derivePhysicsTransformation(force) {
            var bt = ILaya3D.Physics3D._bullet;
            var btColliderObject = this._btColliderObject;
            var oriTransform = bt.btCollisionObject_getWorldTransform(btColliderObject);
            var transform = Rigidbody3D._btTransform0;
            bt.btTransform_equal(transform, oriTransform);
            this._innerDerivePhysicsTransformation(transform, force);
            bt.btRigidBody_setCenterOfMassTransform(btColliderObject, transform);
        }
        _initRigidbody(motionid) {
            var bt = ILaya3D.Physics3D._bullet;
            var motionState = bt.layaMotionState_create();
            bt.layaMotionState_set_rigidBodyID(motionState, motionid);
            this._btLayaMotionState = motionState;
            var constructInfo = bt.btRigidBodyConstructionInfo_create(0.0, motionState, null, Rigidbody3D._btVector3Zero);
            var btRigid = bt.btRigidBody_create(constructInfo);
            bt.btCollisionObject_setUserIndex(btRigid, this.id);
            this._btColliderObject = btRigid;
            bt.btRigidBodyConstructionInfo_destroy(constructInfo);
        }
        _onAdded() {
            this._initRigidbody(this.id);
            super._onAdded();
            this.mass = this._mass;
            this.linearFactor = this._linearFactor;
            this.angularFactor = this._angularFactor;
            this.linearDamping = this._linearDamping;
            this.angularDamping = this._angularDamping;
            this.overrideGravity = this._overrideGravity;
            this.gravity = this._gravity;
            this.isKinematic = this._isKinematic;
        }
        _onDestroy() {
            ILaya3D.Physics3D._bullet.btMotionState_destroy(this._btLayaMotionState);
            super._onDestroy();
            this._btLayaMotionState = null;
            this._gravity = null;
            this._totalTorque = null;
            this._linearVelocity = null;
            this._angularVelocity = null;
            this._linearFactor = null;
            this._angularFactor = null;
        }
        set colliderShape(value) {
            if (value instanceof MeshColliderShape) {
                value = null;
                console.error("RigidBody3D is not support MeshColliderShape");
            }
            super.colliderShape = value;
        }
        get colliderShape() {
            return this._colliderShape;
        }
        _onShapeChange(colShape) {
            super._onShapeChange(colShape);
            if (this.mass <= 0)
                return;
            if (this._isKinematic) {
                this._updateMass(0);
            }
            else {
                var bt = ILaya3D.Physics3D._bullet;
                bt.btRigidBody_setCenterOfMassTransform(this._btColliderObject, bt.btCollisionObject_getWorldTransform(this._btColliderObject));
                this._updateMass(this._mass);
            }
        }
        _parse(data) {
            (data.friction != null) && (this.friction = data.friction);
            (data.rollingFriction != null) && (this.rollingFriction = data.rollingFriction);
            (data.restitution != null) && (this.restitution = data.restitution);
            (data.isTrigger != null) && (this.isTrigger = data.isTrigger);
            (data.mass != null) && (this.mass = data.mass);
            (data.linearDamping != null) && (this.linearDamping = data.linearDamping);
            (data.angularDamping != null) && (this.angularDamping = data.angularDamping);
            (data.overrideGravity != null) && (this.overrideGravity = data.overrideGravity);
            if (data.linearFactor != null) {
                var linFac = this.linearFactor;
                linFac.fromArray(data.linearFactor);
                this.linearFactor = linFac;
            }
            if (data.angularFactor != null) {
                var angFac = this.angularFactor;
                angFac.fromArray(data.angularFactor);
                this.angularFactor = angFac;
            }
            if (data.gravity) {
                this.gravity.fromArray(data.gravity);
                this.gravity = this.gravity;
            }
            super._parse(data);
            this._parseShape(data.shapes);
            (data.isKinematic != null) && (this.isKinematic = data.isKinematic);
        }
        _addToSimulation() {
            this._simulation._addRigidBody(this, this._collisionGroup, this._detectCollisions ? this._canCollideWith : 0);
        }
        _removeFromSimulation() {
            this._simulation._removeRigidBody(this);
        }
        _cloneTo(dest) {
            super._cloneTo(dest);
            var destRigidbody3D = dest;
            destRigidbody3D.isKinematic = this._isKinematic;
            destRigidbody3D.mass = this._mass;
            destRigidbody3D.gravity = this._gravity;
            destRigidbody3D.angularDamping = this._angularDamping;
            destRigidbody3D.linearDamping = this._linearDamping;
            destRigidbody3D.overrideGravity = this._overrideGravity;
            destRigidbody3D.linearVelocity = this._linearVelocity;
            destRigidbody3D.angularVelocity = this._angularVelocity;
            destRigidbody3D.linearFactor = this._linearFactor;
            destRigidbody3D.angularFactor = this._angularFactor;
            destRigidbody3D.detectCollisions = this._detectCollisions;
        }
        applyForce(force, localOffset = null) {
            this.applyForceXYZ(force.x, force.y, force.z, localOffset);
        }
        applyForceXYZ(fx, fy, fz, localOffset = null) {
            if (this._btColliderObject == null)
                throw "Attempted to call a Physics function that is avaliable only when the Entity has been already added to the Scene.";
            var bt = ILaya3D.Physics3D._bullet;
            var btForce = Rigidbody3D._btTempVector30;
            bt.btVector3_setValue(btForce, fx, fy, fz);
            this.wakeUp();
            if (localOffset) {
                var btOffset = Rigidbody3D._btTempVector31;
                bt.btVector3_setValue(btOffset, localOffset.x, localOffset.y, localOffset.z);
                bt.btRigidBody_applyForce(this._btColliderObject, btForce, btOffset);
            }
            else {
                bt.btRigidBody_applyCentralForce(this._btColliderObject, btForce);
            }
        }
        setCollisionFlags(flags) {
            var bt = ILaya3D.Physics3D._bullet;
            var canInSimulation = !!(this._simulation && this._enabled);
            canInSimulation && this._removeFromSimulation();
            if (flags & 3) {
                this._isKinematic = true;
                this._simulation && this._updateMass(0);
            }
            else {
                this._simulation && this._updateMass(this._mass);
            }
            bt.btCollisionObject_setCollisionFlags(this._btColliderObject, flags);
            canInSimulation && this._addToSimulation();
        }
        applyTorque(torque) {
            if (this._btColliderObject == null)
                throw "Attempted to call a Physics function that is avaliable only when the Entity has been already added to the Scene.";
            var bullet = ILaya3D.Physics3D._bullet;
            var btTorque = Rigidbody3D._btTempVector30;
            this.wakeUp();
            bullet.btVector3_setValue(btTorque, torque.x, torque.y, torque.z);
            bullet.btRigidBody_applyTorque(this._btColliderObject, btTorque);
        }
        applyImpulse(impulse, localOffset = null) {
            if (this._btColliderObject == null)
                throw "Attempted to call a Physics function that is avaliable only when the Entity has been already added to the Scene.";
            var bt = ILaya3D.Physics3D._bullet;
            bt.btVector3_setValue(Rigidbody3D._btImpulse, impulse.x, impulse.y, impulse.z);
            this.wakeUp();
            if (localOffset) {
                bt.btVector3_setValue(Rigidbody3D._btImpulseOffset, localOffset.x, localOffset.y, localOffset.z);
                bt.btRigidBody_applyImpulse(this._btColliderObject, Rigidbody3D._btImpulse, Rigidbody3D._btImpulseOffset);
            }
            else {
                bt.btRigidBody_applyCentralImpulse(this._btColliderObject, Rigidbody3D._btImpulse);
            }
        }
        applyTorqueImpulse(torqueImpulse) {
            if (this._btColliderObject == null)
                throw "Attempted to call a Physics function that is avaliable only when the Entity has been already added to the Scene.";
            var bt = ILaya3D.Physics3D._bullet;
            var btTorqueImpulse = Rigidbody3D._btTempVector30;
            this.wakeUp();
            bt.btVector3_setValue(btTorqueImpulse, torqueImpulse.x, torqueImpulse.y, torqueImpulse.z);
            bt.btRigidBody_applyTorqueImpulse(this._btColliderObject, btTorqueImpulse);
        }
        wakeUp() {
            this._btColliderObject && (ILaya3D.Physics3D._bullet.btCollisionObject_activate(this._btColliderObject, false));
        }
        clearForces() {
            var rigidBody = this._btColliderObject;
            if (rigidBody == null)
                throw "Attempted to call a Physics function that is avaliable only when the Entity has been already added to the Scene.";
            var bt = ILaya3D.Physics3D._bullet;
            bt.btRigidBody_clearForces(rigidBody);
            var btZero = Rigidbody3D._btVector3Zero;
            bt.btCollisionObject_setInterpolationLinearVelocity(rigidBody, btZero);
            bt.btRigidBody_setLinearVelocity(rigidBody, btZero);
            bt.btCollisionObject_setInterpolationAngularVelocity(rigidBody, btZero);
            bt.btRigidBody_setAngularVelocity(rigidBody, btZero);
        }
    }
    Rigidbody3D.TYPE_STATIC = 0;
    Rigidbody3D.TYPE_DYNAMIC = 1;
    Rigidbody3D.TYPE_KINEMATIC = 2;
    Rigidbody3D._BT_DISABLE_WORLD_GRAVITY = 1;
    Rigidbody3D._BT_ENABLE_GYROPSCOPIC_FORCE = 2;

    class StaticPlaneColliderShape extends ColliderShape {
        constructor(normal, offset) {
            super();
            this._normal = normal;
            this._offset = offset;
            this._type = ColliderShape.SHAPETYPES_STATICPLANE;
            var bt = ILaya3D.Physics3D._bullet;
            bt.btVector3_setValue(StaticPlaneColliderShape._btNormal, -normal.x, normal.y, normal.z);
            this._btShape = bt.btStaticPlaneShape_create(StaticPlaneColliderShape._btNormal, offset);
        }
        static __init__() {
            StaticPlaneColliderShape._btNormal = ILaya3D.Physics3D._bullet.btVector3_create(0, 0, 0);
        }
        clone() {
            var dest = new StaticPlaneColliderShape(this._normal, this._offset);
            this.cloneTo(dest);
            return dest;
        }
    }

    class Physics3D {
        static __bulletinit__() {
            this._bullet = window.Physics3D;
            if (this._bullet) {
                StaticPlaneColliderShape.__init__();
                ColliderShape.__init__();
                CompoundColliderShape.__init__();
                PhysicsComponent.__init__();
                PhysicsSimulation.__init__();
                BoxColliderShape.__init__();
                CylinderColliderShape.__init__();
                CharacterController.__init__();
                Rigidbody3D.__init__();
            }
        }
    }
    Physics3D._bullet = null;
    Physics3D._cannon = null;
    Physics3D._enablePhysics = false;

    class KeyframeNode {
        constructor() {
            this._ownerPath = [];
            this._propertys = [];
            this._keyFrames = [];
        }
        get ownerPathCount() {
            return this._ownerPath.length;
        }
        get propertyCount() {
            return this._propertys.length;
        }
        get keyFramesCount() {
            return this._keyFrames.length;
        }
        _setOwnerPathCount(value) {
            this._ownerPath.length = value;
        }
        _setOwnerPathByIndex(index, value) {
            this._ownerPath[index] = value;
        }
        _joinOwnerPath(sep) {
            return this._ownerPath.join(sep);
        }
        _setPropertyCount(value) {
            this._propertys.length = value;
        }
        _setPropertyByIndex(index, value) {
            this._propertys[index] = value;
        }
        _joinProperty(sep) {
            return this._propertys.join(sep);
        }
        _setKeyframeCount(value) {
            this._keyFrames.length = value;
        }
        _setKeyframeByIndex(index, value) {
            this._keyFrames[index] = value;
        }
        getOwnerPathByIndex(index) {
            return this._ownerPath[index];
        }
        getPropertyByIndex(index) {
            return this._propertys[index];
        }
        getKeyframeByIndex(index) {
            return this._keyFrames[index];
        }
    }

    class AnimationEvent {
        constructor() {
        }
    }

    exports.WeightedMode = void 0;
    (function (WeightedMode) {
        WeightedMode[WeightedMode["None"] = 0] = "None";
        WeightedMode[WeightedMode["In"] = 1] = "In";
        WeightedMode[WeightedMode["Out"] = 2] = "Out";
        WeightedMode[WeightedMode["Both"] = 3] = "Both";
    })(exports.WeightedMode || (exports.WeightedMode = {}));
    class Keyframe {
        constructor() {
        }
        cloneTo(destObject) {
            var destKeyFrame = destObject;
            destKeyFrame.time = this.time;
        }
        clone() {
            var dest = new Keyframe();
            this.cloneTo(dest);
            return dest;
        }
    }
    Keyframe.defaultWeight = 0.33333;

    class FloatKeyframe extends Keyframe {
        constructor() {
            super();
            this.inWeight = Keyframe.defaultWeight;
            this.outWeight = Keyframe.defaultWeight;
            this.weightedMode = exports.WeightedMode.None;
        }
        cloneTo(destObject) {
            super.cloneTo(destObject);
            var destKeyFrame = destObject;
            destKeyFrame.inTangent = this.inTangent;
            destKeyFrame.outTangent = this.outTangent;
            destKeyFrame.value = this.value;
            destKeyFrame.inTangent = this.inTangent;
            destKeyFrame.outTangent = this.outTangent;
            destKeyFrame.value = this.value;
            destKeyFrame.inWeight = this.inWeight;
            destKeyFrame.outWeight = this.outWeight;
            destKeyFrame.weightedMode = this.weightedMode;
        }
        clone() {
            let f = new FloatKeyframe();
            this.cloneTo(f);
            return f;
        }
    }

    class QuaternionKeyframe extends Keyframe {
        constructor() {
            super();
            this.inTangent = new Laya.Vector4();
            this.outTangent = new Laya.Vector4();
            this.value = new Laya.Quaternion();
            this.inWeight = new Laya.Vector4();
            this.outWeight = new Laya.Vector4();
            this.weightedMode = new Laya.Vector4();
        }
        cloneTo(dest) {
            super.cloneTo(dest);
            var destKeyFarme = dest;
            this.inTangent.cloneTo(destKeyFarme.inTangent);
            this.outTangent.cloneTo(destKeyFarme.outTangent);
            this.value.cloneTo(destKeyFarme.value);
            this.inWeight.cloneTo(destKeyFarme.inWeight);
            this.outWeight.cloneTo(destKeyFarme.outWeight);
            this.weightedMode.cloneTo(destKeyFarme.weightedMode);
        }
    }

    class Vector3Keyframe extends Keyframe {
        constructor() {
            super();
            this.inTangent = new Laya.Vector3();
            this.outTangent = new Laya.Vector3();
            this.value = new Laya.Vector3();
            this.inWeight = new Laya.Vector3(Keyframe.defaultWeight, Keyframe.defaultWeight, Keyframe.defaultWeight);
            this.outWeight = new Laya.Vector3(Keyframe.defaultWeight, Keyframe.defaultWeight, Keyframe.defaultWeight);
            this.weightedMode = new Laya.Vector3(exports.WeightedMode.None, exports.WeightedMode.None, exports.WeightedMode.None);
        }
        cloneTo(dest) {
            super.cloneTo(dest);
            var destKeyFarme = dest;
            this.inTangent.cloneTo(destKeyFarme.inTangent);
            this.outTangent.cloneTo(destKeyFarme.outTangent);
            this.value.cloneTo(destKeyFarme.value);
            this.inWeight.cloneTo(destKeyFarme.inWeight);
            this.outWeight.cloneTo(destKeyFarme.outWeight);
            this.weightedMode.cloneTo(destKeyFarme.weightedMode);
        }
    }

    class AnimationClipParser03 {
        static READ_DATA() {
            AnimationClipParser03._DATA.offset = AnimationClipParser03._reader.getUint32();
            AnimationClipParser03._DATA.size = AnimationClipParser03._reader.getUint32();
        }
        static READ_BLOCK() {
            var count = AnimationClipParser03._BLOCK.count = AnimationClipParser03._reader.getUint16();
            var blockStarts = AnimationClipParser03._BLOCK.blockStarts = [];
            var blockLengths = AnimationClipParser03._BLOCK.blockLengths = [];
            for (var i = 0; i < count; i++) {
                blockStarts.push(AnimationClipParser03._reader.getUint32());
                blockLengths.push(AnimationClipParser03._reader.getUint32());
            }
        }
        static READ_STRINGS() {
            var offset = AnimationClipParser03._reader.getUint32();
            var count = AnimationClipParser03._reader.getUint16();
            var prePos = AnimationClipParser03._reader.pos;
            AnimationClipParser03._reader.pos = offset + AnimationClipParser03._DATA.offset;
            for (var i = 0; i < count; i++)
                AnimationClipParser03._strings[i] = AnimationClipParser03._reader.readUTFString();
            AnimationClipParser03._reader.pos = prePos;
        }
        static parse(clip, reader) {
            AnimationClipParser03._animationClip = clip;
            AnimationClipParser03._reader = reader;
            AnimationClipParser03.READ_DATA();
            AnimationClipParser03.READ_BLOCK();
            AnimationClipParser03.READ_STRINGS();
            for (var i = 0, n = AnimationClipParser03._BLOCK.count; i < n; i++) {
                var index = reader.getUint16();
                var blockName = AnimationClipParser03._strings[index];
                var fn = AnimationClipParser03["READ_" + blockName];
                if (fn == null)
                    throw new Error("model file err,no this function:" + index + " " + blockName);
                else
                    fn.call(null);
            }
        }
        static READ_ANIMATIONS() {
            var i, j;
            var node;
            var reader = AnimationClipParser03._reader;
            var startTimeTypes = [];
            var startTimeTypeCount = reader.getUint16();
            startTimeTypes.length = startTimeTypeCount;
            for (i = 0; i < startTimeTypeCount; i++)
                startTimeTypes[i] = reader.getFloat32();
            var clip = AnimationClipParser03._animationClip;
            clip.name = AnimationClipParser03._strings[reader.getUint16()];
            var clipDur = clip._duration = reader.getFloat32();
            clip.islooping = !!reader.getByte();
            clip._frameRate = reader.getInt16();
            var nodeCount = reader.getInt16();
            var nodes = clip._nodes;
            nodes.count = nodeCount;
            var nodesMap = clip._nodesMap = {};
            var nodesDic = clip._nodesDic = {};
            for (i = 0; i < nodeCount; i++) {
                node = new KeyframeNode();
                nodes.setNodeByIndex(i, node);
                node._indexInList = i;
                var type = node.type = reader.getUint8();
                var pathLength = reader.getUint16();
                node._setOwnerPathCount(pathLength);
                for (j = 0; j < pathLength; j++)
                    node._setOwnerPathByIndex(j, AnimationClipParser03._strings[reader.getUint16()]);
                var nodePath = node._joinOwnerPath("/");
                var mapArray = nodesMap[nodePath];
                (mapArray) || (nodesMap[nodePath] = mapArray = []);
                mapArray.push(node);
                node.propertyOwner = AnimationClipParser03._strings[reader.getUint16()];
                var propertyLength = reader.getUint16();
                node._setPropertyCount(propertyLength);
                for (j = 0; j < propertyLength; j++)
                    node._setPropertyByIndex(j, AnimationClipParser03._strings[reader.getUint16()]);
                var fullPath = nodePath + "." + node.propertyOwner + "." + node._joinProperty(".");
                nodesDic[fullPath] = node;
                node.fullPath = fullPath;
                var keyframeCount = reader.getUint16();
                node._setKeyframeCount(keyframeCount);
                for (j = 0; j < keyframeCount; j++) {
                    switch (type) {
                        case 0:
                            var floatKeyframe = new FloatKeyframe();
                            node._setKeyframeByIndex(j, floatKeyframe);
                            floatKeyframe.time = startTimeTypes[reader.getUint16()];
                            floatKeyframe.inTangent = reader.getFloat32();
                            floatKeyframe.outTangent = reader.getFloat32();
                            floatKeyframe.value = reader.getFloat32();
                            break;
                        case 1:
                        case 3:
                        case 4:
                            var floatArrayKeyframe = new Vector3Keyframe();
                            node._setKeyframeByIndex(j, floatArrayKeyframe);
                            floatArrayKeyframe.time = startTimeTypes[reader.getUint16()];
                            var inTangent = floatArrayKeyframe.inTangent;
                            var outTangent = floatArrayKeyframe.outTangent;
                            var value = floatArrayKeyframe.value;
                            inTangent.x = reader.getFloat32();
                            inTangent.y = reader.getFloat32();
                            inTangent.z = reader.getFloat32();
                            outTangent.x = reader.getFloat32();
                            outTangent.y = reader.getFloat32();
                            outTangent.z = reader.getFloat32();
                            value.x = reader.getFloat32();
                            value.y = reader.getFloat32();
                            value.z = reader.getFloat32();
                            break;
                        case 2:
                            var quaArrayKeyframe = new QuaternionKeyframe();
                            node._setKeyframeByIndex(j, quaArrayKeyframe);
                            quaArrayKeyframe.time = startTimeTypes[reader.getUint16()];
                            var inTangentQua = quaArrayKeyframe.inTangent;
                            var outTangentQua = quaArrayKeyframe.outTangent;
                            var valueQua = quaArrayKeyframe.value;
                            inTangentQua.x = reader.getFloat32();
                            inTangentQua.y = reader.getFloat32();
                            inTangentQua.z = reader.getFloat32();
                            inTangentQua.w = reader.getFloat32();
                            outTangentQua.x = reader.getFloat32();
                            outTangentQua.y = reader.getFloat32();
                            outTangentQua.z = reader.getFloat32();
                            outTangentQua.w = reader.getFloat32();
                            valueQua.x = reader.getFloat32();
                            valueQua.y = reader.getFloat32();
                            valueQua.z = reader.getFloat32();
                            valueQua.w = reader.getFloat32();
                            break;
                        default:
                            throw "AnimationClipParser03:unknown type.";
                    }
                }
            }
            var eventCount = reader.getUint16();
            for (i = 0; i < eventCount; i++) {
                var event = new AnimationEvent();
                event.time = Math.min(clipDur, reader.getFloat32());
                event.eventName = AnimationClipParser03._strings[reader.getUint16()];
                var params = [];
                var paramCount = reader.getUint16();
                (paramCount > 0) && (event.params = params = []);
                for (j = 0; j < paramCount; j++) {
                    var eventType = reader.getByte();
                    switch (eventType) {
                        case 0:
                            params.push(!!reader.getByte());
                            break;
                        case 1:
                            params.push(reader.getInt32());
                            break;
                        case 2:
                            params.push(reader.getFloat32());
                            break;
                        case 3:
                            params.push(AnimationClipParser03._strings[reader.getUint16()]);
                            break;
                        default:
                            throw new Error("unknown type.");
                    }
                }
                clip.addEvent(event);
            }
        }
    }
    AnimationClipParser03._strings = [];
    AnimationClipParser03._BLOCK = { count: 0 };
    AnimationClipParser03._DATA = { offset: 0, size: 0 };

    class Vector2Keyframe extends Keyframe {
        constructor() {
            super();
            this.inTangent = new Laya.Vector2();
            this.outTangent = new Laya.Vector2();
            this.value = new Laya.Vector2();
            this.inWeight = new Laya.Vector2(Keyframe.defaultWeight, Keyframe.defaultWeight);
            this.outWeight = new Laya.Vector2(Keyframe.defaultWeight, Keyframe.defaultWeight);
            this.weightedMode = new Laya.Vector2(exports.WeightedMode.None, exports.WeightedMode.None);
        }
        cloneTo(dest) {
            super.cloneTo(dest);
            var destKeyFarme = dest;
            this.inTangent.cloneTo(destKeyFarme.inTangent);
            this.outTangent.cloneTo(destKeyFarme.outTangent);
            this.value.cloneTo(destKeyFarme.value);
            this.inWeight.cloneTo(destKeyFarme.inWeight);
            this.outWeight.cloneTo(destKeyFarme.outWeight);
            this.weightedMode.cloneTo(destKeyFarme.weightedMode);
        }
    }

    class Vector4Keyframe extends Keyframe {
        constructor() {
            super();
            this.inTangent = new Laya.Vector4();
            this.outTangent = new Laya.Vector4();
            this.value = new Laya.Vector4();
            this.inWeight = new Laya.Vector4(Keyframe.defaultWeight, Keyframe.defaultWeight, Keyframe.defaultWeight, Keyframe.defaultWeight);
            this.outWeight = new Laya.Vector4(Keyframe.defaultWeight, Keyframe.defaultWeight, Keyframe.defaultWeight, Keyframe.defaultWeight);
            this.weightedMode = new Laya.Vector4(exports.WeightedMode.None, exports.WeightedMode.None, exports.WeightedMode.None, exports.WeightedMode.None);
        }
        cloneTo(dest) {
            super.cloneTo(dest);
            var destKeyFarme = dest;
            this.inTangent.cloneTo(destKeyFarme.inTangent);
            this.outTangent.cloneTo(destKeyFarme.outTangent);
            this.value.cloneTo(destKeyFarme.value);
            this.inWeight.cloneTo(destKeyFarme.inWeight);
            this.outWeight.cloneTo(destKeyFarme.outWeight);
            this.weightedMode.cloneTo(destKeyFarme.weightedMode);
        }
    }

    exports.KeyFrameValueType = void 0;
    (function (KeyFrameValueType) {
        KeyFrameValueType[KeyFrameValueType["Float"] = 0] = "Float";
        KeyFrameValueType[KeyFrameValueType["Position"] = 1] = "Position";
        KeyFrameValueType[KeyFrameValueType["Rotation"] = 2] = "Rotation";
        KeyFrameValueType[KeyFrameValueType["Scale"] = 3] = "Scale";
        KeyFrameValueType[KeyFrameValueType["RotationEuler"] = 4] = "RotationEuler";
        KeyFrameValueType[KeyFrameValueType["Vector2"] = 5] = "Vector2";
        KeyFrameValueType[KeyFrameValueType["Vector3"] = 6] = "Vector3";
        KeyFrameValueType[KeyFrameValueType["Vector4"] = 7] = "Vector4";
        KeyFrameValueType[KeyFrameValueType["Color"] = 8] = "Color";
    })(exports.KeyFrameValueType || (exports.KeyFrameValueType = {}));
    class KeyframeNodeOwner {
        constructor() {
            this.indexInList = -1;
            this.referenceCount = 0;
            this.updateMark = -1;
            this.type = -1;
            this.fullPath = null;
            this.nodePath = null;
            this.propertyOwner = null;
            this.property = null;
            this.defaultValue = null;
            this.value = null;
            this.crossFixedValue = null;
            this.isMaterial = false;
        }
        saveCrossFixedValue() {
            var pro = this.propertyOwner;
            if (pro) {
                switch (this.type) {
                    case 0:
                        this.crossFixedValue = this.value;
                        break;
                    case 1:
                    case 3:
                    case 4:
                        this.value.cloneTo(this.crossFixedValue);
                        break;
                    case 2:
                        this.value.cloneTo(this.crossFixedValue);
                        break;
                    default:
                        throw "Animator:unknown type.";
                }
            }
        }
    }

    class AnimationClipParser04 {
        static READ_DATA() {
            AnimationClipParser04._DATA.offset = AnimationClipParser04._reader.getUint32();
            AnimationClipParser04._DATA.size = AnimationClipParser04._reader.getUint32();
        }
        static READ_BLOCK() {
            var count = AnimationClipParser04._BLOCK.count = AnimationClipParser04._reader.getUint16();
            var blockStarts = AnimationClipParser04._BLOCK.blockStarts = [];
            var blockLengths = AnimationClipParser04._BLOCK.blockLengths = [];
            for (var i = 0; i < count; i++) {
                blockStarts.push(AnimationClipParser04._reader.getUint32());
                blockLengths.push(AnimationClipParser04._reader.getUint32());
            }
        }
        static READ_STRINGS() {
            var offset = AnimationClipParser04._reader.getUint32();
            var count = AnimationClipParser04._reader.getUint16();
            var prePos = AnimationClipParser04._reader.pos;
            AnimationClipParser04._reader.pos = offset + AnimationClipParser04._DATA.offset;
            for (var i = 0; i < count; i++)
                AnimationClipParser04._strings[i] = AnimationClipParser04._reader.readUTFString();
            AnimationClipParser04._reader.pos = prePos;
        }
        static parse(clip, reader, version) {
            AnimationClipParser04._animationClip = clip;
            AnimationClipParser04._reader = reader;
            AnimationClipParser04._version = version;
            AnimationClipParser04.READ_DATA();
            AnimationClipParser04.READ_BLOCK();
            AnimationClipParser04.READ_STRINGS();
            for (var i = 0, n = AnimationClipParser04._BLOCK.count; i < n; i++) {
                var index = reader.getUint16();
                var blockName = AnimationClipParser04._strings[index];
                var fn = AnimationClipParser04["READ_" + blockName];
                if (fn == null)
                    throw new Error("model file err,no this function:" + index + " " + blockName);
                else
                    fn.call(null);
            }
            AnimationClipParser04._version = null;
            AnimationClipParser04._reader = null;
            AnimationClipParser04._animationClip = null;
        }
        static READ_ANIMATIONS() {
            var i, j;
            var node;
            var reader = AnimationClipParser04._reader;
            var startTimeTypes = [];
            var startTimeTypeCount = reader.getUint16();
            startTimeTypes.length = startTimeTypeCount;
            for (i = 0; i < startTimeTypeCount; i++)
                startTimeTypes[i] = reader.getFloat32();
            var clip = AnimationClipParser04._animationClip;
            clip.name = AnimationClipParser04._strings[reader.getUint16()];
            var clipDur = clip._duration = reader.getFloat32();
            clip.islooping = !!reader.getByte();
            clip._frameRate = reader.getInt16();
            var nodeCount = reader.getInt16();
            var nodes = clip._nodes;
            nodes.count = nodeCount;
            var nodesMap = clip._nodesMap = {};
            var nodesDic = clip._nodesDic = {};
            for (i = 0; i < nodeCount; i++) {
                node = new KeyframeNode();
                nodes.setNodeByIndex(i, node);
                node._indexInList = i;
                var type = node.type = reader.getUint8();
                var pathLength = reader.getUint16();
                node._setOwnerPathCount(pathLength);
                for (j = 0; j < pathLength; j++)
                    node._setOwnerPathByIndex(j, AnimationClipParser04._strings[reader.getUint16()]);
                var nodePath = node._joinOwnerPath("/");
                var mapArray = nodesMap[nodePath];
                (mapArray) || (nodesMap[nodePath] = mapArray = []);
                mapArray.push(node);
                node.propertyOwner = AnimationClipParser04._strings[reader.getUint16()];
                var propertyLength = reader.getUint16();
                node._setPropertyCount(propertyLength);
                for (j = 0; j < propertyLength; j++)
                    node._setPropertyByIndex(j, AnimationClipParser04._strings[reader.getUint16()]);
                var fullPath = nodePath + "." + node.propertyOwner + "." + node._joinProperty(".");
                nodesDic[fullPath] = node;
                node.fullPath = fullPath;
                node.nodePath = nodePath;
                var keyframeCount = reader.getUint16();
                node._setKeyframeCount(keyframeCount);
                switch (AnimationClipParser04._version) {
                    case "LAYAANIMATION:04":
                        for (j = 0; j < keyframeCount; j++) {
                            switch (type) {
                                case exports.KeyFrameValueType.Float:
                                    var floatKeyframe = new FloatKeyframe();
                                    node._setKeyframeByIndex(j, floatKeyframe);
                                    floatKeyframe.time = startTimeTypes[reader.getUint16()];
                                    floatKeyframe.inTangent = reader.getFloat32();
                                    floatKeyframe.outTangent = reader.getFloat32();
                                    floatKeyframe.value = reader.getFloat32();
                                    break;
                                case exports.KeyFrameValueType.Position:
                                case exports.KeyFrameValueType.Scale:
                                case exports.KeyFrameValueType.RotationEuler:
                                case exports.KeyFrameValueType.Vector3:
                                    var floatArrayKeyframe = new Vector3Keyframe();
                                    node._setKeyframeByIndex(j, floatArrayKeyframe);
                                    floatArrayKeyframe.time = startTimeTypes[reader.getUint16()];
                                    var inTangent = floatArrayKeyframe.inTangent;
                                    var outTangent = floatArrayKeyframe.outTangent;
                                    var value = floatArrayKeyframe.value;
                                    inTangent.x = reader.getFloat32();
                                    inTangent.y = reader.getFloat32();
                                    inTangent.z = reader.getFloat32();
                                    outTangent.x = reader.getFloat32();
                                    outTangent.y = reader.getFloat32();
                                    outTangent.z = reader.getFloat32();
                                    value.x = reader.getFloat32();
                                    value.y = reader.getFloat32();
                                    value.z = reader.getFloat32();
                                    break;
                                case exports.KeyFrameValueType.Rotation:
                                    var quaternionKeyframe = new QuaternionKeyframe();
                                    node._setKeyframeByIndex(j, quaternionKeyframe);
                                    quaternionKeyframe.time = startTimeTypes[reader.getUint16()];
                                    var inTangentQua = quaternionKeyframe.inTangent;
                                    var outTangentQua = quaternionKeyframe.outTangent;
                                    var valueQua = quaternionKeyframe.value;
                                    inTangentQua.x = reader.getFloat32();
                                    inTangentQua.y = reader.getFloat32();
                                    inTangentQua.z = reader.getFloat32();
                                    inTangentQua.w = reader.getFloat32();
                                    outTangentQua.x = reader.getFloat32();
                                    outTangentQua.y = reader.getFloat32();
                                    outTangentQua.z = reader.getFloat32();
                                    outTangentQua.w = reader.getFloat32();
                                    valueQua.x = reader.getFloat32();
                                    valueQua.y = reader.getFloat32();
                                    valueQua.z = reader.getFloat32();
                                    valueQua.w = reader.getFloat32();
                                    break;
                                case exports.KeyFrameValueType.Vector2:
                                    var vec2Keyfram = new Vector2Keyframe();
                                    node._setKeyframeByIndex(j, vec2Keyfram);
                                    vec2Keyfram.time = startTimeTypes[reader.getUint16()];
                                    var inTangentV2 = vec2Keyfram.inTangent;
                                    var outTangentV2 = vec2Keyfram.outTangent;
                                    var valueV2 = vec2Keyfram.value;
                                    inTangentV2.x = reader.getFloat32();
                                    inTangentV2.y = reader.getFloat32();
                                    outTangentV2.x = reader.getFloat32();
                                    outTangentV2.y = reader.getFloat32();
                                    valueV2.x = reader.getFloat32();
                                    valueV2.y = reader.getFloat32();
                                    break;
                                case exports.KeyFrameValueType.Vector4:
                                case exports.KeyFrameValueType.Color:
                                    var vec4Keyfram = new Vector4Keyframe();
                                    node._setKeyframeByIndex(j, vec4Keyfram);
                                    vec4Keyfram.time = startTimeTypes[reader.getUint16()];
                                    var inTangentV4 = vec4Keyfram.inTangent;
                                    var outTangentV4 = vec4Keyfram.outTangent;
                                    var valueV4 = vec4Keyfram.value;
                                    inTangentV4.x = reader.getFloat32();
                                    inTangentV4.y = reader.getFloat32();
                                    inTangentV4.z = reader.getFloat32();
                                    inTangentV4.w = reader.getFloat32();
                                    outTangentV4.x = reader.getFloat32();
                                    outTangentV4.y = reader.getFloat32();
                                    outTangentV4.z = reader.getFloat32();
                                    outTangentV4.w = reader.getFloat32();
                                    valueV4.x = reader.getFloat32();
                                    valueV4.y = reader.getFloat32();
                                    valueV4.z = reader.getFloat32();
                                    valueV4.w = reader.getFloat32();
                                    break;
                                default:
                                    throw "AnimationClipParser04:unknown type.";
                            }
                        }
                        break;
                    case "LAYAANIMATION:WEIGHT_04":
                        for (j = 0; j < keyframeCount; j++) {
                            switch (type) {
                                case exports.KeyFrameValueType.Float:
                                    var floatKeyframe = new FloatKeyframe();
                                    node._setKeyframeByIndex(j, floatKeyframe);
                                    floatKeyframe.time = startTimeTypes[reader.getUint16()];
                                    floatKeyframe.inTangent = reader.getFloat32();
                                    floatKeyframe.outTangent = reader.getFloat32();
                                    floatKeyframe.value = reader.getFloat32();
                                    floatKeyframe.weightedMode = reader.getUint8();
                                    floatKeyframe.inWeight = reader.getFloat32();
                                    floatKeyframe.outWeight = reader.getFloat32();
                                    break;
                                case exports.KeyFrameValueType.Position:
                                case exports.KeyFrameValueType.Scale:
                                case exports.KeyFrameValueType.RotationEuler:
                                case exports.KeyFrameValueType.Vector3:
                                    var floatArrayKeyframe = new Vector3Keyframe();
                                    node._setKeyframeByIndex(j, floatArrayKeyframe);
                                    floatArrayKeyframe.time = startTimeTypes[reader.getUint16()];
                                    var inTangent = floatArrayKeyframe.inTangent;
                                    var outTangent = floatArrayKeyframe.outTangent;
                                    var value = floatArrayKeyframe.value;
                                    let weidhtMode = floatArrayKeyframe.weightedMode;
                                    let inWeight = floatArrayKeyframe.inWeight;
                                    let outWeight = floatArrayKeyframe.outWeight;
                                    inTangent.x = reader.getFloat32();
                                    inTangent.y = reader.getFloat32();
                                    inTangent.z = reader.getFloat32();
                                    outTangent.x = reader.getFloat32();
                                    outTangent.y = reader.getFloat32();
                                    outTangent.z = reader.getFloat32();
                                    value.x = reader.getFloat32();
                                    value.y = reader.getFloat32();
                                    value.z = reader.getFloat32();
                                    weidhtMode.x = reader.getUint8();
                                    weidhtMode.y = reader.getUint8();
                                    weidhtMode.z = reader.getUint8();
                                    inWeight.x = reader.getFloat32();
                                    inWeight.y = reader.getFloat32();
                                    inWeight.z = reader.getFloat32();
                                    outWeight.x = reader.getFloat32();
                                    outWeight.y = reader.getFloat32();
                                    outWeight.z = reader.getFloat32();
                                    break;
                                case exports.KeyFrameValueType.Rotation:
                                    var quaternionKeyframe = new QuaternionKeyframe();
                                    node._setKeyframeByIndex(j, quaternionKeyframe);
                                    quaternionKeyframe.time = startTimeTypes[reader.getUint16()];
                                    var inTangentQua = quaternionKeyframe.inTangent;
                                    var outTangentQua = quaternionKeyframe.outTangent;
                                    var valueQua = quaternionKeyframe.value;
                                    let weightModeV4 = quaternionKeyframe.weightedMode;
                                    let inWeightQua = quaternionKeyframe.inWeight;
                                    let outWeightQua = quaternionKeyframe.outWeight;
                                    inTangentQua.x = reader.getFloat32();
                                    inTangentQua.y = reader.getFloat32();
                                    inTangentQua.z = reader.getFloat32();
                                    inTangentQua.w = reader.getFloat32();
                                    outTangentQua.x = reader.getFloat32();
                                    outTangentQua.y = reader.getFloat32();
                                    outTangentQua.z = reader.getFloat32();
                                    outTangentQua.w = reader.getFloat32();
                                    valueQua.x = reader.getFloat32();
                                    valueQua.y = reader.getFloat32();
                                    valueQua.z = reader.getFloat32();
                                    valueQua.w = reader.getFloat32();
                                    weightModeV4.x = reader.getUint8();
                                    weightModeV4.y = reader.getUint8();
                                    weightModeV4.z = reader.getUint8();
                                    weightModeV4.w = reader.getUint8();
                                    inWeightQua.x = reader.getFloat32();
                                    inWeightQua.y = reader.getFloat32();
                                    inWeightQua.z = reader.getFloat32();
                                    inWeightQua.w = reader.getFloat32();
                                    outWeightQua.x = reader.getFloat32();
                                    outWeightQua.y = reader.getFloat32();
                                    outWeightQua.z = reader.getFloat32();
                                    outWeightQua.w = reader.getFloat32();
                                    break;
                                case exports.KeyFrameValueType.Vector2:
                                    var vec2Keyfram = new Vector2Keyframe();
                                    node._setKeyframeByIndex(j, vec2Keyfram);
                                    vec2Keyfram.time = startTimeTypes[reader.getUint16()];
                                    var inTangentV2 = vec2Keyfram.inTangent;
                                    var outTangentV2 = vec2Keyfram.outTangent;
                                    var valueV2 = vec2Keyfram.value;
                                    let weightModeV2 = vec2Keyfram.weightedMode;
                                    let inWeightV2 = vec2Keyfram.inWeight;
                                    let outWeightV2 = vec2Keyfram.outWeight;
                                    inTangentV2.x = reader.getFloat32();
                                    inTangentV2.y = reader.getFloat32();
                                    outTangentV2.x = reader.getFloat32();
                                    outTangentV2.y = reader.getFloat32();
                                    valueV2.x = reader.getFloat32();
                                    valueV2.y = reader.getFloat32();
                                    weightModeV2.x = reader.getUint8();
                                    weightModeV2.y = reader.getUint8();
                                    inWeightV2.x = reader.getFloat32();
                                    inWeightV2.y = reader.getFloat32();
                                    outWeightV2.x = reader.getFloat32();
                                    outWeightV2.y = reader.getFloat32();
                                    break;
                                case exports.KeyFrameValueType.Vector4:
                                case exports.KeyFrameValueType.Color:
                                    var vec4Keyfram = new Vector4Keyframe();
                                    node._setKeyframeByIndex(j, vec4Keyfram);
                                    vec4Keyfram.time = startTimeTypes[reader.getUint16()];
                                    var inTangentV4 = vec4Keyfram.inTangent;
                                    var outTangentV4 = vec4Keyfram.outTangent;
                                    var valueV4 = vec4Keyfram.value;
                                    var weightMode_V4 = vec4Keyfram.weightedMode;
                                    var inWeightV4 = vec4Keyfram.inWeight;
                                    var outWeightV4 = vec4Keyfram.outWeight;
                                    inTangentV4.x = reader.getFloat32();
                                    inTangentV4.y = reader.getFloat32();
                                    inTangentV4.z = reader.getFloat32();
                                    inTangentV4.w = reader.getFloat32();
                                    outTangentV4.x = reader.getFloat32();
                                    outTangentV4.y = reader.getFloat32();
                                    outTangentV4.z = reader.getFloat32();
                                    outTangentV4.w = reader.getFloat32();
                                    valueV4.x = reader.getFloat32();
                                    valueV4.y = reader.getFloat32();
                                    valueV4.z = reader.getFloat32();
                                    valueV4.w = reader.getFloat32();
                                    weightMode_V4.x = reader.getUint8();
                                    weightMode_V4.y = reader.getUint8();
                                    weightMode_V4.z = reader.getUint8();
                                    weightMode_V4.w = reader.getUint8();
                                    inWeightV4.x = reader.getFloat32();
                                    inWeightV4.y = reader.getFloat32();
                                    inWeightV4.z = reader.getFloat32();
                                    inWeightV4.w = reader.getFloat32();
                                    outWeightV4.x = reader.getFloat32();
                                    outWeightV4.y = reader.getFloat32();
                                    outWeightV4.z = reader.getFloat32();
                                    outWeightV4.w = reader.getFloat32();
                                    break;
                                default:
                                    throw "AnimationClipParser04:unknown type.";
                            }
                        }
                        break;
                    case "LAYAANIMATION:COMPRESSION_04":
                        for (j = 0; j < keyframeCount; j++) {
                            switch (type) {
                                case exports.KeyFrameValueType.Float:
                                    floatKeyframe = new FloatKeyframe();
                                    node._setKeyframeByIndex(j, floatKeyframe);
                                    floatKeyframe.time = startTimeTypes[reader.getUint16()];
                                    floatKeyframe.inTangent = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                    floatKeyframe.outTangent = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                    floatKeyframe.value = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                    break;
                                case exports.KeyFrameValueType.Position:
                                case exports.KeyFrameValueType.Scale:
                                case exports.KeyFrameValueType.RotationEuler:
                                case exports.KeyFrameValueType.Vector3:
                                    floatArrayKeyframe = new Vector3Keyframe();
                                    node._setKeyframeByIndex(j, floatArrayKeyframe);
                                    floatArrayKeyframe.time = startTimeTypes[reader.getUint16()];
                                    inTangent = floatArrayKeyframe.inTangent;
                                    outTangent = floatArrayKeyframe.outTangent;
                                    value = floatArrayKeyframe.value;
                                    inTangent.x = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                    inTangent.y = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                    inTangent.z = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                    outTangent.x = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                    outTangent.y = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                    outTangent.z = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                    value.x = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                    value.y = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                    value.z = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                    break;
                                case exports.KeyFrameValueType.Rotation:
                                    quaternionKeyframe = new QuaternionKeyframe();
                                    node._setKeyframeByIndex(j, quaternionKeyframe);
                                    quaternionKeyframe.time = startTimeTypes[reader.getUint16()];
                                    inTangentQua = quaternionKeyframe.inTangent;
                                    outTangentQua = quaternionKeyframe.outTangent;
                                    valueQua = quaternionKeyframe.value;
                                    inTangentQua.x = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                    inTangentQua.y = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                    inTangentQua.z = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                    inTangentQua.w = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                    outTangentQua.x = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                    outTangentQua.y = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                    outTangentQua.z = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                    outTangentQua.w = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                    valueQua.x = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                    valueQua.y = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                    valueQua.z = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                    valueQua.w = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                    break;
                                case exports.KeyFrameValueType.Vector2:
                                    var vec2Keyfram = new Vector2Keyframe();
                                    node._setKeyframeByIndex(j, vec2Keyfram);
                                    vec2Keyfram.time = startTimeTypes[reader.getUint16()];
                                    var inTangentV2 = vec2Keyfram.inTangent;
                                    var outTangentV2 = vec2Keyfram.outTangent;
                                    var valueV2 = vec2Keyfram.value;
                                    inTangentV2.x = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                    inTangentV2.y = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                    outTangentV2.x = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                    outTangentV2.y = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                    valueV2.x = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                    valueV2.y = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                    break;
                                case exports.KeyFrameValueType.Vector4:
                                case exports.KeyFrameValueType.Color:
                                    var vec4Keyfram = new Vector4Keyframe();
                                    node._setKeyframeByIndex(j, vec4Keyfram);
                                    vec4Keyfram.time = startTimeTypes[reader.getUint16()];
                                    var inTangentV4 = vec4Keyfram.inTangent;
                                    var outTangentV4 = vec4Keyfram.outTangent;
                                    var valueV4 = vec4Keyfram.value;
                                    inTangentV4.x = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                    inTangentV4.y = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                    inTangentV4.z = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                    inTangentV4.w = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                    outTangentV4.x = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                    outTangentV4.y = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                    outTangentV4.z = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                    outTangentV4.w = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                    valueV4.x = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                    valueV4.y = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                    valueV4.z = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                    valueV4.w = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                    break;
                                default:
                                    throw "AnimationClipParser04:unknown type.";
                            }
                        }
                        break;
                }
            }
            var eventCount = reader.getUint16();
            for (i = 0; i < eventCount; i++) {
                var event = new AnimationEvent();
                event.time = Math.min(clipDur, reader.getFloat32());
                event.eventName = AnimationClipParser04._strings[reader.getUint16()];
                var params = [];
                var paramCount = reader.getUint16();
                (paramCount > 0) && (event.params = params = []);
                for (j = 0; j < paramCount; j++) {
                    var eventType = reader.getByte();
                    switch (eventType) {
                        case 0:
                            params.push(!!reader.getByte());
                            break;
                        case 1:
                            params.push(reader.getInt32());
                            break;
                        case 2:
                            params.push(reader.getFloat32());
                            break;
                        case 3:
                            params.push(AnimationClipParser04._strings[reader.getUint16()]);
                            break;
                        default:
                            throw new Error("unknown type.");
                    }
                }
                clip.addEvent(event);
            }
        }
    }
    AnimationClipParser04._strings = [];
    AnimationClipParser04._BLOCK = { count: 0 };
    AnimationClipParser04._DATA = { offset: 0, size: 0 };

    class KeyframeNodeList {
        constructor() {
            this._nodes = [];
        }
        get count() {
            return this._nodes.length;
        }
        set count(value) {
            this._nodes.length = value;
        }
        getNodeByIndex(index) {
            return this._nodes[index];
        }
        setNodeByIndex(index, node) {
            this._nodes[index] = node;
        }
    }

    class AnimationClip extends Laya.Resource {
        constructor() {
            super();
            this._duration = 0;
            this._frameRate = 0;
            this._nodes = new KeyframeNodeList();
            this.islooping = false;
            this._animationEvents = [];
        }
        static _parse(data) {
            var clip = new AnimationClip();
            var reader = new Laya.Byte(data);
            var version = reader.readUTFString();
            switch (version) {
                case "LAYAANIMATION:03":
                    AnimationClipParser03.parse(clip, reader);
                    break;
                case "LAYAANIMATION:04":
                case "LAYAANIMATION:COMPRESSION_04":
                case "LAYAANIMATION:WEIGHT_04":
                    AnimationClipParser04.parse(clip, reader, version);
                    break;
                default:
                    throw "unknown animationClip version.";
            }
            return clip;
        }
        static load(url, complete) {
            Laya.ILaya.loader.load(url, complete, null, Laya.Loader.ANIMATIONCLIP);
        }
        duration() {
            return this._duration;
        }
        _weightModeHermite(weightMode, nextweightMode) {
            return (((weightMode & exports.WeightedMode.Out) == 0) && ((nextweightMode & exports.WeightedMode.In) == 0));
        }
        _hermiteInterpolate(frame, nextFrame, t, dur) {
            var t0 = frame.outTangent, t1 = nextFrame.inTangent;
            if (Number.isFinite(t0) && Number.isFinite(t1)) {
                var t2 = t * t;
                var t3 = t2 * t;
                var a = 2.0 * t3 - 3.0 * t2 + 1.0;
                var b = t3 - 2.0 * t2 + t;
                var c = t3 - t2;
                var d = -2.0 * t3 + 3.0 * t2;
                return a * frame.value + b * t0 * dur + c * t1 * dur + d * nextFrame.value;
            }
            else
                return frame.value;
        }
        _hermiteInterpolateVector3(frame, nextFrame, t, dur, out) {
            var p0 = frame.value;
            var tan0 = frame.outTangent;
            var p1 = nextFrame.value;
            var tan1 = nextFrame.inTangent;
            var t2 = t * t;
            var t3 = t2 * t;
            var a = 2.0 * t3 - 3.0 * t2 + 1.0;
            var b = t3 - 2.0 * t2 + t;
            var c = t3 - t2;
            var d = -2.0 * t3 + 3.0 * t2;
            var t0 = tan0.x, t1 = tan1.x;
            if (this._weightModeHermite(frame.weightedMode.x, nextFrame.weightedMode.x)) {
                if (Number.isFinite(t0) && Number.isFinite(t1))
                    out.x = a * p0.x + b * t0 * dur + c * t1 * dur + d * p1.x;
                else
                    out.x = p0.x;
            }
            else {
                out.x = this._hermiteCurveSplineWeight(frame.value.x, frame.time, frame.outWeight.x, frame.outTangent.x, nextFrame.value.x, nextFrame.time, nextFrame.inWeight.x, nextFrame.inTangent.x, t);
            }
            t0 = tan0.y, t1 = tan1.y;
            if (this._weightModeHermite(frame.weightedMode.y, nextFrame.weightedMode.y)) {
                if (Number.isFinite(t0) && Number.isFinite(t1))
                    out.y = a * p0.y + b * t0 * dur + c * t1 * dur + d * p1.y;
                else
                    out.y = p0.y;
            }
            else {
                out.y = this._hermiteCurveSplineWeight(frame.value.y, frame.time, frame.outWeight.y, frame.outTangent.y, nextFrame.value.y, nextFrame.time, nextFrame.inWeight.y, nextFrame.inTangent.y, t);
            }
            t0 = tan0.z, t1 = tan1.z;
            if (this._weightModeHermite(frame.weightedMode.z, nextFrame.weightedMode.z)) {
                if (Number.isFinite(t0) && Number.isFinite(t1))
                    out.z = a * p0.z + b * t0 * dur + c * t1 * dur + d * p1.z;
                else
                    out.z = p0.z;
            }
            else {
                out.z = this._hermiteCurveSplineWeight(frame.value.z, frame.time, frame.outWeight.z, frame.outTangent.z, nextFrame.value.z, nextFrame.time, nextFrame.inWeight.z, nextFrame.inTangent.z, t);
            }
        }
        _hermiteInterpolateQuaternion(frame, nextFrame, t, dur, out) {
            var p0 = frame.value;
            var tan0 = frame.outTangent;
            var p1 = nextFrame.value;
            var tan1 = nextFrame.inTangent;
            var t2 = t * t;
            var t3 = t2 * t;
            var a = 2.0 * t3 - 3.0 * t2 + 1.0;
            var b = t3 - 2.0 * t2 + t;
            var c = t3 - t2;
            var d = -2.0 * t3 + 3.0 * t2;
            var t0 = tan0.x, t1 = tan1.x;
            if (this._weightModeHermite(frame.weightedMode.x, nextFrame.weightedMode.x)) {
                if (Number.isFinite(t0) && Number.isFinite(t1))
                    out.x = a * p0.x + b * t0 * dur + c * t1 * dur + d * p1.x;
                else
                    out.x = p0.x;
            }
            else {
                out.x = this._hermiteCurveSplineWeight(frame.value.x, frame.time, frame.outWeight.x, frame.outTangent.x, nextFrame.value.x, nextFrame.time, nextFrame.inWeight.x, nextFrame.inTangent.x, t);
            }
            t0 = tan0.y, t1 = tan1.y;
            if (this._weightModeHermite(frame.weightedMode.y, nextFrame.weightedMode.y)) {
                if (Number.isFinite(t0) && Number.isFinite(t1))
                    out.y = a * p0.y + b * t0 * dur + c * t1 * dur + d * p1.y;
                else
                    out.y = p0.y;
            }
            else {
                out.y = this._hermiteCurveSplineWeight(frame.value.y, frame.time, frame.outWeight.y, frame.outTangent.y, nextFrame.value.y, nextFrame.time, nextFrame.inWeight.y, nextFrame.inTangent.y, t);
            }
            t0 = tan0.z, t1 = tan1.z;
            if (this._weightModeHermite(frame.weightedMode.z, nextFrame.weightedMode.z)) {
                if (Number.isFinite(t0) && Number.isFinite(t1))
                    out.z = a * p0.z + b * t0 * dur + c * t1 * dur + d * p1.z;
                else
                    out.z = p0.z;
            }
            else {
                out.z = this._hermiteCurveSplineWeight(frame.value.z, frame.time, frame.outWeight.z, frame.outTangent.z, nextFrame.value.z, nextFrame.time, nextFrame.inWeight.z, nextFrame.inTangent.z, t);
            }
            t0 = tan0.w, t1 = tan1.w;
            if (this._weightModeHermite(frame.weightedMode.w, nextFrame.weightedMode.w)) {
                if (Number.isFinite(t0) && Number.isFinite(t1))
                    out.w = a * p0.w + b * t0 * dur + c * t1 * dur + d * p1.w;
                else
                    out.w = p0.w;
            }
            else {
                out.w = this._hermiteCurveSplineWeight(frame.value.w, frame.time, frame.outWeight.w, frame.outTangent.w, nextFrame.value.w, nextFrame.time, nextFrame.inWeight.w, nextFrame.inTangent.w, t);
            }
        }
        _hermiteInterpolateVector4(frame, nextFrame, t, dur, out) {
            var p0 = frame.value;
            var tan0 = frame.outTangent;
            var p1 = nextFrame.value;
            var tan1 = nextFrame.inTangent;
            var t2 = t * t;
            var t3 = t2 * t;
            var a = 2.0 * t3 - 3.0 * t2 + 1.0;
            var b = t3 - 2.0 * t2 + t;
            var c = t3 - t2;
            var d = -2.0 * t3 + 3.0 * t2;
            var t0 = tan0.x, t1 = tan1.x;
            if (this._weightModeHermite(frame.weightedMode.x, nextFrame.weightedMode.x)) {
                if (Number.isFinite(t0) && Number.isFinite(t1))
                    out.x = a * p0.x + b * t0 * dur + c * t1 * dur + d * p1.x;
                else
                    out.x = p0.x;
            }
            else {
                out.x = this._hermiteCurveSplineWeight(frame.value.x, frame.time, frame.outWeight.x, frame.outTangent.x, nextFrame.value.x, nextFrame.time, nextFrame.inWeight.x, nextFrame.inTangent.x, t);
            }
            t0 = tan0.y, t1 = tan1.y;
            if (this._weightModeHermite(frame.weightedMode.y, nextFrame.weightedMode.y)) {
                if (Number.isFinite(t0) && Number.isFinite(t1))
                    out.y = a * p0.y + b * t0 * dur + c * t1 * dur + d * p1.y;
                else
                    out.y = p0.y;
            }
            else {
                out.y = this._hermiteCurveSplineWeight(frame.value.y, frame.time, frame.outWeight.y, frame.outTangent.y, nextFrame.value.y, nextFrame.time, nextFrame.inWeight.y, nextFrame.inTangent.y, t);
            }
            t0 = tan0.z, t1 = tan1.z;
            if (this._weightModeHermite(frame.weightedMode.z, nextFrame.weightedMode.z)) {
                if (Number.isFinite(t0) && Number.isFinite(t1))
                    out.z = a * p0.z + b * t0 * dur + c * t1 * dur + d * p1.z;
                else
                    out.z = p0.z;
            }
            else {
                out.z = this._hermiteCurveSplineWeight(frame.value.z, frame.time, frame.outWeight.z, frame.outTangent.z, nextFrame.value.z, nextFrame.time, nextFrame.inWeight.z, nextFrame.inTangent.z, t);
            }
            t0 = tan0.w, t1 = tan1.w;
            if (this._weightModeHermite(frame.weightedMode.w, nextFrame.weightedMode.w)) {
                if (Number.isFinite(t0) && Number.isFinite(t1))
                    out.w = a * p0.w + b * t0 * dur + c * t1 * dur + d * p1.w;
                else
                    out.w = p0.w;
            }
            else {
                out.w = this._hermiteCurveSplineWeight(frame.value.w, frame.time, frame.outWeight.w, frame.outTangent.w, nextFrame.value.w, nextFrame.time, nextFrame.inWeight.w, nextFrame.inTangent.w, t);
            }
        }
        _hermiteInterpolateVector2(frame, nextFrame, t, dur, out) {
            var p0 = frame.value;
            var tan0 = frame.outTangent;
            var p1 = nextFrame.value;
            var tan1 = nextFrame.inTangent;
            var t2 = t * t;
            var t3 = t2 * t;
            var a = 2.0 * t3 - 3.0 * t2 + 1.0;
            var b = t3 - 2.0 * t2 + t;
            var c = t3 - t2;
            var d = -2.0 * t3 + 3.0 * t2;
            var t0 = tan0.x, t1 = tan1.x;
            if (this._weightModeHermite(frame.weightedMode.x, nextFrame.weightedMode.x)) {
                if (Number.isFinite(t0) && Number.isFinite(t1))
                    out.x = a * p0.x + b * t0 * dur + c * t1 * dur + d * p1.x;
                else
                    out.x = p0.x;
            }
            else {
                out.x = this._hermiteCurveSplineWeight(frame.value.x, frame.time, frame.outWeight.x, frame.outTangent.x, nextFrame.value.x, nextFrame.time, nextFrame.inWeight.x, nextFrame.inTangent.x, t);
            }
            t0 = tan0.y, t1 = tan1.y;
            if (this._weightModeHermite(frame.weightedMode.y, nextFrame.weightedMode.y)) {
                if (Number.isFinite(t0) && Number.isFinite(t1))
                    out.y = a * p0.y + b * t0 * dur + c * t1 * dur + d * p1.y;
                else
                    out.y = p0.y;
            }
            else {
                out.y = this._hermiteCurveSplineWeight(frame.value.y, frame.time, frame.outWeight.y, frame.outTangent.y, nextFrame.value.y, nextFrame.time, nextFrame.inWeight.y, nextFrame.inTangent.y, t);
            }
        }
        _hermiteCurveSplineWeight(frameValue, frametime, frameOutWeight, frameOutTangent, nextframeValue, nextframetime, nextframeInweight, nextframeIntangent, time) {
            let Eps = 2.22e-16;
            let x = time;
            let x1 = frametime;
            let y1 = frameValue;
            let wt1 = frameOutWeight;
            let x2 = nextframetime;
            let y2 = nextframeValue;
            let wt2 = nextframeInweight;
            let dx = x2 - x1;
            let dy = y2 - y1;
            dy = Math.max(Math.abs(dy), Eps) * (dy < 0 ? -1 : 1);
            let yp1 = frameOutTangent;
            let yp2 = nextframeIntangent;
            if (!Number.isFinite(yp1) || !Number.isFinite(yp2)) {
                return frameValue;
            }
            yp1 = yp1 * dx / dy;
            yp2 = yp2 * dx / dy;
            let wt2s = 1 - wt2;
            let t = 0.5;
            let t2 = 0;
            if (Math.abs(wt1 - 0.33333334) < 0.0001 && Math.abs(wt2 - 0.33333334) < 0.0001) {
                t = x;
                t2 = 1 - t;
            }
            else {
                while (true) {
                    t2 = (1 - t);
                    let fg = 3 * t2 * t2 * t * wt1 + 3 * t2 * t * t * wt2s + t * t * t - x;
                    if (Math.abs(fg) <= 2.5 * Eps)
                        break;
                    let fpg = 3 * t2 * t2 * wt1 + 6 * t2 * t * (wt2s - wt1) + 3 * t * t * (1 - wt2s);
                    let fppg = 6 * t2 * (wt2s - 2 * wt1) + 6 * t * (1 - 2 * wt2s + wt1);
                    let fpppg = 18 * wt1 - 18 * wt2s + 6;
                    t -= (6 * fg * fpg * fpg - 3 * fg * fg * fppg) / (6 * fpg * fpg * fpg - 6 * fg * fpg * fppg + fg * fg * fpppg);
                }
            }
            let y = 3 * t2 * t2 * t * wt1 * yp1 + 3 * t2 * t * t * (1 - wt2 * yp2) + t * t * t;
            return y * dy + y1;
        }
        _curveInterpolate(frame, nextFrame, t, dur) {
            if (this._weightModeHermite(frame.weightedMode, nextFrame.weightedMode)) {
                return this._hermiteInterpolate(frame, nextFrame, t, dur);
            }
            else {
                return this._hermiteCurveSplineWeight(frame.value, frame.time, frame.outWeight, frame.outTangent, nextFrame.value, nextFrame.time, nextFrame.inWeight, nextFrame.inTangent, t);
            }
        }
        _evaluateClipDatasRealTime(nodes, playCurTime, realTimeCurrentFrameIndexes, addtive, frontPlay, outDatas, avatarMask) {
            for (var i = 0, n = nodes.count; i < n; i++) {
                var node = nodes.getNodeByIndex(i);
                var type = node.type;
                var nextFrameIndex;
                var keyFrames = node._keyFrames;
                var keyFramesCount = keyFrames.length;
                var frameIndex = realTimeCurrentFrameIndexes[i];
                if (avatarMask && (!avatarMask.getTransformActive(node.nodePath))) {
                    continue;
                }
                if (frontPlay) {
                    if ((frameIndex !== -1) && (playCurTime < keyFrames[frameIndex].time)) {
                        frameIndex = -1;
                        realTimeCurrentFrameIndexes[i] = frameIndex;
                    }
                    nextFrameIndex = frameIndex + 1;
                    while (nextFrameIndex < keyFramesCount) {
                        if (keyFrames[nextFrameIndex].time > playCurTime)
                            break;
                        frameIndex++;
                        nextFrameIndex++;
                        realTimeCurrentFrameIndexes[i] = frameIndex;
                    }
                }
                else {
                    nextFrameIndex = frameIndex + 1;
                    if ((nextFrameIndex !== keyFramesCount) && (playCurTime > keyFrames[nextFrameIndex].time)) {
                        frameIndex = keyFramesCount - 1;
                        realTimeCurrentFrameIndexes[i] = frameIndex;
                    }
                    nextFrameIndex = frameIndex + 1;
                    while (frameIndex > -1) {
                        if (keyFrames[frameIndex].time < playCurTime)
                            break;
                        frameIndex--;
                        nextFrameIndex--;
                        realTimeCurrentFrameIndexes[i] = frameIndex;
                    }
                }
                var isEnd = nextFrameIndex === keyFramesCount;
                switch (type) {
                    case exports.KeyFrameValueType.Float:
                        if (frameIndex !== -1) {
                            var frame = keyFrames[frameIndex];
                            if (isEnd) {
                                outDatas[i] = frame.value;
                            }
                            else {
                                var nextFarme = keyFrames[nextFrameIndex];
                                var d = nextFarme.time - frame.time;
                                var t;
                                if (d !== 0)
                                    t = (playCurTime - frame.time) / d;
                                else
                                    t = 0;
                                outDatas[i] = this._curveInterpolate(frame, nextFarme, t, d);
                            }
                        }
                        else {
                            outDatas[i] = keyFrames[0].value;
                        }
                        if (addtive)
                            outDatas[i] = outDatas[i] - keyFrames[0].value;
                        break;
                    case exports.KeyFrameValueType.Position:
                    case exports.KeyFrameValueType.RotationEuler:
                    case exports.KeyFrameValueType.Vector3:
                        var clipData = outDatas[i];
                        this._evaluateFrameNodeVector3DatasRealTime(keyFrames, frameIndex, isEnd, playCurTime, clipData);
                        if (addtive) {
                            var firstFrameValue = keyFrames[0].value;
                            clipData.x -= firstFrameValue.x;
                            clipData.y -= firstFrameValue.y;
                            clipData.z -= firstFrameValue.z;
                        }
                        break;
                    case exports.KeyFrameValueType.Rotation:
                        var clipQuat = outDatas[i];
                        this._evaluateFrameNodeQuaternionDatasRealTime(keyFrames, frameIndex, isEnd, playCurTime, clipQuat);
                        if (addtive) {
                            var tempQuat = AnimationClip._tempQuaternion0;
                            var firstFrameValueQua = keyFrames[0].value;
                            Utils3D.quaternionConjugate(firstFrameValueQua, tempQuat);
                            Laya.Quaternion.multiply(tempQuat, clipQuat, clipQuat);
                        }
                        break;
                    case exports.KeyFrameValueType.Scale:
                        clipData = outDatas[i];
                        this._evaluateFrameNodeVector3DatasRealTime(keyFrames, frameIndex, isEnd, playCurTime, clipData);
                        if (addtive) {
                            firstFrameValue = keyFrames[0].value;
                            clipData.x /= firstFrameValue.x;
                            clipData.y /= firstFrameValue.y;
                            clipData.z /= firstFrameValue.z;
                        }
                        break;
                    case exports.KeyFrameValueType.Vector2:
                        var v2Data = outDatas[i];
                        this._evaluateFrameNodeVector2DatasRealTime(keyFrames, frameIndex, isEnd, playCurTime, v2Data);
                        if (addtive) {
                            var v2FrameValue = keyFrames[0].value;
                            v2Data.x -= v2FrameValue.x;
                            v2Data.y -= v2FrameValue.y;
                        }
                        break;
                    case exports.KeyFrameValueType.Vector4:
                    case exports.KeyFrameValueType.Color:
                        var v4Data = outDatas[i];
                        this._evaluateFrameNodeVector4DatasRealTime(keyFrames, frameIndex, isEnd, playCurTime, v4Data);
                        if (addtive) {
                            var v4FrameValue = keyFrames[0].value;
                            v4Data.x -= v4FrameValue.x;
                            v4Data.y -= v4FrameValue.y;
                            v4Data.z -= v4FrameValue.z;
                            v4Data.w -= v4FrameValue.w;
                        }
                        break;
                    default:
                        throw "AnimationClip:unknown node type.";
                }
            }
        }
        _evaluateFrameNodeVector3DatasRealTime(keyFrames, frameIndex, isEnd, playCurTime, outDatas) {
            if (frameIndex !== -1) {
                var frame = keyFrames[frameIndex];
                if (isEnd) {
                    var frameData = frame.value;
                    outDatas.x = frameData.x;
                    outDatas.y = frameData.y;
                    outDatas.z = frameData.z;
                }
                else {
                    var nextKeyFrame = keyFrames[frameIndex + 1];
                    var t;
                    var startTime = frame.time;
                    var d = nextKeyFrame.time - startTime;
                    if (d !== 0)
                        t = (playCurTime - startTime) / d;
                    else
                        t = 0;
                    this._hermiteInterpolateVector3(frame, nextKeyFrame, t, d, outDatas);
                }
            }
            else {
                var firstFrameDatas = keyFrames[0].value;
                outDatas.x = firstFrameDatas.x;
                outDatas.y = firstFrameDatas.y;
                outDatas.z = firstFrameDatas.z;
            }
        }
        _evaluateFrameNodeVector2DatasRealTime(keyFrames, frameIndex, isEnd, playCurTime, outDatas) {
            if (frameIndex !== -1) {
                var frame = keyFrames[frameIndex];
                if (isEnd) {
                    var frameData = frame.value;
                    outDatas.x = frameData.x;
                    outDatas.y = frameData.y;
                }
                else {
                    var nextKeyFrame = keyFrames[frameIndex + 1];
                    var t;
                    var startTime = frame.time;
                    var d = nextKeyFrame.time - startTime;
                    if (d !== 0)
                        t = (playCurTime - startTime) / d;
                    else
                        t = 0;
                    this._hermiteInterpolateVector2(frame, nextKeyFrame, t, d, outDatas);
                }
            }
            else {
                var firstFrameDatas = keyFrames[0].value;
                outDatas.x = firstFrameDatas.x;
                outDatas.y = firstFrameDatas.y;
            }
        }
        _evaluateFrameNodeVector4DatasRealTime(keyFrames, frameIndex, isEnd, playCurTime, outDatas) {
            if (frameIndex !== -1) {
                var frame = keyFrames[frameIndex];
                if (isEnd) {
                    var frameData = frame.value;
                    outDatas.x = frameData.x;
                    outDatas.y = frameData.y;
                    outDatas.z = frameData.z;
                }
                else {
                    var nextKeyFrame = keyFrames[frameIndex + 1];
                    var t;
                    var startTime = frame.time;
                    var d = nextKeyFrame.time - startTime;
                    if (d !== 0)
                        t = (playCurTime - startTime) / d;
                    else
                        t = 0;
                    this._hermiteInterpolateVector4(frame, nextKeyFrame, t, d, outDatas);
                }
            }
            else {
                var firstFrameDatas = keyFrames[0].value;
                outDatas.x = firstFrameDatas.x;
                outDatas.y = firstFrameDatas.y;
                outDatas.z = firstFrameDatas.z;
            }
        }
        _evaluateFrameNodeQuaternionDatasRealTime(keyFrames, frameIndex, isEnd, playCurTime, outDatas) {
            if (frameIndex !== -1) {
                var frame = keyFrames[frameIndex];
                if (isEnd) {
                    var frameData = frame.value;
                    outDatas.x = frameData.x;
                    outDatas.y = frameData.y;
                    outDatas.z = frameData.z;
                    outDatas.w = frameData.w;
                }
                else {
                    var nextKeyFrame = keyFrames[frameIndex + 1];
                    var t;
                    var startTime = frame.time;
                    var d = nextKeyFrame.time - startTime;
                    if (d !== 0)
                        t = (playCurTime - startTime) / d;
                    else
                        t = 0;
                    this._hermiteInterpolateQuaternion(frame, nextKeyFrame, t, d, outDatas);
                }
            }
            else {
                var firstFrameDatas = keyFrames[0].value;
                outDatas.x = firstFrameDatas.x;
                outDatas.y = firstFrameDatas.y;
                outDatas.z = firstFrameDatas.z;
                outDatas.w = firstFrameDatas.w;
            }
        }
        _binarySearchEventIndex(time) {
            var start = 0;
            var end = this._animationEvents.length - 1;
            var mid;
            while (start <= end) {
                mid = Math.floor((start + end) / 2);
                var midValue = this._animationEvents[mid].time;
                if (midValue == time)
                    return mid;
                else if (midValue > time)
                    end = mid - 1;
                else
                    start = mid + 1;
            }
            return start;
        }
        addEvent(event) {
            var index = this._binarySearchEventIndex(event.time);
            this._animationEvents.splice(index, 0, event);
        }
        _disposeResource() {
            this._nodes = null;
            this._nodesMap = null;
        }
    }
    AnimationClip._tempQuaternion0 = new Laya.Quaternion();

    exports.StaticFlag = void 0;
    (function (StaticFlag) {
        StaticFlag[StaticFlag["Normal"] = 1] = "Normal";
        StaticFlag[StaticFlag["StaticBatch"] = 2] = "StaticBatch";
    })(exports.StaticFlag || (exports.StaticFlag = {}));
    class Sprite3D extends Laya.Node {
        constructor(name = null, isStatic = false) {
            super();
            this._isRenderNode = 0;
            this._id = ++Sprite3D._uniqueIDCounter;
            this._is3D = true;
            this._transform = Laya.LayaGL.renderOBJCreate.createTransform(this);
            this._isStatic = isStatic ? exports.StaticFlag.StaticBatch : exports.StaticFlag.Normal;
            this.layer = 0;
            this.name = name ? name : "New Sprite3D";
        }
        static __init__() {
            Sprite3D.WORLDMATRIX = Laya.Shader3D.propertyNameToID("u_WorldMat");
            Sprite3D.sprite3DCommandUniformMap = Laya.LayaGL.renderOBJCreate.createGlobalUniformMap("Sprite3D");
            Sprite3D.sprite3DCommandUniformMap.addShaderUniform(Sprite3D.WORLDMATRIX, "u_WorldMat");
        }
        static instantiate(original, parent = null, worldPositionStays = true, position = null, rotation = null) {
            var destSprite3D = original.clone();
            (parent) && (parent.addChild(destSprite3D));
            var transform = destSprite3D.transform;
            if (worldPositionStays) {
                var worldMatrix = transform.worldMatrix;
                original.transform.worldMatrix.cloneTo(worldMatrix);
                transform.worldMatrix = worldMatrix;
            }
            else {
                (position) && (transform.position = position);
                (rotation) && (transform.rotation = rotation);
            }
            return destSprite3D;
        }
        static load(url, complete) {
            Laya.ILaya.loader.load(url).then((res) => {
                complete && complete.runWith([res === null || res === void 0 ? void 0 : res.create()]);
            });
        }
        get id() {
            return this._id;
        }
        get layer() {
            return this._layer;
        }
        set layer(value) {
            if (this._layer !== value) {
                if (value >= 0 && value <= 30) {
                    this._layer = value;
                    this.event(Laya.Event.LAYERCHANGE, value);
                }
                else {
                    throw new Error("Layer value must be 0-30.");
                }
            }
        }
        get isStatic() {
            return !!(this._isStatic >> 1 | 0x0);
        }
        set isStatic(value) {
            this._isStatic = value ? exports.StaticFlag.StaticBatch : exports.StaticFlag.Normal;
            this.event(Laya.Event.staticMask, this._isStatic);
        }
        get transform() {
            return this._transform;
        }
        get scene() {
            return this._scene;
        }
        _onActive() {
            super._onActive();
            Laya.Stat.sprite3DCount++;
        }
        _onInActive() {
            super._onInActive();
            Laya.Stat.sprite3DCount--;
        }
        _onAdded() {
            if (this._parent instanceof Sprite3D) {
                var parent3D = this._parent;
                this.transform._setParent(parent3D.transform);
            }
            super._onAdded();
        }
        _onRemoved() {
            super._onRemoved();
            if (this._parent instanceof Sprite3D)
                this.transform._setParent(null);
        }
        onStartListeningToType(type) {
            super.onStartListeningToType(type);
            if (type.startsWith("collision"))
                this._setBit(Laya.NodeFlags.PROCESS_COLLISIONS, true);
            else if (type.startsWith("trigger"))
                this._setBit(Laya.NodeFlags.PROCESS_TRIGGERS, true);
        }
        _parse(data, spriteMap) {
            (data.isStatic !== undefined) && (this.isStatic = data.isStatic);
            (data.active !== undefined) && (this.active = data.active);
            (data.name != undefined) && (this.name = data.name);
            if (data.position !== undefined) {
                var loccalPosition = this.transform.localPosition;
                loccalPosition.fromArray(data.position);
                this.transform.localPosition = loccalPosition;
            }
            if (data.rotationEuler !== undefined) {
                var localRotationEuler = this.transform.localRotationEuler;
                localRotationEuler.fromArray(data.rotationEuler);
                this.transform.localRotationEuler = localRotationEuler;
            }
            if (data.rotation !== undefined) {
                var localRotation = this.transform.localRotation;
                localRotation.fromArray(data.rotation);
                this.transform.localRotation = localRotation;
            }
            if (data.scale !== undefined) {
                var localScale = this.transform.localScale;
                localScale.fromArray(data.scale);
                this.transform.localScale = localScale;
            }
            (data.layer != undefined) && (this.layer = data.layer);
        }
        _cloneTo(destObject, srcRoot, dstRoot) {
            if (this._destroyed)
                throw new Error("Sprite3D: Can't be cloned if the Sprite3D has destroyed.");
            var destSprite3D = destObject;
            var trans = this._transform;
            var destTrans = destSprite3D._transform;
            destSprite3D.name = this.name;
            destSprite3D._destroyed = this._destroyed;
            destSprite3D.active = this.active;
            destTrans.localPosition = trans.localPosition;
            destTrans.localRotation = trans.localRotation;
            destTrans.localScale = trans.localScale;
            destSprite3D._isStatic = this._isStatic;
            destSprite3D.layer = this.layer;
            super._cloneTo(destSprite3D, srcRoot, dstRoot);
        }
        static _createSprite3DInstance(scrSprite) {
            var node = scrSprite._create();
            var children = scrSprite._children;
            for (var i = 0, n = children.length; i < n; i++) {
                var child = Sprite3D._createSprite3DInstance(children[i]);
                node.addChild(child);
            }
            return node;
        }
        static _parseSprite3DInstance(srcRoot, dstRoot, scrSprite, dstSprite) {
            var srcChildren = scrSprite._children;
            var dstChildren = dstSprite._children;
            for (var i = 0, n = srcChildren.length; i < n; i++)
                Sprite3D._parseSprite3DInstance(srcRoot, dstRoot, srcChildren[i], dstChildren[i]);
            scrSprite._cloneTo(dstSprite, srcRoot, dstRoot);
        }
        clone() {
            var dstSprite3D = Sprite3D._createSprite3DInstance(this);
            Sprite3D._parseSprite3DInstance(this, dstSprite3D, this, dstSprite3D);
            return dstSprite3D;
        }
        destroy(destroyChild = true) {
            if (this._destroyed)
                return;
            super.destroy(destroyChild);
            this._transform = null;
        }
        _create() {
            return new Sprite3D();
        }
    }
    Sprite3D._uniqueIDCounter = 0;

    class LightBound {
    }
    class ClusterData {
        constructor() {
            this.updateMark = -1;
            this.pointLightCount = 0;
            this.spotLightCount = 0;
            this.indices = [];
        }
    }
    class Cluster {
        constructor(xSlices, ySlices, zSlices, maxLightsPerClusterAverage) {
            this._updateMark = 0;
            this._depthSliceParam = new Laya.Vector2();
            this._xSlices = xSlices;
            this._ySlices = ySlices;
            this._zSlices = zSlices;
            var clusterTexWidth = xSlices * ySlices;
            var clisterTexHeight = zSlices * (1 + Math.ceil(maxLightsPerClusterAverage / 4));
            this._clusterTexture = Utils3D._createFloatTextureBuffer(clusterTexWidth, clisterTexHeight);
            this._clusterTexture.lock = true;
            this._clusterPixels = new Float32Array(clusterTexWidth * clisterTexHeight * 4);
            var clusterDatas = new Array(this._zSlices);
            for (var z = 0; z < this._zSlices; z++) {
                clusterDatas[z] = new Array(this._ySlices);
                for (var y = 0; y < this._ySlices; y++) {
                    clusterDatas[z][y] = new Array(this._xSlices);
                    for (var x = 0; x < this._xSlices; x++)
                        clusterDatas[z][y][x] = new ClusterData();
                }
            }
            this._clusterDatas = clusterDatas;
        }
        _placePointLightToClusters(lightIndex, lightBound) {
            var clusterDatas = this._clusterDatas;
            var updateMark = this._updateMark;
            for (var z = lightBound.zMin, zEnd = lightBound.zMax; z < zEnd; z++) {
                for (var y = lightBound.yMin, yEnd = lightBound.yMax; y < yEnd; y++) {
                    for (var x = lightBound.xMin, xEnd = lightBound.xMax; x < xEnd; x++) {
                        var data = clusterDatas[z][y][x];
                        if (data.updateMark != updateMark) {
                            data.pointLightCount = 0;
                            data.spotLightCount = 0;
                            data.updateMark = updateMark;
                        }
                        var indices = data.indices;
                        var lightCount = data.pointLightCount++;
                        if (lightCount < indices.length)
                            indices[lightCount] = lightIndex;
                        else
                            indices.push(lightIndex);
                    }
                }
            }
        }
        _placeSpotLightToClusters(lightIndex, lightBound) {
            var clusterDatas = this._clusterDatas;
            var updateMark = this._updateMark;
            for (var z = lightBound.zMin, zEnd = lightBound.zMax; z < zEnd; z++) {
                for (var y = lightBound.yMin, yEnd = lightBound.yMax; y < yEnd; y++) {
                    for (var x = lightBound.xMin, xEnd = lightBound.xMax; x < xEnd; x++) {
                        var data = clusterDatas[z][y][x];
                        if (data.updateMark != updateMark) {
                            data.pointLightCount = 0;
                            data.spotLightCount = 0;
                            data.updateMark = updateMark;
                        }
                        var indices = data.indices;
                        var lightCount = data.pointLightCount + data.spotLightCount++;
                        if (lightCount < indices.length)
                            indices[lightCount] = lightIndex;
                        else
                            indices.push(lightIndex);
                    }
                }
            }
        }
        _insertConePlane(origin, forward, radius, halfAngle, pNor) {
            var V1 = Cluster._tempVector36;
            var V2 = Cluster._tempVector37;
            Laya.Vector3.cross(pNor, forward, V1);
            Laya.Vector3.cross(V1, forward, V2);
            Laya.Vector3.normalize(V2, V2);
            var tanR = radius * Math.tan(halfAngle);
            var capRimX = origin.x + radius * forward.x + tanR * V2.x;
            var capRimY = origin.y + radius * forward.y + tanR * V2.y;
            var capRimZ = origin.z + radius * forward.z + tanR * V2.z;
            return capRimX * pNor.x + capRimY * pNor.y + capRimZ * pNor.z <= 0 || origin.x * pNor.x + origin.y * pNor.y + origin.z * pNor.z <= 0;
        }
        _shrinkSphereLightZPerspective(near, far, lightviewPos, radius, lightBound) {
            var lvZ = lightviewPos.z;
            var minZ = lvZ - radius;
            var maxZ = lvZ + radius;
            if ((minZ > far) || (maxZ <= near))
                return false;
            var depthSliceParam = this._depthSliceParam;
            lightBound.zMin = Math.floor(Math.log2(Math.max(minZ, near)) * depthSliceParam.x - depthSliceParam.y);
            lightBound.zMax = Math.min(Math.ceil(Math.log2(maxZ) * depthSliceParam.x - depthSliceParam.y), this._zSlices);
            return true;
        }
        _shrinkSpotLightZPerspective(near, far, viewLightPos, viewConeCap, radius, halfAngle, lightBound) {
            var pbX = viewConeCap.x, pbY = viewConeCap.y, pbZ = viewConeCap.z;
            var rb = Math.tan(halfAngle) * radius;
            var paX = viewLightPos.x, paY = viewLightPos.y, paZ = viewLightPos.z;
            var aX = pbX - paX, aY = pbY - paY, aZ = pbZ - paZ;
            var dotA = aX * aX + aY * aY + aZ * aZ;
            var eZ = Math.sqrt(1.0 - aZ * aZ / dotA);
            var minZ = Math.max(Math.min(paZ, pbZ - eZ * rb), viewLightPos.z - radius);
            var maxZ = Math.min(Math.max(paZ, pbZ + eZ * rb), viewLightPos.z + radius);
            if ((minZ > far) || (maxZ <= near))
                return false;
            var depthSliceParam = this._depthSliceParam;
            lightBound.zMin = Math.floor(Math.log2(Math.max(minZ, near)) * depthSliceParam.x - depthSliceParam.y);
            lightBound.zMax = Math.min(Math.ceil(Math.log2(maxZ) * depthSliceParam.x - depthSliceParam.y), this._zSlices);
            return true;
        }
        _shrinkSphereLightByBoundOrth(halfX, halfY, near, far, lightviewPos, radius, lightBound) {
            var lvZ = lightviewPos.z;
            var minZ = lvZ - radius, maxZ = lvZ + radius;
            if ((minZ > far) || (maxZ <= near))
                return false;
            var lvX = lightviewPos.x;
            var minX = lvX - radius, maxX = lvX + radius;
            if ((minX > halfX) || (maxX <= -halfX))
                return false;
            var lvY = lightviewPos.y;
            var minY = lvY - radius, maxY = lvY + radius;
            if ((minY > halfY) || (maxY <= -halfY))
                return false;
            var xSlices = this._xSlices, ySlices = this._ySlices;
            var depthSliceParam = this._depthSliceParam;
            var xStride = halfX * 2 / xSlices, yStride = halfY * 2 / ySlices;
            lightBound.xMin = Math.max(Math.floor((minX + halfX) / xStride), 0);
            lightBound.xMax = Math.min(Math.ceil((maxX + halfX) / xStride), xSlices);
            lightBound.yMin = Math.max(Math.floor((halfY - maxY) / yStride), 0);
            lightBound.yMax = Math.min(Math.ceil((halfY - minY) / yStride), ySlices);
            lightBound.zMin = Math.floor(Math.log2(Math.max(minZ, near)) * depthSliceParam.x - depthSliceParam.y);
            lightBound.zMax = Math.min(Math.ceil(Math.log2(maxZ) * depthSliceParam.x - depthSliceParam.y), this._zSlices);
            return true;
        }
        _shrinkSpotLightByBoundOrth(halfX, halfY, near, far, viewLightPos, viewConeCap, radius, halfAngle, lightBound) {
            var pbX = viewConeCap.x, pbY = viewConeCap.y, pbZ = viewConeCap.z;
            var rb = Math.tan(halfAngle) * radius;
            var paX = viewLightPos.x, paY = viewLightPos.y, paZ = viewLightPos.z;
            var aX = pbX - paX, aY = pbY - paY, aZ = pbZ - paZ;
            var dotA = aX * aX + aY * aY + aZ * aZ;
            var eZ = Math.sqrt(1.0 - aZ * aZ / dotA);
            var minZ = Math.max(Math.min(paZ, pbZ - eZ * rb), viewLightPos.z - radius);
            var maxZ = Math.min(Math.max(paZ, pbZ + eZ * rb), viewLightPos.z + radius);
            if ((minZ > far) || (maxZ <= near))
                return false;
            var eX = Math.sqrt(1.0 - aX * aX / dotA);
            var minX = Math.max(Math.min(paX, pbX - eX * rb), viewLightPos.x - radius);
            var maxX = Math.min(Math.max(paX, pbX + eX * rb), viewLightPos.x + radius);
            if ((minX > halfX) || (maxX <= -halfX))
                return false;
            var eY = Math.sqrt(1.0 - aY * aY / dotA);
            var minY = Math.max(Math.min(paY, pbY - eY * rb), viewLightPos.y - radius);
            var maxY = Math.min(Math.max(paY, pbY + eY * rb), viewLightPos.y + radius);
            if ((minY > halfY) || (maxY <= -halfY))
                return false;
            var xSlices = this._xSlices, ySlices = this._ySlices;
            var depthSliceParam = this._depthSliceParam;
            var xStride = halfX * 2 / xSlices, yStride = halfY * 2 / ySlices;
            lightBound.xMin = Math.max(Math.floor((minX + halfX) / xStride), 0);
            lightBound.xMax = Math.min(Math.ceil((maxX + halfX) / xStride), xSlices);
            lightBound.yMin = Math.max(Math.floor((halfY - maxY) / yStride), 0);
            lightBound.yMax = Math.min(Math.ceil((halfY - minY) / yStride), ySlices);
            lightBound.zMin = Math.floor(Math.log2(Math.max(minZ, near)) * depthSliceParam.x - depthSliceParam.y);
            lightBound.zMax = Math.min(Math.ceil(Math.log2(maxZ) * depthSliceParam.x - depthSliceParam.y), this._zSlices);
            return true;
        }
        _shrinkXYByRadiusPerspective(lightviewPos, radius, lightBound, xPlanes, yPlanes) {
            var xMin, yMin;
            var xMax, yMax;
            var lvX = lightviewPos.x, lvY = lightviewPos.y, lvZ = lightviewPos.z;
            var i;
            var n = this._ySlices + 1;
            for (i = 0; i < n; i++) {
                var plane = yPlanes[i];
                if (lvY * plane.y + lvZ * plane.z < radius) {
                    yMin = Math.max(0, i - 1);
                    break;
                }
            }
            if (i == n)
                return false;
            yMax = this._ySlices;
            for (i = yMin + 1; i < n; i++) {
                var plane = yPlanes[i];
                if (lvY * plane.y + lvZ * plane.z <= -radius) {
                    yMax = Math.max(0, i);
                    break;
                }
            }
            n = this._xSlices + 1;
            for (i = 0; i < n; i++) {
                var plane = xPlanes[i];
                if (lvX * plane.x + lvZ * plane.z < radius) {
                    xMin = Math.max(0, i - 1);
                    break;
                }
            }
            xMax = this._xSlices;
            for (i = xMin + 1; i < n; i++) {
                var plane = xPlanes[i];
                if (lvX * plane.x + lvZ * plane.z <= -radius) {
                    xMax = Math.max(0, i);
                    break;
                }
            }
            lightBound.xMin = xMin;
            lightBound.xMax = xMax;
            lightBound.yMin = yMin;
            lightBound.yMax = yMax;
            return true;
        }
        _shrinkSpotXYByConePerspective(lightviewPos, viewForward, radius, halfAngle, lightBound, xPlanes, yPlanes) {
            var xMin, yMin;
            var xMax, yMax;
            var normal = Cluster._tempVector32;
            var n = lightBound.yMax + 1;
            for (var i = lightBound.yMin + 1; i < n; i++) {
                if (this._insertConePlane(lightviewPos, viewForward, radius, halfAngle, yPlanes[i])) {
                    yMin = Math.max(0, i - 1);
                    break;
                }
            }
            yMax = lightBound.yMax;
            for (var i = yMin + 1; i < n; i++) {
                var plane = yPlanes[i];
                normal.setValue(0, -plane.y, -plane.z);
                if (!this._insertConePlane(lightviewPos, viewForward, radius, halfAngle, normal)) {
                    yMax = Math.max(0, i);
                    break;
                }
            }
            n = lightBound.xMax + 1;
            for (var i = lightBound.xMin + 1; i < n; i++) {
                if (this._insertConePlane(lightviewPos, viewForward, radius, halfAngle, xPlanes[i])) {
                    xMin = Math.max(0, i - 1);
                    break;
                }
            }
            xMax = lightBound.xMax;
            for (var i = xMin + 1; i < n; i++) {
                var plane = xPlanes[i];
                normal.setValue(-plane.x, 0, -plane.z);
                if (!this._insertConePlane(lightviewPos, viewForward, radius, halfAngle, normal)) {
                    xMax = Math.max(0, i);
                    break;
                }
            }
            lightBound.xMin = xMin;
            lightBound.xMax = xMax;
            lightBound.yMin = yMin;
            lightBound.yMax = yMax;
        }
        _updatePointLightPerspective(near, far, viewMat, pointLight, lightIndex, xPlanes, yPlanes) {
            var lightBound = Cluster._tempLightBound;
            var lightviewPos = Cluster._tempVector30;
            Laya.Vector3.transformV3ToV3(pointLight.owner._transform.position, viewMat, lightviewPos);
            lightviewPos.z *= -1;
            if (!this._shrinkSphereLightZPerspective(near, far, lightviewPos, pointLight.range, lightBound))
                return;
            if (!this._shrinkXYByRadiusPerspective(lightviewPos, pointLight.range, lightBound, xPlanes, yPlanes))
                return;
            this._placePointLightToClusters(lightIndex, lightBound);
        }
        _updateSpotLightPerspective(near, far, viewMat, spotLight, lightIndex, xPlanes, yPlanes) {
            var lightBound = Cluster._tempLightBound;
            var viewPos = Cluster._tempVector30;
            var forward = Cluster._tempVector31;
            var viewConeCap = Cluster._tempVector34;
            var position = spotLight.owner._transform.position;
            var range = spotLight.range;
            spotLight.owner._transform.worldMatrix.getForward(forward);
            Laya.Vector3.normalize(forward, forward);
            Laya.Vector3.scale(forward, range, viewConeCap);
            Laya.Vector3.add(position, viewConeCap, viewConeCap);
            Laya.Vector3.transformV3ToV3(position, viewMat, viewPos);
            Laya.Vector3.transformV3ToV3(viewConeCap, viewMat, viewConeCap);
            viewPos.z *= -1;
            viewConeCap.z *= -1;
            var halfAngle = (spotLight.spotAngle / 2) * Math.PI / 180;
            if (!this._shrinkSpotLightZPerspective(near, far, viewPos, viewConeCap, range, halfAngle, lightBound))
                return;
            if (!this._shrinkXYByRadiusPerspective(viewPos, range, lightBound, xPlanes, yPlanes))
                return;
            var viewFor = Cluster._tempVector33;
            viewFor.x = viewConeCap.x - viewPos.x, viewFor.y = viewConeCap.y - viewPos.y, viewFor.z = viewConeCap.z - viewPos.z;
            Laya.Vector3.normalize(viewFor, viewFor);
            this._shrinkSpotXYByConePerspective(viewPos, viewFor, range, halfAngle, lightBound, xPlanes, yPlanes);
            this._placeSpotLightToClusters(lightIndex, lightBound);
        }
        _updatePointLightOrth(halfX, halfY, near, far, viewMat, pointLight, lightIndex) {
            var lightBound = Cluster._tempLightBound;
            var lightviewPos = Cluster._tempVector30;
            Laya.Vector3.transformV3ToV3(pointLight.owner._transform.position, viewMat, lightviewPos);
            lightviewPos.z *= -1;
            if (!this._shrinkSphereLightByBoundOrth(halfX, halfY, near, far, lightviewPos, pointLight.range, lightBound))
                return;
            this._placePointLightToClusters(lightIndex, lightBound);
        }
        _updateSpotLightOrth(halfX, halfY, near, far, viewMat, spotLight, lightIndex) {
            var lightBound = Cluster._tempLightBound;
            var viewPos = Cluster._tempVector30;
            var forward = Cluster._tempVector31;
            var viewConeCap = Cluster._tempVector34;
            var position = spotLight.owner._transform.position;
            var range = spotLight.range;
            spotLight.owner._transform.worldMatrix.getForward(forward);
            Laya.Vector3.normalize(forward, forward);
            Laya.Vector3.scale(forward, range, viewConeCap);
            Laya.Vector3.add(position, viewConeCap, viewConeCap);
            Laya.Vector3.transformV3ToV3(position, viewMat, viewPos);
            Laya.Vector3.transformV3ToV3(viewConeCap, viewMat, viewConeCap);
            viewPos.z *= -1;
            viewConeCap.z *= -1;
            var halfAngle = (spotLight.spotAngle / 2) * Math.PI / 180;
            if (!this._shrinkSpotLightByBoundOrth(halfX, halfY, near, far, viewPos, viewConeCap, range, halfAngle, lightBound))
                return;
            this._placeSpotLightToClusters(lightIndex, lightBound);
        }
        update(camera, scene) {
            this._updateMark++;
            var camNear = camera.nearPlane;
            this._depthSliceParam.x = Laya.Config3D.lightClusterCount.z / Math.log2(camera.farPlane / camNear);
            this._depthSliceParam.y = Math.log2(camNear) * this._depthSliceParam.x;
            var near = camera.nearPlane;
            var far = camera.farPlane;
            var viewMat = camera.viewMatrix;
            var curCount = scene._directionLights._length;
            var pointLights = scene._pointLights;
            var poiCount = pointLights._length;
            var poiElements = pointLights._elements;
            var spotLights = scene._spotLights;
            var spoCount = spotLights._length;
            var spoElements = spotLights._elements;
            if (camera.orthographic) {
                var halfY = camera.orthographicVerticalSize / 2.0;
                var halfX = halfY * camera.aspectRatio;
                for (var i = 0; i < poiCount; i++, curCount++)
                    this._updatePointLightOrth(halfX, halfY, near, far, viewMat, poiElements[i], curCount);
                for (var i = 0; i < spoCount; i++, curCount++)
                    this._updateSpotLightOrth(halfX, halfY, near, far, viewMat, spoElements[i], curCount);
            }
            else {
                camera._updateClusterPlaneXY();
                var xPlanes = camera._clusterXPlanes;
                var yPlanes = camera._clusterYPlanes;
                for (var i = 0; i < poiCount; i++, curCount++)
                    this._updatePointLightPerspective(near, far, viewMat, poiElements[i], curCount, xPlanes, yPlanes);
                for (var i = 0; i < spoCount; i++, curCount++)
                    this._updateSpotLightPerspective(near, far, viewMat, spoElements[i], curCount, xPlanes, yPlanes);
            }
            if (poiCount + spoCount > 0) {
                var xSlices = this._xSlices, ySlices = this._ySlices, zSlices = this._zSlices;
                var widthFloat = xSlices * ySlices * 4;
                var lightOff = widthFloat * zSlices;
                var clusterPixels = this._clusterPixels;
                var clusterPixelsCount = clusterPixels.length;
                var clusterDatas = this._clusterDatas;
                var updateMark = this._updateMark;
                var freeSpace = true;
                for (var z = 0; z < zSlices; z++) {
                    for (var y = 0; y < ySlices; y++) {
                        for (var x = 0; x < xSlices; x++) {
                            var data = clusterDatas[z][y][x];
                            var clusterOff = (x + y * xSlices + z * xSlices * ySlices) * 4;
                            if (data.updateMark !== updateMark) {
                                clusterPixels[clusterOff] = 0;
                                clusterPixels[clusterOff + 1] = 0;
                            }
                            else {
                                if (freeSpace) {
                                    var indices = data.indices;
                                    var pCount = data.pointLightCount;
                                    var sCount = data.spotLightCount;
                                    var count = pCount + sCount;
                                    if (lightOff + count < clusterPixelsCount) {
                                        clusterPixels[clusterOff] = pCount;
                                        clusterPixels[clusterOff + 1] = sCount;
                                        clusterPixels[clusterOff + 2] = Math.floor(lightOff / widthFloat);
                                        clusterPixels[clusterOff + 3] = lightOff % widthFloat;
                                        for (var i = 0; i < count; i++)
                                            clusterPixels[lightOff++] = indices[i];
                                    }
                                    else {
                                        count = clusterPixelsCount - (lightOff + count);
                                        pCount = Math.min(pCount, count);
                                        clusterPixels[clusterOff] = pCount;
                                        clusterPixels[clusterOff + 1] = Math.min(sCount, count - pCount);
                                        clusterPixels[clusterOff + 2] = Math.floor(lightOff / widthFloat);
                                        clusterPixels[clusterOff + 3] = lightOff % widthFloat;
                                        for (var i = 0; i < count; i++)
                                            clusterPixels[lightOff++] = indices[i];
                                        freeSpace = false;
                                    }
                                }
                            }
                        }
                    }
                }
                var width = this._clusterTexture.width;
                this._clusterTexture.setSubPixelsData(0, 0, width, Math.ceil(lightOff / (4 * width)), clusterPixels, 0, false, false, false);
            }
        }
    }
    Cluster._tempVector30 = new Laya.Vector3();
    Cluster._tempVector31 = new Laya.Vector3();
    Cluster._tempVector32 = new Laya.Vector3();
    Cluster._tempVector33 = new Laya.Vector3();
    Cluster._tempVector34 = new Laya.Vector3();
    Cluster._tempVector35 = new Laya.Vector3();
    Cluster._tempVector36 = new Laya.Vector3();
    Cluster._tempVector37 = new Laya.Vector3();
    Cluster._tempLightBound = new LightBound();

    class Plane {
        constructor(normal = new Laya.Vector3, d = 0) {
            this._normal = normal;
            this._distance = d;
        }
        set normal(value) {
            value.cloneTo(this._normal);
        }
        get normal() {
            return this._normal;
        }
        set distance(value) {
            this._distance = value;
        }
        get distance() {
            return this._distance;
        }
        static createPlaneBy3P(point0, point1, point2, out) {
            var x1 = point1.x - point0.x;
            var y1 = point1.y - point0.y;
            var z1 = point1.z - point0.z;
            var x2 = point2.x - point0.x;
            var y2 = point2.y - point0.y;
            var z2 = point2.z - point0.z;
            var yz = (y1 * z2) - (z1 * y2);
            var xz = (z1 * x2) - (x1 * z2);
            var xy = (x1 * y2) - (y1 * x2);
            var invPyth = 1.0 / (Math.sqrt((yz * yz) + (xz * xz) + (xy * xy)));
            var x = yz * invPyth;
            var y = xz * invPyth;
            var z = xy * invPyth;
            var normal = out.normal;
            normal.x = x;
            normal.y = y;
            normal.z = z;
            out.normal = normal.normalize();
            out.distance = -((x * point0.x) + (y * point0.y) + (z * point0.z));
        }
        normalize() {
            var normalEX = this.normal.x;
            var normalEY = this.normal.y;
            var normalEZ = this.normal.z;
            var magnitude = 1.0 / Math.sqrt(normalEX * normalEX + normalEY * normalEY + normalEZ * normalEZ);
            this.normal.x = normalEX * magnitude;
            this.normal.y = normalEY * magnitude;
            this.normal.z = normalEZ * magnitude;
            this.distance *= magnitude;
        }
        cloneTo(destObject) {
            var dest = destObject;
            this.normal.cloneTo(dest.normal);
            dest.distance = this.distance;
        }
        clone() {
            var dest = new Plane();
            this.cloneTo(dest);
            return dest;
        }
    }
    Plane.PlaneIntersectionType_Back = 0;
    Plane.PlaneIntersectionType_Front = 1;
    Plane.PlaneIntersectionType_Intersecting = 2;

    class Ray {
        constructor(origin, direction) {
            this.origin = origin;
            this.direction = direction;
        }
        at(t, out) {
            Laya.Vector3.scale(this.direction, t, out);
            Laya.Vector3.add(this.origin, out, out);
        }
    }

    class ContainmentType {
    }
    ContainmentType.Disjoint = 0;
    ContainmentType.Contains = 1;
    ContainmentType.Intersects = 2;

    class CollisionUtils {
        constructor() {
        }
        static distancePlaneToPoint(plane, point) {
            var dot = Laya.Vector3.dot(plane.normal, point);
            return dot + plane.distance;
        }
        static distanceBoxToPoint(box, point) {
            var boxMin = box.min;
            var boxMineX = boxMin.x;
            var boxMineY = boxMin.y;
            var boxMineZ = boxMin.z;
            var boxMax = box.max;
            var boxMaxeX = boxMax.x;
            var boxMaxeY = boxMax.y;
            var boxMaxeZ = boxMax.z;
            var pointeX = point.x;
            var pointeY = point.y;
            var pointeZ = point.z;
            var distance = 0;
            if (pointeX < boxMineX)
                distance += (boxMineX - pointeX) * (boxMineX - pointeX);
            if (pointeX > boxMaxeX)
                distance += (boxMaxeX - pointeX) * (boxMaxeX - pointeX);
            if (pointeY < boxMineY)
                distance += (boxMineY - pointeY) * (boxMineY - pointeY);
            if (pointeY > boxMaxeY)
                distance += (boxMaxeY - pointeY) * (boxMaxeY - pointeY);
            if (pointeZ < boxMineZ)
                distance += (boxMineZ - pointeZ) * (boxMineZ - pointeZ);
            if (pointeZ > boxMaxeZ)
                distance += (boxMaxeZ - pointeZ) * (boxMaxeZ - pointeZ);
            return Math.sqrt(distance);
        }
        static distanceBoxToBox(box1, box2) {
            var box1Mine = box1.min;
            var box1MineX = box1Mine.x;
            var box1MineY = box1Mine.y;
            var box1MineZ = box1Mine.z;
            var box1Maxe = box1.max;
            var box1MaxeX = box1Maxe.x;
            var box1MaxeY = box1Maxe.y;
            var box1MaxeZ = box1Maxe.z;
            var box2Mine = box2.min;
            var box2MineX = box2Mine.x;
            var box2MineY = box2Mine.y;
            var box2MineZ = box2Mine.z;
            var box2Maxe = box2.max;
            var box2MaxeX = box2Maxe.x;
            var box2MaxeY = box2Maxe.y;
            var box2MaxeZ = box2Maxe.z;
            var distance = 0;
            var delta;
            if (box1MineX > box2MaxeX) {
                delta = box1MineX - box2MaxeX;
                distance += delta * delta;
            }
            else if (box2MineX > box1MaxeX) {
                delta = box2MineX - box1MaxeX;
                distance += delta * delta;
            }
            if (box1MineY > box2MaxeY) {
                delta = box1MineY - box2MaxeY;
                distance += delta * delta;
            }
            else if (box2MineY > box1MaxeY) {
                delta = box2MineY - box1MaxeY;
                distance += delta * delta;
            }
            if (box1MineZ > box2MaxeZ) {
                delta = box1MineZ - box2MaxeZ;
                distance += delta * delta;
            }
            else if (box2MineZ > box1MaxeZ) {
                delta = box2MineZ - box1MaxeZ;
                distance += delta * delta;
            }
            return Math.sqrt(distance);
        }
        static distanceSphereToPoint(sphere, point) {
            var distance = Math.sqrt(Laya.Vector3.distanceSquared(sphere.center, point));
            distance -= sphere.radius;
            return Math.max(distance, 0);
        }
        static distanceSphereToSphere(sphere1, sphere2) {
            var distance = Math.sqrt(Laya.Vector3.distanceSquared(sphere1.center, sphere2.center));
            distance -= sphere1.radius + sphere2.radius;
            return Math.max(distance, 0);
        }
        static intersectsRayAndTriangleRD(ray, vertex1, vertex2, vertex3, out) {
            var rayO = ray.origin;
            var rayOeX = rayO.x;
            var rayOeY = rayO.y;
            var rayOeZ = rayO.z;
            var rayD = ray.direction;
            var rayDeX = rayD.x;
            var rayDeY = rayD.y;
            var rayDeZ = rayD.z;
            var v1eX = vertex1.x;
            var v1eY = vertex1.y;
            var v1eZ = vertex1.z;
            var v2eX = vertex2.x;
            var v2eY = vertex2.y;
            var v2eZ = vertex2.z;
            var v3eX = vertex3.x;
            var v3eY = vertex3.y;
            var v3eZ = vertex3.z;
            var _tempV30eX = CollisionUtils._tempV30.x;
            var _tempV30eY = CollisionUtils._tempV30.y;
            var _tempV30eZ = CollisionUtils._tempV30.z;
            _tempV30eX = v2eX - v1eX;
            _tempV30eY = v2eY - v1eY;
            _tempV30eZ = v2eZ - v1eZ;
            var _tempV31eX = CollisionUtils._tempV31.x;
            var _tempV31eY = CollisionUtils._tempV31.y;
            var _tempV31eZ = CollisionUtils._tempV31.z;
            _tempV31eX = v3eX - v1eX;
            _tempV31eY = v3eY - v1eY;
            _tempV31eZ = v3eZ - v1eZ;
            var _tempV32eX = CollisionUtils._tempV32.x;
            var _tempV32eY = CollisionUtils._tempV32.y;
            var _tempV32eZ = CollisionUtils._tempV32.z;
            _tempV32eX = (rayDeY * _tempV31eZ) - (rayDeZ * _tempV31eY);
            _tempV32eY = (rayDeZ * _tempV31eX) - (rayDeX * _tempV31eZ);
            _tempV32eZ = (rayDeX * _tempV31eY) - (rayDeY * _tempV31eX);
            var determinant = (_tempV30eX * _tempV32eX) + (_tempV30eY * _tempV32eY) + (_tempV30eZ * _tempV32eZ);
            if (Laya.MathUtils3D.isZero(determinant)) {
                return false;
            }
            var inversedeterminant = 1 / determinant;
            var _tempV33eX = CollisionUtils._tempV33.x;
            var _tempV33eY = CollisionUtils._tempV33.y;
            var _tempV33eZ = CollisionUtils._tempV33.z;
            _tempV33eX = rayOeX - v1eX;
            _tempV33eY = rayOeY - v1eY;
            _tempV33eZ = rayOeZ - v1eZ;
            var triangleU = (_tempV33eX * _tempV32eX) + (_tempV33eY * _tempV32eY) + (_tempV33eZ * _tempV32eZ);
            triangleU *= inversedeterminant;
            if (triangleU < 0 || triangleU > 1) {
                return false;
            }
            var _tempV34eX = CollisionUtils._tempV34.x;
            var _tempV34eY = CollisionUtils._tempV34.y;
            var _tempV34eZ = CollisionUtils._tempV34.z;
            _tempV34eX = (_tempV33eY * _tempV30eZ) - (_tempV33eZ * _tempV30eY);
            _tempV34eY = (_tempV33eZ * _tempV30eX) - (_tempV33eX * _tempV30eZ);
            _tempV34eZ = (_tempV33eX * _tempV30eY) - (_tempV33eY * _tempV30eX);
            var triangleV = ((rayDeX * _tempV34eX) + (rayDeY * _tempV34eY)) + (rayDeZ * _tempV34eZ);
            triangleV *= inversedeterminant;
            if (triangleV < 0 || triangleU + triangleV > 1) {
                return false;
            }
            var raydistance = (_tempV31eX * _tempV34eX) + (_tempV31eY * _tempV34eY) + (_tempV31eZ * _tempV34eZ);
            raydistance *= inversedeterminant;
            if (raydistance < 0) {
                return false;
            }
            return true;
        }
        static intersectsRayAndTriangleRP(ray, vertex1, vertex2, vertex3, out) {
            var distance;
            if (!CollisionUtils.intersectsRayAndTriangleRD(ray, vertex1, vertex2, vertex3, distance)) {
                Laya.Vector3.ZERO.cloneTo(out);
                return false;
            }
            Laya.Vector3.scale(ray.direction, distance, CollisionUtils._tempV30);
            Laya.Vector3.add(ray.origin, CollisionUtils._tempV30, out);
            return true;
        }
        static intersectsRayAndPoint(ray, point) {
            Laya.Vector3.subtract(ray.origin, point, CollisionUtils._tempV30);
            var b = Laya.Vector3.dot(CollisionUtils._tempV30, ray.direction);
            var c = Laya.Vector3.dot(CollisionUtils._tempV30, CollisionUtils._tempV30) - Laya.MathUtils3D.zeroTolerance;
            if (c > 0 && b > 0)
                return false;
            var discriminant = b * b - c;
            if (discriminant < 0)
                return false;
            return true;
        }
        static intersectsRayAndRay(ray1, ray2, out) {
            var ray1o = ray1.origin;
            var ray1oeX = ray1o.x;
            var ray1oeY = ray1o.y;
            var ray1oeZ = ray1o.z;
            var ray1d = ray1.direction;
            var ray1deX = ray1d.x;
            var ray1deY = ray1d.y;
            var ray1deZ = ray1d.z;
            var ray2o = ray2.origin;
            var ray2oeX = ray2o.x;
            var ray2oeY = ray2o.y;
            var ray2oeZ = ray2o.z;
            var ray2d = ray2.direction;
            var ray2deX = ray2d.x;
            var ray2deY = ray2d.y;
            var ray2deZ = ray2d.z;
            Laya.Vector3.cross(ray1d, ray2d, CollisionUtils._tempV30);
            var tempV3 = CollisionUtils._tempV30;
            var denominator = Laya.Vector3.scalarLength(CollisionUtils._tempV30);
            if (Laya.MathUtils3D.isZero(denominator)) {
                if (Laya.MathUtils3D.nearEqual(ray2oeX, ray1oeX) && Laya.MathUtils3D.nearEqual(ray2oeY, ray1oeY) && Laya.MathUtils3D.nearEqual(ray2oeZ, ray1oeZ)) {
                    Laya.Vector3.ZERO.cloneTo(out);
                    return true;
                }
            }
            denominator = denominator * denominator;
            var m11 = ray2oeX - ray1oeX;
            var m12 = ray2oeY - ray1oeY;
            var m13 = ray2oeZ - ray1oeZ;
            var m21 = ray2deX;
            var m22 = ray2deY;
            var m23 = ray2deZ;
            var m31 = tempV3.x;
            var m32 = tempV3.y;
            var m33 = tempV3.z;
            var dets = m11 * m22 * m33 + m12 * m23 * m31 + m13 * m21 * m32 - m11 * m23 * m32 - m12 * m21 * m33 - m13 * m22 * m31;
            m21 = ray1deX;
            m22 = ray1deY;
            m23 = ray1deZ;
            var s = dets / denominator;
            Laya.Vector3.scale(ray1d, s, CollisionUtils._tempV30);
            Laya.Vector3.scale(ray2d, s, CollisionUtils._tempV31);
            Laya.Vector3.add(ray1o, CollisionUtils._tempV30, CollisionUtils._tempV32);
            Laya.Vector3.add(ray2o, CollisionUtils._tempV31, CollisionUtils._tempV33);
            var point1e = CollisionUtils._tempV32;
            var point2e = CollisionUtils._tempV33;
            if (!Laya.MathUtils3D.nearEqual(point2e.x, point1e.x) || !Laya.MathUtils3D.nearEqual(point2e.y, point1e.y) || !Laya.MathUtils3D.nearEqual(point2e.z, point1e.z)) {
                Laya.Vector3.ZERO.cloneTo(out);
                return false;
            }
            out = CollisionUtils._tempV32;
            return true;
        }
        static intersectsPlaneAndTriangle(plane, vertex1, vertex2, vertex3) {
            var test1 = CollisionUtils.intersectsPlaneAndPoint(plane, vertex1);
            var test2 = CollisionUtils.intersectsPlaneAndPoint(plane, vertex2);
            var test3 = CollisionUtils.intersectsPlaneAndPoint(plane, vertex3);
            if (test1 == Plane.PlaneIntersectionType_Front && test2 == Plane.PlaneIntersectionType_Front && test3 == Plane.PlaneIntersectionType_Front)
                return Plane.PlaneIntersectionType_Front;
            if (test1 == Plane.PlaneIntersectionType_Back && test2 == Plane.PlaneIntersectionType_Back && test3 == Plane.PlaneIntersectionType_Back)
                return Plane.PlaneIntersectionType_Back;
            return Plane.PlaneIntersectionType_Intersecting;
        }
        static intersectsRayAndPlaneRD(ray, plane) {
            var planeNor = plane.normal;
            var direction = Laya.Vector3.dot(planeNor, ray.direction);
            if (Math.abs(direction) < Laya.MathUtils3D.zeroTolerance)
                return -1;
            var position = Laya.Vector3.dot(planeNor, ray.origin);
            var distance = (-plane.distance - position) / direction;
            if (distance < 0) {
                if (distance < -Laya.MathUtils3D.zeroTolerance)
                    return -1;
                distance = 0;
            }
            return distance;
        }
        static intersectsRayAndPlaneRP(ray, plane, out) {
            var distance = CollisionUtils.intersectsRayAndPlaneRD(ray, plane);
            if (distance == -1) {
                out.setValue(0, 0, 0);
                return false;
            }
            var scaDis = CollisionUtils._tempV30;
            Laya.Vector3.scale(ray.direction, distance, scaDis);
            Laya.Vector3.add(ray.origin, scaDis, out);
            return true;
        }
        static intersectsRayAndBoxRD(ray, box) {
            var rayoe = ray.origin;
            var rayoeX = rayoe.x;
            var rayoeY = rayoe.y;
            var rayoeZ = rayoe.z;
            var rayde = ray.direction;
            var raydeX = rayde.x;
            var raydeY = rayde.y;
            var raydeZ = rayde.z;
            var boxMine = box.min;
            var boxMineX = boxMine.x;
            var boxMineY = boxMine.y;
            var boxMineZ = boxMine.z;
            var boxMaxe = box.max;
            var boxMaxeX = boxMaxe.x;
            var boxMaxeY = boxMaxe.y;
            var boxMaxeZ = boxMaxe.z;
            var out = 0;
            var tmax = Laya.MathUtils3D.MaxValue;
            if (Laya.MathUtils3D.isZero(raydeX)) {
                if (rayoeX < boxMineX || rayoeX > boxMaxeX) {
                    return -1;
                }
            }
            else {
                var inverse = 1 / raydeX;
                var t1 = (boxMineX - rayoeX) * inverse;
                var t2 = (boxMaxeX - rayoeX) * inverse;
                if (t1 > t2) {
                    var temp = t1;
                    t1 = t2;
                    t2 = temp;
                }
                out = Math.max(t1, out);
                tmax = Math.min(t2, tmax);
                if (out > tmax) {
                    return -1;
                }
            }
            if (Laya.MathUtils3D.isZero(raydeY)) {
                if (rayoeY < boxMineY || rayoeY > boxMaxeY) {
                    return -1;
                }
            }
            else {
                var inverse1 = 1 / raydeY;
                var t3 = (boxMineY - rayoeY) * inverse1;
                var t4 = (boxMaxeY - rayoeY) * inverse1;
                if (t3 > t4) {
                    var temp1 = t3;
                    t3 = t4;
                    t4 = temp1;
                }
                out = Math.max(t3, out);
                tmax = Math.min(t4, tmax);
                if (out > tmax) {
                    return -1;
                }
            }
            if (Laya.MathUtils3D.isZero(raydeZ)) {
                if (rayoeZ < boxMineZ || rayoeZ > boxMaxeZ) {
                    return -1;
                }
            }
            else {
                var inverse2 = 1 / raydeZ;
                var t5 = (boxMineZ - rayoeZ) * inverse2;
                var t6 = (boxMaxeZ - rayoeZ) * inverse2;
                if (t5 > t6) {
                    var temp2 = t5;
                    t5 = t6;
                    t6 = temp2;
                }
                out = Math.max(t5, out);
                tmax = Math.min(t6, tmax);
                if (out > tmax) {
                    return -1;
                }
            }
            return out;
        }
        static intersectsRayAndBoxRP(ray, box, out) {
            var distance = CollisionUtils.intersectsRayAndBoxRD(ray, box);
            if (distance === -1) {
                Laya.Vector3.ZERO.cloneTo(out);
                return distance;
            }
            Laya.Vector3.scale(ray.direction, distance, CollisionUtils._tempV30);
            Laya.Vector3.add(ray.origin, CollisionUtils._tempV30, CollisionUtils._tempV31);
            CollisionUtils._tempV31.cloneTo(out);
            return distance;
        }
        static intersectsRayAndSphereRD(ray, sphere) {
            var sphereR = sphere.radius;
            Laya.Vector3.subtract(ray.origin, sphere.center, CollisionUtils._tempV30);
            var b = Laya.Vector3.dot(CollisionUtils._tempV30, ray.direction);
            var c = Laya.Vector3.dot(CollisionUtils._tempV30, CollisionUtils._tempV30) - (sphereR * sphereR);
            if (c > 0 && b > 0) {
                return -1;
            }
            var discriminant = b * b - c;
            if (discriminant < 0) {
                return -1;
            }
            var distance = -b - Math.sqrt(discriminant);
            if (distance < 0)
                distance = 0;
            return distance;
        }
        static intersectsRayAndSphereRP(ray, sphere, out) {
            var distance = CollisionUtils.intersectsRayAndSphereRD(ray, sphere);
            if (distance === -1) {
                Laya.Vector3.ZERO.cloneTo(out);
                return distance;
            }
            Laya.Vector3.scale(ray.direction, distance, CollisionUtils._tempV30);
            Laya.Vector3.add(ray.origin, CollisionUtils._tempV30, CollisionUtils._tempV31);
            CollisionUtils._tempV31.cloneTo(out);
            return distance;
        }
        static intersectsSphereAndTriangle(sphere, vertex1, vertex2, vertex3) {
            var sphereC = sphere.center;
            var sphereR = sphere.radius;
            CollisionUtils.closestPointPointTriangle(sphereC, vertex1, vertex2, vertex3, CollisionUtils._tempV30);
            Laya.Vector3.subtract(CollisionUtils._tempV30, sphereC, CollisionUtils._tempV31);
            var dot = Laya.Vector3.dot(CollisionUtils._tempV31, CollisionUtils._tempV31);
            return dot <= sphereR * sphereR;
        }
        static intersectsPlaneAndPoint(plane, point) {
            var distance = Laya.Vector3.dot(plane.normal, point) + plane.distance;
            if (distance > 0)
                return Plane.PlaneIntersectionType_Front;
            if (distance < 0)
                return Plane.PlaneIntersectionType_Back;
            return Plane.PlaneIntersectionType_Intersecting;
        }
        static intersectsPlaneAndPlane(plane1, plane2) {
            Laya.Vector3.cross(plane1.normal, plane2.normal, CollisionUtils._tempV30);
            var denominator = Laya.Vector3.dot(CollisionUtils._tempV30, CollisionUtils._tempV30);
            if (Laya.MathUtils3D.isZero(denominator))
                return false;
            return true;
        }
        static intersectsPlaneAndPlaneRL(plane1, plane2, line) {
            var plane1nor = plane1.normal;
            var plane2nor = plane2.normal;
            Laya.Vector3.cross(plane1nor, plane2nor, CollisionUtils._tempV34);
            var denominator = Laya.Vector3.dot(CollisionUtils._tempV34, CollisionUtils._tempV34);
            if (Laya.MathUtils3D.isZero(denominator))
                return false;
            Laya.Vector3.scale(plane2nor, plane1.distance, CollisionUtils._tempV30);
            Laya.Vector3.scale(plane1nor, plane2.distance, CollisionUtils._tempV31);
            Laya.Vector3.subtract(CollisionUtils._tempV30, CollisionUtils._tempV31, CollisionUtils._tempV32);
            Laya.Vector3.cross(CollisionUtils._tempV32, CollisionUtils._tempV34, CollisionUtils._tempV33);
            Laya.Vector3.normalize(CollisionUtils._tempV34, CollisionUtils._tempV34);
            new Ray(CollisionUtils._tempV33, CollisionUtils._tempV34);
            return true;
        }
        static intersectsPlaneAndBox(plane, box) {
            var planeD = plane.distance;
            var planeNor = plane.normal;
            var planeNoreX = planeNor.x;
            var planeNoreY = planeNor.y;
            var planeNoreZ = planeNor.z;
            var boxMine = box.min;
            var boxMineX = boxMine.x;
            var boxMineY = boxMine.y;
            var boxMineZ = boxMine.z;
            var boxMaxe = box.max;
            var boxMaxeX = boxMaxe.x;
            var boxMaxeY = boxMaxe.y;
            var boxMaxeZ = boxMaxe.z;
            CollisionUtils._tempV30.x = (planeNoreX > 0) ? boxMineX : boxMaxeX;
            CollisionUtils._tempV30.y = (planeNoreY > 0) ? boxMineY : boxMaxeY;
            CollisionUtils._tempV30.z = (planeNoreZ > 0) ? boxMineZ : boxMaxeZ;
            CollisionUtils._tempV31.x = (planeNoreX > 0) ? boxMaxeX : boxMineX;
            CollisionUtils._tempV31.y = (planeNoreY > 0) ? boxMaxeY : boxMineY;
            CollisionUtils._tempV31.z = (planeNoreZ > 0) ? boxMaxeZ : boxMineZ;
            var distance = Laya.Vector3.dot(planeNor, CollisionUtils._tempV30);
            if (distance + planeD > 0)
                return Plane.PlaneIntersectionType_Front;
            distance = Laya.Vector3.dot(planeNor, CollisionUtils._tempV31);
            if (distance + planeD < 0)
                return Plane.PlaneIntersectionType_Back;
            return Plane.PlaneIntersectionType_Intersecting;
        }
        static intersectsPlaneAndSphere(plane, sphere) {
            var sphereR = sphere.radius;
            var distance = Laya.Vector3.dot(plane.normal, sphere.center) + plane.distance;
            if (distance > sphereR)
                return Plane.PlaneIntersectionType_Front;
            if (distance < -sphereR)
                return Plane.PlaneIntersectionType_Back;
            return Plane.PlaneIntersectionType_Intersecting;
        }
        static intersectsBoxAndBox(box1, box2) {
            var box1Mine = box1.min;
            var box1Maxe = box1.max;
            var box2Mine = box2.min;
            var box2Maxe = box2.max;
            if (box1Mine.x > box2Maxe.x || box2Mine.x > box1Maxe.x)
                return false;
            if (box1Mine.y > box2Maxe.y || box2Mine.y > box1Maxe.y)
                return false;
            if (box1Mine.z > box2Maxe.z || box2Mine.z > box1Maxe.z)
                return false;
            return true;
        }
        static intersectsBoxAndSphere(box, sphere) {
            var center = sphere.center;
            var radius = sphere.radius;
            var nearest = CollisionUtils._tempV30;
            Laya.Vector3.Clamp(center, box.min, box.max, nearest);
            var distance = Laya.Vector3.distanceSquared(center, nearest);
            return distance <= radius * radius;
        }
        static intersectsSphereAndSphere(sphere1, sphere2) {
            var radiisum = sphere1.radius + sphere2.radius;
            return Laya.Vector3.distanceSquared(sphere1.center, sphere2.center) <= radiisum * radiisum;
        }
        static boxContainsPoint(box, point) {
            var boxMine = box.min;
            var boxMaxe = box.max;
            if (boxMine.x <= point.x && boxMaxe.x >= point.x && boxMine.y <= point.y && boxMaxe.y >= point.y && boxMine.z <= point.z && boxMaxe.z >= point.z)
                return ContainmentType.Contains;
            return ContainmentType.Disjoint;
        }
        static boxContainsBox(box1, box2) {
            var box1Mine = box1.min;
            var box1MineX = box1Mine.x;
            var box1MineY = box1Mine.y;
            var box1MineZ = box1Mine.z;
            var box1Maxe = box1.max;
            var box1MaxeX = box1Maxe.x;
            var box1MaxeY = box1Maxe.y;
            var box1MaxeZ = box1Maxe.z;
            var box2Mine = box2.min;
            var box2MineX = box2Mine.x;
            var box2MineY = box2Mine.y;
            var box2MineZ = box2Mine.z;
            var box2Maxe = box2.max;
            var box2MaxeX = box2Maxe.x;
            var box2MaxeY = box2Maxe.y;
            var box2MaxeZ = box2Maxe.z;
            if (box1MaxeX < box2MineX || box1MineX > box2MaxeX)
                return ContainmentType.Disjoint;
            if (box1MaxeY < box2MineY || box1MineY > box2MaxeY)
                return ContainmentType.Disjoint;
            if (box1MaxeZ < box2MineZ || box1MineZ > box2MaxeZ)
                return ContainmentType.Disjoint;
            if (box1MineX <= box2MineX && box2MaxeX <= box1MaxeX && box1MineY <= box2MineY && box2MaxeY <= box1MaxeY && box1MineZ <= box2MineZ && box2MaxeZ <= box1MaxeZ) {
                return ContainmentType.Contains;
            }
            return ContainmentType.Intersects;
        }
        static boxContainsSphere(box, sphere) {
            var boxMin = box.min;
            var boxMineX = boxMin.x;
            var boxMineY = boxMin.y;
            var boxMineZ = boxMin.z;
            var boxMax = box.max;
            var boxMaxeX = boxMax.x;
            var boxMaxeY = boxMax.y;
            var boxMaxeZ = boxMax.z;
            var sphereC = sphere.center;
            var sphereCeX = sphereC.x;
            var sphereCeY = sphereC.y;
            var sphereCeZ = sphereC.z;
            var sphereR = sphere.radius;
            Laya.Vector3.Clamp(sphereC, boxMin, boxMax, CollisionUtils._tempV30);
            var distance = Laya.Vector3.distanceSquared(sphereC, CollisionUtils._tempV30);
            if (distance > sphereR * sphereR)
                return ContainmentType.Disjoint;
            if ((((boxMineX + sphereR <= sphereCeX) && (sphereCeX <= boxMaxeX - sphereR)) && ((boxMaxeX - boxMineX > sphereR) &&
                (boxMineY + sphereR <= sphereCeY))) && (((sphereCeY <= boxMaxeY - sphereR) && (boxMaxeY - boxMineY > sphereR)) &&
                (((boxMineZ + sphereR <= sphereCeZ) && (sphereCeZ <= boxMaxeZ - sphereR)) && (boxMaxeZ - boxMineZ > sphereR))))
                return ContainmentType.Contains;
            return ContainmentType.Intersects;
        }
        static sphereContainsPoint(sphere, point) {
            if (Laya.Vector3.distanceSquared(point, sphere.center) <= sphere.radius * sphere.radius)
                return ContainmentType.Contains;
            return ContainmentType.Disjoint;
        }
        static sphereContainsTriangle(sphere, vertex1, vertex2, vertex3) {
            var test1 = CollisionUtils.sphereContainsPoint(sphere, vertex1);
            var test2 = CollisionUtils.sphereContainsPoint(sphere, vertex2);
            var test3 = CollisionUtils.sphereContainsPoint(sphere, vertex3);
            if (test1 == ContainmentType.Contains && test2 == ContainmentType.Contains && test3 == ContainmentType.Contains)
                return ContainmentType.Contains;
            if (CollisionUtils.intersectsSphereAndTriangle(sphere, vertex1, vertex2, vertex3))
                return ContainmentType.Intersects;
            return ContainmentType.Disjoint;
        }
        static sphereContainsBox(sphere, box) {
            var sphereC = sphere.center;
            sphereC.x;
            sphereC.y;
            sphereC.z;
            var sphereR = sphere.radius;
            var boxMin = box.min;
            boxMin.x;
            boxMin.y;
            boxMin.z;
            var boxMax = box.max;
            boxMax.x;
            boxMax.y;
            boxMax.z;
            var _tempV30e = CollisionUtils._tempV30;
            _tempV30e.x;
            _tempV30e.y;
            _tempV30e.z;
            if (!CollisionUtils.intersectsBoxAndSphere(box, sphere))
                return ContainmentType.Disjoint;
            var radiusSquared = sphereR * sphereR;
            if (Laya.Vector3.scalarLengthSquared(CollisionUtils._tempV30) > radiusSquared)
                return ContainmentType.Intersects;
            if (Laya.Vector3.scalarLengthSquared(CollisionUtils._tempV30) > radiusSquared)
                return ContainmentType.Intersects;
            if (Laya.Vector3.scalarLengthSquared(CollisionUtils._tempV30) > radiusSquared)
                return ContainmentType.Intersects;
            if (Laya.Vector3.scalarLengthSquared(CollisionUtils._tempV30) > radiusSquared)
                return ContainmentType.Intersects;
            if (Laya.Vector3.scalarLengthSquared(CollisionUtils._tempV30) > radiusSquared)
                return ContainmentType.Intersects;
            if (Laya.Vector3.scalarLengthSquared(CollisionUtils._tempV30) > radiusSquared)
                return ContainmentType.Intersects;
            if (Laya.Vector3.scalarLengthSquared(CollisionUtils._tempV30) > radiusSquared)
                return ContainmentType.Intersects;
            if (Laya.Vector3.scalarLengthSquared(CollisionUtils._tempV30) > radiusSquared)
                return ContainmentType.Intersects;
            return ContainmentType.Contains;
        }
        static sphereContainsSphere(sphere1, sphere2) {
            var sphere1R = sphere1.radius;
            var sphere2R = sphere2.radius;
            var distance = Laya.Vector3.distance(sphere1.center, sphere2.center);
            if (sphere1R + sphere2R < distance)
                return ContainmentType.Disjoint;
            if (sphere1R - sphere2R < distance)
                return ContainmentType.Intersects;
            return ContainmentType.Contains;
        }
        static closestPointPointTriangle(point, vertex1, vertex2, vertex3, out) {
            Laya.Vector3.subtract(vertex2, vertex1, CollisionUtils._tempV30);
            Laya.Vector3.subtract(vertex3, vertex1, CollisionUtils._tempV31);
            Laya.Vector3.subtract(point, vertex1, CollisionUtils._tempV32);
            Laya.Vector3.subtract(point, vertex2, CollisionUtils._tempV33);
            Laya.Vector3.subtract(point, vertex3, CollisionUtils._tempV34);
            var d1 = Laya.Vector3.dot(CollisionUtils._tempV30, CollisionUtils._tempV32);
            var d2 = Laya.Vector3.dot(CollisionUtils._tempV31, CollisionUtils._tempV32);
            var d3 = Laya.Vector3.dot(CollisionUtils._tempV30, CollisionUtils._tempV33);
            var d4 = Laya.Vector3.dot(CollisionUtils._tempV31, CollisionUtils._tempV33);
            var d5 = Laya.Vector3.dot(CollisionUtils._tempV30, CollisionUtils._tempV34);
            var d6 = Laya.Vector3.dot(CollisionUtils._tempV31, CollisionUtils._tempV34);
            if (d1 <= 0 && d2 <= 0) {
                vertex1.cloneTo(out);
                return;
            }
            if (d3 >= 0 && d4 <= d3) {
                vertex2.cloneTo(out);
                return;
            }
            var vc = d1 * d4 - d3 * d2;
            if (vc <= 0 && d1 >= 0 && d3 <= 0) {
                var v = d1 / (d1 - d3);
                Laya.Vector3.scale(CollisionUtils._tempV30, v, out);
                Laya.Vector3.add(vertex1, out, out);
                return;
            }
            if (d6 >= 0 && d5 <= d6) {
                vertex3.cloneTo(out);
                return;
            }
            var vb = d5 * d2 - d1 * d6;
            if (vb <= 0 && d2 >= 0 && d6 <= 0) {
                var w = d2 / (d2 - d6);
                Laya.Vector3.scale(CollisionUtils._tempV31, w, out);
                Laya.Vector3.add(vertex1, out, out);
                return;
            }
            var va = d3 * d6 - d5 * d4;
            if (va <= 0 && (d4 - d3) >= 0 && (d5 - d6) >= 0) {
                var w3 = (d4 - d3) / ((d4 - d3) + (d5 - d6));
                Laya.Vector3.subtract(vertex3, vertex2, out);
                Laya.Vector3.scale(out, w3, out);
                Laya.Vector3.add(vertex2, out, out);
                return;
            }
            var denom = 1 / (va + vb + vc);
            var v2 = vb * denom;
            var w2 = vc * denom;
            Laya.Vector3.scale(CollisionUtils._tempV30, v2, CollisionUtils._tempV35);
            Laya.Vector3.scale(CollisionUtils._tempV31, w2, CollisionUtils._tempV36);
            Laya.Vector3.add(CollisionUtils._tempV35, CollisionUtils._tempV36, out);
            Laya.Vector3.add(vertex1, out, out);
        }
        static closestPointPlanePoint(plane, point, out) {
            var planeN = plane.normal;
            var t = Laya.Vector3.dot(planeN, point) - plane.distance;
            Laya.Vector3.scale(planeN, t, CollisionUtils._tempV30);
            Laya.Vector3.subtract(point, CollisionUtils._tempV30, out);
        }
        static closestPointBoxPoint(box, point, out) {
            Laya.Vector3.max(point, box.min, CollisionUtils._tempV30);
            Laya.Vector3.min(CollisionUtils._tempV30, box.max, out);
        }
        static closestPointSpherePoint(sphere, point, out) {
            var sphereC = sphere.center;
            Laya.Vector3.subtract(point, sphereC, out);
            Laya.Vector3.normalize(out, out);
            Laya.Vector3.scale(out, sphere.radius, out);
            Laya.Vector3.add(out, sphereC, out);
        }
        static closestPointSphereSphere(sphere1, sphere2, out) {
            var sphere1C = sphere1.center;
            Laya.Vector3.subtract(sphere2.center, sphere1C, out);
            Laya.Vector3.normalize(out, out);
            Laya.Vector3.scale(out, sphere1.radius, out);
            Laya.Vector3.add(out, sphere1C, out);
        }
    }
    CollisionUtils._tempV30 = new Laya.Vector3();
    CollisionUtils._tempV31 = new Laya.Vector3();
    CollisionUtils._tempV32 = new Laya.Vector3();
    CollisionUtils._tempV33 = new Laya.Vector3();
    CollisionUtils._tempV34 = new Laya.Vector3();
    CollisionUtils._tempV35 = new Laya.Vector3();
    CollisionUtils._tempV36 = new Laya.Vector3();

    exports.FrustumCorner = void 0;
    (function (FrustumCorner) {
        FrustumCorner[FrustumCorner["FarBottomLeft"] = 0] = "FarBottomLeft";
        FrustumCorner[FrustumCorner["FarTopLeft"] = 1] = "FarTopLeft";
        FrustumCorner[FrustumCorner["FarTopRight"] = 2] = "FarTopRight";
        FrustumCorner[FrustumCorner["FarBottomRight"] = 3] = "FarBottomRight";
        FrustumCorner[FrustumCorner["nearBottomLeft"] = 4] = "nearBottomLeft";
        FrustumCorner[FrustumCorner["nearTopLeft"] = 5] = "nearTopLeft";
        FrustumCorner[FrustumCorner["nearTopRight"] = 6] = "nearTopRight";
        FrustumCorner[FrustumCorner["nearBottomRight"] = 7] = "nearBottomRight";
        FrustumCorner[FrustumCorner["unknown"] = 8] = "unknown";
    })(exports.FrustumCorner || (exports.FrustumCorner = {}));
    class BoundFrustum {
        constructor(matrix) {
            this._matrix = matrix;
            this.initBoundingPlane();
        }
        static getPlanesFromMatrix(m, np, fp, lp, rp, tp, bp) {
            var matrixE = m.elements;
            var m11 = matrixE[0];
            var m12 = matrixE[1];
            var m13 = matrixE[2];
            var m14 = matrixE[3];
            var m21 = matrixE[4];
            var m22 = matrixE[5];
            var m23 = matrixE[6];
            var m24 = matrixE[7];
            var m31 = matrixE[8];
            var m32 = matrixE[9];
            var m33 = matrixE[10];
            var m34 = matrixE[11];
            var m41 = matrixE[12];
            var m42 = matrixE[13];
            var m43 = matrixE[14];
            var m44 = matrixE[15];
            var nearNorE = np.normal;
            nearNorE.x = m13;
            nearNorE.y = m23;
            nearNorE.z = m33;
            np.distance = m43;
            np.normal = nearNorE;
            np.normalize();
            var farNorE = fp.normal;
            farNorE.x = m14 - m13;
            farNorE.y = m24 - m23;
            farNorE.z = m34 - m33;
            fp.distance = m44 - m43;
            fp.normal = farNorE;
            fp.normalize();
            var leftNorE = lp.normal;
            leftNorE.x = m14 + m11;
            leftNorE.y = m24 + m21;
            leftNorE.z = m34 + m31;
            lp.distance = m44 + m41;
            lp.normal = leftNorE;
            lp.normalize();
            var rightNorE = rp.normal;
            rightNorE.x = m14 - m11;
            rightNorE.y = m24 - m21;
            rightNorE.z = m34 - m31;
            rp.distance = m44 - m41;
            rp.normal = rightNorE;
            rp.normalize();
            var topNorE = tp.normal;
            topNorE.x = m14 - m12;
            topNorE.y = m24 - m22;
            topNorE.z = m34 - m32;
            tp.distance = m44 - m42;
            tp.normal = topNorE;
            tp.normalize();
            var bottomNorE = bp.normal;
            bottomNorE.x = m14 + m12;
            bottomNorE.y = m24 + m22;
            bottomNorE.z = m34 + m32;
            bp.distance = m44 + m42;
            bp.normal = bottomNorE;
            bp.normalize();
        }
        initBoundingPlane() {
            this._near = new Plane();
            this._far = new Plane();
            this._left = new Plane();
            this._right = new Plane();
            this._top = new Plane();
            this._bottom = new Plane();
            BoundFrustum.getPlanesFromMatrix(this._matrix, this._near, this._far, this._left, this._right, this._top, this._bottom);
        }
        get matrix() {
            return this._matrix;
        }
        set matrix(matrix) {
            matrix.cloneTo(this._matrix);
            BoundFrustum.getPlanesFromMatrix(this._matrix, this._near, this._far, this._left, this._right, this._top, this._bottom);
        }
        get near() {
            return this._near;
        }
        get far() {
            return this._far;
        }
        get left() {
            return this._left;
        }
        get right() {
            return this._right;
        }
        get top() {
            return this._top;
        }
        get bottom() {
            return this._bottom;
        }
        equalsBoundFrustum(other) {
            return this._matrix.equalsOtherMatrix(other.matrix);
        }
        equalsObj(obj) {
            if (obj instanceof BoundFrustum) {
                var bf = obj;
                return this.equalsBoundFrustum(bf);
            }
            return false;
        }
        getPlane(index) {
            switch (index) {
                case 0:
                    return this._near;
                case 1:
                    return this._far;
                case 2:
                    return this._left;
                case 3:
                    return this._right;
                case 4:
                    return this._top;
                case 5:
                    return this._bottom;
                default:
                    return null;
            }
        }
        static get3PlaneInterPoint(p1, p2, p3, out) {
            var p1Nor = p1.normal;
            var p2Nor = p2.normal;
            var p3Nor = p3.normal;
            Laya.Vector3.cross(p2Nor, p3Nor, BoundFrustum._tempV30);
            Laya.Vector3.cross(p3Nor, p1Nor, BoundFrustum._tempV31);
            Laya.Vector3.cross(p1Nor, p2Nor, BoundFrustum._tempV32);
            var a = Laya.Vector3.dot(p1Nor, BoundFrustum._tempV30);
            var b = Laya.Vector3.dot(p2Nor, BoundFrustum._tempV31);
            var c = Laya.Vector3.dot(p3Nor, BoundFrustum._tempV32);
            Laya.Vector3.scale(BoundFrustum._tempV30, -p1.distance / a, BoundFrustum._tempV33);
            Laya.Vector3.scale(BoundFrustum._tempV31, -p2.distance / b, BoundFrustum._tempV34);
            Laya.Vector3.scale(BoundFrustum._tempV32, -p3.distance / c, BoundFrustum._tempV35);
            Laya.Vector3.add(BoundFrustum._tempV33, BoundFrustum._tempV34, BoundFrustum._tempV36);
            Laya.Vector3.add(BoundFrustum._tempV35, BoundFrustum._tempV36, out);
        }
        getCorners(corners) {
            BoundFrustum.get3PlaneInterPoint(this._near, this._bottom, this._right, corners[exports.FrustumCorner.nearBottomRight]);
            BoundFrustum.get3PlaneInterPoint(this._near, this._top, this._right, corners[exports.FrustumCorner.nearTopRight]);
            BoundFrustum.get3PlaneInterPoint(this._near, this._top, this._left, corners[exports.FrustumCorner.nearTopLeft]);
            BoundFrustum.get3PlaneInterPoint(this._near, this._bottom, this._left, corners[exports.FrustumCorner.nearBottomLeft]);
            BoundFrustum.get3PlaneInterPoint(this._far, this._bottom, this._right, corners[exports.FrustumCorner.FarBottomRight]);
            BoundFrustum.get3PlaneInterPoint(this._far, this._top, this._right, corners[exports.FrustumCorner.FarTopRight]);
            BoundFrustum.get3PlaneInterPoint(this._far, this._top, this._left, corners[exports.FrustumCorner.FarTopLeft]);
            BoundFrustum.get3PlaneInterPoint(this._far, this._bottom, this._left, corners[exports.FrustumCorner.FarBottomLeft]);
        }
        containsPoint(point) {
            var result = Plane.PlaneIntersectionType_Front;
            var planeResult = Plane.PlaneIntersectionType_Front;
            for (var i = 0; i < 6; i++) {
                switch (i) {
                    case 0:
                        planeResult = CollisionUtils.intersectsPlaneAndPoint(this._near, point);
                        break;
                    case 1:
                        planeResult = CollisionUtils.intersectsPlaneAndPoint(this._far, point);
                        break;
                    case 2:
                        planeResult = CollisionUtils.intersectsPlaneAndPoint(this._left, point);
                        break;
                    case 3:
                        planeResult = CollisionUtils.intersectsPlaneAndPoint(this._right, point);
                        break;
                    case 4:
                        planeResult = CollisionUtils.intersectsPlaneAndPoint(this._top, point);
                        break;
                    case 5:
                        planeResult = CollisionUtils.intersectsPlaneAndPoint(this._bottom, point);
                        break;
                }
                switch (planeResult) {
                    case Plane.PlaneIntersectionType_Back:
                        return ContainmentType.Disjoint;
                    case Plane.PlaneIntersectionType_Intersecting:
                        result = Plane.PlaneIntersectionType_Intersecting;
                        break;
                }
            }
            switch (result) {
                case Plane.PlaneIntersectionType_Intersecting:
                    return ContainmentType.Intersects;
                default:
                    return ContainmentType.Contains;
            }
        }
        intersects(box) {
            var min = box.min;
            var max = box.max;
            var minX = min.x;
            var minY = min.y;
            var minZ = min.z;
            var maxX = max.x;
            var maxY = max.y;
            var maxZ = max.z;
            var nearNormal = this._near.normal;
            if (this._near.distance + (nearNormal.x * (nearNormal.x < 0 ? minX : maxX)) + (nearNormal.y * (nearNormal.y < 0 ? minY : maxY)) + (nearNormal.z * (nearNormal.z < 0 ? minZ : maxZ)) < 0)
                return false;
            var leftNormal = this._left.normal;
            if (this._left.distance + (leftNormal.x * (leftNormal.x < 0 ? minX : maxX)) + (leftNormal.y * (leftNormal.y < 0 ? minY : maxY)) + (leftNormal.z * (leftNormal.z < 0 ? minZ : maxZ)) < 0)
                return false;
            var rightNormal = this._right.normal;
            if (this._right.distance + (rightNormal.x * (rightNormal.x < 0 ? minX : maxX)) + (rightNormal.y * (rightNormal.y < 0 ? minY : maxY)) + (rightNormal.z * (rightNormal.z < 0 ? minZ : maxZ)) < 0)
                return false;
            var bottomNormal = this._bottom.normal;
            if (this._bottom.distance + (bottomNormal.x * (bottomNormal.x < 0 ? minX : maxX)) + (bottomNormal.y * (bottomNormal.y < 0 ? minY : maxY)) + (bottomNormal.z * (bottomNormal.z < 0 ? minZ : maxZ)) < 0)
                return false;
            var topNormal = this._top.normal;
            if (this._top.distance + (topNormal.x * (topNormal.x < 0 ? minX : maxX)) + (topNormal.y * (topNormal.y < 0 ? minY : maxY)) + (topNormal.z * (topNormal.z < 0 ? minZ : maxZ)) < 0)
                return false;
            var farNormal = this._far.normal;
            if (this._far.distance + (farNormal.x * (farNormal.x < 0 ? minX : maxX)) + (farNormal.y * (farNormal.y < 0 ? minY : maxY)) + (farNormal.z * (farNormal.z < 0 ? minZ : maxZ)) < 0)
                return false;
            return true;
        }
        containsBoundBox(box) {
            var p = BoundFrustum._tempV30, n = BoundFrustum._tempV31;
            var boxMin = box.min;
            var boxMax = box.max;
            var result = ContainmentType.Contains;
            for (var i = 0; i < 6; i++) {
                var plane = this.getPlane(i);
                var planeNor = plane.normal;
                if (planeNor.x >= 0) {
                    p.x = boxMax.x;
                    n.x = boxMin.x;
                }
                else {
                    p.x = boxMin.x;
                    n.x = boxMax.x;
                }
                if (planeNor.y >= 0) {
                    p.y = boxMax.y;
                    n.y = boxMin.y;
                }
                else {
                    p.y = boxMin.y;
                    n.y = boxMax.y;
                }
                if (planeNor.z >= 0) {
                    p.z = boxMax.z;
                    n.z = boxMin.z;
                }
                else {
                    p.z = boxMin.z;
                    n.z = boxMax.z;
                }
                if (CollisionUtils.intersectsPlaneAndPoint(plane, p) === Plane.PlaneIntersectionType_Back)
                    return ContainmentType.Disjoint;
                if (CollisionUtils.intersectsPlaneAndPoint(plane, n) === Plane.PlaneIntersectionType_Back)
                    result = ContainmentType.Intersects;
            }
            return result;
        }
        containsBoundSphere(sphere) {
            var result = Plane.PlaneIntersectionType_Front;
            var planeResult = Plane.PlaneIntersectionType_Front;
            for (var i = 0; i < 6; i++) {
                switch (i) {
                    case 0:
                        planeResult = CollisionUtils.intersectsPlaneAndSphere(this._near, sphere);
                        break;
                    case 1:
                        planeResult = CollisionUtils.intersectsPlaneAndSphere(this._far, sphere);
                        break;
                    case 2:
                        planeResult = CollisionUtils.intersectsPlaneAndSphere(this._left, sphere);
                        break;
                    case 3:
                        planeResult = CollisionUtils.intersectsPlaneAndSphere(this._right, sphere);
                        break;
                    case 4:
                        planeResult = CollisionUtils.intersectsPlaneAndSphere(this._top, sphere);
                        break;
                    case 5:
                        planeResult = CollisionUtils.intersectsPlaneAndSphere(this._bottom, sphere);
                        break;
                }
                switch (planeResult) {
                    case Plane.PlaneIntersectionType_Back:
                        return ContainmentType.Disjoint;
                    case Plane.PlaneIntersectionType_Intersecting:
                        result = Plane.PlaneIntersectionType_Intersecting;
                        break;
                }
            }
            switch (result) {
                case Plane.PlaneIntersectionType_Intersecting:
                    return ContainmentType.Intersects;
                default:
                    return ContainmentType.Contains;
            }
        }
        cloneTo(dest) {
            dest.matrix = this.matrix;
        }
        clone() {
            let dest = new BoundFrustum(new Laya.Matrix4x4);
            this.cloneTo(dest);
            return dest;
        }
    }
    BoundFrustum._tempV30 = new Laya.Vector3();
    BoundFrustum._tempV31 = new Laya.Vector3();
    BoundFrustum._tempV32 = new Laya.Vector3();
    BoundFrustum._tempV33 = new Laya.Vector3();
    BoundFrustum._tempV34 = new Laya.Vector3();
    BoundFrustum._tempV35 = new Laya.Vector3();
    BoundFrustum._tempV36 = new Laya.Vector3();

    class Viewport {
        constructor(x, y, width, height) {
            this.minDepth = 0.0;
            this.maxDepth = 1.0;
            this.x = x !== null && x !== void 0 ? x : 0;
            this.y = y !== null && y !== void 0 ? y : 0;
            this.width = width !== null && width !== void 0 ? width : 0;
            this.height = height !== null && height !== void 0 ? height : 0;
        }
        project(source, matrix, out) {
            Laya.Vector3.transformV3ToV4(source, matrix, out);
            var x = out.x, y = out.y, z = out.z;
            var w = out.w;
            if (w !== 1.0) {
                x = x / w;
                y = y / w;
                z = z / w;
            }
            out.x = (x + 1.0) * 0.5 * this.width + this.x;
            out.y = (-y + 1.0) * 0.5 * this.height + this.y;
            out.z = z * (this.maxDepth - this.minDepth) + this.minDepth;
        }
        unprojectFromMat(source, matrix, out) {
            var matrixEleme = matrix.elements;
            out.x = (((source.x - this.x) / this.width) * 2.0) - 1.0;
            out.y = -((((source.y - this.y) / this.height) * 2.0) - 1.0);
            out.z = (source.z - this.minDepth) / (this.maxDepth - this.minDepth);
            var a = (((out.x * matrixEleme[3]) + (out.y * matrixEleme[7])) + (out.z * matrixEleme[11])) + matrixEleme[15];
            Laya.Vector3.transformV3ToV3(out, matrix, out);
            if (a !== 1.0) {
                out.x = out.x / a;
                out.y = out.y / a;
                out.z = out.z / a;
            }
        }
        unprojectFromWVP(source, projection, view, world, out) {
            Laya.Matrix4x4.multiply(projection, view, Viewport._tempMatrix4x4);
            (world) && (Laya.Matrix4x4.multiply(Viewport._tempMatrix4x4, world, Viewport._tempMatrix4x4));
            Viewport._tempMatrix4x4.invert(Viewport._tempMatrix4x4);
            this.unprojectFromMat(source, Viewport._tempMatrix4x4, out);
        }
        set(x, y, width, height) {
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
        }
        cloneTo(out) {
            out.x = this.x;
            out.y = this.y;
            out.width = this.width;
            out.height = this.height;
            out.minDepth = this.minDepth;
            out.maxDepth = this.maxDepth;
        }
    }
    Viewport._tempMatrix4x4 = new Laya.Matrix4x4();
    Viewport._tempViewport = new Viewport(0, 0, 0, 0);

    class Picker {
        constructor() {
        }
        static calculateCursorRay(point, viewPort, projectionMatrix, viewMatrix, world, out) {
            var x = point.x;
            var y = point.y;
            var nearSource = Picker._tempVector30;
            var nerSourceE = nearSource;
            nerSourceE.x = x;
            nerSourceE.y = y;
            nerSourceE.z = viewPort.minDepth;
            var farSource = Picker._tempVector31;
            var farSourceE = farSource;
            farSourceE.x = x;
            farSourceE.y = y;
            farSourceE.z = viewPort.maxDepth;
            var nearPoint = out.origin;
            var farPoint = Picker._tempVector32;
            viewPort.unprojectFromWVP(nearSource, projectionMatrix, viewMatrix, world, nearPoint);
            viewPort.unprojectFromWVP(farSource, projectionMatrix, viewMatrix, world, farPoint);
            var outDire = out.direction;
            outDire.x = farPoint.x - nearPoint.x;
            outDire.y = farPoint.y - nearPoint.y;
            outDire.z = farPoint.z - nearPoint.z;
            Laya.Vector3.normalize(out.direction, out.direction);
        }
        static rayIntersectsTriangle(ray, vertex1, vertex2, vertex3) {
            var result;
            var edge1 = Picker._tempVector30, edge2 = Picker._tempVector31;
            Laya.Vector3.subtract(vertex2, vertex1, edge1);
            Laya.Vector3.subtract(vertex3, vertex1, edge2);
            var directionCrossEdge2 = Picker._tempVector32;
            Laya.Vector3.cross(ray.direction, edge2, directionCrossEdge2);
            var determinant;
            determinant = Laya.Vector3.dot(edge1, directionCrossEdge2);
            if (determinant > -Number.MIN_VALUE && determinant < Number.MIN_VALUE) {
                result = Number.NaN;
                return result;
            }
            var inverseDeterminant = 1.0 / determinant;
            var distanceVector = Picker._tempVector33;
            Laya.Vector3.subtract(ray.origin, vertex1, distanceVector);
            var triangleU;
            triangleU = Laya.Vector3.dot(distanceVector, directionCrossEdge2);
            triangleU *= inverseDeterminant;
            if (triangleU < 0 || triangleU > 1) {
                result = Number.NaN;
                return result;
            }
            var distanceCrossEdge1 = Picker._tempVector34;
            Laya.Vector3.cross(distanceVector, edge1, distanceCrossEdge1);
            var triangleV;
            triangleV = Laya.Vector3.dot(ray.direction, distanceCrossEdge1);
            triangleV *= inverseDeterminant;
            if (triangleV < 0 || triangleU + triangleV > 1) {
                result = Number.NaN;
                return result;
            }
            var rayDistance;
            rayDistance = Laya.Vector3.dot(edge2, distanceCrossEdge1);
            rayDistance *= inverseDeterminant;
            if (rayDistance < 0) {
                result = Number.NaN;
                return result;
            }
            result = rayDistance;
            return result;
        }
        static rayPlaneIntersection(ray, plane) {
            let point = new Laya.Vector3();
            let ddotn = Laya.Vector3.dot(ray.direction.normalize(), plane.normal.normalize());
            if (ddotn == 0) {
                return null;
            }
            let t = (plane.distance - Laya.Vector3.dot(ray.origin, plane.normal)) / ddotn;
            if (t < 0)
                return null;
            ray.at(t, point);
            return point;
        }
    }
    Picker._tempVector30 = new Laya.Vector3();
    Picker._tempVector31 = new Laya.Vector3();
    Picker._tempVector32 = new Laya.Vector3();
    Picker._tempVector33 = new Laya.Vector3();
    Picker._tempVector34 = new Laya.Vector3();

    class RenderableSprite3D extends Sprite3D {
        constructor(name) {
            super(name);
        }
        static __init__() {
            RenderableSprite3D.SHADERDEFINE_RECEIVE_SHADOW = Laya.Shader3D.getDefineByName("RECEIVESHADOW");
            RenderableSprite3D.SAHDERDEFINE_LIGHTMAP = Laya.Shader3D.getDefineByName("LIGHTMAP");
            RenderableSprite3D.SHADERDEFINE_LIGHTMAP_DIRECTIONAL = Laya.Shader3D.getDefineByName("LIGHTMAP_DIRECTIONAL");
            RenderableSprite3D.LIGHTMAPSCALEOFFSET = Laya.Shader3D.propertyNameToID("u_LightmapScaleOffset");
            RenderableSprite3D.LIGHTMAP = Laya.Shader3D.propertyNameToID("u_LightMap");
            RenderableSprite3D.LIGHTMAP_DIRECTION = Laya.Shader3D.propertyNameToID("u_LightMapDirection");
            RenderableSprite3D.PICKCOLOR = Laya.Shader3D.propertyNameToID("u_PickColor");
            RenderableSprite3D.REFLECTIONCUBE_PROBEPOSITION = Laya.Shader3D.propertyNameToID("u_SpecCubeProbePosition");
            RenderableSprite3D.REFLECTIONCUBE_PROBEBOXMAX = Laya.Shader3D.propertyNameToID("u_SpecCubeBoxMax");
            RenderableSprite3D.REFLECTIONCUBE_PROBEBOXMIN = Laya.Shader3D.propertyNameToID("u_SpecCubeBoxMin");
            RenderableSprite3D.AMBIENTCOLOR = Laya.Shader3D.propertyNameToID("u_AmbientColor");
            RenderableSprite3D.AMBIENTSH = Laya.Shader3D.propertyNameToID("u_IblSH");
            RenderableSprite3D.AMBIENTINTENSITY = Laya.Shader3D.propertyNameToID("u_AmbientIntensity");
            RenderableSprite3D.REFLECTIONINTENSITY = Laya.Shader3D.propertyNameToID("u_ReflectionIntensity");
            RenderableSprite3D.IBLTEX = Laya.Shader3D.propertyNameToID("u_IBLTex");
            const commandUniform = Laya.LayaGL.renderOBJCreate.createGlobalUniformMap("Sprite3D");
            commandUniform.addShaderUniform(RenderableSprite3D.LIGHTMAPSCALEOFFSET, "u_LightmapScaleOffset");
            commandUniform.addShaderUniform(RenderableSprite3D.LIGHTMAP, "u_LightMap");
            commandUniform.addShaderUniform(RenderableSprite3D.LIGHTMAP_DIRECTION, "u_LightMapDirection");
            commandUniform.addShaderUniform(RenderableSprite3D.PICKCOLOR, "u_PickColor");
            commandUniform.addShaderUniform(RenderableSprite3D.REFLECTIONCUBE_PROBEPOSITION, "u_SpecCubeProbePosition");
            commandUniform.addShaderUniform(RenderableSprite3D.REFLECTIONCUBE_PROBEBOXMAX, "u_SpecCubeBoxMax");
            commandUniform.addShaderUniform(RenderableSprite3D.REFLECTIONCUBE_PROBEBOXMIN, "u_SpecCubeBoxMin");
            commandUniform.addShaderUniform(RenderableSprite3D.IBLTEX, "u_IBLTex");
            commandUniform.addShaderUniform(RenderableSprite3D.AMBIENTSH, "u_IblSH");
            commandUniform.addShaderUniform(RenderableSprite3D.AMBIENTCOLOR, "u_AmbientColor");
            commandUniform.addShaderUniform(RenderableSprite3D.AMBIENTINTENSITY, "u_AmbientIntensity");
            commandUniform.addShaderUniform(RenderableSprite3D.REFLECTIONINTENSITY, "u_ReflectionIntensity");
            RenderableSprite3D.REFLECTIONTEXTURE = Laya.Shader3D.propertyNameToID("u_ReflectTexture");
            RenderableSprite3D.REFLECTIONCUBE_HDR_PARAMS = Laya.Shader3D.propertyNameToID("u_ReflectCubeHDRParams");
            commandUniform.addShaderUniform(RenderableSprite3D.REFLECTIONTEXTURE, "REFLECTIONTEXTURE");
            commandUniform.addShaderUniform(RenderableSprite3D.REFLECTIONCUBE_HDR_PARAMS, "u_ReflectCubeHDRParams");
            RenderableSprite3D.AMBIENTSHAR = Laya.Shader3D.propertyNameToID("u_AmbientSHAr");
            commandUniform.addShaderUniform(RenderableSprite3D.AMBIENTSHAR, "u_AmbientSHAr");
            RenderableSprite3D.AMBIENTSHAG = Laya.Shader3D.propertyNameToID("u_AmbientSHAg");
            commandUniform.addShaderUniform(RenderableSprite3D.AMBIENTSHAG, "u_AmbientSHAg");
            RenderableSprite3D.AMBIENTSHAB = Laya.Shader3D.propertyNameToID("u_AmbientSHAb");
            commandUniform.addShaderUniform(RenderableSprite3D.AMBIENTSHAB, "u_AmbientSHAb");
            RenderableSprite3D.AMBIENTSHBR = Laya.Shader3D.propertyNameToID("u_AmbientSHBr");
            commandUniform.addShaderUniform(RenderableSprite3D.AMBIENTSHBR, "u_AmbientSHBr");
            RenderableSprite3D.AMBIENTSHBG = Laya.Shader3D.propertyNameToID("u_AmbientSHBg");
            commandUniform.addShaderUniform(RenderableSprite3D.AMBIENTSHBG, "u_AmbientSHBg");
            RenderableSprite3D.AMBIENTSHBB = Laya.Shader3D.propertyNameToID("u_AmbientSHBb");
            commandUniform.addShaderUniform(RenderableSprite3D.AMBIENTSHBB, "u_AmbientSHBb");
            RenderableSprite3D.AMBIENTSHC = Laya.Shader3D.propertyNameToID("u_AmbientSHC");
            commandUniform.addShaderUniform(RenderableSprite3D.AMBIENTSHC, "u_AmbientSHC");
        }
        _onInActive() {
            super._onInActive();
        }
        _onActive() {
            super._onActive();
        }
        _onActiveInScene() {
            super._onActiveInScene();
        }
        _create() {
            return new Sprite3D(this.name);
        }
        _addToInitStaticBatchManager() {
        }
        _setBelongScene(scene) {
            super._setBelongScene(scene);
        }
        _setUnBelongScene() {
            super._setUnBelongScene();
        }
    }

    class MeshSprite3DShaderDeclaration {
    }

    exports.TextureCubeFace = void 0;
    (function (TextureCubeFace) {
        TextureCubeFace[TextureCubeFace["PositiveX"] = 0] = "PositiveX";
        TextureCubeFace[TextureCubeFace["NegativeX"] = 1] = "NegativeX";
        TextureCubeFace[TextureCubeFace["PositiveY"] = 2] = "PositiveY";
        TextureCubeFace[TextureCubeFace["NegativeY"] = 3] = "NegativeY";
        TextureCubeFace[TextureCubeFace["PositiveZ"] = 4] = "PositiveZ";
        TextureCubeFace[TextureCubeFace["NegativeZ"] = 5] = "NegativeZ";
    })(exports.TextureCubeFace || (exports.TextureCubeFace = {}));
    const DEFAULT_PIXELS = new Uint8Array(3);
    class TextureCube extends Laya.BaseTexture {
        constructor(size, format, mipmap = true, sRGB = false) {
            super(size, size, format);
            this._dimension = Laya.TextureDimension.Cube;
            this._texture = Laya.LayaGL.textureContext.createTextureInternal(this._dimension, size, size, format, mipmap, sRGB);
            return;
        }
        static get blackTexture() {
            return TextureCube._blackTexture;
        }
        static get grayTexture() {
            return TextureCube._grayTexture;
        }
        static get whiteTexture() {
            return TextureCube._grayTexture;
        }
        static __init__() {
            var blackTexture = new TextureCube(1, Laya.TextureFormat.R8G8B8, false);
            var grayTexture = new TextureCube(1, Laya.TextureFormat.R8G8B8, false);
            var writeTexture = new TextureCube(1, Laya.TextureFormat.R8G8B8, false);
            var pixels = DEFAULT_PIXELS;
            pixels[0] = 0, pixels[1] = 0, pixels[2] = 0;
            blackTexture.setPixelsData([pixels, pixels, pixels, pixels, pixels, pixels], false, false);
            blackTexture.lock = true;
            pixels[0] = 128, pixels[1] = 128, pixels[2] = 128;
            grayTexture.setPixelsData([pixels, pixels, pixels, pixels, pixels, pixels], false, false);
            grayTexture.lock = true;
            pixels[0] = 255, pixels[1] = 255, pixels[2] = 255;
            writeTexture.setPixelsData([pixels, pixels, pixels, pixels, pixels, pixels], false, false);
            writeTexture.lock = true;
            TextureCube._grayTexture = grayTexture;
            TextureCube._blackTexture = blackTexture;
            TextureCube._whiteTexture = writeTexture;
        }
        setImageData(source, premultiplyAlpha, invertY) {
            let error = false;
            let k = source.findIndex(s => s != null);
            if (k != -1) {
                let img = source[k];
                if (!source.every(s => s != null && s.width == img.width && s.height == img.height))
                    error = true;
            }
            else
                error = true;
            let texture = this._texture;
            if (!error)
                Laya.LayaGL.textureContext.setCubeImageData(texture, source, premultiplyAlpha, invertY);
            else {
                let pixels = DEFAULT_PIXELS;
                Laya.LayaGL.textureContext.setCubePixelsData(texture, [pixels, pixels, pixels, pixels, pixels, pixels], premultiplyAlpha, invertY);
            }
        }
        setPixelsData(source, premultiplyAlpha, invertY) {
            let texture = this._texture;
            Laya.LayaGL.textureContext.setCubePixelsData(texture, source, premultiplyAlpha, invertY);
        }
        updateSubPixelsData(source, xOffset, yOffset, width, height, mipmapLevel, generateMipmap, premultiplyAlpha, invertY) {
            let texture = this._texture;
            Laya.LayaGL.textureContext.setCubeSubPixelData(texture, source, mipmapLevel, generateMipmap, xOffset, yOffset, width, height, premultiplyAlpha, invertY);
        }
        setDDSData(ddsInfo) {
            let texture = this._texture;
            Laya.LayaGL.textureContext.setCubeDDSData(texture, ddsInfo);
        }
        setKTXData(ktxInfo) {
            let texture = this._texture;
            Laya.LayaGL.textureContext.setCubeKTXData(texture, ktxInfo);
        }
        get defaultTexture() {
            return TextureCube.grayTexture;
        }
    }

    class Bounds {
        constructor(min, max) {
            this._imp = Laya.LayaGL.renderOBJCreate.createBounds(min, max);
        }
        static merge(box1, box2, out) {
            Laya.Vector3.min(box1.min, box2.min, out.min);
            Laya.Vector3.max(box1.max, box2.max, out.max);
            out.min = out.min;
            out.max = out.max;
        }
        static containPoint(box, point) {
            let max = box.getMax();
            let min = box.getMin();
            if (point.x > max.x || point.x < min.x)
                return false;
            if (point.y > max.y || point.y < min.y)
                return false;
            if (point.z > max.z || point.z < min.z)
                return false;
            return true;
        }
        get min() {
            return this.getMin();
        }
        set min(value) {
            this.setMin(value);
        }
        get max() {
            return this.getMax();
        }
        set max(value) {
            this.setMax(value);
        }
        setMin(value) {
            this._imp.setMin(value);
        }
        getMin() {
            return this._imp.getMin();
        }
        setMax(value) {
            this._imp.setMax(value);
        }
        getMax() {
            return this._imp.getMax();
        }
        setCenter(value) {
            this._imp.setCenter(value);
        }
        getCenter() {
            return this._imp.getCenter();
        }
        setExtent(value) {
            this._imp.setExtent(value);
        }
        getExtent() {
            return this._imp.getExtent();
        }
        _getUpdateFlag(type) {
            return this._imp._getUpdateFlag(type);
        }
        _setUpdateFlag(type, value) {
            this._imp._setUpdateFlag(type, value);
        }
        _getCenter(min, max, out) {
            Laya.Vector3.add(min, max, out);
            Laya.Vector3.scale(out, 0.5, out);
        }
        _getExtent(min, max, out) {
            Laya.Vector3.subtract(max, min, out);
            Laya.Vector3.scale(out, 0.5, out);
        }
        _getMin(center, extent, out) {
            Laya.Vector3.subtract(center, extent, out);
        }
        _getMax(center, extent, out) {
            Laya.Vector3.add(center, extent, out);
        }
        _rotateExtents(extents, rotation, out) {
            var extentsX = extents.x;
            var extentsY = extents.y;
            var extentsZ = extents.z;
            var matE = rotation.elements;
            out.x = Math.abs(matE[0] * extentsX) + Math.abs(matE[4] * extentsY) + Math.abs(matE[8] * extentsZ);
            out.y = Math.abs(matE[1] * extentsX) + Math.abs(matE[5] * extentsY) + Math.abs(matE[9] * extentsZ);
            out.z = Math.abs(matE[2] * extentsX) + Math.abs(matE[6] * extentsY) + Math.abs(matE[10] * extentsZ);
        }
        _tranform(matrix, out) {
            this._imp._tranform(matrix, out._imp);
        }
        getCorners(corners) {
            this._imp.getCorners(corners);
        }
        getBoundBox(box) {
            this._imp._getBoundBox().cloneTo(box);
        }
        calculateBoundsintersection(bounds) {
            return this._imp.calculateBoundsintersection(bounds._imp);
        }
        cloneTo(destObject) {
            this._imp.cloneTo(destObject._imp);
        }
        clone() {
            var dest = new Bounds(new Laya.Vector3(), new Laya.Vector3());
            this.cloneTo(dest);
            return dest;
        }
    }
    Bounds._UPDATE_MIN = 0x01;
    Bounds._UPDATE_MAX = 0x02;
    Bounds._UPDATE_CENTER = 0x04;
    Bounds._UPDATE_EXTENT = 0x08;
    new Laya.Vector3();
    new Laya.Vector3();

    exports.volumeIntersectType = void 0;
    (function (volumeIntersectType) {
        volumeIntersectType[volumeIntersectType["contain"] = 0] = "contain";
        volumeIntersectType[volumeIntersectType["intersect"] = 1] = "intersect";
        volumeIntersectType[volumeIntersectType["Disjoint"] = 2] = "Disjoint";
    })(exports.volumeIntersectType || (exports.volumeIntersectType = {}));
    class volumeIntersectInfo {
    }
    class Volume extends Laya.Component {
        constructor() {
            super();
            this._aroundVolumeCacheNum = 0;
            this._bounds = new Bounds();
            this._primitiveBounds = new Bounds();
            this._importance = 0;
            this.runInEditor = true;
        }
        get type() {
            return this._type;
        }
        get bounds() {
            return this._bounds;
        }
        get boundsMax() {
            return this._primitiveBounds.getMax();
        }
        set boundsMax(value) {
            this._primitiveBounds.setMax(value);
            this._reCaculateBoundBox();
        }
        set boundsMin(value) {
            this._primitiveBounds.setMin(value);
            this._reCaculateBoundBox();
        }
        get boundsMin() {
            return this._primitiveBounds.getMin();
        }
        get probePosition() {
            return this.owner.transform.position;
        }
        get importance() {
            return this._importance;
        }
        set importance(value) {
            this._importance = value;
        }
        _onEnable() {
            this.owner.transform.on(Laya.Event.TRANSFORM_CHANGED, this, this._VolumeChange);
            this._volumeManager = this.owner.scene._volumeManager;
            this._volumeManager.add(this);
            this._reCaculateBoundBox();
        }
        _onDisable() {
            this.owner.transform.off(Laya.Event.TRANSFORM_CHANGED, this, this._VolumeChange);
            this._volumeManager.remove(this);
        }
        _VolumeChange() {
            this._volumeManager._needUpdateAllRender = true;
            this._reCaculateBoundBox();
        }
        _reCaculateBoundBox() {
            this.owner && this._primitiveBounds._tranform(this.owner.transform.worldMatrix, this._bounds);
        }
        _cloneTo(dest) {
        }
    }

    class ReflectionProbeManager {
        constructor() {
            this._reflectionProbes = new Laya.SingletonList();
            this._needUpdateAllRender = false;
            this._sceneReflectionProbe = new ReflectionProbe();
            this._sceneReflectionProbe.boxProjection = false;
            this._sceneReflectionProbe._isScene = true;
        }
        set sceneReflectionProbe(value) {
            this._sceneReflectionProbe = value;
            this._needUpdateAllRender = true;
        }
        get sceneReflectionProbe() {
            return this._sceneReflectionProbe;
        }
        _updateRenderObject(baseRender) {
            if (this._reflectionProbes.length == 0) {
                baseRender.probReflection = this._sceneReflectionProbe;
                return;
            }
            var elements = this._reflectionProbes.elements;
            var maxOverlap = 0;
            var mainProbe;
            var renderBounds = baseRender.bounds;
            var overlop;
            for (var i = 0, n = this._reflectionProbes.length; i < n; i++) {
                var renflectProbe = elements[i];
                if (!mainProbe) {
                    overlop = renderBounds.calculateBoundsintersection(renflectProbe.bounds);
                    if (overlop < maxOverlap)
                        continue;
                }
                else {
                    if (mainProbe.importance > renflectProbe.importance)
                        continue;
                    overlop = renderBounds.calculateBoundsintersection(renflectProbe.bounds);
                    if (overlop < maxOverlap && mainProbe.importance == renflectProbe.importance)
                        continue;
                }
                mainProbe = renflectProbe;
                maxOverlap = overlop;
            }
            if (!mainProbe && this._sceneReflectionProbe)
                mainProbe = this._sceneReflectionProbe;
            baseRender.probReflection = mainProbe;
        }
        add(volume) {
            this._reflectionProbes.add(volume);
            this._needUpdateAllRender = true;
        }
        remove(volume) {
            this._reflectionProbes.remove(volume);
            this._needUpdateAllRender = true;
        }
        handleMotionlist(motionObjects) {
            var elements = motionObjects.elements;
            let render;
            for (var i = 0, n = motionObjects.length; i < n; i++) {
                render = elements[i];
                if (render._surportReflectionProbe && render._reflectionMode == 1) {
                    this._updateRenderObject(elements[i]);
                }
            }
        }
        reCaculateAllRenderObjects(baseRenders) {
            var elements = baseRenders.elements;
            let render;
            for (var i = 0, n = baseRenders.length; i < n; i++) {
                render = elements[i];
                if (render._surportReflectionProbe && render._reflectionMode == 1) {
                    this._updateRenderObject(render);
                }
                this._needUpdateAllRender = false;
            }
        }
        destroy() {
            for (let index = 0; index < this._reflectionProbes.length; index++) {
                let probe = this._reflectionProbes.elements[index];
                probe.destroy();
            }
            this._reflectionProbes.length = 0;
            this._sceneReflectionProbe.destroy();
            this._sceneReflectionProbe = null;
        }
    }

    class VolumeManager {
        constructor() {
            this._motionObjects = new Laya.SingletonList();
            this._volumeList = new Laya.SingletonList();
            this._needUpdateAllRender = false;
            this._regVolumeManager = {};
            this._reflectionProbeManager = new ReflectionProbeManager();
            this._regVolumeManager[VolumeManager.ReflectionProbeVolumeType] = this._reflectionProbeManager;
        }
        get reflectionProbeManager() {
            return this._reflectionProbeManager;
        }
        add(volume) {
            let reManager = this._regVolumeManager[volume.type];
            if (reManager) {
                reManager.add(volume);
            }
            else {
                this._volumeList.add(volume);
                this._needUpdateAllRender = true;
            }
        }
        remove(volume) {
            let reManager = this._regVolumeManager[volume.type];
            if (reManager) {
                reManager.remove(volume);
            }
            else {
                this._volumeList.remove(volume);
                this._needUpdateAllRender = true;
            }
        }
        addMotionObject(renderObj) {
            this._motionObjects.add(renderObj);
        }
        removeMotionObject(renderObj) {
            this._motionObjects.remove(renderObj);
        }
        _updateRenderObject(baseRender) {
            let elements = this._volumeList.elements;
            let renderBounds = baseRender.bounds;
            let center = renderBounds.getCenter();
            let mainVolume;
            for (var i = 0, n = this._volumeList.length; i < n; i++) {
                let volume = elements[i];
                let bounds = volume.bounds;
                if (Bounds.containPoint(bounds, center)) {
                    mainVolume = volume;
                    continue;
                }
            }
            baseRender.volume = mainVolume;
        }
        handleMotionlist() {
            var elements = this._motionObjects.elements;
            for (var i = 0, n = this._motionObjects.length; i < n; i++) {
                this._updateRenderObject(elements[i]);
            }
            this.reflectionProbeManager.handleMotionlist(this._motionObjects);
            this.clearMotionObjects();
        }
        reCaculateAllRenderObjects(baseRenders) {
            if (this._needUpdateAllRender) {
                var elements = baseRenders.elements;
                for (var i = 0, n = baseRenders.length; i < n; i++) {
                    this._updateRenderObject(elements[i]);
                }
                this._needUpdateAllRender = false;
            }
            else {
                this.handleMotionlist();
            }
            if (this.reflectionProbeManager._needUpdateAllRender) {
                this.reflectionProbeManager.reCaculateAllRenderObjects(baseRenders);
            }
            else {
                this.reflectionProbeManager.handleMotionlist(this._motionObjects);
            }
        }
        needreCaculateAllRenderObjects() {
            return this._needUpdateAllRender || this.reflectionProbeManager._needUpdateAllRender;
        }
        clearMotionObjects() {
            this._motionObjects.length = 0;
        }
        destroy() {
        }
    }
    VolumeManager.ReflectionProbeVolumeType = 1;

    class SphericalHarmonicsL2 {
        constructor() {
            this._coefficients = new Float32Array(27);
        }
        getCoefficient(i, j) {
            return this._coefficients[i * 9 + j];
        }
        setCoefficient(i, j, coefficient) {
            this._coefficients[i * 9 + j] = coefficient;
        }
        setCoefficients(i, coefficient0, coefficient1, coefficient2, coefficient3, coefficient4, coefficient5, coefficient6, coefficient7, coefficient8) {
            var offset = i * 9;
            this._coefficients[offset] = coefficient0;
            this._coefficients[++offset] = coefficient1;
            this._coefficients[++offset] = coefficient2;
            this._coefficients[++offset] = coefficient3;
            this._coefficients[++offset] = coefficient4;
            this._coefficients[++offset] = coefficient5;
            this._coefficients[++offset] = coefficient6;
            this._coefficients[++offset] = coefficient7;
            this._coefficients[++offset] = coefficient8;
        }
        cloneTo(dest) {
            if (this === dest)
                return;
            var coes = this._coefficients;
            var destCoes = dest._coefficients;
            for (var i = 0; i < 27; i++)
                destCoes[i] = coes[i];
        }
    }
    SphericalHarmonicsL2._default = new SphericalHarmonicsL2();
    class SphericalHarmonicsL2Generater {
        static surfaceArea(u, v) {
            return Math.atan2(u * v, Math.sqrt(u * u + v * v + 1.0));
        }
        static uv2Dir(u, v, face, out_dir) {
            switch (face) {
                case exports.TextureCubeFace.PositiveX:
                    out_dir.x = 1.0;
                    out_dir.y = -v;
                    out_dir.z = -u;
                    break;
                case exports.TextureCubeFace.NegativeX:
                    out_dir.x = -1.0;
                    out_dir.y = -v;
                    out_dir.z = u;
                    break;
                case exports.TextureCubeFace.PositiveY:
                    out_dir.x = u;
                    out_dir.y = 1.0;
                    out_dir.z = v;
                    break;
                case exports.TextureCubeFace.NegativeY:
                    out_dir.x = u;
                    out_dir.y = -1.0;
                    out_dir.z = -v;
                    break;
                case exports.TextureCubeFace.PositiveZ:
                    out_dir.x = u;
                    out_dir.y = -v;
                    out_dir.z = 1.0;
                    break;
                case exports.TextureCubeFace.NegativeZ:
                    out_dir.x = -u;
                    out_dir.y = -v;
                    out_dir.z = -1.0;
                    break;
            }
        }
        static sh_eval_9(i, x, y, z) {
            const sqrt = Math.sqrt;
            const M_PI = Math.PI;
            switch (i) {
                case 0:
                    return 0.5 * sqrt(1.0 / M_PI);
                case 1:
                    return -y * 0.5 * sqrt(3.0 / M_PI);
                case 2:
                    return z * 0.5 * sqrt(3.0 / M_PI);
                case 3:
                    return -x * 0.5 * sqrt(3.0 / M_PI);
                case 4:
                    return x * y * 0.5 * sqrt(15.0 / M_PI);
                case 5:
                    return -y * z * 0.5 * sqrt(15.0 / M_PI);
                case 6:
                    return (3.0 * z * z - 1.0) * 0.25 * sqrt(5.0 / M_PI);
                case 7:
                    return -x * z * 0.5 * sqrt(15.0 / M_PI);
                case 8:
                    return (x * x - y * y) * 0.25 * sqrt(15.0 / M_PI);
                default:
                    return 0;
            }
        }
        static CalCubemapSH(cubemapPixels, pixelComponentSize, cubemapSize, isGamma = true) {
            let width = cubemapSize;
            let height = cubemapSize;
            let shr = this._tempSHR.fill(0);
            let shg = this._tempSHG.fill(0);
            let shb = this._tempSHB.fill(0);
            let dir = new Laya.Vector3();
            for (let face = 0; face < 6; face++) {
                let facePixels = cubemapPixels[face];
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        let px = x + 0.5;
                        let py = y + 0.5;
                        let u = 2.0 * (px / width) - 1.0;
                        let v = 2.0 * (py / height) - 1.0;
                        let dx = 1.0 / width;
                        let dy = 1.0 / height;
                        let x0 = u - dx;
                        let y0 = v - dy;
                        let x1 = u + dx;
                        let y1 = v + dy;
                        let da = this.surfaceArea(x0, y0) - this.surfaceArea(x0, y1) - this.surfaceArea(x1, y0) + this.surfaceArea(x1, y1);
                        this.uv2Dir(u, v, face, dir);
                        Laya.Vector3.normalize(dir, dir);
                        let pixelOffset = (x + y * width) * pixelComponentSize;
                        let r = facePixels[pixelOffset];
                        let g = facePixels[pixelOffset + 1];
                        let b = facePixels[pixelOffset + 2];
                        if (isGamma) {
                            r = Laya.Color.gammaToLinearSpace(r);
                            g = Laya.Color.gammaToLinearSpace(g);
                            b = Laya.Color.gammaToLinearSpace(b);
                        }
                        for (let s = 0; s < this.SH_Count; s++) {
                            let sh_val = this.sh_eval_9(s, dir.x, dir.y, dir.z);
                            shr[s] += r * sh_val * da;
                            shg[s] += g * sh_val * da;
                            shb[s] += b * sh_val * da;
                        }
                    }
                }
            }
            let sh = new SphericalHarmonicsL2();
            for (let index = 0; index < this.SH_Count; index++) {
                let scale = this.k[index];
                let r = shr[index];
                sh.setCoefficient(0, index, r * scale);
                let g = shg[index];
                sh.setCoefficient(1, index, g * scale);
                let b = shb[index];
                sh.setCoefficient(2, index, b * scale);
            }
            return sh;
        }
        static CalGradientSH(skyColor, equatorColor, groundColor, isGamma = true) {
            console.time("Gradient SH");
            let skyPixels = this._tempSkyPixels;
            let equatorPixels = this._tempEquatorPixels;
            let groundPixels = this._tempGroundPixels;
            const fillPixelBuffer = (float32, color, isGamma) => {
                let fillColor = new Laya.Color(color.x, color.y, color.z, 1.0);
                if (isGamma) {
                    fillColor.toLinear(fillColor);
                }
                let r = Math.min(fillColor.r, 1.0);
                let g = Math.min(fillColor.g, 1.0);
                let b = Math.min(fillColor.b, 1.0);
                for (let index = 0; index < float32.length; index += 3) {
                    float32[index] = r;
                    float32[index + 1] = g;
                    float32[index + 2] = b;
                }
            };
            fillPixelBuffer(skyPixels, skyColor, isGamma);
            fillPixelBuffer(equatorPixels, equatorColor, isGamma);
            fillPixelBuffer(groundPixels, groundColor, isGamma);
            let gradientPixles = [];
            gradientPixles[exports.TextureCubeFace.PositiveY] = skyPixels;
            gradientPixles[exports.TextureCubeFace.NegativeY] = groundPixels;
            gradientPixles[exports.TextureCubeFace.PositiveX] = equatorPixels;
            gradientPixles[exports.TextureCubeFace.NegativeX] = equatorPixels;
            gradientPixles[exports.TextureCubeFace.PositiveZ] = equatorPixels;
            gradientPixles[exports.TextureCubeFace.NegativeZ] = equatorPixels;
            let sh = SphericalHarmonicsL2Generater.CalCubemapSH(gradientPixles, 3, this.GradientSimulateSize, false);
            console.timeEnd("Gradient SH");
            return sh;
        }
    }
    SphericalHarmonicsL2Generater._tempSHR = new Float32Array(9);
    SphericalHarmonicsL2Generater._tempSHG = new Float32Array(9);
    SphericalHarmonicsL2Generater._tempSHB = new Float32Array(9);
    SphericalHarmonicsL2Generater.k = [
        0.28209479177387814347,
        -0.32573500793527994772, 0.32573500793527994772, -0.32573500793527994772,
        0.27313710764801976764, -0.27313710764801976764, 0.07884789131313000151, -0.27313710764801976764, 0.13656855382400988382
    ];
    SphericalHarmonicsL2Generater.GradientSimulateSize = 3;
    SphericalHarmonicsL2Generater.SH_Count = 9;
    SphericalHarmonicsL2Generater._tempSkyPixels = new Float32Array(SphericalHarmonicsL2Generater.GradientSimulateSize * SphericalHarmonicsL2Generater.GradientSimulateSize * 3);
    SphericalHarmonicsL2Generater._tempEquatorPixels = new Float32Array(SphericalHarmonicsL2Generater.GradientSimulateSize * SphericalHarmonicsL2Generater.GradientSimulateSize * 3);
    SphericalHarmonicsL2Generater._tempGroundPixels = new Float32Array(SphericalHarmonicsL2Generater.GradientSimulateSize * SphericalHarmonicsL2Generater.GradientSimulateSize * 3);

    class Sprite3DRenderDeclaration {
    }

    exports.AmbientMode = void 0;
    (function (AmbientMode) {
        AmbientMode[AmbientMode["SolidColor"] = 0] = "SolidColor";
        AmbientMode[AmbientMode["SphericalHarmonics"] = 1] = "SphericalHarmonics";
        AmbientMode[AmbientMode["TripleColor"] = 2] = "TripleColor";
    })(exports.AmbientMode || (exports.AmbientMode = {}));

    exports.ReflectionProbeMode = void 0;
    (function (ReflectionProbeMode) {
        ReflectionProbeMode[ReflectionProbeMode["off"] = 0] = "off";
        ReflectionProbeMode[ReflectionProbeMode["simple"] = 1] = "simple";
    })(exports.ReflectionProbeMode || (exports.ReflectionProbeMode = {}));
    class ReflectionProbe extends Volume {
        constructor() {
            super();
            this._boxProjection = false;
            this._ambientColor = new Laya.Color();
            this._ambientMode = exports.AmbientMode.SolidColor;
            this._isScene = false;
            this._reflectionHDRParams = new Laya.Vector4();
            this._reflectionDecodeFormat = Laya.TextureDecodeFormat.Normal;
            this._ambientSkyColor = new Laya.Vector3();
            this._ambientEquatorColor = new Laya.Vector3();
            this._ambientGroundColor = new Laya.Vector3();
            this._importance = 0;
            this._type = VolumeManager.ReflectionProbeVolumeType;
            this._ambientIntensity = 1.0;
            this._reflectionIntensity = 1.0;
            this.boundsMax = new Laya.Vector3(5, 5, 5);
            this.boundsMin = new Laya.Vector3(-5, -5, -5);
        }
        get boxProjection() {
            return this._boxProjection;
        }
        set boxProjection(value) {
            if (value != this._boxProjection) {
                this._updateMark = ILaya3D.Scene3D._updateMark;
            }
            this._boxProjection = value;
        }
        get importance() {
            return this._importance;
        }
        set importance(value) {
            this._importance = value;
        }
        get ambientIntensity() {
            return this._ambientIntensity;
        }
        set ambientIntensity(value) {
            if (value == this._ambientIntensity)
                return;
            this._ambientIntensity = value;
            this._updateMark = ILaya3D.Scene3D._updateMark;
        }
        get reflectionIntensity() {
            return this._reflectionIntensity;
        }
        set reflectionIntensity(value) {
            if (value == this._reflectionIntensity)
                return;
            value = Math.max(value, 0.0);
            this._reflectionIntensity = value;
            this._updateMark = ILaya3D.Scene3D._updateMark;
        }
        get bounds() {
            return this._bounds;
        }
        set boundsMax(value) {
            super.boundsMax = value;
            if (this.boxProjection)
                this._updateMark = ILaya3D.Scene3D._updateMark;
        }
        get boundsMax() {
            return this._primitiveBounds.getMax();
        }
        set boundsMin(value) {
            super.boundsMin = value;
            if (this.boxProjection)
                this._updateMark = ILaya3D.Scene3D._updateMark;
        }
        get boundsMin() {
            return this._primitiveBounds.getMin();
        }
        get probePosition() {
            return this.owner.transform.position;
        }
        get ambientColor() {
            return this._ambientColor;
        }
        set ambientColor(value) {
            value && value.cloneTo(this._ambientColor);
            if (this.ambientMode == exports.AmbientMode.SolidColor)
                this._updateMark = ILaya3D.Scene3D._updateMark;
        }
        get ambientSH() {
            return this._ambientSH;
        }
        set ambientSH(value) {
            if (this.ambientMode == exports.AmbientMode.SphericalHarmonics)
                this._updateMark = ILaya3D.Scene3D._updateMark;
            this._ambientSH = value;
        }
        get ambientMode() {
            return this._ambientMode;
        }
        set ambientMode(value) {
            if (value == this.ambientMode)
                return;
            this._ambientMode = value;
            if (!this.ambientSH) {
                if (value == exports.AmbientMode.SphericalHarmonics) {
                    this._ambientSphericalHarmonics && this._applySHCoefficients(this._ambientSphericalHarmonics, 2.2);
                }
                else if (value == exports.AmbientMode.TripleColor) {
                    this._ambientTripleColorSphericalHarmonics && this._applySHCoefficients(this._ambientTripleColorSphericalHarmonics, 1.0);
                }
            }
            this._updateMark = ILaya3D.Scene3D._updateMark;
        }
        get iblTex() {
            return this._iblTex;
        }
        set iblTex(value) {
            if (this.iblTex == value)
                return;
            if (this.iblTex)
                this.iblTex._removeReference();
            this._iblTex = value;
            this._iblTex._addReference();
            this._updateMark = ILaya3D.Scene3D._updateMark;
        }
        get iblTexRGBD() {
            return this._iblTexRGBD;
        }
        set iblTexRGBD(value) {
            if (value == this._iblTexRGBD)
                return;
            this._iblTexRGBD = value;
            this._updateMark = ILaya3D.Scene3D._updateMark;
        }
        applyReflectionShaderData(shaderData) {
            if (!this.boxProjection) {
                shaderData.removeDefine(Sprite3DRenderDeclaration.SHADERDEFINE_SPECCUBE_BOX_PROJECTION);
            }
            else {
                shaderData.addDefine(Sprite3DRenderDeclaration.SHADERDEFINE_SPECCUBE_BOX_PROJECTION);
                shaderData.setShaderData(RenderableSprite3D.REFLECTIONCUBE_PROBEPOSITION, Laya.ShaderDataType.Vector3, this.probePosition);
                shaderData.setShaderData(RenderableSprite3D.REFLECTIONCUBE_PROBEBOXMAX, Laya.ShaderDataType.Vector3, this._bounds.getMax());
                shaderData.setShaderData(RenderableSprite3D.REFLECTIONCUBE_PROBEBOXMIN, Laya.ShaderDataType.Vector3, this._bounds.getMin());
            }
            if (this.ambientMode == exports.AmbientMode.SolidColor) {
                shaderData.removeDefine(Sprite3DRenderDeclaration.SHADERDEFINE_GI_LEGACYIBL);
                shaderData.removeDefine(Sprite3DRenderDeclaration.SHADERDEFINE_GI_IBL);
                shaderData.setColor(RenderableSprite3D.AMBIENTCOLOR, this.ambientColor);
            }
            else if (this.iblTex && this.ambientSH) {
                shaderData.addDefine(Sprite3DRenderDeclaration.SHADERDEFINE_GI_IBL);
                shaderData.removeDefine(Sprite3DRenderDeclaration.SHADERDEFINE_GI_LEGACYIBL);
                this.iblTex && shaderData.setTexture(RenderableSprite3D.IBLTEX, this.iblTex);
                this.iblTexRGBD ? shaderData.addDefine(Sprite3DRenderDeclaration.SHADERDEFINE_IBL_RGBD) : shaderData.removeDefine(Sprite3DRenderDeclaration.SHADERDEFINE_IBL_RGBD);
                this.ambientSH && shaderData.setBuffer(RenderableSprite3D.AMBIENTSH, this.ambientSH);
            }
            else {
                shaderData.removeDefine(Sprite3DRenderDeclaration.SHADERDEFINE_GI_IBL);
                shaderData.addDefine(Sprite3DRenderDeclaration.SHADERDEFINE_GI_LEGACYIBL);
                if (this._reflectionTexture) {
                    shaderData.setShaderData(RenderableSprite3D.REFLECTIONTEXTURE, Laya.ShaderDataType.TextureCube, this.reflectionTexture);
                    shaderData.setShaderData(RenderableSprite3D.REFLECTIONCUBE_HDR_PARAMS, Laya.ShaderDataType.Vector4, this.reflectionHDRParams);
                }
                if (this._shCoefficients) {
                    shaderData.setVector(RenderableSprite3D.AMBIENTSHAR, this._shCoefficients[0]);
                    shaderData.setVector(RenderableSprite3D.AMBIENTSHAG, this._shCoefficients[1]);
                    shaderData.setVector(RenderableSprite3D.AMBIENTSHAB, this._shCoefficients[2]);
                    shaderData.setVector(RenderableSprite3D.AMBIENTSHBR, this._shCoefficients[3]);
                    shaderData.setVector(RenderableSprite3D.AMBIENTSHBG, this._shCoefficients[4]);
                    shaderData.setVector(RenderableSprite3D.AMBIENTSHBB, this._shCoefficients[5]);
                    shaderData.setVector(RenderableSprite3D.AMBIENTSHC, this._shCoefficients[6]);
                }
            }
            shaderData.setNumber(RenderableSprite3D.AMBIENTINTENSITY, this.ambientIntensity);
            shaderData.setNumber(RenderableSprite3D.REFLECTIONINTENSITY, this.reflectionIntensity);
        }
        _onEnable() {
            super._onEnable();
            this._updateMark = ILaya3D.Scene3D._updateMark;
        }
        _onDisable() {
            super._onDisable();
        }
        _onDestroy() {
        }
        _cloneTo(dest) {
        }
        get reflectionTexture() {
            return this._reflectionTexture;
        }
        set reflectionTexture(value) {
            if (this._reflectionTexture == value)
                return;
            if (this._reflectionTexture)
                this.iblTex._removeReference();
            this._reflectionTexture = value;
            this._reflectionTexture._addReference();
            this._updateMark = ILaya3D.Scene3D._updateMark;
        }
        get customReflection() {
            return this.reflectionTexture;
        }
        set customReflection(value) {
            this.reflectionTexture = value;
        }
        get reflectionHDRParams() {
            return this._reflectionHDRParams;
        }
        set reflectionHDRParams(value) {
            this._reflectionHDRParams = value;
            this._updateMark = ILaya3D.Scene3D._updateMark;
        }
        get reflectionDecodingFormat() {
            return this._reflectionDecodeFormat;
        }
        set reflectionDecodingFormat(value) {
            if (this._reflectionDecodeFormat != value) {
                this._reflectionDecodeFormat = value;
                if (this._reflectionDecodeFormat == Laya.TextureDecodeFormat.RGBM)
                    this._reflectionHDRParams.x = 5.0;
                this._updateMark = ILaya3D.Scene3D._updateMark;
            }
        }
        get ambientSphericalHarmonics() {
            return this._ambientSphericalHarmonics;
        }
        set ambientSphericalHarmonics(value) {
            var originalSH = value || SphericalHarmonicsL2._default;
            if (!this._ambientSphericalHarmonics) {
                this._ambientSphericalHarmonics = new SphericalHarmonicsL2();
            }
            if (this._ambientSphericalHarmonics != value)
                value.cloneTo(this._ambientSphericalHarmonics);
            if (this.ambientMode == exports.AmbientMode.TripleColor)
                this._applySHCoefficients(originalSH, 2.2);
            this._updateMark = ILaya3D.Scene3D._updateMark;
        }
        _applySHCoefficients(originalSH, intensity) {
            if (!this._shCoefficients) {
                this._shCoefficients = new Array(7);
                for (var i = 0; i < 7; i++)
                    this._shCoefficients[i] = new Laya.Vector4();
            }
            var optSH = this._shCoefficients;
            for (var i = 0; i < 3; i++) {
                var shaderSHA = optSH[i];
                var shaderSHB = optSH[i + 3];
                shaderSHA.setValue(originalSH.getCoefficient(i, 3) * intensity, originalSH.getCoefficient(i, 1) * intensity, originalSH.getCoefficient(i, 2) * intensity, (originalSH.getCoefficient(i, 0) - originalSH.getCoefficient(i, 6)) * intensity);
                shaderSHB.setValue(originalSH.getCoefficient(i, 4) * intensity, originalSH.getCoefficient(i, 5) * intensity, originalSH.getCoefficient(i, 6) * 3 * intensity, originalSH.getCoefficient(i, 7) * intensity);
            }
            optSH[6].setValue(originalSH.getCoefficient(0, 8) * intensity, originalSH.getCoefficient(1, 8) * intensity, originalSH.getCoefficient(2, 8) * intensity, 1);
        }
        setGradientAmbient(skyColor, equatorColor, groundColor) {
            this._ambientSkyColor = skyColor;
            this._ambientEquatorColor = equatorColor;
            this._ambientGroundColor = groundColor;
            let gradientSH = SphericalHarmonicsL2Generater.CalGradientSH(this._ambientSkyColor, this._ambientEquatorColor, this._ambientGroundColor, true);
            this._ambientTripleColorSphericalHarmonics = gradientSH;
            if (this.ambientMode == exports.AmbientMode.TripleColor) {
                this._applySHCoefficients(gradientSH, 2.2);
            }
            this._updateMark = ILaya3D.Scene3D._updateMark;
        }
    }
    ReflectionProbe.TEMPVECTOR3 = new Laya.Vector3();
    ReflectionProbe.defaultTextureHDRDecodeValues = new Laya.Vector4(1.0, 1.0, 0.0, 0.0);

    exports.RenderBitFlag = void 0;
    (function (RenderBitFlag) {
        RenderBitFlag[RenderBitFlag["RenderBitFlag_CullFlag"] = 0] = "RenderBitFlag_CullFlag";
        RenderBitFlag[RenderBitFlag["RenderBitFlag_Batch"] = 1] = "RenderBitFlag_Batch";
        RenderBitFlag[RenderBitFlag["RenderBitFlag_Editor"] = 2] = "RenderBitFlag_Editor";
        RenderBitFlag[RenderBitFlag["RenderBitFlag_InstanceBatch"] = 3] = "RenderBitFlag_InstanceBatch";
        RenderBitFlag[RenderBitFlag["RenderBitFlag_VertexMergeBatch"] = 4] = "RenderBitFlag_VertexMergeBatch";
    })(exports.RenderBitFlag || (exports.RenderBitFlag = {}));
    class BaseRender extends Laya.Component {
        constructor() {
            super();
            this._lightmapScaleOffset = new Laya.Vector4(1, 1, 0, 0);
            this._sharedMaterials = [];
            this._supportOctree = true;
            this._sceneUpdateMark = -1;
            this._updateMark = -1;
            this._surportReflectionProbe = false;
            this._reflectionMode = exports.ReflectionProbeMode.simple;
            this._updateRenderType = -1;
            this._motionIndexList = -1;
            this._ratioIgnor = 0.005;
            this._LOD = -1;
            this._rendernode = this._createBaseRenderNode();
            this._rendernode.owner = this;
            this._rendernode.renderId = ++BaseRender._uniqueIDCounter;
            this._bounds = this._rendernode.bounds = new Bounds(Laya.Vector3.ZERO, Laya.Vector3.ZERO);
            this._renderElements = [];
            this._enabled = true;
            this._materialsInstance = [];
            this._shaderValues = Laya.LayaGL.renderOBJCreate.createShaderData(null);
            this.lightmapIndex = -1;
            this.receiveShadow = false;
            this.sortingFudge = 0.0;
            this._customCull = this._needRender !== BaseRender.prototype._needRender;
            this.runInEditor = true;
            this.boundsChange = true;
            this._rendernode.renderbitFlag = 0;
            this._rendernode.staticMask = 1;
        }
        static __init__() {
            BaseRender.shaderValueInit();
        }
        static getMeshDefine(mesh, out) {
            out.length = 0;
            var define;
            for (var i = 0, n = mesh._subMeshes.length; i < n; i++) {
                var subMesh = mesh.getSubMesh(i);
                var vertexElements = subMesh._vertexBuffer._vertexDeclaration._vertexElements;
                for (var j = 0, m = vertexElements.length; j < m; j++) {
                    var vertexElement = vertexElements[j];
                    var name = vertexElement._elementUsage;
                    switch (name) {
                        case Laya.VertexMesh.MESH_COLOR0:
                            out.push(MeshSprite3DShaderDeclaration.SHADERDEFINE_COLOR);
                            break;
                        case Laya.VertexMesh.MESH_TEXTURECOORDINATE0:
                            out.push(MeshSprite3DShaderDeclaration.SHADERDEFINE_UV0);
                            break;
                        case Laya.VertexMesh.MESH_TEXTURECOORDINATE1:
                            out.push(MeshSprite3DShaderDeclaration.SHADERDEFINE_UV1);
                            break;
                        case Laya.VertexMesh.MESH_TANGENT0:
                            out.push(MeshSprite3DShaderDeclaration.SHADERDEFINE_TANGENT);
                            break;
                    }
                }
            }
            return define;
        }
        static changeVertexDefine(oldMesh, mesh, defineDatas) {
            var lastValue = oldMesh;
            if (lastValue) {
                BaseRender.getMeshDefine(lastValue, BaseRender._meshVerticeDefine);
                for (var i = 0, n = BaseRender._meshVerticeDefine.length; i < n; i++)
                    defineDatas.removeDefine(BaseRender._meshVerticeDefine[i]);
            }
            if (mesh) {
                BaseRender.getMeshDefine(mesh, BaseRender._meshVerticeDefine);
                for (var i = 0, n = BaseRender._meshVerticeDefine.length; i < n; i++)
                    defineDatas.addDefine(BaseRender._meshVerticeDefine[i]);
            }
        }
        static shaderValueInit() {
            Sprite3DRenderDeclaration.SHADERDEFINE_GI_LEGACYIBL = Laya.Shader3D.getDefineByName("GI_LEGACYIBL");
            Sprite3DRenderDeclaration.SHADERDEFINE_GI_IBL = Laya.Shader3D.getDefineByName("GI_IBL");
            Sprite3DRenderDeclaration.SHADERDEFINE_IBL_RGBD = Laya.Shader3D.getDefineByName("IBL_RGBD");
            Sprite3DRenderDeclaration.SHADERDEFINE_SPECCUBE_BOX_PROJECTION = Laya.Shader3D.getDefineByName("SPECCUBE_BOX_PROJECTION");
        }
        set ratioIgnor(value) {
            this._ratioIgnor = value;
        }
        get ratioIgnor() {
            return this._ratioIgnor;
        }
        get renderbitFlag() {
            return this._rendernode.renderbitFlag;
        }
        set boundsChange(value) {
            this._rendernode.boundsChange = value;
        }
        get boundsChange() {
            return this._rendernode.boundsChange;
        }
        get renderNode() {
            return this._rendernode;
        }
        set distanceForSort(value) {
            this._rendernode.distanceForSort = value;
        }
        get distanceForSort() {
            return this._rendernode.distanceForSort;
        }
        set geometryBounds(value) {
            this._baseGeometryBounds = this._rendernode.geometryBounds = value;
        }
        get geometryBounds() {
            return this._baseGeometryBounds;
        }
        get id() {
            return this._rendernode.renderId;
        }
        get lightmapIndex() {
            return this._lightmapIndex;
        }
        set lightmapIndex(value) {
            this._lightmapIndex = value;
        }
        get lightmapScaleOffset() {
            return this._lightmapScaleOffset;
        }
        set lightmapScaleOffset(value) {
            if (!value)
                throw "BaseRender: lightmapScaleOffset can't be null.";
            this._lightmapScaleOffset = value;
            this._setShaderValue(RenderableSprite3D.LIGHTMAPSCALEOFFSET, Laya.ShaderDataType.Vector4, value);
        }
        get material() {
            var material = this._sharedMaterials[0];
            if (material && !this._materialsInstance[0]) {
                var insMat = this._getInstanceMaterial(material, 0);
                var renderElement = this._renderElements[0];
                (renderElement) && (renderElement.material = insMat);
            }
            return this._sharedMaterials[0];
        }
        set material(value) {
            this.sharedMaterial = value;
            this._isSupportReflection();
        }
        get materials() {
            for (var i = 0, n = this._sharedMaterials.length; i < n; i++) {
                if (!this._materialsInstance[i]) {
                    var insMat = this._getInstanceMaterial(this._sharedMaterials[i], i);
                    var renderElement = this._renderElements[i];
                    (renderElement) && (renderElement.material = insMat);
                }
            }
            return this._sharedMaterials.slice();
        }
        set materials(value) {
            this.sharedMaterials = value;
            this._isSupportReflection();
        }
        get sharedMaterial() {
            return this._sharedMaterials[0];
        }
        set sharedMaterial(value) {
            var lastValue = this._sharedMaterials[0];
            if (lastValue !== value) {
                this._sharedMaterials[0] = value;
                this._materialsInstance[0] = false;
                this._changeMaterialReference(lastValue, value);
                var renderElement = this._renderElements[0];
                (renderElement) && (renderElement.material = value);
            }
            this._isSupportReflection();
        }
        get sharedMaterials() {
            return this._sharedMaterials.slice();
        }
        set sharedMaterials(value) {
            var materialsInstance = this._materialsInstance;
            var sharedMats = this._sharedMaterials;
            for (var i = 0, n = sharedMats.length; i < n; i++) {
                var lastMat = sharedMats[i];
                (lastMat) && (lastMat._removeReference());
            }
            if (value) {
                var count = value.length;
                materialsInstance.length = count;
                sharedMats.length = count;
                for (i = 0; i < count; i++) {
                    lastMat = sharedMats[i];
                    var mat = value[i];
                    if (lastMat !== mat) {
                        materialsInstance[i] = false;
                        var renderElement = this._renderElements[i];
                        (renderElement) && (renderElement.material = mat);
                    }
                    if (mat) {
                        mat._addReference();
                    }
                    sharedMats[i] = mat;
                }
            }
            else {
                throw new Error("BaseRender: shadredMaterials value can't be null.");
            }
            this._isSupportReflection();
        }
        get bounds() {
            if (this.boundsChange) {
                this._calculateBoundingBox();
                this.boundsChange = false;
            }
            return this._bounds;
        }
        set receiveShadow(value) {
            if (this.renderNode.receiveShadow !== value) {
                this.renderNode.receiveShadow = value;
                if (value)
                    this._shaderValues.addDefine(RenderableSprite3D.SHADERDEFINE_RECEIVE_SHADOW);
                else
                    this._shaderValues.removeDefine(RenderableSprite3D.SHADERDEFINE_RECEIVE_SHADOW);
            }
        }
        get receiveShadow() {
            return this.renderNode.receiveShadow;
        }
        get castShadow() {
            return this.renderNode.castShadow;
        }
        set castShadow(value) {
            this.renderNode.castShadow = value;
        }
        set reflectionMode(value) {
            this._reflectionMode = value;
        }
        get reflectionMode() {
            return this._reflectionMode;
        }
        set volume(value) {
            if (!value) {
                if (this._volume) {
                    this._volume._removeRenderNode && this._volume._removeRenderNode(this);
                    this._volume = null;
                }
                return;
            }
            if (this._volume != value) {
                value._addRenderNode && value._addRenderNode(this);
                this._volume = value;
                return;
            }
            else {
                value._motionInVolume && value._motionInVolume(this);
            }
        }
        get volume() {
            return this._volume;
        }
        set probReflection(voluemProbe) {
            if (this._probReflection == voluemProbe)
                return;
            this._probReflection = voluemProbe;
            if (this._reflectionMode == exports.ReflectionProbeMode.off) {
                this._shaderValues.removeDefine(Sprite3DRenderDeclaration.SHADERDEFINE_SPECCUBE_BOX_PROJECTION);
                this._shaderValues.addDefine(Sprite3DRenderDeclaration.SHADERDEFINE_GI_IBL);
                this._setShaderValue(RenderableSprite3D.IBLTEX, Laya.ShaderDataType.TextureCube, TextureCube.blackTexture);
            }
            else {
                this._probReflection.applyReflectionShaderData(this._shaderValues);
            }
        }
        _createBaseRenderNode() {
            return Laya.LayaGL.renderOBJCreate.createBaseRenderNode();
        }
        _changeLayer(layer) {
            this._rendernode.layer = layer;
        }
        _changeStaticMask(staticmask) {
            this._rendernode.staticMask = staticmask;
        }
        _onAdded() {
            this._transform = this.owner.transform;
            this.owner._isRenderNode++;
            this.setRenderbitFlag(exports.RenderBitFlag.RenderBitFlag_Editor, this.owner._getBit(Laya.NodeFlags.HIDE_BY_EDITOR));
            this._rendernode.transform = this._transform;
            this._changeLayer(this.owner.layer);
            this._changeStaticMask(this.owner._isStatic);
        }
        _onEnable() {
            super._onEnable();
            if (this.owner) {
                this.owner.transform.on(Laya.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange);
                this.owner.on(Laya.Event.LAYERCHANGE, this, this._changeLayer);
                this.owner.on(Laya.Event.staticMask, this, this._changeStaticMask);
                this._changeLayer(this.owner.layer);
                this._changeStaticMask(this.owner._isStatic);
            }
            this.owner.scene._addRenderObject(this);
            this._setBelongScene(this.owner.scene);
        }
        _onDisable() {
            if (this.owner) {
                this.owner.transform.off(Laya.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange);
                this.owner.off(Laya.Event.LAYERCHANGE, this, this._changeLayer);
                this.owner.off(Laya.Event.staticMask, this, this._changeStaticMask);
            }
            this.owner.scene._removeRenderObject(this);
            this._setUnBelongScene();
            this.volume = null;
        }
        _changeMaterialReference(lastValue, value) {
            (lastValue) && (lastValue._removeReference());
            value._addReference();
        }
        _getInstanceMaterial(material, index) {
            var insMat = material.clone();
            insMat.name = insMat.name + "(Instance)";
            this._materialsInstance[index] = true;
            this._changeMaterialReference(this._sharedMaterials[index], insMat);
            this._sharedMaterials[index] = insMat;
            return insMat;
        }
        _isSupportReflection() {
            let pre = this._surportReflectionProbe;
            this._surportReflectionProbe = false;
            var sharedMats = this._sharedMaterials;
            for (var i = 0, n = sharedMats.length; i < n; i++) {
                var mat = sharedMats[i];
                this._surportReflectionProbe || (this._surportReflectionProbe = this._surportReflectionProbe || (mat && mat._shader._supportReflectionProbe));
            }
            if (!pre && this._surportReflectionProbe)
                this._addReflectionProbeUpdate();
        }
        _onWorldMatNeedChange(flag) {
            this.boundsChange = true;
            this._addReflectionProbeUpdate();
            this._subUniformBufferData && (this._subUniformBufferData._needUpdate = true);
            this._batchRender && this._batchRender._updateOneRender(this);
        }
        _calculateBoundingBox() {
            throw ("BaseRender: must override it.");
        }
        setRenderbitFlag(flag, pass) {
            if (pass)
                this._rendernode.renderbitFlag |= (1 << flag);
            else
                this._rendernode.renderbitFlag &= ~(1 << flag);
        }
        _setShaderValue(index, shaderdataType, value) {
            this._shaderValues.setShaderData(index, shaderdataType, value);
        }
        _addReflectionProbeUpdate() {
            this._scene && this._scene._volumeManager.addMotionObject(this);
        }
        _applyLightMapParams() {
            if (!this._scene)
                return;
            var lightMaps = this._scene.lightmaps;
            var shaderValues = this._shaderValues;
            var lightmapIndex = this._lightmapIndex;
            if (lightmapIndex >= 0 && lightmapIndex < lightMaps.length) {
                var lightMap = lightMaps[lightmapIndex];
                shaderValues.setTexture(RenderableSprite3D.LIGHTMAP, lightMap.lightmapColor);
                shaderValues.addDefine(RenderableSprite3D.SAHDERDEFINE_LIGHTMAP);
                if (lightMap.lightmapDirection) {
                    shaderValues.setTexture(RenderableSprite3D.LIGHTMAP_DIRECTION, lightMap.lightmapDirection);
                    shaderValues.addDefine(RenderableSprite3D.SHADERDEFINE_LIGHTMAP_DIRECTIONAL);
                }
                else {
                    shaderValues.removeDefine(RenderableSprite3D.SHADERDEFINE_LIGHTMAP_DIRECTIONAL);
                }
            }
            else {
                shaderValues.removeDefine(RenderableSprite3D.SAHDERDEFINE_LIGHTMAP);
                shaderValues.removeDefine(RenderableSprite3D.SHADERDEFINE_LIGHTMAP_DIRECTIONAL);
            }
        }
        _applyReflection() {
            if (!this._probReflection)
                return;
            if (this._probReflection._updateMark = ILaya3D.Scene3D._updateMark) {
                this._probReflection.applyReflectionShaderData(this._shaderValues);
            }
        }
        _setBelongScene(scene) {
            this._scene = scene;
            this._onWorldMatNeedChange(1);
            this._isSupportReflection();
            this._batchRender && this._batchRender._batchOneRender(this);
            Laya.Stat.renderNode++;
        }
        _setUnBelongScene() {
            Laya.Stat.renderNode--;
            this._scene._volumeManager.removeMotionObject(this);
            let batch = this._batchRender;
            this._batchRender && this._batchRender._removeOneRender(this);
            this._batchRender = batch;
            this._scene = null;
        }
        _needRender(boundFrustum, context) {
            if (boundFrustum)
                return boundFrustum.intersects(this.bounds);
            else
                return true;
        }
        _CullOut() {
        }
        _renderUpdate(context, transform) {
        }
        _renderUpdateWithCamera(context, transform) {
        }
        _onDestroy() {
            if (this.owner)
                this.owner._isRenderNode--;
            (this._motionIndexList !== -1) && (this._scene._sceneRenderManager.removeMotionObject(this));
            (this._scene) && this._scene.sceneRenderableManager.removeRenderObject(this);
            var i = 0, n = 0;
            for (i = 0, n = this._renderElements.length; i < n; i++)
                this._renderElements[i].destroy();
            for (i = 0, n = this._sharedMaterials.length; i < n; i++) {
                let m = this._sharedMaterials[i];
                m && !m.destroyed && m._removeReference();
            }
            this._renderElements = null;
            this._sharedMaterials = null;
            this._bounds = null;
            this._lightmapScaleOffset = null;
            this._scene = null;
            this._rendernode = null;
            this._shaderValues.destroy();
            this._shaderValues = null;
            this._transform = null;
            this._batchRender = null;
            if (this._subUniformBufferData) {
                BaseRender._transLargeUbO.recover(this._subUniformBufferData);
                this._subUniformBufferData = null;
            }
        }
        _cloneTo(dest) {
            super._cloneTo(dest);
            let render = dest;
            render.receiveShadow = this.receiveShadow;
            render.sharedMaterials = this.sharedMaterials;
            render.reflectionMode = this.reflectionMode;
            render.castShadow = this.castShadow;
            render.sortingFudge = this.sortingFudge;
        }
    }
    BaseRender._meshVerticeDefine = [];
    BaseRender._uniqueIDCounter = 0;
    BaseRender._tempBoundBoxCorners = [new Laya.Vector3(), new Laya.Vector3(), new Laya.Vector3(), new Laya.Vector3(), new Laya.Vector3(), new Laya.Vector3(), new Laya.Vector3(), new Laya.Vector3()];
    BaseRender._defaultLightmapScaleOffset = new Laya.Vector4(1.0, 1.0, 0.0, 0.0);

    class RenderElement {
        constructor() {
            this._canBatch = false;
            this._subShaderIndex = 0;
            this.renderType = RenderElement.RENDERTYPE_NORMAL;
            this._createRenderElementOBJ();
        }
        set transform(value) {
            this._renderElementOBJ._transform = value;
        }
        get transform() {
            return this._renderElementOBJ._transform;
        }
        set material(value) {
            if (value) {
                this._material = value;
                this._renderElementOBJ._materialShaderData = value.shaderData;
            }
        }
        get material() {
            return this._material;
        }
        set renderSubShader(value) {
            this._subShader = value;
        }
        get renderSubShader() {
            return this._subShader;
        }
        set render(value) {
            this._baseRender = value;
            this._renderElementOBJ._renderShaderData = value._shaderValues;
        }
        get render() {
            return this._baseRender;
        }
        _createRenderElementOBJ() {
            this._renderElementOBJ = Laya.LayaGL.renderOBJCreate.createRenderElement();
        }
        getInvertFront() {
            return this.transform ? this.transform._isFrontFaceInvert : false;
        }
        setTransform(transform) {
            this.transform = transform;
        }
        setGeometry(geometry) {
            this._geometry = geometry;
            this._renderElementOBJ._geometry = geometry._geometryElementOBj;
        }
        compileShader(context) {
            var passes = this._subShader._passes;
            this._renderElementOBJ._clearShaderInstance();
            for (var j = 0, m = passes.length; j < m; j++) {
                var pass = passes[j];
                if (pass._pipelineMode !== context.pipelineMode)
                    continue;
                var comDef = RenderElement._compileDefine;
                if (context.sceneShaderData) {
                    context.sceneShaderData._defineDatas.cloneTo(comDef);
                }
                else {
                    Laya.Shader3D._configDefineValues.cloneTo(comDef);
                }
                context.cameraShaderData && comDef.addDefineDatas(context.cameraShaderData._defineDatas);
                this.render && comDef.addDefineDatas(this.render._shaderValues._defineDatas);
                comDef.addDefineDatas(this._renderElementOBJ._materialShaderData._defineDatas);
                var shaderIns = pass.withCompile(comDef);
                this._renderElementOBJ._addShaderInstance(shaderIns);
            }
        }
        _convertSubShader(customShader, replacementTag, subshaderIndex = 0) {
            var subShader = this.material._shader.getSubShaderAt(this._subShaderIndex);
            this.renderSubShader = null;
            if (customShader) {
                if (replacementTag) {
                    var oriTag = subShader.getFlag(replacementTag);
                    if (oriTag) {
                        var customSubShaders = customShader._subShaders;
                        for (var k = 0, p = customSubShaders.length; k < p; k++) {
                            var customSubShader = customSubShaders[k];
                            if (oriTag === customSubShader.getFlag(replacementTag)) {
                                this.renderSubShader = customSubShader;
                                break;
                            }
                        }
                        if (!this.renderSubShader)
                            return;
                    }
                    else {
                        return;
                    }
                }
                else {
                    this.renderSubShader = customShader.getSubShaderAt(subshaderIndex);
                }
            }
            else {
                this.renderSubShader = subShader;
            }
        }
        _update(scene, context, customShader, replacementTag, subshaderIndex = 0) {
            if (this.material) {
                this._convertSubShader(customShader, replacementTag, subshaderIndex);
                if (!this.renderSubShader)
                    return;
                var renderQueue = scene._getRenderQueue(this.material.renderQueue);
                if (renderQueue._isTransparent)
                    renderQueue.addRenderElement(this);
                else
                    renderQueue.addRenderElement(this);
            }
        }
        _renderUpdatePre(context) {
            var sceneMark = ILaya3D.Scene3D._updateMark;
            var transform = this.transform;
            context.renderElement = this;
            var modelDataRender = (!!this.render) ? (sceneMark !== this.render._sceneUpdateMark || this.renderType !== this.render._updateRenderType) : false;
            if (modelDataRender) {
                this.render._renderUpdate(context, transform);
                this.render._sceneUpdateMark = sceneMark;
            }
            var updateMark = Camera._updateMark;
            var updateRender = (!!this.render) ? (updateMark !== this.render._updateMark || this.renderType !== this.render._updateRenderType) : false;
            if (updateRender) {
                this.render._renderUpdateWithCamera(context, transform);
                this.render._updateMark = updateMark;
                this.render._updateRenderType = this.renderType;
            }
            const subUbo = (!!this.render) ? this.render._subUniformBufferData : false;
            if (subUbo) {
                subUbo._needUpdate && BaseRender._transLargeUbO.updateSubData(subUbo);
            }
            this._renderElementOBJ._isRender = this._geometry._prepareRender(context);
            this._geometry._updateRenderParams(context);
            this.compileShader(context._contextOBJ);
            this._renderElementOBJ._invertFront = this.getInvertFront();
        }
        _render(context) {
            this._renderElementOBJ._render(context);
        }
        destroy() {
            this._renderElementOBJ._destroy();
            this._renderElementOBJ = null;
            this._geometry = null;
            this._baseRender = null;
            this._material = null;
            this._baseRender = null;
            this._subShader = null;
        }
    }
    RenderElement.RENDERTYPE_NORMAL = 0;
    RenderElement.RENDERTYPE_STATICBATCH = 1;
    RenderElement.RENDERTYPE_INSTANCEBATCH = 2;
    RenderElement.RENDERTYPE_VERTEXBATCH = 3;
    RenderElement._compileDefine = new Laya.DefineDatas();

    class GeometryElement {
        constructor(mode, drawType) {
            this._destroyed = false;
            this._geometryElementOBj = Laya.LayaGL.renderOBJCreate.createRenderGeometry(mode, drawType);
            this._id = ++GeometryElement._uniqueIDCounter;
        }
        set bufferState(value) {
            this._geometryElementOBj.bufferState = value;
        }
        get bufferState() {
            return this._geometryElementOBj.bufferState;
        }
        set mode(value) {
            this._geometryElementOBj.mode = value;
        }
        get mode() {
            return this._geometryElementOBj.mode;
        }
        set drawType(value) {
            this._geometryElementOBj.drawType = value;
        }
        get drawType() {
            return this._geometryElementOBj.drawType;
        }
        setDrawArrayParams(first, count) {
            this._geometryElementOBj.setDrawArrayParams(first, count);
        }
        setDrawElemenParams(count, offset) {
            this._geometryElementOBj.setDrawElemenParams(count, offset);
        }
        set instanceCount(value) {
            this._geometryElementOBj.instanceCount = value;
        }
        get instanceCount() {
            return this._geometryElementOBj.instanceCount;
        }
        set indexFormat(value) {
            this._geometryElementOBj.indexFormat = value;
        }
        get indexFormat() {
            return this._geometryElementOBj.indexFormat;
        }
        get destroyed() {
            return this._destroyed;
        }
        _getType() {
            throw "GeometryElement:must override it.";
        }
        _prepareRender(state) {
            return true;
        }
        _render(state) {
            Laya.LayaGL.renderDrawContext.drawGeometryElement(this._geometryElementOBj);
        }
        _updateRenderParams(state) {
            throw "GeometryElement:must override it.";
        }
        destroy() {
            if (this._destroyed)
                return;
            this._destroyed = true;
            this._geometryElementOBj.destroy();
        }
        clearRenderParams() {
            this._geometryElementOBj.clearRenderParams();
        }
    }
    GeometryElement._uniqueIDCounter = 0;
    GeometryElement._typeCounter = 0;

    class SkyBox extends GeometryElement {
        constructor() {
            super(Laya.MeshTopology.Triangles, Laya.DrawType.DrawElement);
            var halfHeight = 1.0;
            var halfWidth = 1.0;
            var halfDepth = 1.0;
            var vertices = new Float32Array([-halfDepth, halfHeight, -halfWidth, halfDepth, halfHeight, -halfWidth, halfDepth, halfHeight, halfWidth, -halfDepth, halfHeight, halfWidth,
                -halfDepth, -halfHeight, -halfWidth, halfDepth, -halfHeight, -halfWidth, halfDepth, -halfHeight, halfWidth, -halfDepth, -halfHeight, halfWidth]);
            var indices = new Uint8Array([
                0, 1, 2, 2, 3, 0,
                4, 7, 6, 6, 5, 4,
                0, 3, 7, 7, 4, 0,
                1, 5, 6, 6, 2, 1,
                3, 2, 6, 6, 7, 3,
                0, 4, 5, 5, 1, 0
            ]);
            var verDec = Laya.VertexMesh.getVertexDeclaration("POSITION");
            let vertexBuffer = Laya.LayaGL.renderOBJCreate.createVertexBuffer3D(verDec.vertexStride * 8, Laya.BufferUsage.Static, false);
            vertexBuffer.vertexDeclaration = verDec;
            let indexBuffer = Laya.LayaGL.renderOBJCreate.createIndexBuffer3D(Laya.IndexFormat.UInt8, 36, Laya.BufferUsage.Static, false);
            vertexBuffer.setData(vertices.buffer);
            indexBuffer.setData(indices);
            this.bufferState = new Laya.BufferState();
            this.bufferState.applyState([vertexBuffer], indexBuffer);
            this._geometryElementOBj.setDrawElemenParams(36, 0);
            this.indexFormat = Laya.IndexFormat.UInt8;
        }
        static __init__() {
            SkyBox.instance = new SkyBox();
        }
        _updateRenderParams(state) {
        }
    }

    class VertexPositionTexture0 {
        constructor(position, textureCoordinate0) {
            this._position = position;
            this._textureCoordinate0 = textureCoordinate0;
        }
        static get vertexDeclaration() {
            return VertexPositionTexture0._vertexDeclaration;
        }
        static __init__() {
            VertexPositionTexture0._vertexDeclaration = new Laya.VertexDeclaration(20, [new Laya.VertexElement(0, Laya.VertexElementFormat.Vector3, Laya.VertexMesh.MESH_POSITION0),
                new Laya.VertexElement(12, Laya.VertexElementFormat.Vector2, Laya.VertexMesh.MESH_TEXTURECOORDINATE0)]);
        }
        get position() {
            return this._position;
        }
        get textureCoordinate0() {
            return this._textureCoordinate0;
        }
        get vertexDeclaration() {
            return VertexPositionTexture0._vertexDeclaration;
        }
    }

    class SkyDome extends GeometryElement {
        constructor(stacks = 48, slices = 48) {
            super(Laya.MeshTopology.Triangles, Laya.DrawType.DrawElement);
            this._stacks = stacks;
            this._slices = slices;
            var vertexDeclaration = VertexPositionTexture0.vertexDeclaration;
            var vertexFloatCount = vertexDeclaration.vertexStride / 4;
            var numberVertices = (this._stacks + 1) * (this._slices + 1);
            var numberIndices = (3 * this._stacks * (this._slices + 1)) * 2;
            var vertices = new Float32Array(numberVertices * vertexFloatCount);
            var indices = new Uint16Array(numberIndices);
            var stackAngle = Math.PI / this._stacks;
            var sliceAngle = (Math.PI * 2.0) / this._slices;
            var vertexIndex = 0;
            var vertexCount = 0;
            var indexCount = 0;
            for (var stack = 0; stack < (this._stacks + 1); stack++) {
                var r = Math.sin(stack * stackAngle);
                var y = Math.cos(stack * stackAngle);
                for (var slice = 0; slice < (this._slices + 1); slice++) {
                    var x = r * Math.sin(slice * sliceAngle);
                    var z = r * Math.cos(slice * sliceAngle);
                    vertices[vertexCount + 0] = x * SkyDome._radius;
                    vertices[vertexCount + 1] = y * SkyDome._radius;
                    vertices[vertexCount + 2] = z * SkyDome._radius;
                    vertices[vertexCount + 3] = -(slice / this._slices) + 0.75;
                    vertices[vertexCount + 4] = stack / this._stacks;
                    vertexCount += vertexFloatCount;
                    if (stack != (this._stacks - 1)) {
                        indices[indexCount++] = vertexIndex + 1;
                        indices[indexCount++] = vertexIndex;
                        indices[indexCount++] = vertexIndex + (this._slices + 1);
                        indices[indexCount++] = vertexIndex + (this._slices + 1);
                        indices[indexCount++] = vertexIndex;
                        indices[indexCount++] = vertexIndex + (this._slices);
                        vertexIndex++;
                    }
                }
            }
            let vertexBuffer = Laya.LayaGL.renderOBJCreate.createVertexBuffer3D(vertices.length * 4, Laya.BufferUsage.Static, false);
            vertexBuffer.vertexDeclaration = vertexDeclaration;
            let indexBuffer = Laya.LayaGL.renderOBJCreate.createIndexBuffer3D(Laya.IndexFormat.UInt16, indices.length, Laya.BufferUsage.Static, false);
            vertexBuffer.setData(vertices.buffer);
            indexBuffer.setData(indices);
            var bufferState = new Laya.BufferState();
            bufferState.applyState([vertexBuffer], indexBuffer);
            this.bufferState = bufferState;
            this.indexFormat = Laya.IndexFormat.UInt16;
            this._geometryElementOBj.setDrawElemenParams(indexBuffer.indexCount, 0);
        }
        static __init__() {
            SkyDome.instance = new SkyDome();
        }
        get stacks() {
            return this._stacks;
        }
        get slices() {
            return this._slices;
        }
        _updateRenderParams(state) {
        }
    }
    SkyDome._radius = 1;

    class SkyRenderer {
        constructor() {
            this._renderElement = new RenderElement();
            this.mesh = SkyDome.instance;
            this._renderData = new BaseRender();
            this._renderElement.render = this._renderData;
        }
        static __init__() {
            SkyRenderer.SUNLIGHTDIRECTION = Laya.Shader3D.propertyNameToID("u_SunLight_direction");
            SkyRenderer.SUNLIGHTDIRCOLOR = Laya.Shader3D.propertyNameToID("u_SunLight_color");
            const commandUniform = Laya.LayaGL.renderOBJCreate.createGlobalUniformMap("Sprite3D");
            commandUniform.addShaderUniform(SkyRenderer.SUNLIGHTDIRECTION, "u_SunLight_direction");
            commandUniform.addShaderUniform(SkyRenderer.SUNLIGHTDIRCOLOR, "u_SunLight_color");
        }
        get material() {
            return this._material;
        }
        set material(value) {
            if (this._material !== value) {
                (this._material) && (this._material._removeReference());
                this._material = value;
                this._renderElement.material = value;
                if (value) {
                    value._addReference();
                    value.cull = Laya.CullMode.Off;
                    value.depthTest = Laya.CompareFunction.LessEqual;
                    value.depthWrite = false;
                    value.stencilWrite = false;
                    this._renderElement.renderSubShader = this._material._shader.getSubShaderAt(0);
                }
                else
                    this._renderElement.renderSubShader = null;
            }
        }
        get mesh() {
            return this._mesh;
        }
        set mesh(value) {
            if (this._mesh !== value) {
                this._mesh = value;
                this._renderElement.setGeometry(this._mesh);
            }
        }
        get meshType() {
            return this.mesh == SkyBox.instance ? "box" : (this.mesh == SkyDome.instance ? "dome" : "");
        }
        set meshType(value) {
            if (value == "dome")
                this.mesh = SkyDome.instance;
            else
                this.mesh = SkyBox.instance;
        }
        _isAvailable() {
            return this._material && this._mesh ? true : false;
        }
        _render(context) {
            if (this._material && this._mesh) {
                var camera = context.camera;
                var scene = context.scene;
                var projectionMatrix = SkyRenderer._tempMatrix1;
                if (camera.orthographic)
                    Laya.Matrix4x4.createPerspective(camera.fieldOfView, camera.aspectRatio, camera.nearPlane, camera.farPlane, projectionMatrix);
                this._renderData._shaderValues.setColor(SkyRenderer.SUNLIGHTDIRCOLOR, scene._sunColor);
                this._renderData._shaderValues.setVector3(SkyRenderer.SUNLIGHTDIRECTION, scene._sundir);
                var viewMatrix = SkyRenderer._tempMatrix0;
                camera.viewMatrix.cloneTo(viewMatrix);
                camera.projectionMatrix.cloneTo(projectionMatrix);
                viewMatrix.setTranslationVector(Laya.Vector3.ZERO);
                var epsilon = 1e-6;
                var yScale = 1.0 / Math.tan(3.1416 * camera.fieldOfView / 180 * 0.5);
                projectionMatrix.elements[0] = yScale / camera.aspectRatio;
                projectionMatrix.elements[5] = yScale;
                projectionMatrix.elements[10] = epsilon - 1.0;
                projectionMatrix.elements[11] = -1.0;
                projectionMatrix.elements[14] = -0;
                if (camera.isWebXR) {
                    camera._applyViewProject(context, viewMatrix, camera.projectionMatrix);
                }
                else {
                    camera._applyViewProject(context, viewMatrix, projectionMatrix);
                }
                context._contextOBJ.applyContext(Camera._updateMark);
                context.drawRenderElement(this._renderElement);
                camera._applyViewProject(context, camera.viewMatrix, camera.projectionMatrix);
            }
        }
        destroy() {
            if (this._material) {
                this._material._removeReference();
                this._material = null;
            }
            this._renderData.destroy();
            this._renderData._onDestroy();
            this._renderElement.destroy();
        }
    }
    SkyRenderer._tempMatrix0 = new Laya.Matrix4x4();
    SkyRenderer._tempMatrix1 = new Laya.Matrix4x4();

    class BaseCamera extends Sprite3D {
        constructor(nearPlane = 0.3, farPlane = 1000) {
            super();
            this._skyRenderer = new SkyRenderer();
            this._forward = new Laya.Vector3();
            this._up = new Laya.Vector3();
            this._shaderValues = Laya.LayaGL.renderOBJCreate.createShaderData(null);
            this._linearClearColor = new Laya.Color();
            this.clearColor = new Laya.Color(100 / 255, 149 / 255, 237 / 255, 255 / 255);
            this._fieldOfView = 60;
            this._useUserProjectionMatrix = false;
            this._orthographicVerticalSize = 10;
            this.renderingOrder = 0;
            this._nearPlane = nearPlane;
            this._farPlane = farPlane;
            this.cullingMask = 2147483647;
            this.staticMask = 0xffffffff;
            this.useOcclusionCulling = true;
            this._renderEngine = Laya.LayaGL.renderEngine;
            this._orthographic = false;
            if (Laya.Config3D._uniformBlock) {
                this._cameraUniformUBO = Laya.UniformBufferObject.getBuffer(Laya.UniformBufferObject.UBONAME_CAMERA, 0);
                this._cameraUniformData = BaseCamera.createCameraUniformBlock();
                if (!this._cameraUniformUBO) {
                    this._cameraUniformUBO = Laya.UniformBufferObject.create(Laya.UniformBufferObject.UBONAME_CAMERA, Laya.BufferUsage.Dynamic, this._cameraUniformData.getbyteLength(), false);
                }
                this._shaderValues._addCheckUBO(Laya.UniformBufferObject.UBONAME_CAMERA, this._cameraUniformUBO, this._cameraUniformData);
                this._shaderValues.setUniformBuffer(BaseCamera.CAMERAUNIFORMBLOCK, this._cameraUniformUBO);
            }
        }
        static shaderValueInit() {
            BaseCamera.SHADERDEFINE_DEPTH = Laya.Shader3D.getDefineByName("DEPTHMAP");
            BaseCamera.SHADERDEFINE_DEPTHNORMALS = Laya.Shader3D.getDefineByName("DEPTHNORMALSMAP");
            BaseCamera.SHADERDEFINE_ORTHOGRAPHIC = Laya.Shader3D.getDefineByName("CAMERAORTHOGRAPHIC");
            BaseCamera.SHADERDEFINE_FXAA = Laya.Shader3D.getDefineByName("FXAA");
            let camerauniformMap = BaseCamera.cameraUniformMap = Laya.LayaGL.renderOBJCreate.createGlobalUniformMap("BaseCamera");
            BaseCamera.CAMERAPOS = Laya.Shader3D.propertyNameToID("u_CameraPos");
            BaseCamera.VIEWMATRIX = Laya.Shader3D.propertyNameToID("u_View");
            BaseCamera.VIEWPROJECTMATRIX = Laya.Shader3D.propertyNameToID("u_ViewProjection");
            BaseCamera.PROJECTMATRIX = Laya.Shader3D.propertyNameToID("u_Projection");
            BaseCamera.CAMERADIRECTION = Laya.Shader3D.propertyNameToID("u_CameraDirection");
            BaseCamera.CAMERAUP = Laya.Shader3D.propertyNameToID("u_CameraUp");
            BaseCamera.VIEWPORT = Laya.Shader3D.propertyNameToID("u_Viewport");
            BaseCamera.PROJECTION_PARAMS = Laya.Shader3D.propertyNameToID("u_ProjectionParams");
            BaseCamera.DEPTHTEXTURE = Laya.Shader3D.propertyNameToID("u_CameraDepthTexture");
            BaseCamera.DEPTHNORMALSTEXTURE = Laya.Shader3D.propertyNameToID("u_CameraDepthNormalsTexture");
            BaseCamera.OPAQUETEXTURE = Laya.Shader3D.propertyNameToID("u_CameraOpaqueTexture");
            BaseCamera.DEPTHZBUFFERPARAMS = Laya.Shader3D.propertyNameToID("u_ZBufferParams");
            BaseCamera.CAMERAUNIFORMBLOCK = Laya.Shader3D.propertyNameToID(Laya.UniformBufferObject.UBONAME_CAMERA);
            camerauniformMap.addShaderUniform(BaseCamera.CAMERAPOS, "u_CameraPos");
            camerauniformMap.addShaderUniform(BaseCamera.VIEWMATRIX, "u_View");
            camerauniformMap.addShaderUniform(BaseCamera.PROJECTMATRIX, "u_Projection");
            camerauniformMap.addShaderUniform(BaseCamera.VIEWPROJECTMATRIX, "u_ViewProjection");
            camerauniformMap.addShaderUniform(BaseCamera.CAMERADIRECTION, "u_CameraDirection");
            camerauniformMap.addShaderUniform(BaseCamera.CAMERAUP, "u_CameraUp");
            camerauniformMap.addShaderUniform(BaseCamera.VIEWPORT, "u_Viewport");
            camerauniformMap.addShaderUniform(BaseCamera.PROJECTION_PARAMS, "u_ProjectionParams");
            camerauniformMap.addShaderUniform(BaseCamera.DEPTHTEXTURE, "u_CameraDepthTexture");
            camerauniformMap.addShaderUniform(BaseCamera.DEPTHNORMALSTEXTURE, "u_CameraDepthNormalsTexture");
            camerauniformMap.addShaderUniform(BaseCamera.OPAQUETEXTURE, "u_CameraOpaqueTexture");
            camerauniformMap.addShaderUniform(BaseCamera.DEPTHZBUFFERPARAMS, "u_ZBufferParams");
            camerauniformMap.addShaderUniform(BaseCamera.CAMERAUNIFORMBLOCK, Laya.UniformBufferObject.UBONAME_CAMERA);
        }
        static createCameraUniformBlock() {
            if (!BaseCamera.CameraUBOData) {
                let uniformPara = new Map();
                uniformPara.set("u_View", Laya.UniformBufferParamsType.Matrix4x4);
                uniformPara.set("u_Projection", Laya.UniformBufferParamsType.Matrix4x4);
                uniformPara.set("u_ViewProjection", Laya.UniformBufferParamsType.Matrix4x4);
                uniformPara.set("u_ProjectionParams", Laya.UniformBufferParamsType.Vector4);
                uniformPara.set("u_Viewport", Laya.UniformBufferParamsType.Vector4);
                uniformPara.set("u_CameraDirection", Laya.UniformBufferParamsType.Vector3);
                uniformPara.set("u_CameraUp", Laya.UniformBufferParamsType.Vector3);
                uniformPara.set("u_CameraPos", Laya.UniformBufferParamsType.Vector3);
                let uniformMap = new Map();
                uniformPara.forEach((value, key) => {
                    uniformMap.set(Laya.Shader3D.propertyNameToID(key), value);
                });
                BaseCamera.CameraUBOData = new Laya.UnifromBufferData(uniformMap);
            }
            return BaseCamera.CameraUBOData;
        }
        static __init__() {
            BaseCamera.shaderValueInit();
        }
        get clearColor() {
            return this._clearColor;
        }
        set clearColor(value) {
            this._clearColor = value;
            value.toLinear(this._linearClearColor);
        }
        get skyRenderer() {
            return this._skyRenderer;
        }
        get fieldOfView() {
            return this._fieldOfView;
        }
        set fieldOfView(value) {
            this._fieldOfView = value;
            this._calculateProjectionMatrix();
            this._caculateMaxLocalYRange();
        }
        get maxlocalYDistance() {
            return this._yrange;
        }
        get nearPlane() {
            return this._nearPlane;
        }
        set nearPlane(value) {
            this._nearPlane = value;
            this._calculateProjectionMatrix();
        }
        get farPlane() {
            return this._farPlane;
        }
        set farPlane(vaule) {
            this._farPlane = vaule;
            this._calculateProjectionMatrix();
            this._caculateMaxLocalYRange();
        }
        get orthographic() {
            return this._orthographic;
        }
        set orthographic(vaule) {
            this._orthographic = vaule;
            this._calculateProjectionMatrix();
            if (vaule) {
                this._shaderValues.addDefine(BaseCamera.SHADERDEFINE_ORTHOGRAPHIC);
            }
            else
                this._shaderValues.removeDefine(BaseCamera.SHADERDEFINE_ORTHOGRAPHIC);
        }
        get orthographicVerticalSize() {
            return this._orthographicVerticalSize;
        }
        set orthographicVerticalSize(vaule) {
            this._orthographicVerticalSize = vaule;
            this._calculateProjectionMatrix();
        }
        get cullingMask() {
            return this._cullingMask;
        }
        set cullingMask(value) {
            this._cullingMask = value;
        }
        get renderingOrder() {
            return this._renderingOrder;
        }
        set renderingOrder(value) {
            this._renderingOrder = value;
            this._sortCamerasByRenderingOrder();
        }
        _caculateMaxLocalYRange() {
            let halffield = 3.1416 * this.fieldOfView / 180.0 / 2;
            let dist = this.farPlane;
            this._yrange = Math.tan(halffield) * dist * 2;
        }
        _calculateProjectionMatrix() {
        }
        _onScreenSizeChanged() {
            this._calculateProjectionMatrix();
        }
        _create() {
            return new BaseCamera();
        }
        _sortCamerasByRenderingOrder() {
            if (this.displayedInStage) {
                var cameraPool = this.scene._cameraPool;
                var n = cameraPool.length - 1;
                for (var i = 0; i < n; i++) {
                    if (cameraPool[i].renderingOrder > cameraPool[n].renderingOrder) {
                        var tempCamera = cameraPool[i];
                        cameraPool[i] = cameraPool[n];
                        cameraPool[n] = tempCamera;
                    }
                }
            }
        }
        _prepareCameraToRender() {
            this.transform.getForward(this._forward);
            this.transform.getUp(this._up);
            this._shaderValues.setVector3(BaseCamera.CAMERAPOS, this.transform.position);
            this._shaderValues.setVector3(BaseCamera.CAMERADIRECTION, this._forward);
            this._shaderValues.setVector3(BaseCamera.CAMERAUP, this._up);
        }
        render(shader = null, replacementTag = null) {
        }
        addLayer(layer) {
            this.cullingMask |= Math.pow(2, layer);
        }
        removeLayer(layer) {
            this.cullingMask &= ~Math.pow(2, layer);
        }
        addAllLayers() {
            this.cullingMask = 2147483647;
        }
        removeAllLayers() {
            this.cullingMask = 0;
        }
        resetProjectionMatrix() {
            this._useUserProjectionMatrix = false;
            this._calculateProjectionMatrix();
        }
        _onActive() {
            this._scene._addCamera(this);
            super._onActive();
        }
        _onInActive() {
            this._scene._removeCamera(this);
            super._onInActive();
        }
        _parse(data, spriteMap) {
            super._parse(data, spriteMap);
            this.orthographic = data.orthographic;
            (data.orthographicVerticalSize !== undefined) && (this.orthographicVerticalSize = data.orthographicVerticalSize);
            (data.fieldOfView !== undefined) && (this.fieldOfView = data.fieldOfView);
            this.nearPlane = data.nearPlane;
            this.farPlane = data.farPlane;
            var color = data.clearColor;
            this.clearColor = new Laya.Color(color[0], color[1], color[2], color[3]);
            var skyboxMaterial = data.skyboxMaterial;
            if (skyboxMaterial) {
                this._skyRenderer.material = Laya.Loader.getRes(skyboxMaterial.path);
            }
        }
        destroy(destroyChild = true) {
            this._skyRenderer.destroy();
            this._skyRenderer = null;
            Laya.ILaya.stage.off(Laya.Event.RESIZE, this, this._onScreenSizeChanged);
            super.destroy(destroyChild);
        }
    }
    BaseCamera.RENDERINGTYPE_SHADERDEFINE_FXAA = "FXAA";
    BaseCamera.RENDERINGTYPE_DEFERREDLIGHTING = "DEFERREDLIGHTING";
    BaseCamera.RENDERINGTYPE_FORWARDRENDERING = "FORWARDRENDERING";
    BaseCamera._invertYScaleMatrix = new Laya.Matrix4x4(1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    BaseCamera._invertYProjectionMatrix = new Laya.Matrix4x4();
    BaseCamera._invertYProjectionViewMatrix = new Laya.Matrix4x4();
    BaseCamera._tempMatrix4x40 = new Laya.Matrix4x4();

    exports.ShadowMode = void 0;
    (function (ShadowMode) {
        ShadowMode[ShadowMode["None"] = 0] = "None";
        ShadowMode[ShadowMode["Hard"] = 1] = "Hard";
        ShadowMode[ShadowMode["SoftLow"] = 2] = "SoftLow";
        ShadowMode[ShadowMode["SoftHigh"] = 3] = "SoftHigh";
    })(exports.ShadowMode || (exports.ShadowMode = {}));

    exports.ShadowCascadesMode = void 0;
    (function (ShadowCascadesMode) {
        ShadowCascadesMode[ShadowCascadesMode["NoCascades"] = 0] = "NoCascades";
        ShadowCascadesMode[ShadowCascadesMode["TwoCascades"] = 1] = "TwoCascades";
        ShadowCascadesMode[ShadowCascadesMode["FourCascades"] = 2] = "FourCascades";
    })(exports.ShadowCascadesMode || (exports.ShadowCascadesMode = {}));

    exports.LightType = void 0;
    (function (LightType) {
        LightType[LightType["Directional"] = 0] = "Directional";
        LightType[LightType["Spot"] = 1] = "Spot";
        LightType[LightType["Point"] = 2] = "Point";
        LightType[LightType["Area"] = 3] = "Area";
    })(exports.LightType || (exports.LightType = {}));
    exports.LightMode = void 0;
    (function (LightMode) {
        LightMode[LightMode["mix"] = 0] = "mix";
        LightMode[LightMode["realTime"] = 1] = "realTime";
        LightMode[LightMode["bakeOnly"] = 2] = "bakeOnly";
    })(exports.LightMode || (exports.LightMode = {}));
    class Light extends Laya.Component {
        constructor() {
            super();
            this._shadowMode = exports.ShadowMode.None;
            this._isAlternate = false;
            this._shadowResolution = 2048;
            this._shadowDistance = 50.0;
            this._shadowDepthBias = 1.0;
            this._shadowNormalBias = 1.0;
            this._shadowNearPlane = 0.1;
            this._shadowStrength = 1.0;
            this._lightWoldMatrix = new Laya.Matrix4x4();
            this.runInEditor = true;
            this._intensity = 1.0;
            this._intensityColor = new Laya.Vector3();
            this.color = new Laya.Color(1.0, 1.0, 1.0, 1.0);
            this._lightmapBakedType = exports.LightMode.realTime;
        }
        get intensity() {
            return this._intensity;
        }
        set intensity(value) {
            this._intensity = value;
        }
        get shadowMode() {
            return this._shadowMode;
        }
        set shadowMode(value) {
            this._shadowMode = value;
        }
        get shadowDistance() {
            return this._shadowDistance;
        }
        set shadowDistance(value) {
            this._shadowDistance = value;
        }
        get shadowResolution() {
            return this._shadowResolution;
        }
        set shadowResolution(value) {
            this._shadowResolution = value;
        }
        get shadowDepthBias() {
            return this._shadowDepthBias;
        }
        set shadowDepthBias(value) {
            this._shadowDepthBias = value;
        }
        get shadowNormalBias() {
            return this._shadowNormalBias;
        }
        set shadowNormalBias(value) {
            this._shadowNormalBias = value;
        }
        get shadowStrength() {
            return this._shadowStrength;
        }
        set shadowStrength(value) {
            this._shadowStrength = value;
        }
        get shadowNearPlane() {
            return this._shadowNearPlane;
        }
        set shadowNearPlane(value) {
            this._shadowNearPlane = value;
        }
        get lightmapBakedType() {
            return this._lightmapBakedType;
        }
        set lightmapBakedType(value) {
            let premode = this._lightmapBakedType;
            if (this._lightmapBakedType !== value) {
                this._lightmapBakedType = value;
                if (this._enabled) {
                    if (value == exports.LightMode.bakeOnly)
                        this._removeFromScene();
                    else if (premode == exports.LightMode.bakeOnly)
                        this._addToScene();
                }
            }
        }
        get lightWorldMatrix() {
            var position = this.owner.transform.position;
            var quaterian = this.owner.transform.rotation;
            Laya.Matrix4x4.createAffineTransformation(position, quaterian, Laya.Vector3.ONE, this._lightWoldMatrix);
            return this._lightWoldMatrix;
        }
        _parse(data, spriteMap) {
            super._parse(data, spriteMap);
            var colorData = data.color;
            this.color.r = colorData[0];
            this.color.g = colorData[1];
            this.color.b = colorData[2];
            this.intensity = data.intensity;
            this.lightmapBakedType = data.lightmapBakedType;
        }
        _cloneTo(dest) {
            super._cloneTo(dest);
            var light = dest;
            light.color = this.color.clone();
            light.intensity = this.intensity;
            light.lightmapBakedType = this.lightmapBakedType;
        }
        _addToScene() {
            var scene = this.owner.scene;
            var maxLightCount = Laya.Config3D.maxLightCount;
            if (scene._lightCount < maxLightCount) {
                scene._lightCount++;
                this._addToLightQueue();
                this._isAlternate = false;
            }
            else {
                scene._alternateLights.add(this);
                this._isAlternate = true;
                console.warn("LightSprite:light count has large than maxLightCount,the latest added light will be ignore.");
            }
        }
        _removeFromScene() {
            var scene = this.owner._scene;
            if (!scene)
                return;
            if (this._isAlternate) {
                scene._alternateLights.remove(this);
            }
            else {
                scene._lightCount--;
                this._removeFromLightQueue();
                if (scene._alternateLights._length > 0) {
                    var alternateLight = scene._alternateLights.shift();
                    alternateLight._addToLightQueue();
                    alternateLight._isAlternate = false;
                    scene._lightCount++;
                }
            }
        }
        _addToLightQueue() {
        }
        _removeFromLightQueue() {
        }
        _onEnable() {
            (this.lightmapBakedType !== exports.LightMode.bakeOnly) && (this._addToScene());
        }
        _onDisable() {
            (this.lightmapBakedType !== exports.LightMode.bakeOnly) && (this._removeFromScene());
        }
        _onDestroy() {
        }
        _create() {
            return new Light();
        }
    }

    var FrustumFace;
    (function (FrustumFace) {
        FrustumFace[FrustumFace["Near"] = 0] = "Near";
        FrustumFace[FrustumFace["Far"] = 1] = "Far";
        FrustumFace[FrustumFace["Left"] = 2] = "Left";
        FrustumFace[FrustumFace["Right"] = 3] = "Right";
        FrustumFace[FrustumFace["Bottom"] = 4] = "Bottom";
        FrustumFace[FrustumFace["Top"] = 5] = "Top";
    })(FrustumFace || (FrustumFace = {}));
    exports.ShadowMapFormat = void 0;
    (function (ShadowMapFormat) {
        ShadowMapFormat[ShadowMapFormat["bit16"] = 0] = "bit16";
        ShadowMapFormat[ShadowMapFormat["bit24_8"] = 1] = "bit24_8";
        ShadowMapFormat[ShadowMapFormat["bit32"] = 2] = "bit32";
    })(exports.ShadowMapFormat || (exports.ShadowMapFormat = {}));
    class ShadowUtils {
        static init() {
            ShadowUtils._adjustNearPlane = new Plane(new Laya.Vector3(), 0);
            ShadowUtils._adjustFarPlane = new Plane(new Laya.Vector3(), 0);
        }
        static supportShadow() {
            return Laya.LayaGL.renderEngine.getCapable(Laya.RenderCapable.RenderTextureFormat_Depth);
        }
        static getTemporaryShadowTexture(witdh, height, shadowFormat) {
            let depthFormat = Laya.RenderTargetFormat.DEPTH_16;
            switch (shadowFormat) {
                case exports.ShadowMapFormat.bit16:
                    depthFormat = Laya.RenderTargetFormat.DEPTH_16;
                    break;
                case exports.ShadowMapFormat.bit24_8:
                    depthFormat = Laya.RenderTargetFormat.DEPTHSTENCIL_24_8;
                    break;
                case exports.ShadowMapFormat.bit32:
                    depthFormat = Laya.RenderTargetFormat.DEPTH_32;
                    break;
            }
            var shadowMap = Laya.RenderTexture.createFromPool(witdh, height, depthFormat, Laya.RenderTargetFormat.None, false, 1);
            shadowMap.compareMode = Laya.TextureCompareMode.LESS;
            shadowMap.filterMode = Laya.FilterMode.Bilinear;
            shadowMap.wrapModeU = Laya.WrapMode.Clamp;
            shadowMap.wrapModeV = Laya.WrapMode.Clamp;
            return shadowMap;
        }
        static getShadowBias(light, shadowProjectionMatrix, shadowResolution, out) {
            var frustumSize;
            if (light._lightType == exports.LightType.Directional) {
                frustumSize = 2.0 / shadowProjectionMatrix.elements[0];
            }
            else if (light._lightType == exports.LightType.Spot) {
                frustumSize = Math.tan(light.spotAngle * 0.5 * Laya.MathUtils3D.Deg2Rad) * light.range;
            }
            else {
                console.warn("ShadowUtils:Only spot and directional shadow casters are supported now.");
                frustumSize = 0.0;
            }
            var texelSize = frustumSize / shadowResolution;
            var depthBias = -light._shadowDepthBias * texelSize;
            var normalBias = -light._shadowNormalBias * texelSize;
            if (light.shadowMode == exports.ShadowMode.SoftHigh) {
                const kernelRadius = 2.5;
                depthBias *= kernelRadius;
                normalBias *= kernelRadius;
            }
            out.setValue(depthBias, normalBias, 0.0, 0.0);
        }
        static getCameraFrustumPlanes(cameraViewProjectMatrix, frustumPlanes) {
            BoundFrustum.getPlanesFromMatrix(cameraViewProjectMatrix, frustumPlanes[FrustumFace.Near], frustumPlanes[FrustumFace.Far], frustumPlanes[FrustumFace.Left], frustumPlanes[FrustumFace.Right], frustumPlanes[FrustumFace.Top], frustumPlanes[FrustumFace.Bottom]);
        }
        static getFarWithRadius(radius, denominator) {
            return Math.sqrt(radius * radius / denominator);
        }
        static getCascadesSplitDistance(twoSplitRatio, fourSplitRatio, cameraNear, shadowFar, fov, aspectRatio, cascadesMode, out) {
            out[0] = cameraNear;
            var range = shadowFar - cameraNear;
            var tFov = Math.tan(fov * 0.5);
            var denominator = 1.0 + tFov * tFov * (aspectRatio * aspectRatio + 1.0);
            switch (cascadesMode) {
                case exports.ShadowCascadesMode.NoCascades:
                    out[1] = ShadowUtils.getFarWithRadius(shadowFar, denominator);
                    break;
                case exports.ShadowCascadesMode.TwoCascades:
                    out[1] = ShadowUtils.getFarWithRadius(cameraNear + range * twoSplitRatio, denominator);
                    out[2] = ShadowUtils.getFarWithRadius(shadowFar, denominator);
                    break;
                case exports.ShadowCascadesMode.FourCascades:
                    out[1] = ShadowUtils.getFarWithRadius(cameraNear + range * fourSplitRatio.x, denominator);
                    out[2] = ShadowUtils.getFarWithRadius(cameraNear + range * fourSplitRatio.y, denominator);
                    out[3] = ShadowUtils.getFarWithRadius(cameraNear + range * fourSplitRatio.z, denominator);
                    out[4] = ShadowUtils.getFarWithRadius(shadowFar, denominator);
                    break;
            }
        }
        static applySliceTransform(shadowSliceData, atlasWidth, atlasHeight, cascadeIndex, outShadowMatrices) {
            var sliceE = ShadowUtils._tempMatrix0.elements;
            var oneOverAtlasWidth = 1.0 / atlasWidth;
            var oneOverAtlasHeight = 1.0 / atlasHeight;
            sliceE[0] = shadowSliceData.resolution * oneOverAtlasWidth;
            sliceE[5] = shadowSliceData.resolution * oneOverAtlasHeight;
            sliceE[12] = shadowSliceData.offsetX * oneOverAtlasWidth;
            sliceE[13] = shadowSliceData.offsetY * oneOverAtlasHeight;
            sliceE[1] = sliceE[2] = sliceE[2] = sliceE[4] = sliceE[6] = sliceE[7] = sliceE[8] = sliceE[9] = sliceE[11] = sliceE[14] = 0;
            sliceE[10] = sliceE[15] = 1;
            var offset = cascadeIndex * 16;
            Utils3D._mulMatrixArray(sliceE, outShadowMatrices, offset, outShadowMatrices, offset);
        }
        static getDirectionLightShadowCullPlanes(cameraFrustumPlanes, cascadeIndex, splitDistance, cameraNear, direction, shadowSliceData) {
            var frustumCorners = ShadowUtils._frustumCorners;
            var backPlaneFaces = ShadowUtils._backPlaneFaces;
            var planeNeighbors = ShadowUtils._frustumPlaneNeighbors;
            var twoPlaneCorners = ShadowUtils._frustumTwoPlaneCorners;
            var edgePlanePoint2 = ShadowUtils._edgePlanePoint2;
            var out = shadowSliceData.cullPlanes;
            var near = cameraFrustumPlanes[FrustumFace.Near], far = cameraFrustumPlanes[FrustumFace.Far];
            var left = cameraFrustumPlanes[FrustumFace.Left], right = cameraFrustumPlanes[FrustumFace.Right];
            var bottom = cameraFrustumPlanes[FrustumFace.Bottom], top = cameraFrustumPlanes[FrustumFace.Top];
            var splitNearDistance = splitDistance[cascadeIndex] - cameraNear;
            var splitNear = ShadowUtils._adjustNearPlane;
            var splitFar = ShadowUtils._adjustFarPlane;
            splitNear.normal = near.normal;
            splitFar.normal = far.normal;
            splitNear.distance = near.distance - splitNearDistance;
            splitFar.distance = Math.min(-near.distance + shadowSliceData.sphereCenterZ + shadowSliceData.splitBoundSphere.radius, far.distance);
            BoundFrustum.get3PlaneInterPoint(splitNear, bottom, right, frustumCorners[exports.FrustumCorner.nearBottomRight]);
            BoundFrustum.get3PlaneInterPoint(splitNear, top, right, frustumCorners[exports.FrustumCorner.nearTopRight]);
            BoundFrustum.get3PlaneInterPoint(splitNear, top, left, frustumCorners[exports.FrustumCorner.nearTopLeft]);
            BoundFrustum.get3PlaneInterPoint(splitNear, bottom, left, frustumCorners[exports.FrustumCorner.nearBottomLeft]);
            BoundFrustum.get3PlaneInterPoint(splitFar, bottom, right, frustumCorners[exports.FrustumCorner.FarBottomRight]);
            BoundFrustum.get3PlaneInterPoint(splitFar, top, right, frustumCorners[exports.FrustumCorner.FarTopRight]);
            BoundFrustum.get3PlaneInterPoint(splitFar, top, left, frustumCorners[exports.FrustumCorner.FarTopLeft]);
            BoundFrustum.get3PlaneInterPoint(splitFar, bottom, left, frustumCorners[exports.FrustumCorner.FarBottomLeft]);
            var backIndex = 0;
            for (var i = 0; i < 6; i++) {
                var plane;
                switch (i) {
                    case FrustumFace.Near:
                        plane = splitNear;
                        break;
                    case FrustumFace.Far:
                        plane = splitFar;
                        break;
                    default:
                        plane = cameraFrustumPlanes[i];
                        break;
                }
                if (Laya.Vector3.dot(plane.normal, direction) < 0.0) {
                    plane.cloneTo(out[backIndex]);
                    backPlaneFaces[backIndex] = i;
                    backIndex++;
                }
            }
            var edgeIndex = backIndex;
            for (var i = 0; i < backIndex; i++) {
                var backFace = backPlaneFaces[i];
                var neighborFaces = planeNeighbors[backFace];
                for (var j = 0; j < 4; j++) {
                    var neighborFace = neighborFaces[j];
                    var notBackFace = true;
                    for (var k = 0; k < backIndex; k++)
                        if (neighborFace == backPlaneFaces[k]) {
                            notBackFace = false;
                            break;
                        }
                    if (notBackFace) {
                        var corners = twoPlaneCorners[backFace][neighborFace];
                        var point0 = frustumCorners[corners[0]];
                        var point1 = frustumCorners[corners[1]];
                        Laya.Vector3.add(point0, direction, edgePlanePoint2);
                        Plane.createPlaneBy3P(point0, point1, edgePlanePoint2, out[edgeIndex++]);
                    }
                }
            }
            shadowSliceData.cullPlaneCount = edgeIndex;
        }
        static getBoundSphereByFrustum(near, far, fov, aspectRatio, cameraPos, forward, outBoundSphere) {
            var centerZ;
            var radius;
            var k = Math.sqrt(1.0 + aspectRatio * aspectRatio) * Math.tan(fov / 2.0);
            var k2 = k * k;
            var farSNear = far - near;
            var farANear = far + near;
            if (k2 > farSNear / farANear) {
                centerZ = far;
                radius = far * k;
            }
            else {
                centerZ = 0.5 * farANear * (1 + k2);
                radius = 0.5 * Math.sqrt(farSNear * farSNear + 2.0 * (far * far + near * near) * k2 + farANear * farANear * k2 * k2);
            }
            var center = outBoundSphere.center;
            outBoundSphere.radius = radius;
            Laya.Vector3.scale(forward, centerZ, center);
            Laya.Vector3.add(cameraPos, center, center);
            outBoundSphere.center = center;
            return centerZ;
        }
        static getMaxTileResolutionInAtlas(atlasWidth, atlasHeight, tileCount) {
            var resolution = Math.min(atlasWidth, atlasHeight);
            var currentTileCount = Math.floor(atlasWidth / resolution) * Math.floor(atlasHeight / resolution);
            while (currentTileCount < tileCount) {
                resolution = Math.floor(resolution >> 1);
                currentTileCount = Math.floor(atlasWidth / resolution) * Math.floor(atlasHeight / resolution);
            }
            return resolution;
        }
        static getDirectionalLightMatrices(lightUp, lightSide, lightForward, cascadeIndex, nearPlane, shadowResolution, shadowSliceData, shadowMatrices) {
            var boundSphere = shadowSliceData.splitBoundSphere;
            var center = boundSphere.center;
            var radius = boundSphere.radius;
            var halfShadowResolution = shadowResolution / 2;
            var borderRadius = radius * halfShadowResolution / (halfShadowResolution - ShadowUtils.atlasBorderSize);
            var borderDiam = borderRadius * 2.0;
            var sizeUnit = shadowResolution / borderDiam;
            var radiusUnit = borderDiam / shadowResolution;
            var upLen = Math.ceil(Laya.Vector3.dot(center, lightUp) * sizeUnit) * radiusUnit;
            var sideLen = Math.ceil(Laya.Vector3.dot(center, lightSide) * sizeUnit) * radiusUnit;
            var forwardLen = Laya.Vector3.dot(center, lightForward);
            center.x = lightUp.x * upLen + lightSide.x * sideLen + lightForward.x * forwardLen;
            center.y = lightUp.y * upLen + lightSide.y * sideLen + lightForward.y * forwardLen;
            center.z = lightUp.z * upLen + lightSide.z * sideLen + lightForward.z * forwardLen;
            boundSphere.center = center;
            var origin = shadowSliceData.position;
            var viewMatrix = shadowSliceData.viewMatrix;
            var projectMatrix = shadowSliceData.projectionMatrix;
            var viewProjectMatrix = shadowSliceData.viewProjectMatrix;
            shadowSliceData.resolution = shadowResolution;
            shadowSliceData.offsetX = (cascadeIndex % 2) * shadowResolution;
            shadowSliceData.offsetY = Math.floor(cascadeIndex / 2) * shadowResolution;
            Laya.Vector3.scale(lightForward, radius + nearPlane, origin);
            Laya.Vector3.subtract(center, origin, origin);
            Laya.Matrix4x4.createLookAt(origin, center, lightUp, viewMatrix);
            Laya.Matrix4x4.createOrthoOffCenter(-borderRadius, borderRadius, -borderRadius, borderRadius, 0.0, radius * 2.0 + nearPlane, projectMatrix);
            Laya.Matrix4x4.multiply(projectMatrix, viewMatrix, viewProjectMatrix);
            Utils3D._mulMatrixArray(ShadowUtils._shadowMapScaleOffsetMatrix.elements, viewProjectMatrix.elements, 0, shadowMatrices, cascadeIndex * 16);
        }
        static getSpotLightShadowData(shadowSpotData, spotLight, resolution, shadowParams, shadowSpotMatrices, shadowMapSize) {
            var out = shadowSpotData.position = spotLight.owner.transform.position;
            shadowSpotData.resolution = resolution;
            shadowMapSize.setValue(1.0 / resolution, 1.0 / resolution, resolution, resolution);
            shadowSpotData.offsetX = 0;
            shadowSpotData.offsetY = 0;
            var spotWorldMatrix = spotLight.lightWorldMatrix;
            var viewMatrix = shadowSpotData.viewMatrix;
            var projectMatrix = shadowSpotData.projectionMatrix;
            var viewProjectMatrix = shadowSpotData.viewProjectMatrix;
            var BoundFrustum = shadowSpotData.cameraCullInfo.boundFrustum;
            spotWorldMatrix.invert(viewMatrix);
            Laya.Matrix4x4.createPerspective(3.1416 * spotLight.spotAngle / 180.0, 1, 0.1, spotLight.range, projectMatrix);
            shadowParams.y = spotLight.shadowStrength;
            Laya.Matrix4x4.multiply(projectMatrix, viewMatrix, viewProjectMatrix);
            BoundFrustum.matrix = viewProjectMatrix;
            viewProjectMatrix.cloneTo(shadowSpotMatrices);
            shadowSpotData.cameraCullInfo.position = out;
        }
        static prepareShadowReceiverShaderValues(light, shadowMapWidth, shadowMapHeight, shadowSliceDatas, cascadeCount, shadowMapSize, shadowParams, shadowMatrices, splitBoundSpheres) {
            shadowMapSize.setValue(1.0 / shadowMapWidth, 1.0 / shadowMapHeight, shadowMapWidth, shadowMapHeight);
            shadowParams.setValue(light._shadowStrength, 0.0, 0.0, 0.0);
            if (cascadeCount > 1) {
                const matrixFloatCount = 16;
                for (var i = cascadeCount * matrixFloatCount, n = 4 * matrixFloatCount; i < n; i++)
                    shadowMatrices[i] = 0.0;
                for (var i = 0; i < cascadeCount; i++) {
                    var boundSphere = shadowSliceDatas[i].splitBoundSphere;
                    var center = boundSphere.center;
                    var radius = boundSphere.radius;
                    var offset = i * 4;
                    splitBoundSpheres[offset] = center.x;
                    splitBoundSpheres[offset + 1] = center.y;
                    splitBoundSpheres[offset + 2] = center.z;
                    splitBoundSpheres[offset + 3] = radius * radius;
                }
                const sphereFloatCount = 4;
                for (var i = cascadeCount * sphereFloatCount, n = 4 * sphereFloatCount; i < n; i++)
                    splitBoundSpheres[i] = 0.0;
            }
        }
    }
    ShadowUtils._tempMatrix0 = new Laya.Matrix4x4();
    ShadowUtils._shadowMapScaleOffsetMatrix = new Laya.Matrix4x4(0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.5, 0.5, 0.0, 1.0);
    ShadowUtils._frustumCorners = [new Laya.Vector3(), new Laya.Vector3(), new Laya.Vector3(), new Laya.Vector3(), new Laya.Vector3(), new Laya.Vector3(), new Laya.Vector3(), new Laya.Vector3()];
    ShadowUtils._backPlaneFaces = new Array(5);
    ShadowUtils._edgePlanePoint2 = new Laya.Vector3();
    ShadowUtils._frustumPlaneNeighbors = [
        [FrustumFace.Left, FrustumFace.Right, FrustumFace.Top, FrustumFace.Bottom],
        [FrustumFace.Left, FrustumFace.Right, FrustumFace.Top, FrustumFace.Bottom],
        [FrustumFace.Near, FrustumFace.Far, FrustumFace.Top, FrustumFace.Bottom],
        [FrustumFace.Near, FrustumFace.Far, FrustumFace.Top, FrustumFace.Bottom],
        [FrustumFace.Near, FrustumFace.Far, FrustumFace.Left, FrustumFace.Right],
        [FrustumFace.Near, FrustumFace.Far, FrustumFace.Left, FrustumFace.Right]
    ];
    ShadowUtils._frustumTwoPlaneCorners = [
        [[exports.FrustumCorner.unknown, exports.FrustumCorner.unknown], [exports.FrustumCorner.unknown, exports.FrustumCorner.unknown], [exports.FrustumCorner.nearBottomLeft, exports.FrustumCorner.nearTopLeft], [exports.FrustumCorner.nearTopRight, exports.FrustumCorner.nearBottomRight], [exports.FrustumCorner.nearBottomRight, exports.FrustumCorner.nearBottomLeft], [exports.FrustumCorner.nearTopLeft, exports.FrustumCorner.nearTopRight]],
        [[exports.FrustumCorner.unknown, exports.FrustumCorner.unknown], [exports.FrustumCorner.unknown, exports.FrustumCorner.unknown], [exports.FrustumCorner.FarTopLeft, exports.FrustumCorner.FarBottomLeft], [exports.FrustumCorner.FarBottomRight, exports.FrustumCorner.FarTopRight], [exports.FrustumCorner.FarBottomLeft, exports.FrustumCorner.FarBottomRight], [exports.FrustumCorner.FarTopRight, exports.FrustumCorner.FarTopLeft]],
        [[exports.FrustumCorner.nearTopLeft, exports.FrustumCorner.nearBottomLeft], [exports.FrustumCorner.FarBottomLeft, exports.FrustumCorner.FarTopLeft], [exports.FrustumCorner.unknown, exports.FrustumCorner.unknown], [exports.FrustumCorner.unknown, exports.FrustumCorner.unknown], [exports.FrustumCorner.nearBottomLeft, exports.FrustumCorner.FarBottomLeft], [exports.FrustumCorner.FarTopLeft, exports.FrustumCorner.nearTopLeft]],
        [[exports.FrustumCorner.nearBottomRight, exports.FrustumCorner.nearTopRight], [exports.FrustumCorner.FarTopRight, exports.FrustumCorner.FarBottomRight], [exports.FrustumCorner.unknown, exports.FrustumCorner.unknown], [exports.FrustumCorner.unknown, exports.FrustumCorner.unknown], [exports.FrustumCorner.FarBottomRight, exports.FrustumCorner.nearBottomRight], [exports.FrustumCorner.nearTopRight, exports.FrustumCorner.FarTopRight]],
        [[exports.FrustumCorner.nearBottomLeft, exports.FrustumCorner.nearBottomRight], [exports.FrustumCorner.FarBottomRight, exports.FrustumCorner.FarBottomLeft], [exports.FrustumCorner.FarBottomLeft, exports.FrustumCorner.nearBottomLeft], [exports.FrustumCorner.nearBottomRight, exports.FrustumCorner.FarBottomRight], [exports.FrustumCorner.unknown, exports.FrustumCorner.unknown], [exports.FrustumCorner.unknown, exports.FrustumCorner.unknown]],
        [[exports.FrustumCorner.nearTopRight, exports.FrustumCorner.nearTopLeft], [exports.FrustumCorner.FarTopLeft, exports.FrustumCorner.FarTopRight], [exports.FrustumCorner.nearTopLeft, exports.FrustumCorner.FarTopLeft], [exports.FrustumCorner.FarTopRight, exports.FrustumCorner.nearTopRight], [exports.FrustumCorner.unknown, exports.FrustumCorner.unknown], [exports.FrustumCorner.unknown, exports.FrustumCorner.unknown]]
    ];
    ShadowUtils.atlasBorderSize = 4.0;

    class RenderContext3D {
        constructor() {
            this.configPipeLineMode = "Forward";
            this._contextOBJ = Laya.LayaGL.renderOBJCreate.createRenderContext3D();
        }
        static __init__() {
            RenderContext3D._instance = new RenderContext3D();
        }
        get destTarget() {
            return this._contextOBJ.destTarget;
        }
        set destTarget(value) {
            this._contextOBJ.destTarget = value;
        }
        get viewport() {
            return this._contextOBJ.viewPort;
        }
        set viewport(value) {
            value.cloneTo(this._contextOBJ.viewPort);
        }
        get scissor() {
            return this._contextOBJ.scissor;
        }
        set scissor(value) {
            value.cloneTo(this._contextOBJ.scissor);
        }
        get invertY() {
            return this._contextOBJ.invertY;
        }
        set invertY(value) {
            this._contextOBJ.invertY = value;
        }
        get pipelineMode() {
            return this._contextOBJ.pipelineMode;
        }
        set pipelineMode(value) {
            this._contextOBJ.pipelineMode = value;
        }
        get cameraShaderValue() {
            return this._contextOBJ.cameraShaderData;
        }
        set cameraShaderValue(value) {
            this._contextOBJ.cameraShaderData = value;
        }
        set scene(value) {
            if (value) {
                this._contextOBJ.sceneID = value._id;
                this._contextOBJ.sceneShaderData = value._shaderValues;
                this._scene = value;
            }
            else {
                this._contextOBJ.sceneID = -1;
                this._contextOBJ.sceneShaderData = null;
                this._scene = null;
            }
        }
        get scene() {
            return this._scene;
        }
        changeViewport(x, y, width, height) {
            Viewport._tempViewport.set(x, y, width, height);
            this.viewport = Viewport._tempViewport;
        }
        changeScissor(x, y, width, height) {
            Laya.Vector4.tempVec4.setValue(x, y, width, height);
            this.scissor = Laya.Vector4.tempVec4;
        }
        drawRenderElement(renderelemt) {
            renderelemt.material && renderelemt._convertSubShader(this.customShader, this.replaceTag);
            if (!renderelemt.renderSubShader)
                return;
            renderelemt._renderUpdatePre(this);
            this._contextOBJ.drawRenderElement(renderelemt._renderElementOBJ);
        }
    }

    class ScreenQuad extends GeometryElement {
        constructor() {
            super(Laya.MeshTopology.TriangleStrip, Laya.DrawType.DrawArray);
            this._bufferState = new Laya.BufferState();
            this._bufferStateInvertUV = new Laya.BufferState();
            this.setDrawArrayParams(0, 4);
            this._vertexBuffer = Laya.LayaGL.renderOBJCreate.createVertexBuffer3D(16 * 4, Laya.BufferUsage.Static, false);
            this._vertexBuffer.vertexDeclaration = ScreenQuad._vertexDeclaration;
            this._vertexBuffer.setData(ScreenQuad._vertices.buffer);
            this._bufferState.applyState([this._vertexBuffer], null);
            this._vertexBufferInvertUV = Laya.LayaGL.renderOBJCreate.createVertexBuffer3D(16 * 4, Laya.BufferUsage.Static, false);
            this._vertexBufferInvertUV.vertexDeclaration = ScreenQuad._vertexDeclaration;
            this._vertexBufferInvertUV.setData(ScreenQuad._verticesInvertUV.buffer);
            this._bufferStateInvertUV.applyState([this._vertexBufferInvertUV], null);
        }
        static __init__() {
            ScreenQuad._vertexDeclaration = new Laya.VertexDeclaration(16, [new Laya.VertexElement(0, Laya.VertexElementFormat.Vector4, ScreenQuad.SCREENQUAD_POSITION_UV)]);
            ScreenQuad.instance = new ScreenQuad();
        }
        set invertY(value) {
            this.bufferState = value ? this._bufferStateInvertUV : this._bufferState;
        }
        _updateRenderParams(state) {
        }
        destroy() {
            super.destroy();
            this._bufferState.destroy();
            this._vertexBuffer.destroy();
            this._bufferStateInvertUV.destroy();
            this._vertexBufferInvertUV.destroy();
        }
    }
    ScreenQuad.SCREENQUAD_POSITION_UV = 0;
    ScreenQuad._vertices = new Float32Array([1, 1, 1, 1, 1, -1, 1, 0, -1, 1, 0, 1, -1, -1, 0, 0]);
    ScreenQuad._verticesInvertUV = new Float32Array([1, 1, 1, 0, 1, -1, 1, 1, -1, 1, 0, 0, -1, -1, 0, 1]);

    class Command {
        constructor() {
            this._commandBuffer = null;
        }
        static __init__() {
            Command._screenShaderData = Laya.LayaGL.renderOBJCreate.createShaderData(null);
            Command._screenShader = Laya.Shader3D.find("BlitScreen");
            Command.SCREENTEXTURE_ID = Laya.Shader3D.propertyNameToID(Command.SCREENTEXTURE_NAME);
            Command.SCREENTEXTUREOFFSETSCALE_ID = Laya.Shader3D.propertyNameToID(Command.SCREENTEXTUREOFFSETSCALE_NAME);
            Command.MAINTEXTURE_TEXELSIZE_ID = Laya.Shader3D.propertyNameToID(Command.MAINTEXTURE_TEXELSIZE_NAME);
        }
        run() {
        }
        recover() {
            this._commandBuffer = null;
        }
        setContext(context) {
            this._context = context;
        }
        destroy() {
            this._commandBuffer = null;
            this._context = null;
        }
    }
    Command.SCREENTEXTURE_NAME = "u_MainTex";
    Command.SCREENTEXTUREOFFSETSCALE_NAME = "u_OffsetScale";
    Command.MAINTEXTURE_TEXELSIZE_NAME = "u_MainTex_TexelSize";

    class BlitScreenQuadCMD extends Command {
        constructor() {
            super();
            this._source = null;
            this._dest = null;
            this._offsetScale = null;
            this._shader = null;
            this._shaderData = null;
            this._subShader = 0;
            this._sourceTexelSize = new Laya.Vector4();
            this._transform3D = Laya.LayaGL.renderOBJCreate.createTransform(null);
            this._renderElement = new RenderElement();
            this._renderElement.setTransform(this._transform3D);
            this._renderElement.setGeometry(ScreenQuad.instance);
        }
        static create(source, dest, offsetScale = null, shader = null, shaderData = null, subShader = 0, screenType = BlitScreenQuadCMD._SCREENTYPE_QUAD, commandbuffer = null) {
            var cmd;
            cmd = BlitScreenQuadCMD._pool.length > 0 ? BlitScreenQuadCMD._pool.pop() : new BlitScreenQuadCMD();
            cmd._source = source;
            cmd._dest = dest;
            cmd._offsetScale = offsetScale;
            cmd.setshader(shader, subShader, shaderData);
            cmd._commandBuffer = commandbuffer;
            return cmd;
        }
        set shaderData(value) {
            this._shaderData = value || Command._screenShaderData;
            this._renderElement._renderElementOBJ._materialShaderData = this._shaderData;
        }
        setshader(shader, subShader, shaderData) {
            this._shader = shader || Command._screenShader;
            this._subShader = subShader || 0;
            this.shaderData = shaderData;
            this._renderElement.renderSubShader = this._shader.getSubShaderAt(this._subShader);
            this._renderElement._subShaderIndex = subShader;
        }
        run() {
            this._commandBuffer && (this.setContext(this._commandBuffer._context));
            var context = this._context;
            var source;
            if (!this._source) {
                if (!this._commandBuffer._camera._internalRenderTexture)
                    throw "camera internalRenderTexture is null,please set camera enableBuiltInRenderTexture";
                source = this._commandBuffer._camera._internalRenderTexture;
            }
            else
                source = this._source;
            var shaderData = this._shaderData;
            var dest = this._dest ? this._dest : this._commandBuffer._camera._internalRenderTexture;
            if (dest) {
                context.changeViewport(0, 0, dest.width, dest.height);
                context.changeScissor(0, 0, dest.width, dest.height);
            }
            else {
                let camera = this._commandBuffer._camera;
                let viewport = camera.viewport;
                let vpH = viewport.height;
                let vpY = RenderContext3D.clientHeight - viewport.y - vpH;
                context.changeViewport(viewport.x, vpY, viewport.width, vpH);
                context.changeScissor(viewport.x, vpY, viewport.width, vpH);
            }
            shaderData.setTexture(Command.SCREENTEXTURE_ID, source);
            shaderData.setVector(Command.SCREENTEXTUREOFFSETSCALE_ID, this._offsetScale || BlitScreenQuadCMD._defaultOffsetScale);
            this._sourceTexelSize.setValue(1.0 / source.width, 1.0 / source.height, source.width, source.height);
            shaderData.setVector(Command.MAINTEXTURE_TEXELSIZE_ID, this._sourceTexelSize);
            context.destTarget = dest;
            context._contextOBJ.applyContext(Camera._updateMark);
            ScreenQuad.instance.invertY = context.invertY;
            context.drawRenderElement(this._renderElement);
            Laya.Stat.blitDrawCall++;
        }
        recover() {
            BlitScreenQuadCMD._pool.push(this);
            this._source = null;
            this._dest = null;
            this._offsetScale = null;
            this._shader = null;
            this._shaderData = null;
            super.recover();
        }
        destroy() {
            this._source = null;
            this._dest = null;
            this._offsetScale = null;
            this._shader = null;
            this._shaderData = null;
            this._renderElement.destroy();
        }
    }
    BlitScreenQuadCMD._SCREENTYPE_QUAD = 0;
    BlitScreenQuadCMD._SCREENTYPE_TRIANGLE = 1;
    BlitScreenQuadCMD._pool = [];
    BlitScreenQuadCMD._defaultOffsetScale = new Laya.Vector4(0, 0, 1, 1);

    class SetRenderTargetCMD extends Command {
        constructor() {
            super(...arguments);
            this._renderTexture = null;
        }
        static create(renderTexture) {
            var cmd;
            cmd = SetRenderTargetCMD._pool.length > 0 ? SetRenderTargetCMD._pool.pop() : new SetRenderTargetCMD();
            cmd._renderTexture = renderTexture;
            return cmd;
        }
        run() {
            (Laya.RenderTexture.currentActive) && (Laya.RenderTexture.currentActive._end());
            RenderContext3D._instance.destTarget = this._renderTexture;
            RenderContext3D._instance.changeScissor(0, 0, this._renderTexture.width, this._renderTexture.height);
            RenderContext3D._instance.changeViewport(0, 0, this._renderTexture.width, this._renderTexture.height);
            RenderContext3D._instance._contextOBJ.applyContext(Camera._updateMark);
        }
        recover() {
            SetRenderTargetCMD._pool.push(this);
            this._renderTexture = null;
        }
    }
    SetRenderTargetCMD._pool = [];

    class SetShaderDataCMD extends Command {
        constructor() {
            super(...arguments);
            this._shaderData = null;
            this._nameID = 0;
            this._value = null;
            this._dataType = -1;
        }
        static create(shaderData, nameID, value, shaderDataType, commandBuffer) {
            var cmd;
            cmd = SetShaderDataCMD._pool.length > 0 ? SetShaderDataCMD._pool.pop() : new SetShaderDataCMD();
            cmd._shaderData = shaderData;
            cmd._nameID = nameID;
            cmd._value = value.clone ? value.clone() : value;
            cmd._dataType = shaderDataType;
            cmd._commandBuffer = commandBuffer;
            return cmd;
        }
        run() {
            switch (this._dataType) {
                case Laya.ShaderDataType.Int:
                    this._shaderData.setInt(this._nameID, this._value);
                    break;
                case Laya.ShaderDataType.Float:
                    this._shaderData.setNumber(this._nameID, this._value);
                    break;
                case Laya.ShaderDataType.Bool:
                    this._shaderData.setBool(this._nameID, this._value);
                    break;
                case Laya.ShaderDataType.Matrix4x4:
                    this._shaderData.setMatrix4x4(this._nameID, this._value);
                    break;
                case Laya.ShaderDataType.Color:
                    this._shaderData.setColor(this._nameID, this._value);
                    break;
                case Laya.ShaderDataType.Texture2D:
                    this._shaderData.setTexture(this._nameID, this._value);
                    break;
                case Laya.ShaderDataType.Vector4:
                    this._shaderData.setVector(this._nameID, this._value);
                    break;
                case Laya.ShaderDataType.Vector2:
                    this._shaderData.setVector2(this._nameID, this._value);
                    break;
                case Laya.ShaderDataType.Vector3:
                    this._shaderData.setVector3(this._nameID, this._value);
                    break;
                case Laya.ShaderDataType.Buffer:
                    this._shaderData.setBuffer(this._nameID, this._value);
                    break;
                default:
                    if (this._dataType == SetShaderDataCMD.ShaderDataType_define) {
                        let defineData = Laya.Shader3D.getDefineByName(this._nameID);
                        if (this._value)
                            this._shaderData.addDefine(defineData);
                        else
                            this._shaderData.removeDefine(defineData);
                        break;
                    }
                    else
                        throw "no type shaderValue on this CommendBuffer";
            }
        }
        recover() {
            SetShaderDataCMD._pool.push(this);
            this._shaderData = null;
            this._nameID = 0;
            this._value = null;
            this._dataType = -1;
        }
    }
    SetShaderDataCMD.ShaderDataType_define = -2;
    SetShaderDataCMD._pool = [];

    exports.MaterialRenderMode = void 0;
    (function (MaterialRenderMode) {
        MaterialRenderMode[MaterialRenderMode["RENDERMODE_OPAQUE"] = 0] = "RENDERMODE_OPAQUE";
        MaterialRenderMode[MaterialRenderMode["RENDERMODE_CUTOUT"] = 1] = "RENDERMODE_CUTOUT";
        MaterialRenderMode[MaterialRenderMode["RENDERMODE_TRANSPARENT"] = 2] = "RENDERMODE_TRANSPARENT";
        MaterialRenderMode[MaterialRenderMode["RENDERMODE_ADDTIVE"] = 3] = "RENDERMODE_ADDTIVE";
        MaterialRenderMode[MaterialRenderMode["RENDERMODE_ALPHABLENDED"] = 4] = "RENDERMODE_ALPHABLENDED";
        MaterialRenderMode[MaterialRenderMode["RENDERMODE_CUSTOME"] = 5] = "RENDERMODE_CUSTOME";
    })(exports.MaterialRenderMode || (exports.MaterialRenderMode = {}));
    class Material extends Laya.Resource {
        constructor() {
            super();
            this._shaderValues = Laya.LayaGL.renderOBJCreate.createShaderData(this);
            this.renderQueue = Material.RENDERQUEUE_OPAQUE;
            this.alphaTest = false;
            this.cull = Laya.RenderState.CULL_BACK;
            this.blend = Laya.RenderState.BLEND_DISABLE;
            this.blendSrc = Laya.RenderState.BLENDPARAM_ONE;
            this.blendDst = Laya.RenderState.BLENDPARAM_ZERO;
            this.blendSrcRGB = Laya.RenderState.BLENDPARAM_ONE;
            this.blendDstRGB = Laya.RenderState.BLENDPARAM_ZERO;
            this.blendSrcAlpha = Laya.RenderState.BLENDPARAM_ONE;
            this.blendDstAlpha = Laya.RenderState.BLENDPARAM_ZERO;
            this.blendEquation = Laya.RenderState.BLENDEQUATION_ADD;
            this.blendEquationRGB = Laya.RenderState.BLENDEQUATION_ADD;
            this.blendEquationAlpha = Laya.RenderState.BLENDEQUATION_ADD;
            this.depthTest = Laya.RenderState.DEPTHTEST_LEQUAL;
            this.depthWrite = true;
            this.stencilRef = 1;
            this.stencilTest = Laya.RenderState.STENCILTEST_OFF;
            this.stencilWrite = false;
            this.stencilOp = new Laya.Vector3(Laya.RenderState.STENCILOP_KEEP, Laya.RenderState.STENCILOP_KEEP, Laya.RenderState.STENCILOP_REPLACE);
            this.destoryedImmediately = false;
        }
        static load(url, complete) {
            Laya.ILaya.loader.load(url, complete, null, Laya.Loader.MATERIAL);
        }
        static __initDefine__() {
            Material.SHADERDEFINE_ALPHATEST = Laya.Shader3D.getDefineByName("ALPHATEST");
            Material.SHADERDEFINE_MAINTEXTURE = Laya.Shader3D.getDefineByName("MAINTEXTURE");
            Material.SHADERDEFINE_ADDTIVEFOG = Laya.Shader3D.getDefineByName("ADDTIVEFOG");
            Material.ALPHATESTVALUE = Laya.Shader3D.propertyNameToID("u_AlphaTestValue");
            Material.CULL = Laya.Shader3D.propertyNameToID("s_Cull");
            Material.BLEND = Laya.Shader3D.propertyNameToID("s_Blend");
            Material.BLEND_SRC = Laya.Shader3D.propertyNameToID("s_BlendSrc");
            Material.BLEND_DST = Laya.Shader3D.propertyNameToID("s_BlendDst");
            Material.BLEND_SRC_RGB = Laya.Shader3D.propertyNameToID("s_BlendSrcRGB");
            Material.BLEND_DST_RGB = Laya.Shader3D.propertyNameToID("s_BlendDstRGB");
            Material.BLEND_SRC_ALPHA = Laya.Shader3D.propertyNameToID("s_BlendSrcAlpha");
            Material.BLEND_DST_ALPHA = Laya.Shader3D.propertyNameToID("s_BlendDstAlpha");
            Material.BLEND_EQUATION = Laya.Shader3D.propertyNameToID("s_BlendEquation");
            Material.BLEND_EQUATION_RGB = Laya.Shader3D.propertyNameToID("s_BlendEquationRGB");
            Material.BLEND_EQUATION_ALPHA = Laya.Shader3D.propertyNameToID("s_BlendEquationAlpha");
            Material.DEPTH_TEST = Laya.Shader3D.propertyNameToID("s_DepthTest");
            Material.DEPTH_WRITE = Laya.Shader3D.propertyNameToID("s_DepthWrite");
            Material.STENCIL_Ref = Laya.Shader3D.propertyNameToID("s_StencilRef");
            Material.STENCIL_TEST = Laya.Shader3D.propertyNameToID("s_StencilTest");
            Material.STENCIL_WRITE = Laya.Shader3D.propertyNameToID("s_StencilWrite");
            Material.STENCIL_Op = Laya.Shader3D.propertyNameToID("s_StencilOp");
        }
        get shaderData() {
            return this._shaderValues;
        }
        get alphaTestValue() {
            return this._shaderValues.getNumber(Material.ALPHATESTVALUE);
        }
        set alphaTestValue(value) {
            this._shaderValues.setNumber(Material.ALPHATESTVALUE, value);
        }
        get alphaTest() {
            return this.shaderData.hasDefine(Material.SHADERDEFINE_ALPHATEST);
        }
        set alphaTest(value) {
            if (value)
                this._shaderValues.addDefine(Material.SHADERDEFINE_ALPHATEST);
            else
                this._shaderValues.removeDefine(Material.SHADERDEFINE_ALPHATEST);
        }
        addDefine(define) {
            this._shaderValues.addDefine(define);
        }
        removeDefine(define) {
            this._shaderValues.removeDefine(define);
        }
        hasDefine(define) {
            return this._shaderValues.hasDefine(define);
        }
        get depthWrite() {
            return this._shaderValues.getBool(Material.DEPTH_WRITE);
        }
        set depthWrite(value) {
            this._shaderValues.setBool(Material.DEPTH_WRITE, value);
        }
        get cull() {
            return this._shaderValues.getInt(Material.CULL);
        }
        set cull(value) {
            this._shaderValues.setInt(Material.CULL, value);
        }
        get blend() {
            return this._shaderValues.getInt(Material.BLEND);
        }
        set blend(value) {
            this._shaderValues.setInt(Material.BLEND, value);
        }
        get blendSrc() {
            return this._shaderValues.getInt(Material.BLEND_SRC);
        }
        set blendSrc(value) {
            this._shaderValues.setInt(Material.BLEND_SRC, value);
        }
        get blendDst() {
            return this._shaderValues.getInt(Material.BLEND_DST);
        }
        set blendDst(value) {
            this._shaderValues.setInt(Material.BLEND_DST, value);
        }
        get blendSrcAlpha() {
            return this._shaderValues.getInt(Material.BLEND_SRC_ALPHA);
        }
        set blendSrcAlpha(value) {
            this._shaderValues.setInt(Material.BLEND_SRC_ALPHA, value);
        }
        get blendSrcRGB() {
            return this._shaderValues.getInt(Material.BLEND_SRC_RGB);
        }
        set blendSrcRGB(value) {
            this._shaderValues.setInt(Material.BLEND_SRC_RGB, value);
        }
        get blendDstRGB() {
            return this._shaderValues.getInt(Material.BLEND_DST_RGB);
        }
        set blendDstRGB(value) {
            this._shaderValues.setInt(Material.BLEND_DST_RGB, value);
        }
        get blendDstAlpha() {
            return this._shaderValues.getInt(Material.BLEND_DST_ALPHA);
        }
        set blendDstAlpha(value) {
            this._shaderValues.setInt(Material.BLEND_DST_ALPHA, value);
        }
        get blendEquation() {
            return this._shaderValues.getInt(Material.BLEND_EQUATION);
        }
        set blendEquation(value) {
            this._shaderValues.setInt(Material.BLEND_EQUATION, value);
        }
        get blendEquationRGB() {
            return this._shaderValues.getInt(Material.BLEND_EQUATION_RGB);
        }
        set blendEquationRGB(value) {
            this._shaderValues.setInt(Material.BLEND_EQUATION_RGB, value);
        }
        get blendEquationAlpha() {
            return this._shaderValues.getInt(Material.BLEND_EQUATION_ALPHA);
        }
        set blendEquationAlpha(value) {
            this._shaderValues.setInt(Material.BLEND_EQUATION_ALPHA, value);
        }
        get depthTest() {
            return this._shaderValues.getInt(Material.DEPTH_TEST);
        }
        set depthTest(value) {
            this._shaderValues.setInt(Material.DEPTH_TEST, value);
        }
        get stencilTest() {
            return this._shaderValues.getInt(Material.STENCIL_TEST);
        }
        set stencilTest(value) {
            this._shaderValues.setInt(Material.STENCIL_TEST, value);
        }
        get stencilWrite() {
            return this._shaderValues.getBool(Material.STENCIL_WRITE);
        }
        set stencilWrite(value) {
            this._shaderValues.setBool(Material.STENCIL_WRITE, value);
        }
        set stencilRef(value) {
            this._shaderValues.setInt(Material.STENCIL_Ref, value);
        }
        get stencilRef() {
            return this._shaderValues.getInt(Material.STENCIL_Ref);
        }
        set stencilOp(value) {
            this._shaderValues.setVector3(Material.STENCIL_Op, value);
        }
        get stencilOp() {
            return this._shaderValues.getVector3(Material.STENCIL_Op);
        }
        get MaterialProperty() {
            let propertyMap = {};
            var shaderValues = this._shaderValues.getData();
            for (let key in shaderValues) {
                propertyMap[Laya.LayaGL.renderEngine.propertyIDToName(parseInt(key))] = shaderValues[key];
            }
            return propertyMap;
        }
        get MaterialDefine() {
            let shaderDefineArray = new Array();
            let defineData = this._shaderValues._defineDatas;
            Laya.Shader3D._getNamesByDefineData(defineData, shaderDefineArray);
            return shaderDefineArray;
        }
        set materialRenderMode(value) {
            this._matRenderNode = value;
            switch (value) {
                case exports.MaterialRenderMode.RENDERMODE_OPAQUE:
                    this.alphaTest = false;
                    this.renderQueue = Material.RENDERQUEUE_OPAQUE;
                    this.depthWrite = true;
                    this.blend = Laya.RenderState.BLEND_DISABLE;
                    this.depthTest = Laya.RenderState.DEPTHTEST_LESS;
                    break;
                case exports.MaterialRenderMode.RENDERMODE_CUTOUT:
                    this.renderQueue = Material.RENDERQUEUE_ALPHATEST;
                    this.alphaTest = true;
                    this.depthWrite = true;
                    this.blend = Laya.RenderState.BLEND_DISABLE;
                    this.depthTest = Laya.RenderState.DEPTHTEST_LESS;
                    break;
                case exports.MaterialRenderMode.RENDERMODE_TRANSPARENT:
                    this.renderQueue = Material.RENDERQUEUE_TRANSPARENT;
                    this.alphaTest = false;
                    this.depthWrite = false;
                    this.blend = Laya.RenderState.BLEND_ENABLE_ALL;
                    this.blendSrc = Laya.RenderState.BLENDPARAM_SRC_ALPHA;
                    this.blendDst = Laya.RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA;
                    this.depthTest = Laya.RenderState.DEPTHTEST_LESS;
                    break;
                case exports.MaterialRenderMode.RENDERMODE_ADDTIVE:
                    this.renderQueue = Material.RENDERQUEUE_TRANSPARENT;
                    this.alphaTest = false;
                    this.depthWrite = false;
                    this.blend = Laya.RenderState.BLEND_ENABLE_ALL;
                    this.blendSrc = Laya.RenderState.BLENDPARAM_SRC_ALPHA;
                    this.blendDst = Laya.RenderState.BLENDPARAM_ONE;
                    this.depthTest = Laya.RenderState.DEPTHTEST_LESS;
                    this._shaderValues.addDefine(Material.SHADERDEFINE_ADDTIVEFOG);
                    break;
                case exports.MaterialRenderMode.RENDERMODE_ALPHABLENDED:
                    this.renderQueue = Material.RENDERQUEUE_TRANSPARENT;
                    this.alphaTest = false;
                    this.depthWrite = false;
                    this.blend = Laya.RenderState.BLEND_ENABLE_ALL;
                    this.blendSrc = Laya.RenderState.BLENDPARAM_SRC_ALPHA;
                    this.blendDst = Laya.RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA;
                    this.depthTest = Laya.RenderState.DEPTHTEST_LESS;
                    this._shaderValues.removeDefine(Material.SHADERDEFINE_ADDTIVEFOG);
                    break;
                case exports.MaterialRenderMode.RENDERMODE_CUSTOME:
                    break;
                default:
                    throw new Error("UnlitMaterial : renderMode value error.");
            }
        }
        get materialRenderMode() {
            return this._matRenderNode;
        }
        _bindShaderInfo(shader) {
            let subShader = shader.getSubShaderAt(0);
            let shaderUBODatas = subShader._uniformBufferDataMap;
            if (!shaderUBODatas)
                return;
            for (let key of shaderUBODatas.keys()) {
                let uboData = shaderUBODatas.get(key).clone();
                let ubo = Laya.UniformBufferObject.create(key, Laya.BufferUsage.Dynamic, uboData.getbyteLength(), false);
                this._shaderValues.setUniformBuffer(Laya.Shader3D.propertyNameToID(key), ubo);
                this._shaderValues._addCheckUBO(key, ubo, uboData);
            }
        }
        _releaseUBOData() {
            if (!this._shaderValues.uniformBufferDatas) {
                return;
            }
            for (let value of this._shaderValues.uniformBufferDatas.values()) {
                value._updateDataInfo.destroy();
                value.destroy();
                value._updateDataInfo = null;
            }
            this._shaderValues.uniformBufferDatas.clear();
            this._shaderValues.uniformBuffersMap.clear();
        }
        _disposeResource() {
            this._releaseUBOData();
            this._shaderValues.destroy();
            this._shaderValues = null;
        }
        effectiveProperty() {
            return this._shader.getSubShaderAt(0)._uniformTypeMap;
        }
        setShaderName(name) {
            this._shader = Laya.Shader3D.find(name);
            if (!this._shader) {
                console.warn(`Material: unknown shader name '${name}'`);
                this._shader = Laya.Shader3D.find("BLINNPHONG");
            }
            if (Laya.Config3D._uniformBlock) {
                this._releaseUBOData();
                this._bindShaderInfo(this._shader);
            }
            let subShader = this._shader.getSubShaderAt(0);
            let defaultValue = subShader._uniformDefaultValue;
            let typeMap = subShader._uniformTypeMap;
            this.applyUniformDefaultValue(typeMap, defaultValue);
        }
        applyUniformDefaultValue(typeMap, defaultValue) {
            typeMap.forEach((type, key) => {
                if (defaultValue && defaultValue[key] != undefined) {
                    let value = defaultValue[key];
                    this.setShaderData(key, type, value);
                }
                else {
                    this.setShaderData(key, type, Laya.ShaderDataDefaultValue(type));
                }
            });
        }
        getBoolByIndex(uniformIndex) {
            return this.shaderData.getBool(uniformIndex);
        }
        setBoolByIndex(uniformIndex, value) {
            this.shaderData.setBool(uniformIndex, value);
        }
        getBool(name) {
            let uniformIndex = Laya.Shader3D.propertyNameToID(name);
            return this.getBoolByIndex(uniformIndex);
        }
        setBool(name, value) {
            let uniformIndex = Laya.Shader3D.propertyNameToID(name);
            this.setBoolByIndex(uniformIndex, value);
        }
        getFloatByIndex(uniformIndex) {
            return this.shaderData.getNumber(uniformIndex);
        }
        setFloatByIndex(uniformIndex, value) {
            this.shaderData.setNumber(uniformIndex, value);
        }
        getFloat(name) {
            let uniformIndex = Laya.Shader3D.propertyNameToID(name);
            return this.getFloatByIndex(uniformIndex);
        }
        setFloat(name, value) {
            let uniformIndex = Laya.Shader3D.propertyNameToID(name);
            this.setFloatByIndex(uniformIndex, value);
        }
        getIntByIndex(uniformIndex) {
            return this.shaderData.getInt(uniformIndex);
        }
        setIntByIndex(uniformIndex, value) {
            this.shaderData.setInt(uniformIndex, value);
        }
        getInt(name) {
            let uniformIndex = Laya.Shader3D.propertyNameToID(name);
            return this.getIntByIndex(uniformIndex);
        }
        setInt(name, value) {
            let uniformIndex = Laya.Shader3D.propertyNameToID(name);
            this.setIntByIndex(uniformIndex, value);
        }
        getVector2ByIndex(uniformIndex) {
            return this.shaderData.getVector2(uniformIndex);
        }
        setVector2ByIndex(uniformIndex, value) {
            this.shaderData.setVector2(uniformIndex, value);
        }
        getVector2(name) {
            let uniformIndex = Laya.Shader3D.propertyNameToID(name);
            return this.getVector2ByIndex(uniformIndex);
        }
        setVector2(name, value) {
            let uniformIndex = Laya.Shader3D.propertyNameToID(name);
            this.setVector2ByIndex(uniformIndex, value);
        }
        getVector3ByIndex(uniformIndex) {
            return this.shaderData.getVector3(uniformIndex);
        }
        setVector3ByIndex(uniformIndex, value) {
            this.shaderData.setVector3(uniformIndex, value);
        }
        getVector3(name) {
            let uniformIndex = Laya.Shader3D.propertyNameToID(name);
            return this.getVector3ByIndex(uniformIndex);
        }
        setVector3(name, value) {
            let uniformIndex = Laya.Shader3D.propertyNameToID(name);
            this.setVector3ByIndex(uniformIndex, value);
        }
        setVector4ByIndex(uniformIndex, value) {
            this.shaderData.setVector(uniformIndex, value);
        }
        getVector4ByIndex(uniformIndex) {
            return this.shaderData.getVector(uniformIndex);
        }
        setVector4(name, value) {
            let uniformIndex = Laya.Shader3D.propertyNameToID(name);
            this.setVector4ByIndex(uniformIndex, value);
        }
        getVector4(name) {
            let uniformIndex = Laya.Shader3D.propertyNameToID(name);
            return this.getVector4ByIndex(uniformIndex);
        }
        getColorByIndex(uniformIndex) {
            return this.shaderData.getColor(uniformIndex);
        }
        setColorByIndex(uniformIndex, value) {
            this.shaderData.setColor(uniformIndex, value);
        }
        getColor(name) {
            let uniformIndex = Laya.Shader3D.propertyNameToID(name);
            return this.shaderData.getColor(uniformIndex);
        }
        setColor(name, value) {
            let uniformIndex = Laya.Shader3D.propertyNameToID(name);
            this.setColorByIndex(uniformIndex, value);
        }
        getMatrix4x4ByIndex(uniformIndex) {
            return this.shaderData.getMatrix4x4(uniformIndex);
        }
        setMatrix4x4ByIndex(uniformIndex, value) {
            this.shaderData.setMatrix4x4(uniformIndex, value);
        }
        getMatrix4x4(name) {
            let uniformIndex = Laya.Shader3D.propertyNameToID(name);
            return this.getMatrix4x4ByIndex(uniformIndex);
        }
        setMatrix4x4(name, value) {
            let uniformIndex = Laya.Shader3D.propertyNameToID(name);
            this.setMatrix4x4ByIndex(uniformIndex, value);
        }
        setTextureByIndex(uniformIndex, texture) {
            this.shaderData.setTexture(uniformIndex, texture);
            if (texture && !texture._texture)
                texture.once(Laya.Event.READY, this, this.reSetTexture);
        }
        reSetTexture(texture) {
            let index = this.shaderData.getSourceIndex(texture);
            if (index != -1) {
                this.setTextureByIndex(index, texture);
            }
        }
        getTextureByIndex(uniformIndex) {
            return this.shaderData.getTexture(uniformIndex);
        }
        setTexture(name, texture) {
            let uniformIndex = Laya.Shader3D.propertyNameToID(name);
            this.setTextureByIndex(uniformIndex, texture);
        }
        getTexture(name) {
            let uniformIndex = Laya.Shader3D.propertyNameToID(name);
            return this.getTextureByIndex(uniformIndex);
        }
        getBufferByIndex(uniformIndex) {
            return this.shaderData.getBuffer(uniformIndex);
        }
        setBufferByIndex(uniformIndex, value) {
            this.shaderData.setBuffer(uniformIndex, value);
        }
        getBuffer(name) {
            let uniformIndex = Laya.Shader3D.propertyNameToID(name);
            return this.getBufferByIndex(uniformIndex);
        }
        setBuffer(name, value) {
            let uniformIndex = Laya.Shader3D.propertyNameToID(name);
            this.setBufferByIndex(uniformIndex, value);
        }
        setShaderDataByIndex(uniformIndex, type, value) {
            this.shaderData.setShaderData(uniformIndex, type, value);
        }
        setShaderData(name, type, value) {
            let uniformIndex = Laya.Shader3D.propertyNameToID(name);
            this.setShaderDataByIndex(uniformIndex, type, value);
        }
        getShaderData(name, type) {
            let uniformIndex = Laya.Shader3D.propertyNameToID(name);
            return this.getShaderDataByIndex(uniformIndex, type);
        }
        getShaderDataByIndex(uniformIndex, type) {
            return this._shaderValues.getShaderData(uniformIndex, type);
        }
        cloneTo(destObject) {
            var destBaseMaterial = destObject;
            destBaseMaterial.name = this.name;
            destBaseMaterial.renderQueue = this.renderQueue;
            destBaseMaterial.setShaderName(this._shader._name);
            this._shaderValues.cloneTo(destBaseMaterial._shaderValues);
        }
        clone() {
            var dest = new Material();
            this.cloneTo(dest);
            return dest;
        }
        setShaderPropertyValue(name, value) {
            let propertyID = Laya.Shader3D.propertyNameToID(name);
            this.shaderData.setValueData(propertyID, value);
        }
        getShaderPropertyValue(name) {
            return this.shaderData.getValueData(Laya.Shader3D.propertyNameToID(name));
        }
        get _defineDatas() {
            return this._shaderValues._defineDatas;
        }
        oldparseEndEvent() {
        }
    }
    Material.RENDERQUEUE_OPAQUE = 2000;
    Material.RENDERQUEUE_ALPHATEST = 2450;
    Material.RENDERQUEUE_TRANSPARENT = 3000;

    class BlinnPhongMaterial extends Material {
        constructor() {
            super();
            this.setShaderName("BLINNPHONG");
            this.renderMode = BlinnPhongMaterial.RENDERMODE_OPAQUE;
        }
        static __initDefine__() {
            BlinnPhongMaterial.SHADERDEFINE_DIFFUSEMAP = Laya.Shader3D.getDefineByName("DIFFUSEMAP");
            BlinnPhongMaterial.SHADERDEFINE_NORMALMAP = Laya.Shader3D.getDefineByName("NORMALMAP");
            BlinnPhongMaterial.SHADERDEFINE_SPECULARMAP = Laya.Shader3D.getDefineByName("SPECULARMAP");
            BlinnPhongMaterial.SHADERDEFINE_ENABLEVERTEXCOLOR = Laya.Shader3D.getDefineByName("ENABLEVERTEXCOLOR");
            BlinnPhongMaterial.SHADERDEFINE_ENABLETRANSMISSION = Laya.Shader3D.getDefineByName("ENABLETRANSMISSION");
            BlinnPhongMaterial.SHADERDEFINE_THICKNESSMAP = Laya.Shader3D.getDefineByName("THICKNESSMAP");
            BlinnPhongMaterial.ALBEDOTEXTURE = Laya.Shader3D.propertyNameToID("u_DiffuseTexture");
            BlinnPhongMaterial.NORMALTEXTURE = Laya.Shader3D.propertyNameToID("u_NormalTexture");
            BlinnPhongMaterial.SPECULARTEXTURE = Laya.Shader3D.propertyNameToID("u_SpecularTexture");
            BlinnPhongMaterial.ALBEDOCOLOR = Laya.Shader3D.propertyNameToID("u_DiffuseColor");
            BlinnPhongMaterial.MATERIALSPECULAR = Laya.Shader3D.propertyNameToID("u_MaterialSpecular");
            BlinnPhongMaterial.SHININESS = Laya.Shader3D.propertyNameToID("u_Shininess");
            BlinnPhongMaterial.TILINGOFFSET = Laya.Shader3D.propertyNameToID("u_TilingOffset");
            BlinnPhongMaterial.TRANSMISSIONRATE = Laya.Shader3D.propertyNameToID("u_TransmissionRate");
            BlinnPhongMaterial.IBACKDIFFUSE = Laya.Shader3D.propertyNameToID("u_BackDiffuse");
            BlinnPhongMaterial.IBACKSCALE = Laya.Shader3D.propertyNameToID("u_BackScale");
            BlinnPhongMaterial.THINKNESSTEXTURE = Laya.Shader3D.propertyNameToID("u_ThinknessTexture");
            BlinnPhongMaterial.TRANSMISSIONCOLOR = Laya.Shader3D.propertyNameToID("u_TransmissionColor");
            BlinnPhongMaterial.AlbedoIntensity = Laya.Shader3D.propertyNameToID("u_AlbedoIntensity");
        }
        set renderMode(value) {
            switch (value) {
                case BlinnPhongMaterial.RENDERMODE_OPAQUE:
                    this.alphaTest = false;
                    this.renderQueue = Material.RENDERQUEUE_OPAQUE;
                    this.depthWrite = true;
                    this.cull = Laya.RenderState.CULL_BACK;
                    this.blend = Laya.RenderState.BLEND_DISABLE;
                    this.depthTest = Laya.RenderState.DEPTHTEST_LESS;
                    break;
                case BlinnPhongMaterial.RENDERMODE_CUTOUT:
                    this.renderQueue = Material.RENDERQUEUE_ALPHATEST;
                    this.alphaTest = true;
                    this.depthWrite = true;
                    this.cull = Laya.RenderState.CULL_BACK;
                    this.blend = Laya.RenderState.BLEND_DISABLE;
                    this.depthTest = Laya.RenderState.DEPTHTEST_LESS;
                    break;
                case BlinnPhongMaterial.RENDERMODE_TRANSPARENT:
                    this.renderQueue = Material.RENDERQUEUE_TRANSPARENT;
                    this.alphaTest = false;
                    this.depthWrite = false;
                    this.cull = Laya.RenderState.CULL_BACK;
                    this.blend = Laya.RenderState.BLEND_ENABLE_ALL;
                    this.blendSrc = Laya.RenderState.BLENDPARAM_SRC_ALPHA;
                    this.blendDst = Laya.RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA;
                    this.depthTest = Laya.RenderState.DEPTHTEST_LESS;
                    break;
                default:
                    throw new Error("Material:renderMode value error.");
            }
        }
        get enableVertexColor() {
            return this.hasDefine(BlinnPhongMaterial.SHADERDEFINE_ENABLEVERTEXCOLOR);
        }
        set enableVertexColor(value) {
            if (value)
                this.addDefine(BlinnPhongMaterial.SHADERDEFINE_ENABLEVERTEXCOLOR);
            else
                this.removeDefine(BlinnPhongMaterial.SHADERDEFINE_ENABLEVERTEXCOLOR);
        }
        get tilingOffset() {
            return this.getVector4ByIndex(BlinnPhongMaterial.TILINGOFFSET);
        }
        set tilingOffset(value) {
            if (value) {
                this.setVector4ByIndex(BlinnPhongMaterial.TILINGOFFSET, value);
            }
            else {
                this.getVector4ByIndex(BlinnPhongMaterial.TILINGOFFSET).setValue(1.0, 1.0, 0.0, 0.0);
            }
        }
        get albedoColor() {
            return this.getColorByIndex(BlinnPhongMaterial.ALBEDOCOLOR);
        }
        set albedoColor(value) {
            this.setColorByIndex(BlinnPhongMaterial.ALBEDOCOLOR, value);
        }
        get albedoIntensity() {
            return this.getFloatByIndex(BlinnPhongMaterial.AlbedoIntensity);
        }
        set albedoIntensity(value) {
            this.setFloatByIndex(BlinnPhongMaterial.AlbedoIntensity, value);
        }
        get specularColor() {
            return this.getColorByIndex(BlinnPhongMaterial.MATERIALSPECULAR);
        }
        set specularColor(value) {
            this.setColorByIndex(BlinnPhongMaterial.MATERIALSPECULAR, value);
        }
        get shininess() {
            return this.getFloatByIndex(BlinnPhongMaterial.SHININESS);
        }
        set shininess(value) {
            value = Math.max(0.0, Math.min(1.0, value));
            this.setFloatByIndex(BlinnPhongMaterial.SHININESS, value);
        }
        get albedoTexture() {
            return this.getTextureByIndex(BlinnPhongMaterial.ALBEDOTEXTURE);
        }
        set albedoTexture(value) {
            if (value)
                this.addDefine(BlinnPhongMaterial.SHADERDEFINE_DIFFUSEMAP);
            else
                this.removeDefine(BlinnPhongMaterial.SHADERDEFINE_DIFFUSEMAP);
            this.setTextureByIndex(BlinnPhongMaterial.ALBEDOTEXTURE, value);
        }
        get normalTexture() {
            return this.getTextureByIndex(BlinnPhongMaterial.NORMALTEXTURE);
        }
        set normalTexture(value) {
            if (value) {
                this.addDefine(BlinnPhongMaterial.SHADERDEFINE_NORMALMAP);
                this.addDefine(Laya.Shader3D.getDefineByName("NEEDTBN"));
            }
            else {
                this.removeDefine(BlinnPhongMaterial.SHADERDEFINE_NORMALMAP);
                this.removeDefine(Laya.Shader3D.getDefineByName("NEEDTBN"));
            }
            this.setTextureByIndex(BlinnPhongMaterial.NORMALTEXTURE, value);
        }
        get specularTexture() {
            return this.getTextureByIndex(BlinnPhongMaterial.SPECULARTEXTURE);
        }
        set specularTexture(value) {
            if (value)
                this.addDefine(BlinnPhongMaterial.SHADERDEFINE_SPECULARMAP);
            else
                this.removeDefine(BlinnPhongMaterial.SHADERDEFINE_SPECULARMAP);
            this.setTextureByIndex(BlinnPhongMaterial.SPECULARTEXTURE, value);
        }
        get enableTransmission() {
            return this.hasDefine(BlinnPhongMaterial.SHADERDEFINE_ENABLETRANSMISSION);
        }
        set enableTransmission(value) {
            if (value)
                this.addDefine(BlinnPhongMaterial.SHADERDEFINE_ENABLETRANSMISSION);
            else
                this.removeDefine(BlinnPhongMaterial.SHADERDEFINE_ENABLETRANSMISSION);
        }
        get transmissionRata() {
            return this.getFloatByIndex(BlinnPhongMaterial.TRANSMISSIONRATE);
        }
        set transmissionRata(value) {
            this.setFloatByIndex(BlinnPhongMaterial.TRANSMISSIONRATE, value);
        }
        get backDiffuse() {
            return this.getFloatByIndex(BlinnPhongMaterial.IBACKDIFFUSE);
        }
        set backDiffuse(value) {
            this.setFloatByIndex(BlinnPhongMaterial.IBACKDIFFUSE, Math.max(value, 1.0));
        }
        get backScale() {
            return this.getFloatByIndex(BlinnPhongMaterial.IBACKSCALE);
        }
        set backScale(value) {
            this.setFloatByIndex(BlinnPhongMaterial.IBACKSCALE, value);
        }
        get thinknessTexture() {
            return this.getTextureByIndex(BlinnPhongMaterial.THINKNESSTEXTURE);
        }
        set thinknessTexture(value) {
            if (value)
                this.addDefine(BlinnPhongMaterial.SHADERDEFINE_THICKNESSMAP);
            else
                this.removeDefine(BlinnPhongMaterial.SHADERDEFINE_THICKNESSMAP);
            this.setTextureByIndex(BlinnPhongMaterial.THINKNESSTEXTURE, value);
        }
        get transmissionColor() {
            return this.getColorByIndex(BlinnPhongMaterial.TRANSMISSIONCOLOR);
        }
        set transmissionColor(value) {
            this.setColorByIndex(BlinnPhongMaterial.TRANSMISSIONCOLOR, value);
        }
        get transmissionRate() {
            return this.getFloatByIndex(BlinnPhongMaterial.TRANSMISSIONRATE);
        }
        clone() {
            var dest = new BlinnPhongMaterial();
            this.cloneTo(dest);
            return dest;
        }
        cloneTo(destObject) {
            super.cloneTo(destObject);
            var destMaterial = destObject;
            destMaterial.albedoIntensity = this.albedoIntensity;
            destMaterial.enableVertexColor = this.enableVertexColor;
            this.albedoColor.cloneTo(destMaterial.albedoColor);
        }
    }
    BlinnPhongMaterial.RENDERMODE_OPAQUE = 0;
    BlinnPhongMaterial.RENDERMODE_CUTOUT = 1;
    BlinnPhongMaterial.RENDERMODE_TRANSPARENT = 2;

    class SubMeshRenderElement extends RenderElement {
        constructor() {
            super();
            this._dynamicWorldPositionNormalNeedUpdate = true;
            this._canBatch = true;
        }
        _onWorldMatrixChanged() {
            this._dynamicWorldPositionNormalNeedUpdate = true;
        }
        setTransform(transform) {
            if (this.transform !== transform) {
                (this.transform) && (this.transform.off(Laya.Event.TRANSFORM_CHANGED, this, this._onWorldMatrixChanged));
                (transform) && (transform.on(Laya.Event.TRANSFORM_CHANGED, this, this._onWorldMatrixChanged));
                this._dynamicWorldPositionNormalNeedUpdate = true;
                this.transform = transform;
            }
        }
        setGeometry(geometry) {
            if (this._geometry !== geometry) {
                this._geometry = geometry;
                this._renderElementOBJ._geometry = geometry._geometryElementOBj;
            }
        }
        destroy() {
            if (!this._renderElementOBJ)
                return;
            (this.transform) && this.transform.off(Laya.Event.TRANSFORM_CHANGED, this, this._onWorldMatrixChanged);
            super.destroy();
            this.staticBatch = null;
            this.instanceSubMesh = null;
            this.staticBatchElementList && this.staticBatchElementList.destroy();
            this.instanceBatchElementList && this.instanceBatchElementList.destroy();
            this.vertexBatchElementList && this.vertexBatchElementList.destroy();
            this.vertexBatchVertexDeclaration = null;
        }
    }

    class MeshFilter extends Laya.Component {
        constructor() {
            super();
            this.runInEditor = true;
        }
        _onEnable() {
            const render = this.owner.getComponent(MeshRenderer);
            render && render._enabled && render._onMeshChange(this._sharedMesh);
        }
        _onDisable() {
            this.owner.getComponent(MeshRenderer);
        }
        get sharedMesh() {
            return this._sharedMesh;
        }
        set sharedMesh(value) {
            if (this._sharedMesh !== value) {
                var lastValue = this._sharedMesh;
                if (lastValue) {
                    lastValue._removeReference();
                }
                if (value) {
                    value._addReference();
                }
                this._sharedMesh = value;
                const render = this.owner.getComponent(MeshRenderer);
                if (!render) {
                    return;
                }
                render._onMeshChange(value);
                this._sharedMesh = value;
            }
        }
        _onDestroy() {
            (this._sharedMesh) && (this._sharedMesh._removeReference(), this._sharedMesh = null);
        }
        _cloneTo(dest) {
            let meshfilter = dest;
            meshfilter.sharedMesh = this.sharedMesh;
            super._cloneTo(dest);
        }
    }
    MeshFilter._meshVerticeDefine = [];

    class MeshRenderer extends BaseRender {
        constructor() {
            super();
            this._revertStaticBatchDefineUV1 = false;
            this._projectionViewWorldMatrix = new Laya.Matrix4x4();
        }
        static __init__() {
            MeshSprite3DShaderDeclaration.SHADERDEFINE_UV0 = Laya.Shader3D.getDefineByName("UV");
            MeshSprite3DShaderDeclaration.SHADERDEFINE_COLOR = Laya.Shader3D.getDefineByName("COLOR");
            MeshSprite3DShaderDeclaration.SHADERDEFINE_UV1 = Laya.Shader3D.getDefineByName("UV1");
            MeshSprite3DShaderDeclaration.SHADERDEFINE_TANGENT = Laya.Shader3D.getDefineByName("TANGENT");
            MeshSprite3DShaderDeclaration.SHADERDEFINE_GPU_INSTANCE = Laya.Shader3D.getDefineByName("GPU_INSTANCE");
        }
        _createRenderElement() {
            return new SubMeshRenderElement();
        }
        _onEnable() {
            super._onEnable();
            const filter = this.owner.getComponent(MeshFilter);
            if (filter)
                filter._enabled && this._onMeshChange(filter.sharedMesh);
        }
        _getMeshDefine(mesh, out) {
            out.length = 0;
            var define;
            for (var i = 0, n = mesh._subMeshes.length; i < n; i++) {
                var subMesh = mesh.getSubMesh(i);
                var vertexElements = subMesh._vertexBuffer._vertexDeclaration._vertexElements;
                for (var j = 0, m = vertexElements.length; j < m; j++) {
                    var vertexElement = vertexElements[j];
                    var name = vertexElement._elementUsage;
                    switch (name) {
                        case Laya.VertexMesh.MESH_COLOR0:
                            out.push(MeshSprite3DShaderDeclaration.SHADERDEFINE_COLOR);
                            break;
                        case Laya.VertexMesh.MESH_TEXTURECOORDINATE0:
                            out.push(MeshSprite3DShaderDeclaration.SHADERDEFINE_UV0);
                            break;
                        case Laya.VertexMesh.MESH_TEXTURECOORDINATE1:
                            out.push(MeshSprite3DShaderDeclaration.SHADERDEFINE_UV1);
                            break;
                        case Laya.VertexMesh.MESH_TANGENT0:
                            out.push(MeshSprite3DShaderDeclaration.SHADERDEFINE_TANGENT);
                            break;
                    }
                }
            }
            return define;
        }
        _changeVertexDefine(mesh) {
            var defineDatas = this._shaderValues;
            var lastValue = this._mesh;
            if (lastValue) {
                this._getMeshDefine(lastValue, MeshFilter._meshVerticeDefine);
                for (var i = 0, n = MeshFilter._meshVerticeDefine.length; i < n; i++)
                    defineDatas.removeDefine(MeshFilter._meshVerticeDefine[i]);
            }
            if (mesh) {
                this._getMeshDefine(mesh, MeshFilter._meshVerticeDefine);
                for (var i = 0, n = MeshFilter._meshVerticeDefine.length; i < n; i++)
                    defineDatas.addDefine(MeshFilter._meshVerticeDefine[i]);
            }
        }
        _onMeshChange(mesh) {
            if (mesh && this._mesh != mesh) {
                this._changeVertexDefine(mesh);
                this._mesh = mesh;
                this.geometryBounds = mesh.bounds;
                var count = mesh.subMeshCount;
                this._renderElements.length = count;
                for (var i = 0; i < count; i++) {
                    var renderElement = this._renderElements[i];
                    if (!renderElement) {
                        var material = this.sharedMaterials[i];
                        renderElement = this._renderElements[i] = this._renderElements[i] ? this._renderElements[i] : this._createRenderElement();
                        this.owner && renderElement.setTransform(this.owner._transform);
                        renderElement.render = this;
                        renderElement.material = material ? material : BlinnPhongMaterial.defaultMaterial;
                    }
                    renderElement.setGeometry(mesh.getSubMesh(i));
                }
            }
            else if (!mesh) {
                this._renderElements.forEach;
                this._renderElements.forEach(element => {
                    element.destroy();
                });
                this._renderElements.length = 0;
                this._mesh = null;
                this._changeVertexDefine(null);
            }
            this.boundsChange = true;
        }
        updateMulPassRender() {
            const filter = this.owner.getComponent(MeshFilter);
            if (!filter)
                return;
            const mesh = filter.sharedMesh;
            if (mesh) {
                var subCount = mesh.subMeshCount;
                var matCount = this._sharedMaterials.length;
                if (subCount > matCount) {
                    let count = subCount;
                    this._renderElements.length = count;
                    for (var i = 0; i < count; i++) {
                        var renderElement = this._renderElements[i];
                        if (!renderElement) {
                            var material = this.sharedMaterials[i];
                            renderElement = this._renderElements[i] = this._renderElements[i] ? this._renderElements[i] : this._createRenderElement();
                            renderElement.setTransform(this.owner._transform);
                            renderElement.render = this;
                            renderElement.material = material ? material : BlinnPhongMaterial.defaultMaterial;
                        }
                        renderElement.setGeometry(mesh.getSubMesh(i));
                    }
                }
                else {
                    let count = matCount;
                    this._renderElements.length = count;
                    for (var i = 0; i < count; i++) {
                        var renderElement = this._renderElements[i];
                        if (!renderElement) {
                            var material = this.sharedMaterials[i];
                            renderElement = this._renderElements[i] = this._renderElements[i] ? this._renderElements[i] : this._createRenderElement();
                            renderElement.setTransform(this.owner._transform);
                            renderElement.render = this;
                            renderElement.material = material ? material : BlinnPhongMaterial.defaultMaterial;
                        }
                    }
                    renderElement.setGeometry(mesh.getSubMesh(count % subCount));
                }
            }
            else {
                this._renderElements.length = 0;
            }
            this.boundsChange = true;
        }
        _calculateBoundingBox() {
            var sharedMesh = this._mesh;
            if (sharedMesh) {
                var worldMat = this._transform.worldMatrix;
                sharedMesh.bounds._tranform(worldMat, this._bounds);
            }
        }
        _renderUpdate(context, transform) {
            this._applyLightMapParams();
            this._applyReflection();
            context.renderElement;
            this._setShaderValue(Sprite3D.WORLDMATRIX, Laya.ShaderDataType.Matrix4x4, transform ? transform.worldMatrix : this._transform.worldMatrix);
            return;
        }
        _revertBatchRenderUpdate(context) {
            var element = context.renderElement;
            switch (element.renderType) {
                case RenderElement.RENDERTYPE_STATICBATCH:
                    if (this._revertStaticBatchDefineUV1)
                        this._shaderValues.removeDefine(MeshSprite3DShaderDeclaration.SHADERDEFINE_UV1);
                    this._shaderValues.setVector(RenderableSprite3D.LIGHTMAPSCALEOFFSET, this.lightmapScaleOffset);
                    break;
                case RenderElement.RENDERTYPE_INSTANCEBATCH:
                    this._shaderValues.removeDefine(MeshSprite3DShaderDeclaration.SHADERDEFINE_GPU_INSTANCE);
                    break;
            }
        }
        _onDestroy() {
            super._onDestroy();
        }
        _cloneTo(dest) {
            super._cloneTo(dest);
        }
    }

    class DrawMeshCMD extends Command {
        constructor() {
            super();
            this._transform = Laya.LayaGL.renderOBJCreate.createTransform(null);
            this._meshRender = new MeshRenderer();
        }
        static create(mesh, matrix, material, subMeshIndex, subShaderIndex, commandBuffer) {
            var cmd;
            cmd = DrawMeshCMD._pool.length > 0 ? DrawMeshCMD._pool.pop() : new DrawMeshCMD();
            cmd._matrix = matrix;
            cmd._transform.worldMatrix = cmd._matrix;
            cmd.material = material;
            cmd._subMeshIndex = subMeshIndex;
            cmd._subShaderIndex = subShaderIndex;
            cmd.mesh = mesh;
            cmd._commandBuffer = commandBuffer;
            return cmd;
        }
        set material(value) {
            this._material && this._material._removeReference(1);
            this._material = value;
            this._material && this._material._addReference(1);
        }
        set mesh(value) {
            if (this._mesh == value)
                return;
            this._mesh = value;
            this._meshRender._onMeshChange(this._mesh);
            this._renderElemnts = this._meshRender._renderElements;
            this._renderElemnts.forEach(element => {
                element.material = this._material;
                element.setTransform(this._transform);
                element.renderSubShader = this._material._shader.getSubShaderAt(this._subShaderIndex);
                element._subShaderIndex = this._subShaderIndex;
            });
        }
        run() {
            var context = RenderContext3D._instance;
            context._contextOBJ.applyContext(Camera._updateMark);
            let submeshs = this._mesh._subMeshes;
            if (this._subMeshIndex == -1) {
                for (let i = 0, n = submeshs.length; i < n; i++) {
                    let element = this._renderElemnts[i];
                    context.drawRenderElement(element);
                }
            }
            else {
                let element = this._renderElemnts[this._subMeshIndex];
                context.drawRenderElement(element);
            }
        }
        recover() {
            DrawMeshCMD._pool.push(this);
            super.recover();
            this.material && (this.material = null);
            this.mesh && (this.mesh = null);
        }
        destroy() {
            super.destroy();
            this._renderElemnts.forEach(element => {
                element.destroy();
            });
            this._material && this._material._removeReference(1);
            this._material = null;
            this._renderElemnts = null;
            this._transform = null;
            this._material = null;
            this._matrix = null;
        }
    }
    DrawMeshCMD._pool = [];

    class ClearRenderTextureCMD extends Command {
        constructor() {
            super(...arguments);
            this._clearColor = false;
            this._clearDepth = false;
            this._backgroundColor = new Laya.Color();
            this._linearbackgroundColor = new Laya.Color();
            this._depth = 1;
        }
        static create(clearColor, clearDepth, backgroundColor, depth = 1, commandBuffer) {
            var cmd;
            cmd = ClearRenderTextureCMD._pool.length > 0 ? ClearRenderTextureCMD._pool.pop() : new ClearRenderTextureCMD();
            cmd._clearColor = clearColor;
            cmd._clearDepth = clearDepth;
            backgroundColor.cloneTo(cmd._backgroundColor);
            backgroundColor.toLinear(cmd._linearbackgroundColor);
            cmd._depth = depth;
            cmd._commandBuffer = commandBuffer;
            return cmd;
        }
        run() {
            let linearBgColor = this._linearbackgroundColor;
            if (this._clearDepth && this._clearColor) {
                Laya.LayaGL.renderEngine.clearRenderTexture(Laya.RenderClearFlag.Color | Laya.RenderClearFlag.Depth, linearBgColor, this._depth);
            }
            else if (this._clearDepth) {
                Laya.LayaGL.renderEngine.clearRenderTexture(Laya.RenderClearFlag.Depth, linearBgColor, this._depth);
            }
            else if (this._clearColor) {
                Laya.LayaGL.renderEngine.clearRenderTexture(Laya.RenderClearFlag.Color, linearBgColor, this._depth);
            }
        }
        recover() {
        }
    }
    ClearRenderTextureCMD._pool = [];

    class DrawRenderCMD extends Command {
        constructor() {
            super();
        }
        static create(render, material, subShaderIndex, commandBuffer) {
            var cmd;
            cmd = DrawRenderCMD._pool.length > 0 ? DrawRenderCMD._pool.pop() : new DrawRenderCMD();
            cmd._render = render;
            cmd.material = material;
            cmd._subShaderIndex = subShaderIndex;
            cmd._commandBuffer = commandBuffer;
            return cmd;
        }
        _elementRender(renderElement, context) {
            renderElement.renderSubShader = this._material._shader.getSubShaderAt(this._subShaderIndex);
            renderElement.material = this._material;
            context.drawRenderElement(renderElement);
        }
        set material(value) {
            this._material && this._material._removeReference(1);
            this._material = value;
            this._material && this._material._addReference(1);
        }
        run() {
            if (!this._material)
                throw "This render command material cannot be empty";
            this.setContext(this._commandBuffer._context);
            var context = this._context;
            context._contextOBJ.applyContext(Camera._updateMark);
            var renderElements = this._render._renderElements;
            for (var i = 0, n = renderElements.length; i < n; i++) {
                var renderelement = renderElements[i];
                let mat = renderelement.material;
                this._elementRender(renderelement, context);
                renderelement.material = mat;
            }
        }
        recover() {
            DrawRenderCMD._pool.push(this);
            super.recover();
            this._material && this._material._removeReference(1);
            this._material = null;
        }
        destroy() {
            super.destroy();
            this._material && this._material._removeReference(1);
            this._material = null;
        }
    }
    DrawRenderCMD._pool = [];

    class SetGlobalShaderDataCMD extends Command {
        constructor() {
            super(...arguments);
            this._nameID = 0;
            this._value = null;
            this._dataType = -1;
        }
        static create(nameID, value, shaderDataType, commandBuffer) {
            var cmd;
            cmd = SetGlobalShaderDataCMD._pool.length > 0 ? SetGlobalShaderDataCMD._pool.pop() : new SetGlobalShaderDataCMD();
            cmd._nameID = nameID;
            cmd._value = value;
            cmd._dataType = shaderDataType;
            cmd._commandBuffer = commandBuffer;
            return cmd;
        }
        run() {
            let context = RenderContext3D._instance;
            let shaderData = context._contextOBJ.globalShaderData;
            if (!shaderData)
                shaderData = context._contextOBJ.globalShaderData = Laya.LayaGL.renderOBJCreate.createShaderData(null);
            switch (this._dataType) {
                case Laya.ShaderDataType.Int:
                    shaderData.setInt(this._nameID, this._value);
                    break;
                case Laya.ShaderDataType.Float:
                    shaderData.setNumber(this._nameID, this._value);
                    break;
                case Laya.ShaderDataType.Bool:
                    shaderData.setBool(this._nameID, this._value);
                    break;
                case Laya.ShaderDataType.Matrix4x4:
                    shaderData.setMatrix4x4(this._nameID, this._value);
                    break;
                case Laya.ShaderDataType.Texture2D:
                    shaderData.setTexture(this._nameID, this._value);
                    break;
                case Laya.ShaderDataType.Vector4:
                    shaderData.setVector(this._nameID, this._value);
                    break;
                case Laya.ShaderDataType.Vector2:
                    shaderData.setVector2(this._nameID, this._value);
                    break;
                case Laya.ShaderDataType.Vector3:
                    shaderData.setVector3(this._nameID, this._value);
                    break;
                case Laya.ShaderDataType.Buffer:
                    shaderData.setBuffer(this._nameID, this._value);
                    break;
                case Laya.ShaderDataType.Color:
                    shaderData.setColor(this._nameID, this._value);
                    break;
                default:
                    throw "no type shaderValue on this CommendBuffer";
            }
        }
        recover() {
            SetGlobalShaderDataCMD._pool.push(this);
            this._nameID = 0;
            this._value = null;
            this._dataType = -1;
        }
    }
    SetGlobalShaderDataCMD._pool = [];

    class MeshInstanceGeometry extends GeometryElement {
        constructor(subMesh) {
            super(subMesh ? subMesh._geometryElementOBj.mode : Laya.MeshTopology.Triangles, Laya.DrawType.DrawElementInstance);
            this._subMesh = subMesh;
            if (subMesh)
                this.indexFormat = subMesh._mesh.indexFormat;
        }
        set subMesh(value) {
            this._subMesh = value;
            if (value)
                this.indexFormat = value._mesh.indexFormat;
            this.mode = value._geometryElementOBj.mode;
        }
        get subMesh() {
            return this._subMesh;
        }
        _updateRenderParams(state) {
            this.clearRenderParams();
            this.setDrawElemenParams(this._subMesh.indexCount, this._subMesh._indexStart * 2);
        }
    }

    class DrawMeshInstancedCMD extends Command {
        constructor() {
            super();
            this._subShaderIndex = 0;
            this._transform = Laya.LayaGL.renderOBJCreate.createTransform(null);
            this._instanceRenderElementArray = [];
            this._instanceGeometryArray = [];
            this._instanceWorldMatrixData = new Float32Array(DrawMeshInstancedCMD.maxInstanceCount * 16);
            this._instanceWorldMatrixBuffer = Laya.LayaGL.renderOBJCreate.createVertexBuffer3D(this._instanceWorldMatrixData.length * 4, Laya.BufferUsage.Dynamic, false);
            this._instanceWorldMatrixBuffer.vertexDeclaration = Laya.VertexMesh.instanceWorldMatrixDeclaration;
            this._instanceWorldMatrixBuffer.instanceBuffer = true;
            this._render = new BaseRender();
            this._render._shaderValues.addDefine(MeshSprite3DShaderDeclaration.SHADERDEFINE_GPU_INSTANCE);
        }
        static create(mesh, subMeshIndex, matrixs, material, subShaderIndex, instanceProperty, drawnums, commandBuffer) {
            var cmd;
            if ((matrixs && matrixs.length > DrawMeshInstancedCMD.maxInstanceCount) || drawnums > DrawMeshInstancedCMD.maxInstanceCount) {
                throw "the number of renderings exceeds the maximum number of merges";
            }
            cmd = DrawMeshInstancedCMD._pool.length > 0 ? DrawMeshInstancedCMD._pool.pop() : new DrawMeshInstancedCMD();
            cmd._matrixs = matrixs;
            cmd.material = material;
            cmd._subMeshIndex = subMeshIndex;
            cmd._subShaderIndex = subShaderIndex;
            cmd._commandBuffer = commandBuffer;
            cmd._instanceProperty = instanceProperty;
            cmd._drawnums = drawnums;
            cmd.mesh = mesh;
            matrixs && cmd._updateWorldMatrixBuffer();
            cmd._setInstanceBuffer();
            cmd.setContext(RenderContext3D._instance);
            return cmd;
        }
        set material(value) {
            this._material && this._material._removeReference(1);
            this._material = value;
            this._material && this._material._addReference(1);
        }
        get bufferState() {
            return this._instanceWorldMatrixBuffer;
        }
        set mesh(value) {
            if (this._mesh == value)
                return;
            BaseRender.changeVertexDefine(this._mesh, value, this._render._shaderValues);
            this._mesh = value;
            if (!this._mesh)
                return;
            let submeshs = this._mesh._subMeshes;
            if (this._subMeshIndex == -1) {
                for (let i = 0, n = submeshs.length; i < n; i++) {
                    let element = this._instanceRenderElementArray[i] = this._instanceRenderElementArray[i] ? this._instanceRenderElementArray[i] : new RenderElement();
                    let geometry = this._instanceGeometryArray[i] = this._instanceGeometryArray[i] ? this._instanceGeometryArray[i] : new MeshInstanceGeometry(submeshs[i]);
                    element.setGeometry(geometry);
                    element.transform = this._transform;
                    element.material = this._material;
                    element.renderSubShader = this._material._shader.getSubShaderAt(this._subShaderIndex);
                    element._subShaderIndex = this._subShaderIndex;
                    element.render = this._render;
                    geometry.bufferState = this._instanceBufferState;
                    geometry.instanceCount = this._drawnums;
                }
            }
            else {
                let element = this._instanceRenderElementArray[0] = this._instanceRenderElementArray[0] ? this._instanceRenderElementArray[0] : new RenderElement();
                let geometry = this._instanceGeometryArray[0] = this._instanceGeometryArray[0] ? this._instanceGeometryArray[0] : new MeshInstanceGeometry(submeshs[this._subMeshIndex]);
                element.setGeometry(geometry);
                element.transform = this._transform;
                element.material = this._material;
                element.render = this._render;
                element.renderSubShader = this._material._shader.getSubShaderAt(this._subShaderIndex);
                geometry.bufferState = this._instanceBufferState;
                geometry.instanceCount = this._drawnums;
            }
        }
        get mesh() {
            return this._mesh;
        }
        _setInstanceBuffer() {
            if (!this._instanceBufferState) {
                this._instanceBufferState = new Laya.BufferState();
            }
            let instanceBufferState = this._instanceBufferState;
            let vertexArray = [];
            let meshVertexBuffer = this._mesh._bufferState._vertexBuffers;
            meshVertexBuffer.forEach(element => {
                vertexArray.push(element);
            });
            vertexArray.push(this._instanceWorldMatrixBuffer);
            let propertyMap = this._instanceProperty._propertyMap;
            for (let i in propertyMap) {
                vertexArray.push(propertyMap[i]._vertexBuffer);
            }
            instanceBufferState.applyState(vertexArray, this._mesh._indexBuffer);
            this._instanceGeometryArray.forEach(element => {
                element.bufferState = instanceBufferState;
            });
        }
        _updateWorldMatrixBuffer() {
            let worldMatrixData = this._instanceWorldMatrixData;
            let count = this._drawnums;
            for (let i = 0; i < count; i++) {
                worldMatrixData.set(this._matrixs[i].elements, i * 16);
            }
            let worldBuffer = this._instanceWorldMatrixBuffer;
            worldBuffer.orphanStorage();
            worldBuffer.setData(worldMatrixData.buffer, 0, 0, count * 64);
        }
        setWorldMatrix(worldMatrixArray) {
            if (worldMatrixArray.length < this._drawnums)
                throw "worldMatrixArray length is less then drawnums";
            this._matrixs = worldMatrixArray;
            this._matrixs && this._updateWorldMatrixBuffer();
        }
        setDrawNums(drawNums) {
            if (this._matrixs && this._matrixs.length < drawNums)
                throw "worldMatrixArray length is less then drawnums";
            this._drawnums = drawNums;
            let submeshs = this._mesh._subMeshes;
            if (this._subMeshIndex == -1) {
                for (let i = 0, n = submeshs.length; i < n; i++) {
                    let geometry = this._instanceGeometryArray[i] ? this._instanceGeometryArray[i] : new MeshInstanceGeometry(submeshs[i]);
                    geometry.instanceCount = this._drawnums;
                }
            }
            else {
                let geometry = this._instanceGeometryArray[0] ? this._instanceGeometryArray[0] : new MeshInstanceGeometry(submeshs[0]);
                geometry.instanceCount = this._drawnums;
            }
            this._matrixs && this._updateWorldMatrixBuffer();
        }
        run() {
            let context = RenderContext3D._instance;
            context._contextOBJ.applyContext(Camera._updateMark);
            let propertyMap = this._instanceProperty._propertyMap;
            for (let i in propertyMap) {
                propertyMap[i].updateVertexBufferData(this._drawnums);
            }
            let submeshs = this.mesh._subMeshes;
            if (this._subMeshIndex == -1) {
                for (let i = 0, n = submeshs.length; i < n; i++) {
                    let element = this._instanceRenderElementArray[i];
                    context.drawRenderElement(element);
                }
            }
            else {
                let element = this._instanceRenderElementArray[0];
                context.drawRenderElement(element);
            }
        }
        recover() {
            DrawMeshInstancedCMD._pool.push(this);
            super.recover();
            this._material && this._material._removeReference(1);
            this._material = null;
            this._instanceBufferState.destroy();
            this._instanceBufferState = null;
            delete this._instanceRenderElementArray;
            this._instanceRenderElementArray = [];
            delete this._instanceGeometryArray;
            this._instanceGeometryArray = [];
            this.mesh = null;
        }
        destroy() {
            super.destroy();
            this._material && this._material._removeReference(1);
            this._material = null;
            this._instanceBufferState.destroy();
            this._instanceBufferState = null;
            delete this._instanceRenderElementArray;
            this._instanceRenderElementArray = [];
            delete this._instanceGeometryArray;
            this._instanceGeometryArray = [];
            this.mesh = null;
        }
    }
    DrawMeshInstancedCMD._pool = [];
    DrawMeshInstancedCMD.maxInstanceCount = 1024;

    class CommandBuffer {
        constructor(name = null, shadowCaster = false) {
            this._shadow = false;
            this._camera = null;
            this._commands = [];
            this._name = name;
            this._shadow = shadowCaster;
        }
        get name() {
            return this._name;
        }
        get casterShadow() {
            return this._shadow;
        }
        set context(value) {
            this._context = value;
        }
        get context() {
            return this._context;
        }
        _apply() {
            for (var i = 0, n = this._commands.length; i < n; i++)
                this._commands[i].run();
            Laya.Stat.cmdDrawCall += this._commands.length;
        }
        _applyOne() {
            if (this._commands.length) {
                var cmd = this._commands.shift();
                cmd.run();
                cmd.recover();
            }
            return this._commands.length > 0;
        }
        getCommandsSize() {
            return this._commands.length;
        }
        setShaderDataTexture(shaderData, nameID, source) {
            this._commands.push(SetShaderDataCMD.create(shaderData, nameID, source, Laya.ShaderDataType.Texture2D, this));
        }
        setGlobalTexture(nameID, source) {
            this._commands.push(SetGlobalShaderDataCMD.create(nameID, source, Laya.ShaderDataType.Texture2D, this));
        }
        setShaderDataColor(shaderData, nameID, value) {
            this._commands.push(SetShaderDataCMD.create(shaderData, nameID, value, Laya.ShaderDataType.Color, this));
        }
        setGlobalColor(nameID, source) {
            this._commands.push(SetGlobalShaderDataCMD.create(nameID, source, Laya.ShaderDataType.Color, this));
        }
        setShaderDataVector(shaderData, nameID, value) {
            this._commands.push(SetShaderDataCMD.create(shaderData, nameID, value, Laya.ShaderDataType.Vector4, this));
        }
        setGlobalVector(nameID, source) {
            this._commands.push(SetGlobalShaderDataCMD.create(nameID, source, Laya.ShaderDataType.Vector4, this));
        }
        setShaderDataVector3(shaderData, nameID, value) {
            this._commands.push(SetShaderDataCMD.create(shaderData, nameID, value, Laya.ShaderDataType.Vector3, this));
        }
        setGlobalVector3(nameID, source) {
            this._commands.push(SetGlobalShaderDataCMD.create(nameID, source, Laya.ShaderDataType.Vector3, this));
        }
        setShaderDataVector2(shaderData, nameID, value) {
            this._commands.push(SetShaderDataCMD.create(shaderData, nameID, value, Laya.ShaderDataType.Vector2, this));
        }
        setGlobalVector2(nameID, source) {
            this._commands.push(SetGlobalShaderDataCMD.create(nameID, source, Laya.ShaderDataType.Vector2, this));
        }
        setShaderDataNumber(shaderData, nameID, value) {
            this._commands.push(SetShaderDataCMD.create(shaderData, nameID, value, Laya.ShaderDataType.Float, this));
        }
        setGlobalNumber(nameID, source) {
            this._commands.push(SetGlobalShaderDataCMD.create(nameID, source, Laya.ShaderDataType.Float, this));
        }
        setShaderDataInt(shaderData, nameID, value) {
            this._commands.push(SetShaderDataCMD.create(shaderData, nameID, value, Laya.ShaderDataType.Int, this));
        }
        setGlobalInt(nameID, source) {
            this._commands.push(SetGlobalShaderDataCMD.create(nameID, source, Laya.ShaderDataType.Int, this));
        }
        setShaderDataMatrix(shaderData, nameID, value) {
            this._commands.push(SetShaderDataCMD.create(shaderData, nameID, value, Laya.ShaderDataType.Matrix4x4, this));
        }
        setShaderDefine(shaderData, define, value) {
            this._commands.push(SetShaderDataCMD.create(shaderData, define, value, SetShaderDataCMD.ShaderDataType_define, this));
        }
        setGlobalMatrix(nameID, source) {
            this._commands.push(SetGlobalShaderDataCMD.create(nameID, source, Laya.ShaderDataType.Matrix4x4, this));
        }
        blitScreenQuad(source, dest, offsetScale = null, shader = null, shaderData = null, subShader = 0) {
            this._commands.push(BlitScreenQuadCMD.create(source, dest, offsetScale, shader, shaderData, subShader, BlitScreenQuadCMD._SCREENTYPE_QUAD, this));
        }
        blitScreenQuadByMaterial(source, dest, offsetScale = null, material = null, subShader = 0) {
            var shader;
            var shaderData;
            if (material) {
                shader = material._shader;
                shaderData = material.shaderData;
            }
            this._commands.push(BlitScreenQuadCMD.create(source, dest, offsetScale, shader, shaderData, subShader, BlitScreenQuadCMD._SCREENTYPE_QUAD, this));
        }
        blitScreenTriangle(source, dest, offsetScale = null, shader = null, shaderData = null, subShader = 0) {
            this._commands.push(BlitScreenQuadCMD.create(source, dest, offsetScale, shader, shaderData, subShader, BlitScreenQuadCMD._SCREENTYPE_TRIANGLE, this));
        }
        setRenderTarget(renderTexture) {
            this._commands.push(SetRenderTargetCMD.create(renderTexture));
        }
        clearRenderTarget(clearColor, clearDepth, backgroundColor, depth = 1) {
            this._commands.push(ClearRenderTextureCMD.create(clearColor, clearDepth, backgroundColor, depth, this));
        }
        drawMesh(mesh, matrix, material, submeshIndex, subShaderIndex) {
            this._commands.push(DrawMeshCMD.create(mesh, matrix, material, submeshIndex, subShaderIndex, this));
        }
        drawRender(render, material, subShaderIndex) {
            this._commands.push(DrawRenderCMD.create(render, material, subShaderIndex, this));
        }
        drawMeshInstance(mesh, subMeshIndex = 0, matrixs, material, subShaderIndex = 0, instanceProperty, drawnums) {
            if (!Laya.LayaGL.renderEngine.getCapable(Laya.RenderCapable.DrawElement_Instance))
                return null;
            var drawMeshInstancedCMD = DrawMeshInstancedCMD.create(mesh, subMeshIndex, matrixs, material, subShaderIndex, instanceProperty, drawnums, this);
            this._commands.push(drawMeshInstancedCMD);
            return drawMeshInstancedCMD;
        }
        addCustomCMD(command) {
            command._commandBuffer = this;
            this._commands.push(command);
        }
        clear() {
            for (var i = 0, n = this._commands.length; i < n; i++)
                this._commands[i].recover();
            this._commands.length = 0;
        }
    }

    class PhysicsSettings {
        constructor() {
            this.flags = 0;
            this.maxSubSteps = 1;
            this.fixedTimeStep = 1.0 / 60.0;
        }
    }

    class LightQueue {
        constructor() {
            this._length = 0;
            this._elements = [];
        }
        add(light) {
            let index = this._elements.indexOf(light);
            if (index != -1 && index < this._length) {
                return;
            }
            if (this._length === this._elements.length)
                this._elements.push(light);
            else
                this._elements[this._length] = light;
            this._length++;
        }
        remove(light) {
            var index = this._elements.indexOf(light);
            if (index == -1)
                return;
            this._length--;
            if (index !== this._length) {
                var end = this._elements[this._length];
                this._elements[index] = end;
            }
        }
        shift() {
            this._length--;
            return this._elements.shift();
        }
        getBrightestLight() {
            var maxIntIndex;
            var maxIntensity = -1;
            var elements = this._elements;
            for (var i = 0; i < this._length; i++) {
                var intensity = elements[i]._intensity;
                if (maxIntensity < intensity) {
                    maxIntensity = intensity;
                    maxIntIndex = i;
                }
            }
            return maxIntIndex;
        }
        normalLightOrdering(brightestIndex) {
            var firstLight = this._elements[0];
            this._elements[0] = this._elements[brightestIndex];
            this._elements[brightestIndex] = firstLight;
        }
    }
    class AlternateLightQueue extends LightQueue {
        remove(light) {
            var index = this._elements.indexOf(light);
            this._elements.splice(index, 1);
            this._length--;
        }
    }

    class Lightmap {
    }

    class Scene3DShaderDeclaration {
    }

    class BoundSphere {
        constructor(center = new Laya.Vector3, radius = 0) {
            this._center = center;
            this._radius = radius;
        }
        set center(value) {
            value.cloneTo(this._center);
        }
        get center() {
            return this._center;
        }
        set radius(value) {
            this._radius = value;
        }
        get radius() {
            return this._radius;
        }
        toDefault() {
            this._center.toDefault();
            this._radius = 0;
        }
        static createFromSubPoints(points, start, count, out) {
            if (points == null) {
                throw new Error("points");
            }
            if (start < 0 || start >= points.length) {
                throw new Error("start" + start + "Must be in the range [0, " + (points.length - 1) + "]");
            }
            if (count < 0 || (start + count) > points.length) {
                throw new Error("count" + count + "Must be in the range <= " + points.length + "}");
            }
            var upperEnd = start + count;
            var center = BoundSphere._tempVector3;
            center.x = 0;
            center.y = 0;
            center.z = 0;
            for (var i = start; i < upperEnd; ++i) {
                Laya.Vector3.add(points[i], center, center);
            }
            var outCenter = out.center;
            Laya.Vector3.scale(center, 1 / count, outCenter);
            var radius = 0.0;
            for (i = start; i < upperEnd; ++i) {
                var distance = Laya.Vector3.distanceSquared(outCenter, points[i]);
                if (distance > radius)
                    radius = distance;
            }
            out.radius = Math.sqrt(radius);
        }
        static createfromPoints(points, out) {
            if (points == null) {
                throw new Error("points");
            }
            BoundSphere.createFromSubPoints(points, 0, points.length, out);
        }
        intersectsRayDistance(ray) {
            return CollisionUtils.intersectsRayAndSphereRD(ray, this);
        }
        intersectsRayPoint(ray, outPoint) {
            return CollisionUtils.intersectsRayAndSphereRP(ray, this, outPoint);
        }
        cloneTo(destObject) {
            var dest = destObject;
            this._center.cloneTo(dest._center);
            dest._radius = this._radius;
        }
        clone() {
            var dest = new BoundSphere(new Laya.Vector3(), 0);
            this.cloneTo(dest);
            return dest;
        }
    }
    BoundSphere._tempVector3 = new Laya.Vector3();

    class ShadowSliceData {
        constructor() {
            this.cameraShaderValue = Laya.LayaGL.renderOBJCreate.createShaderData(null);
            this.position = new Laya.Vector3();
            this.viewMatrix = new Laya.Matrix4x4();
            this.projectionMatrix = new Laya.Matrix4x4();
            this.viewProjectMatrix = new Laya.Matrix4x4();
            this.cullPlanes = [new Plane(new Laya.Vector3(), 0), new Plane(new Laya.Vector3(), 0), new Plane(new Laya.Vector3(), 0), new Plane(new Laya.Vector3(), 0), new Plane(new Laya.Vector3(), 0), new Plane(new Laya.Vector3(), 0), new Plane(new Laya.Vector3(), 0), new Plane(new Laya.Vector3(), 0), new Plane(new Laya.Vector3(), 0), new Plane(new Laya.Vector3(), 0)];
            this.splitBoundSphere = new BoundSphere(new Laya.Vector3(), 0.0);
        }
    }
    class ShadowSpotData {
        constructor() {
            this.cameraShaderValue = Laya.LayaGL.renderOBJCreate.createShaderData(null);
            this.position = new Laya.Vector3;
            this.viewMatrix = new Laya.Matrix4x4();
            this.projectionMatrix = new Laya.Matrix4x4();
            this.viewProjectMatrix = new Laya.Matrix4x4();
            this.cameraCullInfo = Laya.LayaGL.renderOBJCreate.createCameraCullInfo();
        }
    }

    class FrustumCulling {
        static __init__() {
            FrustumCulling._cameraCullInfo = Laya.LayaGL.renderOBJCreate.createCameraCullInfo();
            FrustumCulling._shadowCullInfo = Laya.LayaGL.renderOBJCreate.createShadowCullInfo();
        }
        static cullingRenderBounds(bounds, cullInfo) {
            var cullPlaneCount = cullInfo.cullPlaneCount;
            var cullPlanes = cullInfo.cullPlanes;
            var min = bounds.getMin();
            var max = bounds.getMax();
            var minX = min.x;
            var minY = min.y;
            var minZ = min.z;
            var maxX = max.x;
            var maxY = max.y;
            var maxZ = max.z;
            var pass = true;
            for (var j = 0; j < cullPlaneCount; j++) {
                var plane = cullPlanes[j];
                var normal = plane.normal;
                if (plane.distance + (normal.x * (normal.x < 0.0 ? minX : maxX)) + (normal.y * (normal.y < 0.0 ? minY : maxY)) + (normal.z * (normal.z < 0.0 ? minZ : maxZ)) < 0.0) {
                    pass = false;
                    break;
                }
            }
            return pass;
        }
        static cullingRenderBoundsState(bounds, cullInfo) {
            var p = FrustumCulling._tempV30, n = FrustumCulling._tempV31;
            var boxMin = bounds.min;
            var boxMax = bounds.max;
            var result = ContainmentType.Contains;
            for (var i = 0, nn = cullInfo.cullPlaneCount; i < nn; i++) {
                var plane = cullInfo.cullPlanes[i];
                var planeNor = plane.normal;
                if (planeNor.x >= 0) {
                    p.x = boxMax.x;
                    n.x = boxMin.x;
                }
                else {
                    p.x = boxMin.x;
                    n.x = boxMax.x;
                }
                if (planeNor.y >= 0) {
                    p.y = boxMax.y;
                    n.y = boxMin.y;
                }
                else {
                    p.y = boxMin.y;
                    n.y = boxMax.y;
                }
                if (planeNor.z >= 0) {
                    p.z = boxMax.z;
                    n.z = boxMin.z;
                }
                else {
                    p.z = boxMin.z;
                    n.z = boxMax.z;
                }
                if (CollisionUtils.intersectsPlaneAndPoint(plane, p) === Plane.PlaneIntersectionType_Back)
                    return ContainmentType.Disjoint;
                if (CollisionUtils.intersectsPlaneAndPoint(plane, n) === Plane.PlaneIntersectionType_Back)
                    result = ContainmentType.Intersects;
            }
            return result;
        }
    }
    FrustumCulling._tempV30 = new Laya.Vector3();
    FrustumCulling._tempV31 = new Laya.Vector3();

    exports.ShadowLightType = void 0;
    (function (ShadowLightType) {
        ShadowLightType[ShadowLightType["DirectionLight"] = 0] = "DirectionLight";
        ShadowLightType[ShadowLightType["SpotLight"] = 1] = "SpotLight";
        ShadowLightType[ShadowLightType["PointLight"] = 2] = "PointLight";
    })(exports.ShadowLightType || (exports.ShadowLightType = {}));

    class ShadowCasterPass {
        constructor() {
            this._shadowBias = new Laya.Vector4();
            this._shadowParams = new Laya.Vector4();
            this._shadowMapSize = new Laya.Vector4();
            this._shadowSpotMapSize = new Laya.Vector4();
            this._shadowMatrices = new Float32Array(16 * (ShadowCasterPass._maxCascades));
            this._shadowSpotMatrices = new Laya.Matrix4x4();
            this._splitBoundSpheres = new Float32Array(ShadowCasterPass._maxCascades * 4);
            this._cascadeCount = 0;
            this._shadowMapWidth = 0;
            this._shadowMapHeight = 0;
            this._shadowSliceDatas = [new ShadowSliceData(), new ShadowSliceData(), new ShadowSliceData(), new ShadowSliceData()];
            this._shadowSpotData = new ShadowSpotData();
            this._lightUp = new Laya.Vector3();
            this._lightSide = new Laya.Vector3();
            this._lightForward = new Laya.Vector3();
            this._shadowSpotData.cameraCullInfo.boundFrustum = new BoundFrustum(new Laya.Matrix4x4());
            if (Laya.Config3D._uniformBlock) {
                this._castDepthBufferData = DepthCasterData.createDepthCasterUniformBlock();
                this._castDepthBufferOBJ = Laya.UniformBufferObject.getBuffer(Laya.UniformBufferObject.UBONAME_SHADOW, 0);
                if (!this._castDepthBufferOBJ) {
                    this._castDepthBufferOBJ = Laya.UniformBufferObject.create(Laya.UniformBufferObject.UBONAME_SHADOW, Laya.BufferUsage.Dynamic, this._castDepthBufferData.getbyteLength(), true);
                }
                BaseCamera.createCameraUniformBlock();
                this._castDepthCameraBufferData = BaseCamera.CameraUBOData.clone();
                this._castDepthCameraBufferOBJ = Laya.UniformBufferObject.getBuffer(Laya.UniformBufferObject.UBONAME_CAMERA, 1);
                if (!this._castDepthCameraBufferOBJ) {
                    this._castDepthCameraBufferOBJ = Laya.UniformBufferObject.create(Laya.UniformBufferObject.UBONAME_CAMERA, Laya.BufferUsage.Dynamic, this._castDepthCameraBufferData.getbyteLength(), false);
                }
            }
        }
        static __init__() {
            ShadowCasterPass._frustumPlanes = new Array(new Plane(new Laya.Vector3(), 0), new Plane(new Laya.Vector3(), 0), new Plane(new Laya.Vector3(), 0), new Plane(new Laya.Vector3(), 0), new Plane(new Laya.Vector3(), 0), new Plane(new Laya.Vector3(), 0));
            ShadowCasterPass.SHADOW_BIAS = Laya.Shader3D.propertyNameToID("u_ShadowBias");
            ShadowCasterPass.SHADOW_LIGHT_DIRECTION = Laya.Shader3D.propertyNameToID("u_ShadowLightDirection");
            ShadowCasterPass.SHADOW_SPLIT_SPHERES = Laya.Shader3D.propertyNameToID("u_ShadowSplitSpheres");
            ShadowCasterPass.SHADOW_MATRICES = Laya.Shader3D.propertyNameToID("u_ShadowMatrices");
            ShadowCasterPass.SHADOW_MAP_SIZE = Laya.Shader3D.propertyNameToID("u_ShadowMapSize");
            ShadowCasterPass.SHADOW_MAP = Laya.Shader3D.propertyNameToID("u_ShadowMap");
            ShadowCasterPass.SHADOW_PARAMS = Laya.Shader3D.propertyNameToID("u_ShadowParams");
            ShadowCasterPass.SHADOW_SPOTMAP_SIZE = Laya.Shader3D.propertyNameToID("u_SpotShadowMapSize");
            ShadowCasterPass.SHADOW_SPOTMAP = Laya.Shader3D.propertyNameToID("u_SpotShadowMap");
            ShadowCasterPass.SHADOW_SPOTMATRICES = Laya.Shader3D.propertyNameToID("u_SpotViewProjectMatrix");
            const sceneUniformMap = Laya.LayaGL.renderOBJCreate.createGlobalUniformMap("Scene3D");
            sceneUniformMap.addShaderUniform(ShadowCasterPass.SHADOW_BIAS, "u_ShadowBias");
            sceneUniformMap.addShaderUniform(ShadowCasterPass.SHADOW_LIGHT_DIRECTION, "u_ShadowLightDirection");
            sceneUniformMap.addShaderUniform(ShadowCasterPass.SHADOW_SPLIT_SPHERES, "u_ShadowSplitSpheres");
            sceneUniformMap.addShaderUniform(ShadowCasterPass.SHADOW_MATRICES, "u_ShadowMatrices");
            sceneUniformMap.addShaderUniform(ShadowCasterPass.SHADOW_MAP_SIZE, "u_ShadowMapSize");
            sceneUniformMap.addShaderUniform(ShadowCasterPass.SHADOW_MAP, "u_ShadowMap");
            sceneUniformMap.addShaderUniform(ShadowCasterPass.SHADOW_PARAMS, "u_ShadowParams");
            sceneUniformMap.addShaderUniform(ShadowCasterPass.SHADOW_SPOTMAP_SIZE, "u_SpotShadowMapSize");
            sceneUniformMap.addShaderUniform(ShadowCasterPass.SHADOW_SPOTMAP, "u_SpotShadowMap");
            sceneUniformMap.addShaderUniform(ShadowCasterPass.SHADOW_SPOTMATRICES, "u_SpotViewProjectMatrix");
            sceneUniformMap.addShaderUniform(Laya.Shader3D.propertyNameToID(Laya.UniformBufferObject.UBONAME_SHADOW), Laya.UniformBufferObject.UBONAME_SHADOW);
        }
        _setupShadowCasterShaderValues(context, shaderValues, shadowSliceData, LightParam, shadowparams, shadowBias, lightType) {
            shaderValues.setVector(ShadowCasterPass.SHADOW_BIAS, shadowBias);
            switch (lightType) {
                case exports.LightType.Directional:
                    shaderValues.setVector3(ShadowCasterPass.SHADOW_LIGHT_DIRECTION, LightParam);
                    break;
                case exports.LightType.Spot:
                    shaderValues.setVector(ShadowCasterPass.SHADOW_PARAMS, shadowparams);
                    break;
                case exports.LightType.Point:
                    break;
            }
            var cameraSV = shadowSliceData.cameraShaderValue;
            if (this._castDepthCameraBufferOBJ) {
                cameraSV._addCheckUBO(Laya.UniformBufferObject.UBONAME_CAMERA, this._castDepthCameraBufferOBJ, this._castDepthCameraBufferData);
                cameraSV.setUniformBuffer(BaseCamera.CAMERAUNIFORMBLOCK, this._castDepthCameraBufferOBJ);
            }
            cameraSV.setMatrix4x4(BaseCamera.VIEWMATRIX, shadowSliceData.viewMatrix);
            cameraSV.setMatrix4x4(BaseCamera.PROJECTMATRIX, shadowSliceData.projectionMatrix);
            cameraSV.setMatrix4x4(BaseCamera.VIEWPROJECTMATRIX, shadowSliceData.viewProjectMatrix);
            shaderValues.setMatrix4x4(BaseCamera.VIEWPROJECTMATRIX, shadowSliceData.viewProjectMatrix);
            context.viewMatrix = shadowSliceData.viewMatrix;
            context.projectionMatrix = shadowSliceData.projectionMatrix;
            context.projectionViewMatrix = shadowSliceData.viewProjectMatrix;
        }
        _setupShadowReceiverShaderValues(shaderValues) {
            var light = this._light;
            if (light.shadowCascadesMode !== exports.ShadowCascadesMode.NoCascades)
                shaderValues.addDefine(Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_CASCADE);
            else
                shaderValues.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_CASCADE);
            switch (light.shadowMode) {
                case exports.ShadowMode.Hard:
                    shaderValues.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_SOFT_SHADOW_LOW);
                    shaderValues.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_SOFT_SHADOW_HIGH);
                    break;
                case exports.ShadowMode.SoftLow:
                    shaderValues.addDefine(Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_SOFT_SHADOW_LOW);
                    shaderValues.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_SOFT_SHADOW_HIGH);
                    break;
                case exports.ShadowMode.SoftHigh:
                    shaderValues.addDefine(Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_SOFT_SHADOW_HIGH);
                    shaderValues.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_SOFT_SHADOW_LOW);
                    break;
            }
            shaderValues.setTexture(ShadowCasterPass.SHADOW_MAP, this._shadowDirectLightMap);
            shaderValues.setBuffer(ShadowCasterPass.SHADOW_MATRICES, this._shadowMatrices);
            shaderValues.setVector(ShadowCasterPass.SHADOW_MAP_SIZE, this._shadowMapSize);
            shaderValues.setVector(ShadowCasterPass.SHADOW_PARAMS, this._shadowParams);
            shaderValues.setBuffer(ShadowCasterPass.SHADOW_SPLIT_SPHERES, this._splitBoundSpheres);
        }
        _setupSpotShadowReceiverShaderValues(shaderValues) {
            var spotLight = this._light;
            switch (spotLight.shadowMode) {
                case exports.ShadowMode.Hard:
                    shaderValues.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_SPOT_SOFT_SHADOW_HIGH);
                    shaderValues.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_SPOT_SOFT_SHADOW_LOW);
                    break;
                case exports.ShadowMode.SoftLow:
                    shaderValues.addDefine(Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_SPOT_SOFT_SHADOW_LOW);
                    shaderValues.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_SPOT_SOFT_SHADOW_HIGH);
                    break;
                case exports.ShadowMode.SoftHigh:
                    shaderValues.addDefine(Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_SPOT_SOFT_SHADOW_HIGH);
                    shaderValues.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_SPOT_SOFT_SHADOW_LOW);
                    break;
            }
            shaderValues.setTexture(ShadowCasterPass.SHADOW_SPOTMAP, this._shadowSpotLightMap);
            shaderValues.setMatrix4x4(ShadowCasterPass.SHADOW_SPOTMATRICES, this._shadowSpotMatrices);
            shaderValues.setVector(ShadowCasterPass.SHADOW_SPOTMAP_SIZE, this._shadowSpotMapSize);
            shaderValues.setVector(ShadowCasterPass.SHADOW_PARAMS, this._shadowParams);
        }
        update(camera, light, lightType) {
            this.cleanUp();
            switch (lightType) {
                case exports.ShadowLightType.DirectionLight:
                    this._light = light;
                    var lightWorld = ShadowCasterPass._tempMatrix0;
                    var lightWorldE = lightWorld.elements;
                    var lightUp = this._lightUp;
                    var lightSide = this._lightSide;
                    var lightForward = this._lightForward;
                    Laya.Matrix4x4.createFromQuaternion(light.owner._transform.rotation, lightWorld);
                    lightSide.setValue(lightWorldE[0], lightWorldE[1], lightWorldE[2]);
                    lightUp.setValue(lightWorldE[4], lightWorldE[5], lightWorldE[6]);
                    lightForward.setValue(-lightWorldE[8], -lightWorldE[9], -lightWorldE[10]);
                    var atlasResolution = light._shadowResolution;
                    var cascadesMode = light._shadowCascadesMode;
                    var cascadesCount;
                    var shadowTileResolution;
                    var shadowMapWidth, shadowMapHeight;
                    if (cascadesMode == exports.ShadowCascadesMode.NoCascades) {
                        cascadesCount = 1;
                        shadowTileResolution = atlasResolution;
                        shadowMapWidth = atlasResolution;
                        shadowMapHeight = atlasResolution;
                    }
                    else {
                        cascadesCount = cascadesMode == exports.ShadowCascadesMode.TwoCascades ? 2 : 4;
                        shadowTileResolution = ShadowUtils.getMaxTileResolutionInAtlas(atlasResolution, atlasResolution, cascadesCount);
                        shadowMapWidth = shadowTileResolution * 2;
                        shadowMapHeight = cascadesMode == exports.ShadowCascadesMode.TwoCascades ? shadowTileResolution : shadowTileResolution * 2;
                    }
                    this._cascadeCount = cascadesCount;
                    this._shadowMapWidth = shadowMapWidth;
                    this._shadowMapHeight = shadowMapHeight;
                    var splitDistance = ShadowCasterPass._cascadesSplitDistance;
                    var frustumPlanes = ShadowCasterPass._frustumPlanes;
                    var cameraNear = camera.nearPlane;
                    var shadowFar = Math.min(camera.farPlane, light._shadowDistance);
                    var shadowMatrices = this._shadowMatrices;
                    var boundSpheres = this._splitBoundSpheres;
                    ShadowUtils.getCascadesSplitDistance(light._shadowTwoCascadeSplits, light._shadowFourCascadeSplits, cameraNear, shadowFar, camera.fieldOfView * Laya.MathUtils3D.Deg2Rad, camera.aspectRatio, cascadesMode, splitDistance);
                    ShadowUtils.getCameraFrustumPlanes(camera.projectionViewMatrix, frustumPlanes);
                    var forward = ShadowCasterPass._tempVector30;
                    camera._transform.getForward(forward);
                    Laya.Vector3.normalize(forward, forward);
                    for (var i = 0; i < cascadesCount; i++) {
                        var sliceData = this._shadowSliceDatas[i];
                        sliceData.sphereCenterZ = ShadowUtils.getBoundSphereByFrustum(splitDistance[i], splitDistance[i + 1], camera.fieldOfView * Laya.MathUtils3D.Deg2Rad, camera.aspectRatio, camera._transform.position, forward, sliceData.splitBoundSphere);
                        ShadowUtils.getDirectionLightShadowCullPlanes(frustumPlanes, i, splitDistance, cameraNear, lightForward, sliceData);
                        ShadowUtils.getDirectionalLightMatrices(lightUp, lightSide, lightForward, i, light._shadowNearPlane, shadowTileResolution, sliceData, shadowMatrices);
                        if (cascadesCount > 1)
                            ShadowUtils.applySliceTransform(sliceData, shadowMapWidth, shadowMapHeight, i, shadowMatrices);
                    }
                    ShadowUtils.prepareShadowReceiverShaderValues(light, shadowMapWidth, shadowMapHeight, this._shadowSliceDatas, cascadesCount, this._shadowMapSize, this._shadowParams, shadowMatrices, boundSpheres);
                    break;
                case exports.ShadowLightType.SpotLight:
                    this._light = light;
                    var lightWorld = ShadowCasterPass._tempMatrix0;
                    var lightForward = this._lightForward;
                    var shadowResolution = this._light._shadowResolution;
                    this._shadowMapWidth = shadowResolution;
                    this._shadowMapHeight = shadowResolution;
                    var shadowSpotData = this._shadowSpotData;
                    ShadowUtils.getSpotLightShadowData(shadowSpotData, this._light, shadowResolution, this._shadowParams, this._shadowSpotMatrices, this._shadowSpotMapSize);
                    break;
                case exports.ShadowLightType.PointLight:
                    break;
                default:
                    throw ("There is no shadow of this type");
            }
        }
        render(context, scene, lightType, camera) {
            switch (lightType) {
                case exports.ShadowLightType.DirectionLight:
                    var shaderValues = scene._shaderValues;
                    context.pipelineMode = "ShadowCaster";
                    var shadowMap = this._shadowDirectLightMap = ShadowUtils.getTemporaryShadowTexture(this._shadowMapWidth, this._shadowMapHeight, exports.ShadowMapFormat.bit16);
                    shadowMap._start();
                    context.destTarget = shadowMap;
                    var light = this._light;
                    for (var i = 0, n = this._cascadeCount; i < n; i++) {
                        var sliceData = this._shadowSliceDatas[i];
                        ShadowUtils.getShadowBias(light, sliceData.projectionMatrix, sliceData.resolution, this._shadowBias);
                        this._setupShadowCasterShaderValues(context, shaderValues, sliceData, this._lightForward, this._shadowParams, this._shadowBias, exports.LightType.Directional);
                        var shadowCullInfo = FrustumCulling._shadowCullInfo;
                        shadowCullInfo.position = sliceData.position;
                        shadowCullInfo.cullPlanes = sliceData.cullPlanes;
                        shadowCullInfo.cullPlaneCount = sliceData.cullPlaneCount;
                        shadowCullInfo.cullSphere = sliceData.splitBoundSphere;
                        shadowCullInfo.direction = this._lightForward;
                        scene._directLightShadowCull(shadowCullInfo, context);
                        context.cameraShaderValue = sliceData.cameraShaderValue;
                        Camera._updateMark++;
                        var resolution = sliceData.resolution;
                        var offsetX = sliceData.offsetX;
                        var offsetY = sliceData.offsetY;
                        Laya.LayaGL.renderEngine.viewport(offsetX, offsetY, resolution, resolution);
                        Laya.LayaGL.renderEngine.scissor(offsetX, offsetY, resolution, resolution);
                        Laya.LayaGL.renderEngine.clearRenderTexture(Laya.RenderClearFlag.Depth, null, 1);
                        if (scene._opaqueQueue.elements.length > 0) {
                            Viewport._tempViewport.set(offsetX, offsetY, resolution, resolution);
                            ShadowCasterPass._tempVector4.setValue(offsetX + 1, offsetY + 1, resolution - 2, resolution - 2);
                            context.viewport = Viewport._tempViewport;
                            context.scissor = ShadowCasterPass._tempVector4;
                            Laya.Stat.depthCastDrawCall += scene._opaqueQueue.renderQueue(context);
                        }
                        camera._applyCasterPassCommandBuffer(context);
                    }
                    shadowMap._end();
                    this._setupShadowReceiverShaderValues(shaderValues);
                    context.pipelineMode = context.configPipeLineMode;
                    break;
                case exports.ShadowLightType.SpotLight:
                    var shaderValues = scene._shaderValues;
                    context.pipelineMode = "ShadowCaster";
                    var spotlight = this._light;
                    var shadowMap = this._shadowSpotLightMap = ShadowUtils.getTemporaryShadowTexture(this._shadowMapWidth, this._shadowMapHeight, exports.ShadowMapFormat.bit16);
                    shadowMap._start();
                    context.destTarget = shadowMap;
                    var shadowSpotData = this._shadowSpotData;
                    ShadowUtils.getShadowBias(spotlight, shadowSpotData.projectionMatrix, shadowSpotData.resolution, this._shadowBias);
                    this._setupShadowCasterShaderValues(context, shaderValues, shadowSpotData, this._light.owner.transform.position, this._shadowParams, this._shadowBias, exports.LightType.Spot);
                    scene._sportLightShadowCull(shadowSpotData.cameraCullInfo, context);
                    context.cameraShaderValue = shadowSpotData.cameraShaderValue;
                    Camera._updateMark++;
                    Laya.LayaGL.renderEngine.viewport(shadowSpotData.offsetX, shadowSpotData.offsetY, shadowSpotData.resolution, shadowSpotData.resolution);
                    Laya.LayaGL.renderEngine.scissor(shadowSpotData.offsetX, shadowSpotData.offsetY, shadowSpotData.resolution, shadowSpotData.resolution);
                    Laya.LayaGL.renderEngine.clearRenderTexture(Laya.RenderClearFlag.Depth, null, 1);
                    if (scene._opaqueQueue.elements.length > 0) {
                        context.changeViewport(shadowSpotData.offsetX, shadowSpotData.offsetY, shadowSpotData.resolution, shadowSpotData.resolution);
                        context.changeScissor(shadowSpotData.offsetX, shadowSpotData.offsetY, shadowSpotData.resolution, shadowSpotData.resolution);
                        Laya.Stat.depthCastDrawCall += scene._opaqueQueue.renderQueue(context);
                    }
                    camera._applyCasterPassCommandBuffer(context);
                    shadowMap._end();
                    this._setupSpotShadowReceiverShaderValues(shaderValues);
                    context.pipelineMode = context.configPipeLineMode;
                    break;
                case exports.ShadowLightType.PointLight:
                    break;
                default:
                    throw ("There is no shadow of this type");
            }
        }
        cleanUp() {
            this._shadowDirectLightMap && Laya.RenderTexture.recoverToPool(this._shadowDirectLightMap);
            this._shadowSpotLightMap && Laya.RenderTexture.recoverToPool(this._shadowSpotLightMap);
            this._shadowDirectLightMap = null;
            this._shadowSpotLightMap = null;
            this._light = null;
        }
    }
    ShadowCasterPass._tempVector30 = new Laya.Vector3();
    ShadowCasterPass._tempVector4 = new Laya.Vector4();
    ShadowCasterPass._tempMatrix0 = new Laya.Matrix4x4();
    ShadowCasterPass._maxCascades = 4;
    ShadowCasterPass._cascadesSplitDistance = new Array(ShadowCasterPass._maxCascades + 1);
    ShadowCasterPass._frustumPlanes = new Array();

    class BlitFrameBufferCMD {
        constructor() {
            this._source = null;
            this._dest = null;
            this._offsetScale = null;
            this._texture_size = null;
            this._shader = null;
            this._shaderData = null;
            this._subShader = 0;
            this._viewPort = null;
            this._transform3D = Laya.LayaGL.renderOBJCreate.createTransform(null);
            this._renderElement = new RenderElement();
            this._renderElement.setTransform(this._transform3D);
            this._renderElement.setGeometry(ScreenQuad.instance);
            this._texture_size = new Laya.Vector4();
        }
        static __init__() {
            BlitFrameBufferCMD.shaderdata = Laya.LayaGL.renderOBJCreate.createShaderData(null);
            BlitFrameBufferCMD.GAMMAOUT = Laya.Shader3D.getDefineByName("GAMMAOUT");
        }
        static create(source, dest, viewport, offsetScale = null, shader = null, shaderData = null, subShader = 0) {
            var cmd;
            cmd = BlitFrameBufferCMD._pool.length > 0 ? BlitFrameBufferCMD._pool.pop() : new BlitFrameBufferCMD();
            cmd._source = source;
            cmd._dest = dest;
            cmd._offsetScale = offsetScale;
            cmd.setshader(shader, subShader, shaderData);
            cmd._source && cmd._texture_size.setValue(source.width, source.height, 1.0 / source.width, 1.0 / source.height);
            cmd._viewPort = viewport;
            return cmd;
        }
        set shaderData(value) {
            this._shaderData = value || BlitFrameBufferCMD.shaderdata;
            this._renderElement._renderElementOBJ._materialShaderData = this._shaderData;
        }
        setshader(shader, subShader, shaderData) {
            this._shader = shader || Command._screenShader;
            this._subShader = subShader || 0;
            this.shaderData = shaderData;
            this._renderElement.renderSubShader = this._shader.getSubShaderAt(this._subShader);
        }
        run() {
            if (!this._source || !this._viewPort)
                return;
            var source = this._source;
            var dest = this._dest;
            var shader = this._shader;
            var shaderData = this._shaderData;
            var viewport = this._viewPort;
            let vph = RenderContext3D.clientHeight - viewport.y - viewport.height;
            let context = RenderContext3D._instance;
            context.changeViewport(viewport.x, vph, viewport.width, viewport.height);
            context.changeScissor(viewport.x, vph, viewport.width, viewport.height);
            shaderData.setTexture(Command.SCREENTEXTURE_ID, source);
            shaderData.setVector(Command.SCREENTEXTUREOFFSETSCALE_ID, this._offsetScale || BlitFrameBufferCMD._defaultOffsetScale);
            source && (shaderData.setVector(Command.MAINTEXTURE_TEXELSIZE_ID, this._texture_size));
            (Laya.RenderTexture.currentActive) && (Laya.RenderTexture.currentActive._end());
            if (!dest) {
                shaderData.addDefine(BlitFrameBufferCMD.GAMMAOUT);
            }
            else {
                dest._start();
                shaderData.removeDefine(BlitFrameBufferCMD.GAMMAOUT);
            }
            var subShader = shader.getSubShaderAt(this._subShader);
            subShader._passes;
            ScreenQuad.instance.invertY = false;
            context.destTarget = dest;
            context._contextOBJ.applyContext(Camera._updateMark);
            context.drawRenderElement(this._renderElement);
        }
        recover() {
            BlitFrameBufferCMD._pool.push(this);
            this._source = null;
            this._dest = null;
            this._offsetScale = null;
            this._shader = null;
            this._shaderData = null;
            this._viewPort = null;
        }
    }
    BlitFrameBufferCMD._pool = [];
    BlitFrameBufferCMD._defaultOffsetScale = new Laya.Vector4(0, 0, 1, 1);

    class SceneRenderManager {
        constructor() {
            this._sceneManagerOBJ = Laya.LayaGL.renderOBJCreate.createSceneRenderManager();
        }
        get list() {
            return this._sceneManagerOBJ.list;
        }
        set list(value) {
            this._sceneManagerOBJ.list = value;
        }
        addRenderObject(object) {
            this._sceneManagerOBJ.addRenderObject(object);
        }
        removeRenderObject(object) {
            this._sceneManagerOBJ.removeRenderObject(object);
        }
        removeMotionObject(object) {
            this._sceneManagerOBJ.removeMotionObject(object);
        }
        updateMotionObjects() {
            this._sceneManagerOBJ.updateMotionObjects();
        }
        addMotionObject(object) {
            this._sceneManagerOBJ.addMotionObject(object);
        }
        destroy() {
            this._sceneManagerOBJ.destroy();
        }
    }

    class UI3DManager {
        constructor() {
            this._UI3Dlist = new Laya.SingletonList();
        }
        add(value) {
            this._UI3Dlist.add(value);
        }
        remove(value) {
            this._UI3Dlist.remove(value);
        }
        update() {
            for (var i = 0, n = this._UI3Dlist.length; i < n; i++) {
                let elements = this._UI3Dlist.elements;
                elements[i]._submitRT();
            }
        }
        destory() {
            this._UI3Dlist.destroy();
        }
    }

    class BVHSpatialManager {
        constructor() {
            this.cellCount = 0;
            this.bvhManager = new Map();
            this.updateBVHBoxList = new Laya.SingletonList();
        }
        clear() {
            this.cellCount = 0;
            this.updateBVHBoxList.clear();
        }
        destroy() {
            this.bvhManager = null;
            this.updateBVHBoxList.destroy();
        }
    }
    class BVHSpatialConfig {
        constructor() {
            this.max_SpatialCount = 7;
            this.limit_size = 32;
            this.Min_BVH_Build_Nums = 10;
        }
    }

    class BVHSpatialBox {
        constructor(bvhmanager, config) {
            this._bounds = new Bounds(new Laya.Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), new Laya.Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE));
            this._cellList = [];
            this._cellCount = 0;
            this._bvhmanager = bvhmanager;
            this._config = config;
        }
        static sciContainsBox(box, cullInfo) {
            const p = BVHSpatialBox._tempV3;
            const n = BVHSpatialBox._tempV3_2;
            const boxMin = box.min;
            const boxMax = box.max;
            let result = ContainmentType.Contains;
            for (let i = 0, nn = cullInfo.cullPlaneCount; i < nn; i++) {
                const plane = cullInfo.cullPlanes[i];
                const planeNor = plane.normal;
                if (planeNor.x >= 0) {
                    p.x = boxMax.x;
                    n.x = boxMin.x;
                }
                else {
                    p.x = boxMin.x;
                    n.x = boxMax.x;
                }
                if (planeNor.y >= 0) {
                    p.y = boxMax.y;
                    n.y = boxMin.y;
                }
                else {
                    p.y = boxMin.y;
                    n.y = boxMax.y;
                }
                if (planeNor.z >= 0) {
                    p.z = boxMax.z;
                    n.z = boxMin.z;
                }
                else {
                    p.z = boxMin.z;
                    n.z = boxMax.z;
                }
                if (CollisionUtils.intersectsPlaneAndPoint(plane, p) === Plane.PlaneIntersectionType_Back)
                    return ContainmentType.Disjoint;
                if (CollisionUtils.intersectsPlaneAndPoint(plane, n) === Plane.PlaneIntersectionType_Back)
                    result = ContainmentType.Intersects;
            }
            return result;
        }
        static sciIntersectsBox(box, cullInfo) {
            const cullPlaneCount = cullInfo.cullPlaneCount;
            const cullPlanes = cullInfo.cullPlanes;
            const min = box.min;
            const max = box.max;
            const minX = min.x;
            const minY = min.y;
            const minZ = min.z;
            const maxX = max.x;
            const maxY = max.y;
            const maxZ = max.z;
            let pass = true;
            for (let j = 0; j < cullPlaneCount; j++) {
                const plane = cullPlanes[j];
                const normal = plane.normal;
                if (plane.distance + (normal.x * (normal.x < 0.0 ? minX : maxX)) + (normal.y * (normal.y < 0.0 ? minY : maxY)) + (normal.z * (normal.z < 0.0 ? minZ : maxZ)) < 0.0) {
                    pass = false;
                    break;
                }
            }
            return pass;
        }
        set parent(value) {
            this._parent = value;
        }
        get parent() {
            return this._parent;
        }
        _isRepeat(cell) {
            return (this._cellList.indexOf(cell) != -1);
        }
        _addOneCell(cell) {
            this._cellList.push(cell);
            this._cellCount++;
            this._bvhmanager.bvhManager.set(cell.id, this);
            this._bvhmanager.cellCount++;
        }
        _removeOneCell(cell) {
            let index = this._cellList.indexOf(cell);
            if (index == -1)
                return false;
            this._cellCount--;
            this._cellList.splice(index, 1);
            this._bvhmanager.bvhManager.delete(cell.id);
            this._bvhmanager.cellCount--;
            return true;
        }
        _clearList() {
            this._bvhmanager.cellCount -= this._cellCount;
            this._cellCount = 0;
            this._cellList = null;
        }
        _isFloatMax(x, y) {
            return x - y > 0.0001;
        }
        _isBoundsContainedBySpatialBox(cell) {
            let cellMin = cell.bounds.getMin();
            let cellMax = cell.bounds.getMax();
            let boxMin = this._bounds.getMin();
            let boxMax = this._bounds.getMax();
            if (this._isFloatMax(cellMin.x, boxMin.x) && this._isFloatMax(cellMin.y, boxMin.y) && this._isFloatMax(cellMin.z, boxMin.z) &&
                this._isFloatMax(boxMax.x, cellMax.x) && this._isFloatMax(boxMax.y, cellMax.y) && this._isFloatMax(boxMax.z, cellMax.z)) {
                return false;
            }
            return true;
        }
        _addBounds(cell) {
            this._boundchanged = this._isBoundsContainedBySpatialBox(cell);
        }
        _removeBounds(cell) {
            this._boundchanged = this._isBoundsContainedBySpatialBox(cell);
        }
        fillCell(cell) {
            if (this._isRepeat(cell)) {
                return;
            }
            this._addOneCell(cell);
            this._boundchanged = true;
            this._bvhmanager.updateBVHBoxList.add(this);
        }
        fillRemove(cell) {
            if (!this._isRepeat(cell)) {
                return;
            }
            this._removeOneCell(cell);
            this._boundchanged = true;
            this._bvhmanager.updateBVHBoxList.add(this);
        }
        addCell(cell) {
            if (this._isRepeat(cell)) {
                return;
            }
            this._addOneCell(cell);
            this._addBounds(cell);
        }
        removeCell(cell) {
            if (this._removeOneCell(cell)) {
                this._removeBounds(cell);
            }
        }
        splitBox() {
            if (!this.isContentBox()) {
                this._children0 && this._children0.splitBox();
                this._children1 && this._children1.splitBox();
                return;
            }
            let v1 = this._bounds.getExtent();
            if ((this._config.max_SpatialCount > this._cellCount && this._config.limit_size >= 2 * Math.max(v1.x, v1.y, v1.z)) || this._cellCount <= 1)
                return;
            if (v1.x > v1.y && v1.x > v1.z)
                this._cellList.sort((a, b) => {
                    if (a && b)
                        return a.bounds.getCenter().x - b.bounds.getCenter().x;
                    else
                        return 0;
                });
            else if (v1.y > v1.x && v1.y > v1.z)
                this._cellList.sort((a, b) => {
                    if (a && b)
                        return a.bounds.getCenter().y - b.bounds.getCenter().y;
                    else
                        return 0;
                });
            else if (v1.z > v1.x && v1.z > v1.y)
                this._cellList.sort((a, b) => {
                    if (a && b)
                        return a.bounds.getCenter().z - b.bounds.getCenter().z;
                    else
                        return 0;
                });
            const mid = this._cellCount / 2 | 0;
            this._children0 = this._creatChildNode();
            this._children0.parent = this;
            for (let i = 0; i < mid; i++) {
                const cell = this._cellList[i];
                this._children0.fillCell(cell);
                Bounds.merge(this._children0._bounds, cell.bounds, this._children0._bounds);
            }
            this._children0._boundchanged = false;
            this._children0.splitBox();
            this._children1 = this._creatChildNode();
            this._children1.parent = this;
            for (let i = mid; i < this._cellCount; i++) {
                const cell = this._cellList[i];
                this._children1.fillCell(cell);
                Bounds.merge(this._children1._bounds, cell.bounds, this._children1._bounds);
            }
            this._children1._boundchanged = false;
            this._children1.splitBox();
            this._clearList();
        }
        getNearlist(checkPos) {
            if (this.isContentBox())
                return this;
            else {
                let v1 = this._children0._bounds.getCenter();
                let v2 = this._children1._bounds.getCenter();
                return Laya.Vector3.distanceSquared(v1, checkPos) < Laya.Vector3.distanceSquared(v2, checkPos) ? this._children0.getNearlist(checkPos) : this._children1.getNearlist(checkPos);
            }
        }
        traverseBoundsCell(out) {
            if (this.isContentBox()) {
                for (var i = 0; i < this._cellCount; i++) {
                    out.add(this._cellList[i]);
                }
            }
            else {
                this._children0 && this._children0.traverseBoundsCell(out);
                this._children1 && this._children1.traverseBoundsCell(out);
            }
        }
        _creatChildNode() {
            return new BVHSpatialBox(this._bvhmanager, this._config);
        }
        getItemByCameraCullInfo(cameraCullInfo, out) {
            var frustum = cameraCullInfo.boundFrustum;
            const result = frustum.containsBoundBox(this._bounds);
            if (result == 1)
                this.traverseBoundsCell(out);
            else if (result == 2) {
                if (this.isContentBox()) {
                    for (let i = 0; i < this._cellList.length; i++) {
                        if (frustum.intersects(this._cellList[i].bounds))
                            out.add(this._cellList[i]);
                    }
                }
                else {
                    this._children0.getItemByCameraCullInfo(cameraCullInfo, out);
                    this._children1.getItemByCameraCullInfo(cameraCullInfo, out);
                }
            }
        }
        getItemByFrustum(frustum, out) {
            const result = frustum.containsBoundBox(this._bounds);
            if (result == 1)
                this.traverseBoundsCell(out);
            else if (result == 2) {
                if (this.isContentBox()) {
                    for (let i = 0; i < this._cellList.length; i++) {
                        if (frustum.intersects(this._cellList[i].bounds))
                            out.add(this._cellList[i]);
                    }
                }
                else {
                    this._children0.getItemByFrustum(frustum, out);
                    this._children1.getItemByFrustum(frustum, out);
                }
            }
        }
        getItemBySCI(sci, out) {
            const result = BVHSpatialBox.sciContainsBox(this._bounds, sci);
            if (result == 1)
                this.traverseBoundsCell(out);
            else if (result == 2) {
                if (this.isContentBox()) {
                    for (let i = 0; i < this._cellList.length; i++) {
                        if (BVHSpatialBox.sciIntersectsBox(this._cellList[i].bounds, sci))
                            out.add(this._cellList[i]);
                    }
                }
                else {
                    this._children0.getItemBySCI(sci, out);
                    this._children1.getItemBySCI(sci, out);
                }
            }
        }
        recaculateBox() {
            if (!!this._children0 && !!this._children1) {
                Bounds.merge(this._children0._bounds, this._children1._bounds, this._bounds);
            }
            else if (this._cellList && this._cellList.length >= 1) {
                this._cellList[0].bounds.cloneTo(this._bounds);
                for (var i = 0, n = this._cellList.length; i < n; i++) {
                    Bounds.merge(this._cellList[i].bounds, this._bounds, this._bounds);
                }
            }
            else {
                console.error("BVHSpatialBox is illegal");
            }
            this.parent && this.parent.recaculateBox();
            this._boundchanged = false;
        }
        isRoot() {
            return !this._parent;
        }
        isContentBox() {
            return this._cellCount != 0;
        }
        destroy() {
            if (this.isContentBox()) {
                this._cellList = null;
            }
            else {
                this._children0 && this._children0.destroy();
                this._children1 && this._children1.destroy();
                this._children0 = null;
                this._children1 = null;
            }
            this._bounds = null;
            this._config = null;
            this._bvhmanager = null;
        }
    }
    BVHSpatialBox._tempV3 = new Laya.Vector3();
    BVHSpatialBox._tempV3_2 = new Laya.Vector3();

    class BVHSpatial {
        constructor(bvhConfig = null, bvhManager = null) {
            this._isBuild = false;
            this._BVHConfig = bvhConfig ? bvhConfig : new BVHSpatialConfig();
            this._BVHManager = bvhManager ? bvhManager : new BVHSpatialManager();
            this._BVHSpatialBox = this._creatChildNode();
        }
        _creatChildNode() {
            return new BVHSpatialBox(this._BVHManager, this._BVHConfig);
        }
        cellLegal(cell) {
            let extend = cell.bounds.getExtent();
            return this._BVHConfig.limit_size > (Math.max(extend.x, extend.y, extend.z) * 2);
        }
        addOne(cell) {
            if (!this.cellLegal(cell)) {
                return false;
            }
            if (this._isBuild) {
                let spatial = this._BVHSpatialBox.getNearlist(cell.bounds.getCenter());
                spatial.addCell(cell);
                this._BVHManager.updateBVHBoxList.add(spatial);
            }
            else {
                this._BVHSpatialBox.fillCell(cell);
            }
            return true;
        }
        removeOne(cell) {
            if (!this._BVHManager.bvhManager.has(cell.id)) {
                return false;
            }
            if (this._isBuild) {
                let spatial = this._BVHManager.bvhManager.get(cell.id);
                spatial.removeCell(cell);
                this._BVHManager.updateBVHBoxList.add(spatial);
            }
            else {
                this._BVHSpatialBox.fillRemove(cell);
            }
            return true;
        }
        motionOne(cell) {
            if (this._BVHSpatialBox.getNearlist(cell.bounds.getCenter()) == this._BVHManager.bvhManager.get(cell.id)) {
                return;
            }
            else {
                this.removeOne(cell);
                this.addOne(cell);
            }
        }
        getItemByCameraCullInfo(cameraCullInfo, out) {
            if (this._BVHManager.updateBVHBoxList.length > 0) {
                this.update();
            }
            if (this._isBuild) {
                this._BVHSpatialBox.getItemByCameraCullInfo(cameraCullInfo, out);
            }
            else {
                this._BVHSpatialBox.traverseBoundsCell(out);
            }
        }
        getItemByFrustum(frustum, out) {
            if (this._BVHManager.updateBVHBoxList.length > 0) {
                this.update();
            }
            if (this._isBuild) {
                this._BVHSpatialBox.getItemByFrustum(frustum, out);
            }
            else {
                this._BVHSpatialBox.traverseBoundsCell(out);
            }
        }
        getItemBySCI(sci, out) {
            if (this._BVHManager.updateBVHBoxList.length > 0) {
                this.update();
            }
            if (this._isBuild) {
                this._BVHSpatialBox.getItemBySCI(sci, out);
            }
            else {
                this._BVHSpatialBox.traverseBoundsCell(out);
            }
        }
        update() {
            if (!this._isBuild) {
                if (this._BVHManager.cellCount > this._BVHConfig.Min_BVH_Build_Nums) {
                    this._BVHSpatialBox.recaculateBox();
                    this._BVHSpatialBox.splitBox();
                    this._BVHManager.updateBVHBoxList.remove(this._BVHSpatialBox);
                    this._isBuild = true;
                }
                this._BVHManager.updateBVHBoxList.length = 0;
            }
            else {
                let list = this._BVHManager.updateBVHBoxList;
                for (let i = 0, n = list.length; i < n; i++) {
                    let spatial = list.elements[i];
                    spatial._boundchanged && spatial.recaculateBox();
                    spatial.splitBox();
                }
                list.length = 0;
            }
        }
        rebuild() {
            if (this._isBuild) {
                let out = new Laya.SingletonList();
                this._BVHSpatialBox.traverseBoundsCell(out);
                this._BVHSpatialBox.destroy();
                this._BVHManager.clear();
                this._isBuild = false;
                this._BVHSpatialBox = this._creatChildNode();
                for (let i = 0, n = out.length; i < n; i++) {
                    this.addOne(out.elements[i]);
                }
                this._BVHSpatialBox.recaculateBox();
                this._BVHSpatialBox.splitBox();
            }
        }
        destroy() {
            this._BVHSpatialBox.destroy();
            this._BVHManager.destroy();
        }
    }

    class BVHRenderBox extends BVHSpatialBox {
        _creatChildNode() {
            return new BVHRenderBox(this._bvhmanager, this._config);
        }
        getItemByCameraCullInfo(cameraCullInfo, out) {
            var frustum = cameraCullInfo.boundFrustum;
            const result = frustum.containsBoundBox(this._bounds);
            if (result == 1) {
                this.traverseBoundsCell(out);
                Laya.Stat.frustumCulling++;
            }
            else if (result == 2) {
                if (this.isContentBox()) {
                    var cullMask = cameraCullInfo.cullingMask;
                    let staticMask = cameraCullInfo.staticMask;
                    let context = RenderContext3D._instance;
                    for (let i = 0; i < this._cellList.length; i++) {
                        var canPass;
                        let render = this._cellList[i];
                        canPass = (Math.pow(2, render.renderNode.layer) & cullMask) != 0 && render._enabled && (render.renderbitFlag == 0);
                        canPass = canPass && ((render.renderNode.staticMask & staticMask) != 0);
                        if (canPass) {
                            Laya.Stat.frustumCulling++;
                            if (!cameraCullInfo.useOcclusionCulling || render._needRender(frustum, context)) {
                                out.add(render);
                            }
                        }
                    }
                }
                else {
                    this._children0.getItemByCameraCullInfo(cameraCullInfo, out);
                    this._children1.getItemByCameraCullInfo(cameraCullInfo, out);
                }
            }
        }
        getItemBySCI(sci, out) {
            const result = BVHSpatialBox.sciContainsBox(this._bounds, sci);
            if (result == 1)
                this.traverseBoundsCell(out);
            else if (result == 2) {
                if (this.isContentBox()) {
                    for (let i = 0; i < this._cellList.length; i++) {
                        var render = this._cellList[i];
                        var canPass = render.castShadow && render._enabled && (render.renderbitFlag == 0);
                        if (canPass) {
                            Laya.Stat.frustumCulling++;
                            let pass = FrustumCulling.cullingRenderBounds(render.bounds, sci);
                            pass && out.add(render);
                        }
                    }
                }
                else {
                    this._children0.getItemBySCI(sci, out);
                    this._children1.getItemBySCI(sci, out);
                }
            }
        }
    }

    class BVHRenderSpatial extends BVHSpatial {
        _creatChildNode() {
            return new BVHRenderBox(this._BVHManager, this._BVHConfig);
        }
        cellLegal(cell) {
            if (cell.renderNode.staticMask == exports.StaticFlag.StaticBatch && super.cellLegal(cell))
                return true;
            return false;
        }
    }

    class BVHSceneRenderManager extends SceneRenderManager {
        constructor(bvhConfig = null) {
            super();
            this._bvhRenderSpatial = new BVHRenderSpatial(bvhConfig);
            this._allRenderList = new Laya.SingletonList();
        }
        get list() {
            return this._allRenderList;
        }
        set list(value) {
            for (let i = 0, n = value.length; i < n; i++) {
                let render = value.elements[i];
                this.addRenderObject(render);
            }
        }
        get bvhSpatial() {
            return this._bvhRenderSpatial;
        }
        get otherList() {
            return this._sceneManagerOBJ.list;
        }
        addRenderObject(object) {
            if (!this._bvhRenderSpatial.addOne(object)) {
                this._sceneManagerOBJ.addRenderObject(object);
            }
            this._allRenderList.add(object);
        }
        removeRenderObject(object) {
            if (!this._bvhRenderSpatial.removeOne(object))
                this._sceneManagerOBJ.removeRenderObject(object);
            this._allRenderList.remove(object);
        }
        removeMotionObject(object) {
            this._sceneManagerOBJ.removeMotionObject(object);
        }
        updateMotionObjects() {
            this._bvhRenderSpatial.update();
            this._sceneManagerOBJ.updateMotionObjects();
        }
        addMotionObject(object) {
            if (this._bvhRenderSpatial.cellLegal(object)) {
                this._bvhRenderSpatial.motionOne(object);
            }
            else {
                this._sceneManagerOBJ.addMotionObject(object);
            }
        }
        destroy() {
            this._sceneManagerOBJ.destroy();
            this._bvhRenderSpatial.destroy();
            this._allRenderList.destroy();
        }
    }

    class CullPassBase {
        constructor() {
            this._cullList = new Laya.SingletonList();
        }
        get cullList() {
            return this._cullList;
        }
        static cullDistanceVolume(context, render) {
            let camera = context.camera;
            if (!camera || !camera.transform)
                return false;
            let bound = render.bounds;
            let center = bound.getCenter();
            let exten = bound.getExtent();
            let dis = Laya.Vector3.distance(camera.transform.position, center);
            let volum = Math.max(exten.x, exten.y, exten.z);
            if (volum / dis < render._ratioIgnor) {
                return false;
            }
            return true;
        }
        cullByCameraCullInfo(cameraCullInfo, renderManager) {
            this._cullList.length = 0;
            var renders = renderManager.list.elements;
            var boundFrustum = cameraCullInfo.boundFrustum;
            var cullMask = cameraCullInfo.cullingMask;
            let staticMask = cameraCullInfo.staticMask;
            let context = RenderContext3D._instance;
            for (var i = 0, n = renderManager.list.length; i < n; i++) {
                var render = renders[i];
                var canPass;
                canPass = (Math.pow(2, render.renderNode.layer) & cullMask) != 0 && render._enabled && (render.renderbitFlag == 0);
                canPass = canPass && ((render.renderNode.staticMask & staticMask) != 0);
                if (canPass) {
                    Laya.Stat.frustumCulling++;
                    if (!cameraCullInfo.useOcclusionCulling || render._needRender(boundFrustum, context)) {
                        this.cullList.add(render);
                    }
                }
            }
        }
        cullByShadowCullInfo(cullInfo, renderManager) {
            this._cullList.length = 0;
            var renderList = renderManager.list;
            var renders = renderList.elements;
            for (var i = 0, n = renderList.length; i < n; i++) {
                var render = renders[i];
                var canPass = render.castShadow && render._enabled && (render.renderbitFlag == 0);
                if (canPass) {
                    Laya.Stat.frustumCulling++;
                    let pass = FrustumCulling.cullingRenderBounds(render.bounds, cullInfo);
                    pass && this._cullList.add(render);
                }
            }
        }
        cullingSpotShadow(cameraCullInfo, renderManager) {
            this._cullList.length = 0;
            let renders = renderManager.list.elements;
            let boundFrustum = cameraCullInfo.boundFrustum;
            let context = RenderContext3D._instance;
            for (let i = 0, n = renderManager.list.length; i < n; i++) {
                let render = renders[i];
                let canPass = render.castShadow && render._enabled && (render.renderbitFlag == 0);
                if (canPass) {
                    Laya.Stat.frustumCulling++;
                    if (render._needRender(boundFrustum, context))
                        this._cullList.add(render);
                }
            }
        }
    }

    class BVHCullPass extends CullPassBase {
        constructor() {
            super(...arguments);
            this._cullList = new Laya.SingletonList();
        }
        get cullList() {
            return this._cullList;
        }
        cullByCameraCullInfo(cameraCullInfo, renderManager) {
            this._cullList.length = 0;
            renderManager.bvhSpatial.getItemByCameraCullInfo(cameraCullInfo, this._cullList);
            var renderList = renderManager.otherList;
            var renders = renderList.elements;
            var boundFrustum = cameraCullInfo.boundFrustum;
            var cullMask = cameraCullInfo.cullingMask;
            let staticMask = cameraCullInfo.staticMask;
            let context = RenderContext3D._instance;
            for (var i = 0, n = renderList.length; i < n; i++) {
                var render = renders[i];
                var canPass;
                canPass = (Math.pow(2, render.renderNode.layer) & cullMask) != 0 && render._enabled && (render.renderbitFlag == 0);
                canPass = canPass && ((render.renderNode.staticMask & staticMask) != 0);
                if (canPass) {
                    Laya.Stat.frustumCulling++;
                    if (!cameraCullInfo.useOcclusionCulling || render._needRender(boundFrustum, context)) {
                        this.cullList.add(render);
                    }
                }
            }
        }
        cullByShadowCullInfo(cullInfo, renderManager) {
            this._cullList.length = 0;
            renderManager.bvhSpatial.getItemBySCI(cullInfo, this._cullList);
            var renderList = renderManager.otherList;
            var renders = renderList.elements;
            for (var i = 0, n = renderList.length; i < n; i++) {
                var render = renders[i];
                var canPass = render.castShadow && render._enabled && (render.renderbitFlag == 0);
                if (canPass) {
                    Laya.Stat.frustumCulling++;
                    let pass = FrustumCulling.cullingRenderBounds(render.bounds, cullInfo);
                    pass && this._cullList.add(render);
                }
            }
        }
        cullingSpotShadow(cameraCullInfo, renderManager) {
        }
    }

    exports.FogMode = void 0;
    (function (FogMode) {
        FogMode[FogMode["Linear"] = 0] = "Linear";
        FogMode[FogMode["EXP"] = 1] = "EXP";
        FogMode[FogMode["EXP2"] = 2] = "EXP2";
    })(exports.FogMode || (exports.FogMode = {}));
    class Scene3D extends Laya.Sprite {
        constructor() {
            super();
            this._reflectionsSource = 0;
            this._reflectionsResolution = "256";
            this._reflectionsIblSamples = 128;
            this._lightCount = 0;
            this._pointLights = new LightQueue();
            this._spotLights = new LightQueue();
            this._directionLights = new LightQueue();
            this._alternateLights = new AlternateLightQueue();
            this._lightmaps = [];
            this._skyRenderer = new SkyRenderer();
            this._time = 0;
            this._sunColor = new Laya.Color(1.0, 1.0, 1.0);
            this._sundir = new Laya.Vector3();
            this._id = Scene3D.sceneID++;
            this._physicsdisableSimulation = false;
            this._collsionTestList = [];
            this._key = new Laya.SubmitKey();
            this._opaqueQueue = Laya.LayaGL.renderOBJCreate.createBaseRenderQueue(false);
            this._transparentQueue = Laya.LayaGL.renderOBJCreate.createBaseRenderQueue(true);
            this._cameraPool = [];
            this._UI3DManager = new UI3DManager();
            this.currentCreationLayer = Math.pow(2, 0);
            this.enableLight = true;
            this._ShadowMapupdateFrequency = 1;
            this._is3D = true;
            this._componentDriver = new Laya.ComponentDriver();
            this._timer = Laya.ILaya.timer;
            if (Laya.LayaEnv.isConch && !window.conchConfig.conchWebGL) {
                this._nativeObj = new window.conchSubmitScene3D(this.renderSubmit.bind(this));
            }
            if (Physics3D._bullet)
                this._physicsSimulation = new PhysicsSimulation(Scene3D.physicsSettings);
            this._shaderValues = Laya.LayaGL.renderOBJCreate.createShaderData(null);
            this._shaderValues._defineDatas.addDefineDatas(Laya.Shader3D._configDefineValues);
            if (Laya.Config3D._uniformBlock) {
                this._sceneUniformObj = Laya.UniformBufferObject.getBuffer(Laya.UniformBufferObject.UBONAME_SCENE, 0);
                this._sceneUniformData = Scene3D.createSceneUniformBlock();
                if (!this._sceneUniformObj) {
                    this._sceneUniformObj = Laya.UniformBufferObject.create(Laya.UniformBufferObject.UBONAME_SCENE, Laya.BufferUsage.Dynamic, this._sceneUniformData.getbyteLength(), true);
                }
                this._shaderValues._addCheckUBO(Laya.UniformBufferObject.UBONAME_SCENE, this._sceneUniformObj, this._sceneUniformData);
                this._shaderValues.setUniformBuffer(Scene3D.SCENEUNIFORMBLOCK, this._sceneUniformObj);
                this._shaderValues._addCheckUBO(Laya.UniformBufferObject.UBONAME_SHADOW, Scene3D._shadowCasterPass._castDepthBufferOBJ, Scene3D._shadowCasterPass._castDepthBufferData);
                this._shaderValues.setUniformBuffer(Laya.Shader3D.propertyNameToID(Laya.UniformBufferObject.UBONAME_SHADOW), Scene3D._shadowCasterPass._castDepthBufferOBJ);
            }
            this._fogParams = new Laya.Vector4(300, 1000, 0.01, 0);
            this.enableFog = false;
            this.fogStart = 300;
            this.fogEnd = 1000;
            this.fogDensity = 0.01;
            this.fogColor = new Laya.Color(0.7, 0.7, 0.7);
            this.fogMode = exports.FogMode.Linear;
            this.GIRotate = 0;
            this._scene = this;
            if (Laya.Config3D.useBVHCull) {
                let bvhConfig = new BVHSpatialConfig();
                bvhConfig.Min_BVH_Build_Nums = Laya.Config3D.BVH_Min_Build_nums;
                bvhConfig.limit_size = Laya.Config3D.BVH_limit_size;
                bvhConfig.max_SpatialCount = Laya.Config3D.BVH_max_SpatialCount;
                this._sceneRenderManager = new BVHSceneRenderManager(bvhConfig);
                this._cullPass = new BVHCullPass();
            }
            else {
                this._sceneRenderManager = new SceneRenderManager();
                this._cullPass = Laya.LayaGL.renderOBJCreate.createCullPass();
            }
            if (Laya.Config3D.debugFrustumCulling) ;
            this._volumeManager = new VolumeManager();
            this._UI3DManager = new UI3DManager();
            this.sceneReflectionProb = this._volumeManager.reflectionProbeManager.sceneReflectionProbe;
            this._sceneReflectionProb.reflectionIntensity = 1.0;
            this.ambientColor = new Laya.Color(0.212, 0.227, 0.259);
        }
        static set _updateMark(value) {
            Scene3D.__updateMark = value;
        }
        static get _updateMark() {
            return Scene3D.__updateMark;
        }
        static shaderValueInit() {
            Scene3DShaderDeclaration.SHADERDEFINE_FOG = Laya.Shader3D.getDefineByName("FOG");
            Scene3DShaderDeclaration.SHADERDEFINE_FOG_LINEAR = Laya.Shader3D.getDefineByName("FOG_LINEAR");
            Scene3DShaderDeclaration.SHADERDEFINE_FOG_EXP = Laya.Shader3D.getDefineByName("FOG_EXP");
            Scene3DShaderDeclaration.SHADERDEFINE_FOG_EXP2 = Laya.Shader3D.getDefineByName("FOG_EXP2");
            Scene3DShaderDeclaration.SHADERDEFINE_DIRECTIONLIGHT = Laya.Shader3D.getDefineByName("DIRECTIONLIGHT");
            Scene3DShaderDeclaration.SHADERDEFINE_POINTLIGHT = Laya.Shader3D.getDefineByName("POINTLIGHT");
            Scene3DShaderDeclaration.SHADERDEFINE_SPOTLIGHT = Laya.Shader3D.getDefineByName("SPOTLIGHT");
            Scene3DShaderDeclaration.SHADERDEFINE_SHADOW = Laya.Shader3D.getDefineByName("SHADOW");
            Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_CASCADE = Laya.Shader3D.getDefineByName("SHADOW_CASCADE");
            Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_SOFT_SHADOW_LOW = Laya.Shader3D.getDefineByName("SHADOW_SOFT_SHADOW_LOW");
            Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_SOFT_SHADOW_HIGH = Laya.Shader3D.getDefineByName("SHADOW_SOFT_SHADOW_HIGH");
            Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_SPOT = Laya.Shader3D.getDefineByName("SHADOW_SPOT");
            Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_SPOT_SOFT_SHADOW_LOW = Laya.Shader3D.getDefineByName("SHADOW_SPOT_SOFT_SHADOW_LOW");
            Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_SPOT_SOFT_SHADOW_HIGH = Laya.Shader3D.getDefineByName("SHADOW_SPOT_SOFT_SHADOW_HIGH");
            Scene3D.FOGCOLOR = Laya.Shader3D.propertyNameToID("u_FogColor");
            Scene3D.FOGPARAMS = Laya.Shader3D.propertyNameToID("u_FogParams");
            Scene3D.DIRECTIONLIGHTCOUNT = Laya.Shader3D.propertyNameToID("u_DirationLightCount");
            Scene3D.LIGHTBUFFER = Laya.Shader3D.propertyNameToID("u_LightBuffer");
            Scene3D.CLUSTERBUFFER = Laya.Shader3D.propertyNameToID("u_LightClusterBuffer");
            Scene3D.TIME = Laya.Shader3D.propertyNameToID("u_Time");
            Scene3D.GIRotate = Laya.Shader3D.propertyNameToID("u_GIRotate");
            Scene3D.SCENEUNIFORMBLOCK = Laya.Shader3D.propertyNameToID(Laya.UniformBufferObject.UBONAME_SCENE);
            let sceneUniformMap = Scene3D.sceneUniformMap = Laya.LayaGL.renderOBJCreate.createGlobalUniformMap("Scene3D");
            sceneUniformMap.addShaderUniform(Scene3D.FOGCOLOR, "u_FogColor");
            sceneUniformMap.addShaderUniform(Scene3D.FOGPARAMS, "u_FogParams");
            sceneUniformMap.addShaderUniform(Scene3D.DIRECTIONLIGHTCOUNT, "u_DirationLightCount");
            sceneUniformMap.addShaderUniform(Scene3D.LIGHTBUFFER, "u_LightBuffer");
            sceneUniformMap.addShaderUniform(Scene3D.CLUSTERBUFFER, "u_LightClusterBuffer");
            sceneUniformMap.addShaderUniform(Scene3D.TIME, "u_Time");
            sceneUniformMap.addShaderUniform(Scene3D.GIRotate, "u_GIRotate");
            sceneUniformMap.addShaderUniform(Scene3D.SCENEUNIFORMBLOCK, Laya.UniformBufferObject.UBONAME_SCENE);
        }
        static legacyLightingValueInit() {
            Scene3D.LIGHTDIRECTION = Laya.Shader3D.propertyNameToID("u_DirectionLight.direction");
            Scene3D.sceneUniformMap.addShaderUniform(Scene3D.LIGHTDIRECTION, "u_DirectionLight.direction");
            Scene3D.LIGHTDIRCOLOR = Laya.Shader3D.propertyNameToID("u_DirectionLight.color");
            Scene3D.sceneUniformMap.addShaderUniform(Scene3D.LIGHTDIRCOLOR, "u_DirectionLight.color");
            Scene3D.POINTLIGHTPOS = Laya.Shader3D.propertyNameToID("u_PointLight.position");
            Scene3D.sceneUniformMap.addShaderUniform(Scene3D.POINTLIGHTPOS, "u_PointLight.position");
            Scene3D.POINTLIGHTRANGE = Laya.Shader3D.propertyNameToID("u_PointLight.range");
            Scene3D.sceneUniformMap.addShaderUniform(Scene3D.POINTLIGHTRANGE, "u_PointLight.range");
            Scene3D.POINTLIGHTATTENUATION = Laya.Shader3D.propertyNameToID("u_PointLight.attenuation");
            Scene3D.sceneUniformMap.addShaderUniform(Scene3D.POINTLIGHTATTENUATION, "u_PointLight.attenuation");
            Scene3D.POINTLIGHTCOLOR = Laya.Shader3D.propertyNameToID("u_PointLight.color");
            Scene3D.sceneUniformMap.addShaderUniform(Scene3D.POINTLIGHTCOLOR, "u_PointLight.color");
            Scene3D.SPOTLIGHTPOS = Laya.Shader3D.propertyNameToID("u_SpotLight.position");
            Scene3D.sceneUniformMap.addShaderUniform(Scene3D.SPOTLIGHTPOS, "u_SpotLight.position");
            Scene3D.SPOTLIGHTDIRECTION = Laya.Shader3D.propertyNameToID("u_SpotLight.direction");
            Scene3D.sceneUniformMap.addShaderUniform(Scene3D.SPOTLIGHTDIRECTION, "u_DirectionLight.direction");
            Scene3D.SPOTLIGHTSPOTANGLE = Laya.Shader3D.propertyNameToID("u_SpotLight.spot");
            Scene3D.sceneUniformMap.addShaderUniform(Scene3D.SPOTLIGHTSPOTANGLE, "u_SpotLight.spot");
            Scene3D.SPOTLIGHTRANGE = Laya.Shader3D.propertyNameToID("u_SpotLight.range");
            Scene3D.sceneUniformMap.addShaderUniform(Scene3D.SPOTLIGHTRANGE, "u_SpotLight.range");
            Scene3D.SPOTLIGHTCOLOR = Laya.Shader3D.propertyNameToID("u_SpotLight.color");
            Scene3D.sceneUniformMap.addShaderUniform(Scene3D.SPOTLIGHTCOLOR, "u_SpotLight.color");
        }
        static createSceneUniformBlock() {
            if (!Scene3D.SceneUBOData) {
                let uniformpara = new Map();
                uniformpara.set("u_Time", Laya.UniformBufferParamsType.Number);
                uniformpara.set("u_FogParams", Laya.UniformBufferParamsType.Vector4);
                uniformpara.set("u_FogColor", Laya.UniformBufferParamsType.Vector4);
                let uniformMap = new Map();
                uniformpara.forEach((value, key) => {
                    uniformMap.set(Laya.Shader3D.propertyNameToID(key), value);
                });
                Scene3D.SceneUBOData = new Laya.UnifromBufferData(uniformMap);
            }
            return Scene3D.SceneUBOData;
        }
        static __init__() {
            var multiLighting = Laya.Config3D._multiLighting;
            if (multiLighting) {
                const width = 4;
                var maxLightCount = Laya.Config3D.maxLightCount;
                var clusterSlices = Laya.Config3D.lightClusterCount;
                Cluster.instance = new Cluster(clusterSlices.x, clusterSlices.y, clusterSlices.z, Math.min(Laya.Config3D.maxLightCount, Laya.Config3D._maxAreaLightCountPerClusterAverage));
                Scene3D._lightTexture = Utils3D._createFloatTextureBuffer(width, maxLightCount);
                Scene3D._lightTexture.lock = true;
                Scene3D._lightPixles = new Float32Array(maxLightCount * width * 4);
            }
            Scene3D.shaderValueInit();
            var configShaderValue = Laya.Shader3D._configDefineValues;
            if (!Laya.Config3D._multiLighting) {
                (configShaderValue.add(Laya.Shader3D.SHADERDEFINE_LEGACYSINGALLIGHTING));
                Scene3D.legacyLightingValueInit();
            }
            Scene3D._shadowCasterPass = new ShadowCasterPass();
            if (Laya.LayaGL.renderEngine.getCapable(Laya.RenderCapable.GRAPHICS_API_GLES3) && Laya.WebGL._isWebGL2)
                configShaderValue.add(Laya.Shader3D.SHADERDEFINE_GRAPHICS_API_GLES3);
            else
                configShaderValue.add(Laya.Shader3D.SHADERDEFINE_GRAPHICS_API_GLES2);
            if (Laya.Config3D._uniformBlock)
                configShaderValue.add(Laya.Shader3D.SHADERDEFINE_ENUNIFORMBLOCK);
            Physics3D._bullet && (Scene3D.physicsSettings = new PhysicsSettings());
        }
        static load(url, complete) {
            Laya.ILaya.loader.load(url).then((res) => {
                if (complete) {
                    let ret;
                    if (res) {
                        let scene = res.create();
                        if (scene instanceof Laya.Scene)
                            ret = scene._scene3D;
                        else
                            ret = scene;
                    }
                    complete.runWith([ret]);
                }
            });
        }
        set sceneRenderableManager(manager) {
            manager.list = this._sceneRenderManager.list;
            this._sceneRenderManager = manager;
        }
        get sceneRenderableManager() {
            return this._sceneRenderManager;
        }
        set cullPass(cullPass) {
            this._cullPass = cullPass;
        }
        get enableFog() {
            return this._enableFog;
        }
        set enableFog(value) {
            if (this._enableFog !== value) {
                this._enableFog = value;
                if (value) {
                    this._shaderValues.addDefine(Scene3DShaderDeclaration.SHADERDEFINE_FOG);
                }
                else
                    this._shaderValues.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_FOG);
            }
        }
        get fogMode() {
            return this._fogMode;
        }
        set fogMode(value) {
            this._fogMode = value;
            switch (value) {
                case exports.FogMode.Linear:
                    this._shaderValues.addDefine(Scene3DShaderDeclaration.SHADERDEFINE_FOG_LINEAR);
                    this._shaderValues.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_FOG_EXP);
                    this._shaderValues.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_FOG_EXP2);
                    break;
                case exports.FogMode.EXP:
                    this._shaderValues.addDefine(Scene3DShaderDeclaration.SHADERDEFINE_FOG_EXP);
                    this._shaderValues.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_FOG_LINEAR);
                    this._shaderValues.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_FOG_EXP2);
                    break;
                case exports.FogMode.EXP2:
                    this._shaderValues.addDefine(Scene3DShaderDeclaration.SHADERDEFINE_FOG_EXP2);
                    this._shaderValues.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_FOG_LINEAR);
                    this._shaderValues.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_FOG_EXP);
                    break;
            }
        }
        get fogColor() {
            return this._shaderValues.getColor(Scene3D.FOGCOLOR);
        }
        set fogColor(value) {
            this._shaderValues.setColor(Scene3D.FOGCOLOR, value);
        }
        get fogStart() {
            return this._fogParams.x;
        }
        set fogStart(value) {
            this._fogParams.x = value;
            this.fogParams = this._fogParams;
        }
        get fogEnd() {
            return this._fogParams.y;
        }
        set fogEnd(value) {
            this._fogParams.y = value;
            this.fogParams = this._fogParams;
        }
        get fogDensity() {
            return this._fogParams.z;
        }
        set fogDensity(value) {
            this._fogParams.z = value;
            this.fogParams = this._fogParams;
        }
        get fogParams() {
            return this._shaderValues.getVector(Scene3D.FOGPARAMS);
        }
        set fogParams(value) {
            this._shaderValues.setVector(Scene3D.FOGPARAMS, value);
        }
        set GIRotate(value) {
            this._shaderValues.setNumber(Scene3D.GIRotate, value);
        }
        get GIRotate() {
            return this._shaderValues.getNumber(Scene3D.GIRotate);
        }
        get ambientMode() {
            return this._sceneReflectionProb.ambientMode;
        }
        set ambientMode(value) {
            this._sceneReflectionProb.ambientMode = value;
        }
        get sceneReflectionProb() {
            return this._sceneReflectionProb;
        }
        set sceneReflectionProb(value) {
            this._sceneReflectionProb = value;
        }
        get ambientColor() {
            return this._sceneReflectionProb.ambientColor;
        }
        set ambientColor(value) {
            this._sceneReflectionProb.ambientColor = value;
        }
        get ambientIntensity() {
            return this._sceneReflectionProb.ambientIntensity;
        }
        set ambientIntensity(value) {
            this._sceneReflectionProb.ambientIntensity = value;
        }
        get reflectionIntensity() {
            return this._sceneReflectionProb.reflectionIntensity;
        }
        set reflectionIntensity(value) {
            this._sceneReflectionProb.reflectionIntensity = value;
        }
        get ambientSH() {
            return this._sceneReflectionProb.ambientSH;
        }
        set ambientSH(value) {
            this._sceneReflectionProb.ambientSH = value;
        }
        get iblTex() {
            return this._sceneReflectionProb.iblTex;
        }
        set iblTex(value) {
            this._sceneReflectionProb.iblTex = value;
        }
        get iblTexRGBD() {
            return this._sceneReflectionProb.iblTexRGBD;
        }
        set iblTexRGBD(value) {
            this._sceneReflectionProb.iblTexRGBD = value;
        }
        get skyRenderer() {
            return this._skyRenderer;
        }
        get physicsSimulation() {
            return this._physicsSimulation;
        }
        get timer() {
            return this._timer;
        }
        set timer(value) {
            this._timer = value;
        }
        get lightmaps() {
            return this._lightmaps.slice();
        }
        set lightmaps(value) {
            var maps = this._lightmaps;
            if (maps) {
                for (var i = 0, n = maps.length; i < n; i++) {
                    var map = maps[i];
                    map.lightmapColor && map.lightmapColor._removeReference();
                    map.lightmapDirection && map.lightmapDirection._removeReference();
                }
            }
            if (value) {
                var count = value.length;
                maps.length = count;
                for (i = 0; i < count; i++) {
                    var map = value[i];
                    map.lightmapColor && map.lightmapColor._addReference();
                    map.lightmapDirection && map.lightmapDirection._addReference();
                    maps[i] = map;
                }
            }
            else {
                maps.length = 0;
            }
        }
        get shadowMapFrequency() {
            return this._ShadowMapupdateFrequency;
        }
        set shadowMapFrequency(value) {
            this._ShadowMapupdateFrequency = value;
        }
        _update() {
            var delta = this.timer._delta / 1000;
            this._time += delta;
            this._shaderValues.setNumber(Scene3D.TIME, this._time);
            let simulation = this._physicsSimulation;
            if (Laya.LayaEnv.isPlaying) {
                if (Physics3D._enablePhysics && !PhysicsSimulation.disableSimulation && Laya.Stat.enablePhysicsUpdate) {
                    simulation._updatePhysicsTransformFromRender();
                    PhysicsComponent._addUpdateList = false;
                    simulation._simulate(delta);
                    simulation._updateCharacters();
                    PhysicsComponent._addUpdateList = true;
                    simulation._updateCollisions();
                    simulation.dispatchCollideEvent();
                }
            }
            if (this._volumeManager.needreCaculateAllRenderObjects())
                this._volumeManager.reCaculateAllRenderObjects(this._sceneRenderManager.list);
            else
                this._volumeManager.handleMotionlist();
            this._componentDriver.callStart();
            this._componentDriver.callUpdate();
            this._componentDriver.callLateUpdate();
            this._componentDriver.callDestroy();
            this._sceneRenderManager.updateMotionObjects();
            this._UI3DManager.update();
        }
        _binarySearchIndexInCameraPool(camera) {
            var start = 0;
            var end = this._cameraPool.length - 1;
            var mid;
            while (start <= end) {
                mid = Math.floor((start + end) / 2);
                var midValue = this._cameraPool[mid]._renderingOrder;
                if (midValue == camera._renderingOrder)
                    return mid;
                else if (midValue > camera._renderingOrder)
                    end = mid - 1;
                else
                    start = mid + 1;
            }
            return start;
        }
        _getGroup() {
            return this._group;
        }
        _setGroup(value) {
            this._group = value;
        }
        _onActive() {
            super._onActive();
            Laya.ILaya.stage._scene3Ds.push(this);
        }
        _onInActive() {
            super._onInActive();
            var scenes = Laya.ILaya.stage._scene3Ds;
            scenes.splice(scenes.indexOf(this), 1);
        }
        _prepareSceneToRender() {
            var shaderValues = this._shaderValues;
            var multiLighting = Laya.Config3D._multiLighting && Laya.Stat.enableMulLight;
            if (multiLighting) {
                var ligTex = Scene3D._lightTexture;
                var ligPix = Scene3D._lightPixles;
                const pixelWidth = ligTex.width;
                const floatWidth = pixelWidth * 4;
                var curCount = 0;
                var dirCount = Laya.Stat.enableLight ? this._directionLights._length : 0;
                var dirElements = this._directionLights._elements;
                if (dirCount > 0) {
                    var sunLightIndex = this._directionLights.getBrightestLight();
                    this._mainDirectionLight = dirElements[sunLightIndex];
                    this._directionLights.normalLightOrdering(sunLightIndex);
                    for (var i = 0; i < dirCount; i++, curCount++) {
                        var dirLight = dirElements[i];
                        var dir = dirLight._direction;
                        var intCor = dirLight._intensityColor;
                        var off = floatWidth * curCount;
                        intCor.x = Laya.Color.gammaToLinearSpace(dirLight.color.r);
                        intCor.y = Laya.Color.gammaToLinearSpace(dirLight.color.g);
                        intCor.z = Laya.Color.gammaToLinearSpace(dirLight.color.b);
                        Laya.Vector3.scale(intCor, dirLight._intensity, intCor);
                        dirLight.owner.transform.worldMatrix.getForward(dir);
                        Laya.Vector3.normalize(dir, dir);
                        ligPix[off] = intCor.x;
                        ligPix[off + 1] = intCor.y;
                        ligPix[off + 2] = intCor.z;
                        ligPix[off + 3] = dirLight._lightmapBakedType;
                        ligPix[off + 4] = dir.x;
                        ligPix[off + 5] = dir.y;
                        ligPix[off + 6] = dir.z;
                        if (i == 0) {
                            this._sunColor = dirLight.color;
                            this._sundir = dir;
                        }
                    }
                    shaderValues.addDefine(Scene3DShaderDeclaration.SHADERDEFINE_DIRECTIONLIGHT);
                }
                else {
                    shaderValues.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_DIRECTIONLIGHT);
                }
                var poiCount = Laya.Stat.enableLight ? this._pointLights._length : 0;
                if (poiCount > 0) {
                    var poiElements = this._pointLights._elements;
                    var mainPointLightIndex = this._pointLights.getBrightestLight();
                    this._mainPointLight = poiElements[mainPointLightIndex];
                    this._pointLights.normalLightOrdering(mainPointLightIndex);
                    for (var i = 0; i < poiCount; i++, curCount++) {
                        var poiLight = poiElements[i];
                        var pos = poiLight.owner.transform.position;
                        var intCor = poiLight._intensityColor;
                        var off = floatWidth * curCount;
                        intCor.x = Laya.Color.gammaToLinearSpace(poiLight.color.r);
                        intCor.y = Laya.Color.gammaToLinearSpace(poiLight.color.g);
                        intCor.z = Laya.Color.gammaToLinearSpace(poiLight.color.b);
                        Laya.Vector3.scale(intCor, poiLight._intensity, intCor);
                        ligPix[off] = intCor.x;
                        ligPix[off + 1] = intCor.y;
                        ligPix[off + 2] = intCor.z;
                        ligPix[off + 3] = poiLight.range;
                        ligPix[off + 4] = pos.x;
                        ligPix[off + 5] = pos.y;
                        ligPix[off + 6] = pos.z;
                        ligPix[off + 7] = poiLight._lightmapBakedType;
                    }
                    shaderValues.addDefine(Scene3DShaderDeclaration.SHADERDEFINE_POINTLIGHT);
                }
                else {
                    shaderValues.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_POINTLIGHT);
                }
                var spoCount = Laya.Stat.enableLight ? this._spotLights._length : 0;
                if (spoCount > 0) {
                    var spoElements = this._spotLights._elements;
                    var mainSpotLightIndex = this._spotLights.getBrightestLight();
                    this._mainSpotLight = spoElements[mainSpotLightIndex];
                    this._spotLights.normalLightOrdering(mainSpotLightIndex);
                    for (var i = 0; i < spoCount; i++, curCount++) {
                        var spoLight = spoElements[i];
                        var dir = spoLight._direction;
                        var pos = spoLight.owner.transform.position;
                        var intCor = spoLight._intensityColor;
                        var off = floatWidth * curCount;
                        intCor.x = Laya.Color.gammaToLinearSpace(spoLight.color.r);
                        intCor.y = Laya.Color.gammaToLinearSpace(spoLight.color.g);
                        intCor.z = Laya.Color.gammaToLinearSpace(spoLight.color.b);
                        Laya.Vector3.scale(intCor, spoLight._intensity, intCor);
                        spoLight.owner.transform.worldMatrix.getForward(dir);
                        Laya.Vector3.normalize(dir, dir);
                        ligPix[off] = intCor.x;
                        ligPix[off + 1] = intCor.y;
                        ligPix[off + 2] = intCor.z;
                        ligPix[off + 3] = spoLight.range;
                        ligPix[off + 4] = pos.x;
                        ligPix[off + 5] = pos.y;
                        ligPix[off + 6] = pos.z;
                        ligPix[off + 7] = spoLight.spotAngle * Math.PI / 180;
                        ligPix[off + 8] = dir.x;
                        ligPix[off + 9] = dir.y;
                        ligPix[off + 10] = dir.z;
                        ligPix[off + 11] = spoLight._lightmapBakedType;
                    }
                    shaderValues.addDefine(Scene3DShaderDeclaration.SHADERDEFINE_SPOTLIGHT);
                }
                else {
                    shaderValues.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_SPOTLIGHT);
                }
                (curCount > 0) && (ligTex.setSubPixelsData(0, 0, pixelWidth, curCount, ligPix, 0, false, false, false));
                shaderValues.setTexture(Scene3D.LIGHTBUFFER, ligTex);
                shaderValues.setInt(Scene3D.DIRECTIONLIGHTCOUNT, this._directionLights._length);
                shaderValues.setTexture(Scene3D.CLUSTERBUFFER, Cluster.instance._clusterTexture);
            }
            else {
                if (this._directionLights._length > 0 && Laya.Stat.enableLight) {
                    var dirLight = this._directionLights._elements[0];
                    this._mainDirectionLight = dirLight;
                    dirLight._intensityColor.x = Laya.Color.gammaToLinearSpace(dirLight.color.r);
                    dirLight._intensityColor.y = Laya.Color.gammaToLinearSpace(dirLight.color.g);
                    dirLight._intensityColor.z = Laya.Color.gammaToLinearSpace(dirLight.color.b);
                    Laya.Vector3.scale(dirLight._intensityColor, dirLight._intensity, dirLight._intensityColor);
                    dirLight.owner.transform.worldMatrix.getForward(dirLight._direction);
                    Laya.Vector3.normalize(dirLight._direction, dirLight._direction);
                    shaderValues.setVector3(Scene3D.LIGHTDIRCOLOR, dirLight._intensityColor);
                    shaderValues.setVector3(Scene3D.LIGHTDIRECTION, dirLight._direction);
                    if (i == 0) {
                        this._sunColor = dirLight.color;
                        this._sundir = dirLight._direction;
                    }
                    shaderValues.addDefine(Scene3DShaderDeclaration.SHADERDEFINE_DIRECTIONLIGHT);
                }
                else {
                    shaderValues.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_DIRECTIONLIGHT);
                }
                if (this._pointLights._length > 0 && Laya.Stat.enableLight) {
                    var poiLight = this._pointLights._elements[0];
                    this._mainPointLight = poiLight;
                    poiLight._intensityColor.x = Laya.Color.gammaToLinearSpace(poiLight.color.r);
                    poiLight._intensityColor.y = Laya.Color.gammaToLinearSpace(poiLight.color.g);
                    poiLight._intensityColor.z = Laya.Color.gammaToLinearSpace(poiLight.color.b);
                    Laya.Vector3.scale(poiLight._intensityColor, poiLight._intensity, poiLight._intensityColor);
                    shaderValues.setVector3(Scene3D.POINTLIGHTCOLOR, poiLight._intensityColor);
                    shaderValues.setVector3(Scene3D.POINTLIGHTPOS, poiLight.owner.transform.position);
                    shaderValues.setNumber(Scene3D.POINTLIGHTRANGE, poiLight.range);
                    shaderValues.addDefine(Scene3DShaderDeclaration.SHADERDEFINE_POINTLIGHT);
                }
                else {
                    shaderValues.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_POINTLIGHT);
                }
                if (this._spotLights._length > 0 && Laya.Stat.enableLight) {
                    var spotLight = this._spotLights._elements[0];
                    this._mainSpotLight = spotLight;
                    spotLight._intensityColor.x = Laya.Color.gammaToLinearSpace(spotLight.color.r);
                    spotLight._intensityColor.y = Laya.Color.gammaToLinearSpace(spotLight.color.g);
                    spotLight._intensityColor.z = Laya.Color.gammaToLinearSpace(spotLight.color.b);
                    Laya.Vector3.scale(spotLight._intensityColor, spotLight._intensity, spotLight._intensityColor);
                    shaderValues.setVector3(Scene3D.SPOTLIGHTCOLOR, spotLight._intensityColor);
                    shaderValues.setVector3(Scene3D.SPOTLIGHTPOS, spotLight.owner.transform.position);
                    spotLight.owner.transform.worldMatrix.getForward(spotLight._direction);
                    Laya.Vector3.normalize(spotLight._direction, spotLight._direction);
                    shaderValues.setVector3(Scene3D.SPOTLIGHTDIRECTION, spotLight._direction);
                    shaderValues.setNumber(Scene3D.SPOTLIGHTRANGE, spotLight.range);
                    shaderValues.setNumber(Scene3D.SPOTLIGHTSPOTANGLE, spotLight.spotAngle * Math.PI / 180);
                    shaderValues.addDefine(Scene3DShaderDeclaration.SHADERDEFINE_SPOTLIGHT);
                }
                else {
                    shaderValues.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_SPOTLIGHT);
                }
            }
        }
        get cullInfoCamera() {
            return this._cullInfoCamera;
        }
        _setCullCamera(camera) {
            this._cullInfoCamera = camera;
        }
        recaculateCullCamera() {
            this._cullInfoCamera = this._cameraPool[0];
            this._cameraPool.forEach(element => {
                if (this.cullInfoCamera.maxlocalYDistance < element.maxlocalYDistance) {
                    this._cullInfoCamera = element;
                }
            });
        }
        _addCamera(camera) {
            var index = this._binarySearchIndexInCameraPool(camera);
            var order = camera._renderingOrder;
            var count = this._cameraPool.length;
            while (index < count && this._cameraPool[index]._renderingOrder <= order)
                index++;
            this._cameraPool.splice(index, 0, camera);
        }
        _removeCamera(camera) {
            this._cameraPool.splice(this._cameraPool.indexOf(camera), 1);
        }
        _preCulling(context, camera) {
            this._clearRenderQueue();
            var cameraCullInfo = FrustumCulling._cameraCullInfo;
            var cameraPos = cameraCullInfo.position = camera._transform.position;
            cameraCullInfo.cullingMask = camera.cullingMask;
            cameraCullInfo.staticMask = camera.staticMask;
            cameraCullInfo.boundFrustum = camera.boundFrustum;
            cameraCullInfo.useOcclusionCulling = camera.useOcclusionCulling;
            this._cullPass.cullByCameraCullInfo(cameraCullInfo, this.sceneRenderableManager);
            let list = this._cullPass.cullList;
            let element = list.elements;
            for (let i = 0; i < list.length; i++) {
                let render = element[i];
                render.distanceForSort = Laya.Vector3.distance(render.bounds.getCenter(), cameraPos);
                var elements = render._renderElements;
                for (var j = 0, m = elements.length; j < m; j++)
                    elements[j]._update(this, context, context.customShader, context.replaceTag);
            }
        }
        _directLightShadowCull(cullInfo, context) {
            this._clearRenderQueue();
            const position = cullInfo.position;
            this._cullPass.cullByShadowCullInfo(cullInfo, this.sceneRenderableManager);
            let list = this._cullPass.cullList;
            let element = list.elements;
            for (let i = 0; i < list.length; i++) {
                let render = element[i];
                render.distanceForSort = Laya.Vector3.distance(render.bounds.getCenter(), position);
                var elements = render._renderElements;
                for (var j = 0, m = elements.length; j < m; j++)
                    elements[j]._update(this, context, null, null);
            }
        }
        _sportLightShadowCull(cameraCullInfo, context) {
            this._clearRenderQueue();
            this._cullPass.cullingSpotShadow(cameraCullInfo, this.sceneRenderableManager);
            let list = this._cullPass.cullList;
            let element = list.elements;
            for (var i = 0, n = list.length; i < n; i++) {
                var render = element[i];
                render.distanceForSort = Laya.Vector3.distance(render.bounds.getCenter(), cameraCullInfo.position);
                var elements = render._renderElements;
                for (var j = 0, m = elements.length; j < m; j++)
                    elements[j]._update(this, context, null, null);
            }
        }
        _clear(state) {
            var viewport = state.viewport;
            var camera = state.camera;
            var renderTex = camera._getRenderTexture();
            var vpX, vpY;
            var vpW = viewport.width;
            var vpH = viewport.height;
            let needInternalRT = camera._needInternalRenderTexture();
            if (needInternalRT) {
                vpX = 0;
                vpY = 0;
            }
            else {
                if (camera.renderTarget) {
                    vpX = viewport.x;
                    vpY = viewport.y;
                }
                else {
                    vpX = viewport.x;
                    vpY = camera._getCanvasHeight() - viewport.y - vpH;
                }
            }
            Laya.LayaGL.renderEngine.viewport(vpX, vpY, vpW, vpH);
            Laya.LayaGL.renderEngine.scissor(vpX, vpY, vpW, vpH);
            state.changeViewport(vpX, vpY, vpW, vpH);
            state.changeScissor(vpX, vpY, vpW, vpH);
            Camera._context3DViewPortCatch.set(vpX, vpY, vpW, vpH);
            Camera._contextScissorPortCatch.setValue(vpX, vpY, vpW, vpH);
            var clearFlag = camera.clearFlag;
            if (clearFlag === exports.CameraClearFlags.Sky && !(camera.skyRenderer._isAvailable() || this._skyRenderer._isAvailable()))
                clearFlag = exports.CameraClearFlags.SolidColor;
            let clearConst = 0;
            let stencilFlag = renderTex.depthStencilFormat == Laya.RenderTargetFormat.DEPTHSTENCIL_24_8 ? Laya.RenderClearFlag.Stencil : 0;
            switch (clearFlag) {
                case exports.CameraClearFlags.SolidColor:
                    clearConst = Laya.RenderClearFlag.Color | Laya.RenderClearFlag.Depth | stencilFlag;
                    break;
                case exports.CameraClearFlags.DepthOnly:
                case exports.CameraClearFlags.Sky:
                    clearConst = Laya.RenderClearFlag.Depth | stencilFlag;
                    break;
                case exports.CameraClearFlags.Nothing:
                    clearConst = 0;
                    break;
                case exports.CameraClearFlags.ColorOnly:
                    clearConst = Laya.RenderClearFlag.Color;
                    break;
            }
            Laya.LayaGL.renderEngine.clearRenderTexture(clearConst, camera._linearClearColor, 1);
        }
        _renderScene(context, renderFlag) {
            var camera = context.camera;
            switch (renderFlag) {
                case Scene3D.SCENERENDERFLAG_RENDERQPAQUE:
                    Laya.Stat.opaqueDrawCall += this._opaqueQueue.renderQueue(context);
                    break;
                case Scene3D.SCENERENDERFLAG_SKYBOX:
                    if (camera.clearFlag === exports.CameraClearFlags.Sky) {
                        if (camera.skyRenderer._isAvailable())
                            camera.skyRenderer._render(context);
                        else if (this._skyRenderer._isAvailable())
                            this._skyRenderer._render(context);
                    }
                    break;
                case Scene3D.SCENERENDERFLAG_RENDERTRANSPARENT:
                    Laya.Stat.transDrawCall += this._transparentQueue.renderQueue(context);
                    if (Laya.Config3D.debugFrustumCulling) ;
                    break;
            }
        }
        _parse(data, spriteMap) {
            var lightMapsData = data.lightmaps;
            if (lightMapsData) {
                var lightMapCount = lightMapsData.length;
                var lightmaps = new Array(lightMapCount);
                for (var i = 0; i < lightMapCount; i++) {
                    var lightMap = new Lightmap();
                    var lightMapData = lightMapsData[i];
                    if (lightMapData.path) {
                        lightMap.lightmapColor = Laya.Loader.getTexture2D(lightMapData.path);
                    }
                    else {
                        lightMap.lightmapColor = Laya.Loader.getTexture2D(lightMapData.color.path);
                        if (lightMapData.direction)
                            lightMap.lightmapDirection = Laya.Loader.getTexture2D(lightMapData.direction.path);
                    }
                    lightmaps[i] = lightMap;
                }
                this.lightmaps = lightmaps;
            }
            var skyData = data.sky;
            if (skyData) {
                this._skyRenderer.material = Laya.Loader.getRes(skyData.material.path);
                switch (skyData.mesh) {
                    case "SkyBox":
                        this._skyRenderer.mesh = SkyBox.instance;
                        break;
                    case "SkyDome":
                        this._skyRenderer.mesh = SkyDome.instance;
                        break;
                    default:
                        this.skyRenderer.mesh = SkyBox.instance;
                }
            }
            this.enableFog = data.enableFog;
            this.fogStart = data.fogStart;
            this.fogEnd = data.fogEnd;
            this.fogDensity = data.fogDensity;
            var fogColorData = data.fogColor;
            if (fogColorData) {
                var fogCol = this.fogColor;
                fogCol.fromArray(fogColorData);
                this.fogColor = fogCol;
            }
            var ambientModeData = data.ambientMode;
            var ambientColorData = data.ambientColor;
            if (ambientColorData) {
                var ambCol = this.ambientColor;
                ambCol.fromArray(ambientColorData);
                this.ambientColor = ambCol;
            }
            if (ambientModeData == exports.AmbientMode.TripleColor) {
                let ambientSkyColor = data.ambientSkyColor;
                let tempV3sky = new Laya.Vector3();
                tempV3sky.fromArray(ambientSkyColor);
                let ambientEquatorColor = data.ambientEquatorColor;
                let tempV3Equaltor = new Laya.Vector3();
                tempV3Equaltor.fromArray(ambientEquatorColor);
                let ambientGroundColor = data.ambientGroundColor;
                let tempV3Ground = new Laya.Vector3();
                tempV3Ground.fromArray(ambientGroundColor);
                this._sceneReflectionProb.setGradientAmbient(tempV3sky, tempV3Equaltor, tempV3Ground);
            }
            var ambientSphericalHarmonicsData = data.ambientSphericalHarmonics;
            if (ambientSphericalHarmonicsData) {
                var ambientSH = new SphericalHarmonicsL2();
                for (var i = 0; i < 3; i++) {
                    var off = i * 9;
                    ambientSH.setCoefficients(i, ambientSphericalHarmonicsData[off], ambientSphericalHarmonicsData[off + 1], ambientSphericalHarmonicsData[off + 2], ambientSphericalHarmonicsData[off + 3], ambientSphericalHarmonicsData[off + 4], ambientSphericalHarmonicsData[off + 5], ambientSphericalHarmonicsData[off + 6], ambientSphericalHarmonicsData[off + 7], ambientSphericalHarmonicsData[off + 8]);
                }
                this._sceneReflectionProb.ambientSphericalHarmonics = ambientSH;
            }
            (ambientModeData != undefined) && (this.ambientMode = ambientModeData);
            var reflectionData = data.reflection;
            (reflectionData != undefined) && (this._sceneReflectionProb.reflectionTexture = Laya.Loader.getRes(reflectionData));
            var reflectionDecodingFormatData = data.reflectionDecodingFormat;
            (reflectionDecodingFormatData != undefined) && (this._sceneReflectionProb.reflectionDecodingFormat = reflectionDecodingFormatData);
            var ambientSphericalHarmonicsIntensityData = data.ambientSphericalHarmonicsIntensity;
            (ambientSphericalHarmonicsIntensityData != undefined) && (this._sceneReflectionProb.ambientIntensity = ambientSphericalHarmonicsIntensityData);
            var reflectionIntensityData = data.reflectionIntensity;
            (reflectionIntensityData != undefined) && (this._sceneReflectionProb.reflectionIntensity = reflectionIntensityData);
        }
        _addRenderObject(render) {
            this._sceneRenderManager.addRenderObject(render);
            render._addReflectionProbeUpdate();
        }
        _removeRenderObject(render) {
            this._sceneRenderManager.removeRenderObject(render);
        }
        _getRenderQueue(index) {
            if (index <= 2500)
                return this._opaqueQueue;
            else
                return this._transparentQueue;
        }
        _clearRenderQueue() {
            this._opaqueQueue.clear();
            this._transparentQueue.clear();
        }
        destroy(destroyChild = true) {
            if (this._destroyed)
                return;
            super.destroy(destroyChild);
            this._nativeObj = null;
            this._skyRenderer.destroy();
            this._skyRenderer = null;
            this._directionLights = null;
            this._pointLights = null;
            this._spotLights = null;
            this._alternateLights = null;
            this._shaderValues.destroy();
            this._opaqueQueue.destroy();
            this._transparentQueue.destroy();
            (RenderContext3D._instance.scene == this) && (RenderContext3D._instance.scene = null);
            this._shaderValues = null;
            this.sceneRenderableManager.destroy();
            this._sceneRenderManager = null;
            this._cameraPool = null;
            this._physicsSimulation && this._physicsSimulation._destroy();
            var maps = this._lightmaps;
            if (maps) {
                for (var i = 0, n = maps.length; i < n; i++) {
                    var map = maps[i];
                    map.lightmapColor && map.lightmapColor._removeReference();
                    map.lightmapDirection && map.lightmapDirection._removeReference();
                }
            }
            this._lightmaps = null;
            this._volumeManager.destroy();
            this._componentDriver.callDestroy();
        }
        render(ctx) {
            if (this._children.length > 0) {
                ctx.addRenderObject3D(this);
            }
        }
        renderSubmit() {
            Laya.BufferState._curBindedBufferState && Laya.BufferState._curBindedBufferState.unBind();
            this._prepareSceneToRender();
            var i, n;
            Scene3D._updateMark++;
            for (i = 0, n = this._cameraPool.length, n - 1; i < n; i++) {
                var camera = this._cameraPool[i];
                if (camera.renderTarget)
                    (camera.enableBuiltInRenderTexture = false);
                else
                    camera.enableBuiltInRenderTexture = true;
                camera.enableRender && camera.render();
                Scene3D._blitTransRT = null;
                if (camera.enableRender && !camera.renderTarget) {
                    (Scene3D._blitTransRT = camera._internalRenderTexture);
                    var canvasWidth = camera._getCanvasWidth(), canvasHeight = camera._getCanvasHeight();
                    Scene3D._blitOffset.setValue(camera.viewport.x / canvasWidth, camera.viewport.y / canvasHeight, camera.viewport.width / canvasWidth, camera.viewport.height / canvasHeight);
                    this.blitMainCanvans(Scene3D._blitTransRT, camera.normalizedViewport, camera);
                }
                if (!camera._cacheDepth) {
                    camera.enableRender && camera._needInternalRenderTexture() && (!camera._internalRenderTexture._inPool) && Laya.RenderTexture.recoverToPool(camera._internalRenderTexture);
                }
            }
            Laya.Context.set2DRenderConfig();
            Laya.RenderTexture.clearPool();
            return 1;
        }
        blitMainCanvans(source, normalizeViewPort, camera) {
            if (!source)
                return;
            Scene3D.mainCavansViewPort.x = RenderContext3D.clientWidth * normalizeViewPort.x | 0;
            Scene3D.mainCavansViewPort.y = RenderContext3D.clientHeight * normalizeViewPort.y | 0;
            Scene3D.mainCavansViewPort.width = RenderContext3D.clientWidth * normalizeViewPort.width | 0;
            Scene3D.mainCavansViewPort.height = RenderContext3D.clientHeight * normalizeViewPort.height | 0;
            source.filterMode = Laya.FilterMode.Bilinear;
            if (camera.fxaa)
                BlitFrameBufferCMD.shaderdata.addDefine(BaseCamera.SHADERDEFINE_FXAA);
            var cmd = BlitFrameBufferCMD.create(source, null, Scene3D.mainCavansViewPort, null, null, BlitFrameBufferCMD.shaderdata);
            cmd.run();
            cmd.recover();
            BlitFrameBufferCMD.shaderdata.removeDefine(BaseCamera.SHADERDEFINE_FXAA);
        }
        getRenderType() {
            return 0;
        }
        releaseRender() {
        }
        reUse(context, pos) {
            return 0;
        }
        setGlobalShaderValue(name, type, value) {
            var shaderOffset = Laya.Shader3D.propertyNameToID(name);
            this._shaderValues.setShaderData(shaderOffset, type, value);
        }
        get fogRange() {
            return this._fogParams.y - this.fogParams.x;
        }
        set fogRange(value) {
            this._fogParams.y = value + this.fogParams.x;
            this.fogParams = this._fogParams;
        }
        setlightmaps(value) {
            var maps = this._lightmaps;
            for (var i = 0, n = maps.length; i < n; i++)
                maps[i].lightmapColor._removeReference();
            if (value) {
                var count = value.length;
                maps.length = count;
                for (i = 0; i < count; i++) {
                    var lightMap = value[i];
                    lightMap._addReference();
                    (maps[i]) || (maps[i] = new Lightmap());
                    maps[i].lightmapColor = lightMap;
                }
            }
            else {
                throw new Error("Scene3D: value value can't be null.");
            }
        }
        getlightmaps() {
            var lightmapColors = new Array(this._lightmaps.length);
            for (var i = 0; i < this._lightmaps.length; i++) {
                lightmapColors[i] = this._lightmaps[i].lightmapColor;
            }
            return lightmapColors;
        }
    }
    Scene3D.REFLECTIONMODE_SKYBOX = 0;
    Scene3D.REFLECTIONMODE_CUSTOM = 1;
    Scene3D.SCENERENDERFLAG_RENDERQPAQUE = 0;
    Scene3D.SCENERENDERFLAG_SKYBOX = 1;
    Scene3D.SCENERENDERFLAG_RENDERTRANSPARENT = 2;
    Scene3D.__updateMark = 0;
    Scene3D._blitOffset = new Laya.Vector4();
    Scene3D.mainCavansViewPort = new Viewport(0, 0, 1, 1);

    exports.CameraClearFlags = void 0;
    (function (CameraClearFlags) {
        CameraClearFlags[CameraClearFlags["SolidColor"] = 0] = "SolidColor";
        CameraClearFlags[CameraClearFlags["Sky"] = 1] = "Sky";
        CameraClearFlags[CameraClearFlags["DepthOnly"] = 2] = "DepthOnly";
        CameraClearFlags[CameraClearFlags["Nothing"] = 3] = "Nothing";
        CameraClearFlags[CameraClearFlags["ColorOnly"] = 4] = "ColorOnly";
    })(exports.CameraClearFlags || (exports.CameraClearFlags = {}));
    exports.CameraEventFlags = void 0;
    (function (CameraEventFlags) {
        CameraEventFlags[CameraEventFlags["BeforeForwardOpaque"] = 0] = "BeforeForwardOpaque";
        CameraEventFlags[CameraEventFlags["BeforeSkyBox"] = 2] = "BeforeSkyBox";
        CameraEventFlags[CameraEventFlags["BeforeTransparent"] = 4] = "BeforeTransparent";
        CameraEventFlags[CameraEventFlags["BeforeImageEffect"] = 6] = "BeforeImageEffect";
        CameraEventFlags[CameraEventFlags["AfterEveryThing"] = 8] = "AfterEveryThing";
    })(exports.CameraEventFlags || (exports.CameraEventFlags = {}));
    class Camera extends BaseCamera {
        constructor(aspectRatio = 0, nearPlane = 0.3, farPlane = 1000) {
            super(nearPlane, farPlane);
            this._updateViewMatrix = true;
            this._postProcess = null;
            this._enableHDR = false;
            this._viewportParams = new Laya.Vector4();
            this._projectionParams = new Laya.Vector4();
            this._needBuiltInRenderTexture = false;
            this._msaa = false;
            this._offScreenRenderTexture = null;
            this._internalRenderTexture = null;
            this._canBlitDepth = false;
            this._internalCommandBuffer = new CommandBuffer();
            this._depthTextureFormat = Laya.RenderTargetFormat.DEPTH_16;
            this._cameraEventCommandBuffer = {};
            this._shadowCasterCommanBuffer = [];
            this._clusterPlaneCacheFlag = new Laya.Vector2(-1, -1);
            this._screenOffsetScale = new Laya.Vector4();
            this.enableRender = true;
            this.clearFlag = exports.CameraClearFlags.SolidColor;
            this._viewMatrix = new Laya.Matrix4x4();
            this._projectionMatrix = new Laya.Matrix4x4();
            this._projectionViewMatrix = new Laya.Matrix4x4();
            this._viewport = new Viewport(0, 0, 0, 0);
            this._normalizedViewport = new Viewport(0, 0, 1, 1);
            this._rayViewport = new Viewport(0, 0, 0, 0);
            this._aspectRatio = aspectRatio;
            this._boundFrustum = new BoundFrustum(new Laya.Matrix4x4());
            this._depthTextureMode = 0;
            this._calculateProjectionMatrix();
            Laya.ILaya.stage.on(Laya.Event.RESIZE, this, this._onScreenSizeChanged);
            this.transform.on(Laya.Event.TRANSFORM_CHANGED, this, this._onTransformChanged);
        }
        static set _updateMark(value) {
            Camera.__updateMark = value;
        }
        static get _updateMark() {
            return Camera.__updateMark;
        }
        static drawRenderTextureByScene(camera, scene, renderTexture, shader = null, replaceFlag = null) {
            if (!renderTexture)
                return null;
            Scene3D._updateMark++;
            scene._prepareSceneToRender();
            scene._setCullCamera(camera);
            let recoverTexture = camera.renderTarget;
            camera.renderTarget = renderTexture;
            var viewport = camera.viewport;
            var needInternalRT = camera._needInternalRenderTexture();
            var context = RenderContext3D._instance;
            var scene = context.scene = scene;
            context.pipelineMode = context.configPipeLineMode;
            context.replaceTag = replaceFlag;
            context.customShader = shader;
            if (needInternalRT) {
                camera._internalRenderTexture = Laya.RenderTexture.createFromPool(viewport.width, viewport.height, camera._getRenderTextureFormat(), camera.depthTextureFormat, false, camera.msaa ? 4 : 1, false, camera._needRenderGamma(camera._getRenderTextureFormat()));
                camera._internalRenderTexture.filterMode = Laya.FilterMode.Bilinear;
            }
            else {
                camera._internalRenderTexture = null;
            }
            scene._componentDriver.callPreRender();
            var needShadowCasterPass = camera._renderShadowMap(scene, context);
            camera._preRenderMainPass(context, scene, needInternalRT, viewport);
            camera._renderMainPass(context, viewport, scene, shader, replaceFlag, needInternalRT);
            camera._aftRenderMainPass(needShadowCasterPass);
            camera.renderTarget = recoverTexture;
            scene.recaculateCullCamera();
            scene._componentDriver.callPostRender();
            if (camera._internalRenderTexture)
                (!camera._internalRenderTexture._inPool) && Laya.RenderTexture.recoverToPool(camera._internalRenderTexture);
            return renderTexture;
        }
        static getTexturePixel(texture) {
            let coverFilter = texture.filterMode;
            texture.filterMode = Laya.FilterMode.Point;
            let rtFormat = Laya.RenderTargetFormat.R8G8B8;
            let pixelData;
            let size = texture.width * texture.height;
            switch (texture.format) {
                case Laya.TextureFormat.R32G32B32A32:
                case Laya.TextureFormat.R16G16B16A16:
                    rtFormat = Laya.RenderTargetFormat.R32G32B32A32;
                    pixelData = new Float32Array(size * 4);
                    break;
                case Laya.TextureFormat.R32G32B32:
                case Laya.TextureFormat.R16G16B16:
                    rtFormat = Laya.RenderTargetFormat.R32G32B32;
                    pixelData = new Float32Array(size * 3);
                    break;
                case Laya.TextureFormat.R5G6B5:
                case Laya.TextureFormat.R8G8B8:
                    rtFormat = Laya.RenderTargetFormat.R8G8B8;
                    pixelData = new Uint8Array(size * 3);
                    break;
                default:
                    rtFormat = Laya.RenderTargetFormat.R8G8B8A8;
                    pixelData = new Uint8Array(size * 4);
                    break;
            }
            let rt = new Laya.RenderTexture(texture.width, texture.height, rtFormat, Laya.RenderTargetFormat.None, false, 0, false);
            var blit = BlitScreenQuadCMD.create(texture, rt);
            blit.setContext(RenderContext3D._instance);
            blit.run();
            blit.recover();
            texture.filterMode = coverFilter;
            rt.getData(0, 0, texture.width, texture.height, pixelData);
            rt.destroy();
            return pixelData;
        }
        static drawTextureCubePixelByScene(camera, scene, renderCubeSize, format, cullingMask) {
            let rtFormat = Laya.RenderTargetFormat.R8G8B8;
            let pixelData;
            let size = renderCubeSize * renderCubeSize;
            let bytelength;
            switch (format) {
                case Laya.TextureFormat.R32G32B32A32:
                case Laya.TextureFormat.R16G16B16A16:
                    rtFormat = Laya.RenderTargetFormat.R32G32B32A32;
                    size *= 4;
                    bytelength = 4;
                    break;
                case Laya.TextureFormat.R32G32B32:
                case Laya.TextureFormat.R16G16B16:
                    rtFormat = Laya.RenderTargetFormat.R32G32B32;
                    size *= 3;
                    bytelength = 4;
                    break;
                case Laya.TextureFormat.R5G6B5:
                case Laya.TextureFormat.R8G8B8:
                    rtFormat = Laya.RenderTargetFormat.R8G8B8;
                    size *= 3;
                    bytelength = 1;
                    break;
                case Laya.TextureFormat.R8G8B8A8:
                    rtFormat = Laya.RenderTargetFormat.R8G8B8A8;
                    pixelData = new Uint8Array(size * 4);
                    size *= 4;
                    bytelength = 1;
                    break;
                default:
                    throw "Type is not supported";
            }
            let rt = new Laya.RenderTexture(renderCubeSize, renderCubeSize, rtFormat, Laya.RenderTargetFormat.DEPTH_16, false, 0, false, false);
            camera.fieldOfView = 90;
            camera.cullingMask = cullingMask;
            let pixels = [];
            let quaterionArray = [
                new Laya.Quaternion(0, 1, 0, 0),
                new Laya.Quaternion(0, 0, 0, 1),
                new Laya.Quaternion(0, 0.7071068, 0, 0.7071068),
                new Laya.Quaternion(0, 0.7071068, 0, -0.7071068),
                new Laya.Quaternion(0, 0.7071068, -0.7071068, 0),
                new Laya.Quaternion(0, -0.7071068, -0.7071068, 0),
            ];
            for (var i = 0; i < 6; i++) {
                camera.transform.rotation = quaterionArray[i];
                this.drawRenderTextureByScene(camera, scene, rt);
                if (bytelength == 4)
                    pixelData = new Float32Array(size);
                else
                    pixelData = new Uint8Array(size);
                pixels[i] = rt.getData(0, 0, renderCubeSize, renderCubeSize, pixelData);
            }
            rt.destroy();
            return pixels;
        }
        static drawTextureCubeByScene(camera, position, scene, renderCubeSize, format, cullingMask = 0) {
            camera.transform.position = position;
            let pixels = this.drawTextureCubePixelByScene(camera, scene, renderCubeSize, format, cullingMask);
            switch (format) {
                case Laya.TextureFormat.R32G32B32A32:
                case Laya.TextureFormat.R16G16B16A16:
                    Laya.TextureFormat.R32G32B32A32;
                    break;
                case Laya.TextureFormat.R32G32B32:
                case Laya.TextureFormat.R16G16B16:
                    Laya.TextureFormat.R32G32B32;
                    break;
                case Laya.TextureFormat.R5G6B5:
                case Laya.TextureFormat.R8G8B8:
                    Laya.TextureFormat.R8G8B8;
                    break;
                case Laya.TextureFormat.R8G8B8A8:
                    Laya.TextureFormat.R8G8B8A8;
                    break;
                default:
                    throw "Type is not supported";
            }
            let textureCube = new TextureCube(renderCubeSize, format, true, false);
            textureCube.setPixelsData(pixels, false, false);
            return textureCube;
        }
        static __init__() {
            Camera.depthPass = new DepthPass();
        }
        get aspectRatio() {
            if (this._aspectRatio === 0) {
                var vp = this.viewport;
                return vp.width / vp.height;
            }
            return this._aspectRatio;
        }
        set aspectRatio(value) {
            if (value < 0)
                throw new Error("Camera: the aspect ratio has to be a positive real number.");
            this._aspectRatio = value;
            this._calculateProjectionMatrix();
        }
        get viewport() {
            if (this._offScreenRenderTexture)
                this._calculationViewport(this._normalizedViewport, this._offScreenRenderTexture.width, this._offScreenRenderTexture.height);
            else
                this._calculationViewport(this._normalizedViewport, this.clientWidth, this.clientHeight);
            return this._viewport;
        }
        set viewport(value) {
            var width;
            var height;
            if (this._offScreenRenderTexture) {
                width = this._offScreenRenderTexture.width;
                height = this._offScreenRenderTexture.height;
            }
            else {
                width = this.clientWidth;
                height = this.clientHeight;
            }
            this._normalizedViewport.x = value.x / width;
            this._normalizedViewport.y = value.y / height;
            this._normalizedViewport.width = value.width / width;
            this._normalizedViewport.height = value.height / height;
            this._calculationViewport(this._normalizedViewport, width, height);
            this._calculateProjectionMatrix();
        }
        get clientWidth() {
            Laya.ILaya.stage.needUpdateCanvasSize();
            if (Laya.Config3D.customResolution)
                return Laya.Config3D.pixelRatio * Laya.Config3D._resoluWidth | 0;
            else
                return RenderContext3D.clientWidth * Laya.Config3D.pixelRatio | 0;
        }
        get clientHeight() {
            Laya.ILaya.stage.needUpdateCanvasSize();
            if (Laya.Config3D.customResolution)
                return Laya.Config3D.pixelRatio * Laya.Config3D._resoluHeight | 0;
            else
                return RenderContext3D.clientHeight * Laya.Config3D.pixelRatio | 0;
        }
        set msaa(value) {
            Laya.LayaGL.renderEngine.getCapable(Laya.RenderCapable.MSAA) ? this._msaa = value : this._msaa = false;
        }
        get msaa() {
            return this._msaa && Laya.Stat.enablemsaa;
        }
        set fxaa(value) {
            this._fxaa = value;
        }
        get fxaa() {
            return this._fxaa;
        }
        get normalizedViewport() {
            return this._normalizedViewport;
        }
        set normalizedViewport(value) {
            var width;
            var height;
            if (this._offScreenRenderTexture) {
                width = this._offScreenRenderTexture.width;
                height = this._offScreenRenderTexture.height;
            }
            else {
                width = this.clientWidth;
                height = this.clientHeight;
            }
            if (this._normalizedViewport !== value)
                value.cloneTo(this._normalizedViewport);
            this._calculationViewport(value, width, height);
            this._calculateProjectionMatrix();
        }
        get viewMatrix() {
            if (this._updateViewMatrix) {
                var scale = this.transform.getWorldLossyScale();
                var scaleX = scale.x;
                var scaleY = scale.y;
                var scaleZ = scale.z;
                var viewMatE = this._viewMatrix.elements;
                this.transform.worldMatrix.cloneTo(this._viewMatrix);
                viewMatE[0] /= scaleX;
                viewMatE[1] /= scaleX;
                viewMatE[2] /= scaleX;
                viewMatE[4] /= scaleY;
                viewMatE[5] /= scaleY;
                viewMatE[6] /= scaleY;
                viewMatE[8] /= scaleZ;
                viewMatE[9] /= scaleZ;
                viewMatE[10] /= scaleZ;
                this._viewMatrix.invert(this._viewMatrix);
                this._updateViewMatrix = false;
            }
            return this._viewMatrix;
        }
        get projectionMatrix() {
            return this._projectionMatrix;
        }
        set projectionMatrix(value) {
            this._projectionMatrix = value;
            this._useUserProjectionMatrix = true;
        }
        get projectionViewMatrix() {
            Laya.Matrix4x4.multiply(this.projectionMatrix, this.viewMatrix, this._projectionViewMatrix);
            return this._projectionViewMatrix;
        }
        get boundFrustum() {
            this._boundFrustum.matrix = this.projectionViewMatrix;
            return this._boundFrustum;
        }
        get renderTarget() {
            return this._offScreenRenderTexture;
        }
        set renderTarget(value) {
            var lastValue = this._offScreenRenderTexture;
            if (lastValue !== value) {
                (lastValue) && (lastValue._isCameraTarget = false);
                (value) && (value._isCameraTarget = true);
                this._offScreenRenderTexture = value;
                this._calculateProjectionMatrix();
            }
        }
        get postProcess() {
            return this._postProcess;
        }
        set postProcess(value) {
            this._postProcess = value;
        }
        get enableHDR() {
            return this._enableHDR;
        }
        set enableHDR(value) {
            if (value && !Laya.LayaGL.renderEngine.getCapable(Laya.RenderCapable.RenderTextureFormat_R16G16B16A16)) {
                console.warn("Camera:can't enable HDR in this device.");
                return;
            }
            this._enableHDR = value;
        }
        get enableBuiltInRenderTexture() {
            return this._needBuiltInRenderTexture;
        }
        set enableBuiltInRenderTexture(value) {
            this._needBuiltInRenderTexture = value;
        }
        get depthTextureMode() {
            return this._depthTextureMode;
        }
        set depthTextureMode(value) {
            this._depthTextureMode = value;
        }
        set opaquePass(value) {
            if (value == this._opaquePass)
                return;
            if (!value) {
                this._shaderValues.setTexture(BaseCamera.OPAQUETEXTURE, null);
                this._opaqueTexture && Laya.RenderTexture.recoverToPool(this._opaqueTexture);
            }
            this._opaquePass = value;
        }
        get opaquePass() {
            return this._opaquePass;
        }
        get depthTextureFormat() {
            return this._depthTextureFormat;
        }
        set depthTextureFormat(value) {
            this._depthTextureFormat = value;
        }
        set enableBlitDepth(value) {
            if (value == this._canBlitDepth)
                return;
            this._canBlitDepth = value;
            this._cacheDepth = value;
            if (value)
                this._internalRenderTexture && (this._internalRenderTexture.generateDepthTexture = true);
            else {
                this._internalRenderTexture && (this._internalRenderTexture.generateDepthTexture = false);
                if (this._cacheDepthTexture)
                    this._cacheDepthTexture._inPool ? 0 : Laya.RenderTexture.recoverToPool(this._cacheDepthTexture);
            }
        }
        get enableBlitDepth() {
            return this._canBlitDepth;
        }
        get canblitDepth() {
            return this._canBlitDepth && this._internalRenderTexture && this._internalRenderTexture.depthStencilFormat != null;
        }
        _calculationViewport(normalizedViewport, width, height) {
            var lx = normalizedViewport.x * width;
            var ly = normalizedViewport.y * height;
            var rx = lx + Math.max(normalizedViewport.width * width, 0);
            var ry = ly + Math.max(normalizedViewport.height * height, 0);
            var ceilLeftX = Math.ceil(lx);
            var ceilLeftY = Math.ceil(ly);
            var floorRightX = Math.floor(rx);
            var floorRightY = Math.floor(ry);
            var pixelLeftX = ceilLeftX - lx >= 0.5 ? Math.floor(lx) : ceilLeftX;
            var pixelLeftY = ceilLeftY - ly >= 0.5 ? Math.floor(ly) : ceilLeftY;
            var pixelRightX = rx - floorRightX >= 0.5 ? Math.ceil(rx) : floorRightX;
            var pixelRightY = ry - floorRightY >= 0.5 ? Math.ceil(ry) : floorRightY;
            this._viewport.x = pixelLeftX;
            this._viewport.y = pixelLeftY;
            this._viewport.width = pixelRightX - pixelLeftX;
            this._viewport.height = pixelRightY - pixelLeftY;
        }
        _calculateProjectionMatrix() {
            if (!this._useUserProjectionMatrix) {
                if (this._orthographic) {
                    var halfHeight = this.orthographicVerticalSize * 0.5;
                    var halfWidth = halfHeight * this.aspectRatio;
                    Laya.Matrix4x4.createOrthoOffCenter(-halfWidth, halfWidth, -halfHeight, halfHeight, this.nearPlane, this.farPlane, this._projectionMatrix);
                }
                else {
                    Laya.Matrix4x4.createPerspective(3.1416 * this.fieldOfView / 180.0, this.aspectRatio, this.nearPlane, this.farPlane, this._projectionMatrix);
                }
            }
        }
        _isLayerVisible(layer) {
            return (Math.pow(2, layer) & this.cullingMask) != 0;
        }
        _onTransformChanged(flag) {
            flag &= Transform3D.TRANSFORM_WORLDMATRIX;
            (flag) && (this._updateViewMatrix = true);
        }
        _parse(data, spriteMap) {
            super._parse(data, spriteMap);
            var clearFlagData = data.clearFlag;
            (clearFlagData !== undefined) && (this.clearFlag = clearFlagData);
            var viewport = data.viewport;
            this.normalizedViewport = new Viewport(viewport[0], viewport[1], viewport[2], viewport[3]);
            var enableHDR = data.enableHDR;
            (enableHDR !== undefined) && (this.enableHDR = enableHDR);
        }
        clone() {
            let camera = super.clone();
            camera.clearFlag = this.clearFlag;
            camera.viewport = this.viewport;
            this.normalizedViewport.cloneTo(camera.normalizedViewport);
            camera.enableHDR = this.enableHDR;
            camera.farPlane = this.farPlane;
            camera.nearPlane = this.nearPlane;
            camera.fieldOfView = this.fieldOfView;
            camera.orthographic = this.orthographic;
            camera._cameraEventCommandBuffer = this._cameraEventCommandBuffer;
            return camera;
        }
        _getCanvasWidth() {
            if (this._offScreenRenderTexture)
                return this._offScreenRenderTexture.width;
            else
                return this.clientWidth;
        }
        _getCanvasHeight() {
            if (this._offScreenRenderTexture)
                return this._offScreenRenderTexture.height;
            else
                return this.clientHeight;
        }
        _getRenderTexture() {
            return this._internalRenderTexture || this._offScreenRenderTexture;
        }
        _needRenderGamma(rt) {
            switch (rt) {
                case Laya.RenderTargetFormat.R8G8B8:
                case Laya.RenderTargetFormat.R8G8B8A8:
                    return true;
                default:
                    return false;
            }
        }
        _needInternalRenderTexture() {
            return (this._postProcess && this._postProcess.enable) || this._enableHDR || this._needBuiltInRenderTexture ? true : false;
        }
        _getRenderTextureFormat() {
            if (this._enableHDR)
                return Laya.RenderTargetFormat.R16G16B16A16;
            else
                return Laya.RenderTargetFormat.R8G8B8A8;
        }
        _updateCameraRenderData(context) {
            this._prepareCameraToRender();
            this._applyViewProject(context, this.viewMatrix, this._projectionMatrix);
        }
        _prepareCameraToRender() {
            super._prepareCameraToRender();
            var vp = this.viewport;
            this._viewportParams.setValue(vp.x, vp.y, vp.width, vp.height);
            this._projectionParams.setValue(this._nearPlane, this._farPlane, RenderContext3D._instance.invertY ? -1 : 1, 1 / this.farPlane);
            this._shaderValues.setVector(BaseCamera.VIEWPORT, this._viewportParams);
            this._shaderValues.setVector(BaseCamera.PROJECTION_PARAMS, this._projectionParams);
        }
        _applyViewProject(context, viewMat, proMat) {
            var projectView;
            if (context.invertY) {
                Laya.Matrix4x4.multiply(BaseCamera._invertYScaleMatrix, proMat, BaseCamera._invertYProjectionMatrix);
                Laya.Matrix4x4.multiply(BaseCamera._invertYProjectionMatrix, viewMat, BaseCamera._invertYProjectionViewMatrix);
                proMat = BaseCamera._invertYProjectionMatrix;
                projectView = BaseCamera._invertYProjectionViewMatrix;
            }
            else {
                Laya.Matrix4x4.multiply(proMat, viewMat, this._projectionViewMatrix);
                projectView = this._projectionViewMatrix;
            }
            context.viewMatrix = viewMat;
            context.projectionMatrix = proMat;
            context.projectionViewMatrix = projectView;
            this._shaderValues.setMatrix4x4(BaseCamera.VIEWMATRIX, viewMat);
            this._shaderValues.setMatrix4x4(BaseCamera.PROJECTMATRIX, proMat);
            this._shaderValues.setMatrix4x4(BaseCamera.VIEWPROJECTMATRIX, projectView);
        }
        _updateClusterPlaneXY() {
            var fieldOfView = this.fieldOfView;
            var aspectRatio = this.aspectRatio;
            if (this._clusterPlaneCacheFlag.x !== fieldOfView || this._clusterPlaneCacheFlag.y !== aspectRatio) {
                var clusterCount = Laya.Config3D.lightClusterCount;
                var xSlixe = clusterCount.x, ySlice = clusterCount.y;
                var xCount = xSlixe + 1, yCount = ySlice + 1;
                var xPlanes = this._clusterXPlanes, yPlanes = this._clusterYPlanes;
                if (!xPlanes) {
                    xPlanes = this._clusterXPlanes = new Array(xCount);
                    yPlanes = this._clusterYPlanes = new Array(yCount);
                    for (var i = 0; i < xCount; i++)
                        xPlanes[i] = new Laya.Vector3();
                    for (var i = 0; i < yCount; i++)
                        yPlanes[i] = new Laya.Vector3();
                }
                var halfY = Math.tan((this.fieldOfView / 2) * Math.PI / 180);
                var halfX = this.aspectRatio * halfY;
                var yLengthPerCluster = 2 * halfY / ySlice;
                var xLengthPerCluster = 2 * halfX / xSlixe;
                for (var i = 0; i < xCount; i++) {
                    var angle = -halfX + xLengthPerCluster * i;
                    var bigHypot = Math.sqrt(1 + angle * angle);
                    var normX = 1 / bigHypot;
                    var xPlane = xPlanes[i];
                    xPlane.setValue(normX, 0, -angle * normX);
                }
                for (var i = 0; i < yCount; i++) {
                    var angle = halfY - yLengthPerCluster * i;
                    var bigHypot = Math.sqrt(1 + angle * angle);
                    var normY = -1 / bigHypot;
                    var yPlane = yPlanes[i];
                    yPlane.setValue(0, normY, -angle * normY);
                }
                this._clusterPlaneCacheFlag.x = fieldOfView;
                this._clusterPlaneCacheFlag.y = aspectRatio;
            }
        }
        _applyCommandBuffer(event, context) {
            if (!Laya.Stat.enableCameraCMD)
                return;
            var commandBufferArray = this._cameraEventCommandBuffer[event];
            if (!commandBufferArray || commandBufferArray.length == 0)
                return;
            commandBufferArray.forEach(function (value) {
                value._context = context;
                value._apply();
            });
            (Laya.RenderTexture.currentActive) && (Laya.RenderTexture.currentActive._end());
            if (this._internalRenderTexture || this._offScreenRenderTexture)
                this._getRenderTexture()._start();
            else {
                Laya.LayaGL.textureContext.bindoutScreenTarget();
            }
            Laya.LayaGL.renderEngine.viewport(0, 0, context.viewport.width, context.viewport.height);
        }
        _applyCasterPassCommandBuffer(context) {
            if (!this._shadowCasterCommanBuffer || this._shadowCasterCommanBuffer.length == 0)
                return;
            this._shadowCasterCommanBuffer.forEach(function (value) {
                value._context = context;
                value._apply();
            });
        }
        _addCasterShadowCommandBuffer(commandBuffer) {
            if (this._shadowCasterCommanBuffer.indexOf(commandBuffer) < 0)
                this._shadowCasterCommanBuffer.push(commandBuffer);
        }
        _removeCasterShadowCommandBuffer(commandBuffer) {
            var index = this._shadowCasterCommanBuffer.indexOf(commandBuffer);
            if (index != -1)
                this._shadowCasterCommanBuffer.splice(index, 1);
        }
        _renderShadowMap(scene, context) {
            if (Scene3D._updateMark % scene._ShadowMapupdateFrequency != 0) {
                return false;
            }
            var shadowCasterPass;
            var mainDirectLight = scene._mainDirectionLight;
            var needShadowCasterPass = mainDirectLight && mainDirectLight.shadowMode !== exports.ShadowMode.None && ShadowUtils.supportShadow() && Laya.Stat.enableShadow;
            if (needShadowCasterPass) {
                scene._shaderValues.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_SPOT);
                scene._shaderValues.addDefine(Scene3DShaderDeclaration.SHADERDEFINE_SHADOW);
                shadowCasterPass = ILaya3D.Scene3D._shadowCasterPass;
                shadowCasterPass.update(this, mainDirectLight, exports.ShadowLightType.DirectionLight);
                shadowCasterPass.render(context, scene, exports.ShadowLightType.DirectionLight, this);
            }
            else {
                scene._shaderValues.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_SHADOW);
            }
            var spotMainLight = scene._mainSpotLight;
            var spotneedShadowCasterPass = spotMainLight && spotMainLight.shadowMode !== exports.ShadowMode.None && ShadowUtils.supportShadow() && Laya.Stat.enableShadow;
            if (spotneedShadowCasterPass) {
                scene._shaderValues.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_SHADOW);
                scene._shaderValues.addDefine(Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_SPOT);
                shadowCasterPass = ILaya3D.Scene3D._shadowCasterPass;
                shadowCasterPass.update(this, spotMainLight, exports.ShadowLightType.SpotLight);
                shadowCasterPass.render(context, scene, exports.ShadowLightType.SpotLight, this);
            }
            else {
                scene._shaderValues.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_SPOT);
            }
            if (needShadowCasterPass)
                scene._shaderValues.addDefine(Scene3DShaderDeclaration.SHADERDEFINE_SHADOW);
            if (spotneedShadowCasterPass)
                scene._shaderValues.addDefine(Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_SPOT);
            return needShadowCasterPass || spotneedShadowCasterPass;
        }
        _preRenderMainPass(context, scene, needInternalRT, viewport) {
            context.camera = this;
            context.cameraShaderValue = this._shaderValues;
            Camera._updateMark++;
            if (needInternalRT && !this._offScreenRenderTexture && (this.clearFlag == exports.CameraClearFlags.DepthOnly || this.clearFlag == exports.CameraClearFlags.Nothing)) {
                if (Laya.RenderTexture.bindCanvasRender) {
                    var blit = BlitScreenQuadCMD.create(Laya.RenderTexture.bindCanvasRender, this._internalRenderTexture);
                    blit.setContext(context);
                    blit.run();
                    blit.recover();
                }
                else {
                    if (this._enableHDR) {
                        var grabTexture = Laya.RenderTexture.createFromPool(viewport.width, viewport.height, Laya.RenderTargetFormat.R8G8B8, Laya.RenderTargetFormat.DEPTH_16, false, 1);
                        grabTexture.filterMode = Laya.FilterMode.Bilinear;
                        this._renderEngine.copySubFrameBuffertoTex(grabTexture, 0, 0, 0, viewport.x, RenderContext3D.clientHeight - (viewport.y + viewport.height), viewport.width, viewport.height);
                        var blit = BlitScreenQuadCMD.create(grabTexture, this._internalRenderTexture);
                        blit.setContext(context);
                        blit.run();
                        blit.recover();
                        Laya.RenderTexture.recoverToPool(grabTexture);
                    }
                    else {
                        this._renderEngine.copySubFrameBuffertoTex(this._internalRenderTexture, 0, 0, 0, viewport.x, RenderContext3D.clientHeight - (viewport.y + viewport.height), viewport.width, viewport.height);
                    }
                }
            }
        }
        _renderMainPass(context, viewport, scene, shader, replacementTag, needInternalRT) {
            var renderTex = this._getRenderTexture();
            if (renderTex && renderTex._isCameraTarget)
                context.invertY = true;
            else
                context.invertY = false;
            context.viewport = viewport;
            context.destTarget = renderTex;
            this._prepareCameraToRender();
            var multiLighting = Laya.Config3D._multiLighting;
            (multiLighting) && (Cluster.instance.update(this, (scene)));
            context.customShader = shader;
            context.replaceTag = replacementTag;
            scene._preCulling(context, this);
            this._applyViewProject(context, this.viewMatrix, this._projectionMatrix);
            if (this._cameraUniformData) {
                this._cameraUniformUBO && this._cameraUniformUBO.setDataByUniformBufferData(this._cameraUniformData);
            }
            this._renderDepthMode(context);
            (renderTex) && (renderTex._start());
            scene._clear(context);
            this._applyCommandBuffer(exports.CameraEventFlags.BeforeForwardOpaque, context);
            this.recoverRenderContext3D(context, renderTex);
            Laya.Stat.enableOpaque && scene._renderScene(context, ILaya3D.Scene3D.SCENERENDERFLAG_RENDERQPAQUE);
            this._applyCommandBuffer(exports.CameraEventFlags.BeforeSkyBox, context);
            this._opaquePass && this._createOpaqueTexture(renderTex, context);
            this.recoverRenderContext3D(context, renderTex);
            scene._renderScene(context, ILaya3D.Scene3D.SCENERENDERFLAG_SKYBOX);
            this._applyCommandBuffer(exports.CameraEventFlags.BeforeTransparent, context);
            this.recoverRenderContext3D(context, renderTex);
            Laya.Stat.enableTransparent && scene._renderScene(context, ILaya3D.Scene3D.SCENERENDERFLAG_RENDERTRANSPARENT);
            this._applyCommandBuffer(exports.CameraEventFlags.BeforeImageEffect, context);
            (renderTex) && (renderTex._end());
            if (needInternalRT && Laya.Stat.enablePostprocess) {
                if (this._postProcess && this._postProcess.enable) {
                    this._postProcess.commandContext = context;
                    this._postProcess._render(this);
                    this._postProcess._applyPostProcessCommandBuffers();
                }
                else if (this._enableHDR || this._needBuiltInRenderTexture) {
                    var canvasWidth = this._getCanvasWidth(), canvasHeight = this._getCanvasHeight();
                    if (this._offScreenRenderTexture) {
                        this._screenOffsetScale.setValue(viewport.x / canvasWidth, (canvasHeight - viewport.y - viewport.height) / canvasHeight, viewport.width / canvasWidth, viewport.height / canvasHeight);
                        this._internalCommandBuffer._camera = this;
                        this._internalCommandBuffer._context = context;
                        this._internalCommandBuffer.blitScreenQuad(this._internalRenderTexture, this._offScreenRenderTexture, this._screenOffsetScale, null, null, 0);
                        this._internalCommandBuffer._apply();
                        this._internalCommandBuffer.clear();
                    }
                }
            }
            if (this._offScreenRenderTexture) {
                Laya.RenderTexture.bindCanvasRender = null;
            }
            else
                Laya.RenderTexture.bindCanvasRender = this._internalRenderTexture;
            this._applyCommandBuffer(exports.CameraEventFlags.AfterEveryThing, context);
        }
        recoverRenderContext3D(context, renderTexture) {
            const cacheViewPor = Camera._context3DViewPortCatch;
            const cacheScissor = Camera._contextScissorPortCatch;
            context.changeViewport(cacheViewPor.x, cacheViewPor.y, cacheViewPor.width, cacheViewPor.height);
            context.changeScissor(cacheScissor.x, cacheScissor.y, cacheScissor.z, cacheScissor.w);
            context.destTarget = renderTexture;
        }
        _renderDepthMode(context) {
            var cameraDepthMode = this._depthTextureMode;
            if (this._postProcess && this._postProcess.enable) {
                cameraDepthMode |= this._postProcess.cameraDepthTextureMode;
            }
            if ((cameraDepthMode & exports.DepthTextureMode.Depth) != 0) {
                if (!this.canblitDepth || !this._internalRenderTexture.depthStencilTexture) {
                    Camera.depthPass.update(this, exports.DepthTextureMode.Depth, this._depthTextureFormat);
                    Camera.depthPass.render(context, exports.DepthTextureMode.Depth);
                }
                else {
                    this.depthTexture = this._cacheDepthTexture.depthStencilTexture;
                    Camera.depthPass._depthTexture = this.depthTexture;
                    Camera.depthPass._setupDepthModeShaderValue(exports.DepthTextureMode.Depth, this);
                }
            }
            if ((cameraDepthMode & exports.DepthTextureMode.DepthNormals) != 0) {
                Camera.depthPass.update(this, exports.DepthTextureMode.DepthNormals, this._depthTextureFormat);
                Camera.depthPass.render(context, exports.DepthTextureMode.DepthNormals);
            }
        }
        get depthTexture() {
            return this._depthTexture;
        }
        set depthTexture(value) {
            this._depthTexture = value;
        }
        get depthNormalTexture() {
            return this._depthNormalsTexture;
        }
        set depthNormalTexture(value) {
            this._depthNormalsTexture = value;
        }
        _aftRenderMainPass(needShadowPass) {
            if (this._cacheDepth && this._internalRenderTexture) {
                if (this._cacheDepthTexture)
                    this._cacheDepthTexture._inPool ? 0 : Laya.RenderTexture.recoverToPool(this._cacheDepthTexture);
                this._cacheDepthTexture = this._internalRenderTexture;
            }
            Camera.depthPass.cleanUp();
        }
        _createOpaqueTexture(currentTarget, renderContext) {
            if (!this._opaqueTexture) {
                let tex = this._getRenderTexture();
                this._opaqueTexture = Laya.RenderTexture.createFromPool(tex.width, tex.height, tex.colorFormat, Laya.RenderTargetFormat.None, false, 1, false, true);
                this._shaderValues.setTexture(BaseCamera.OPAQUETEXTURE, this._opaqueTexture);
            }
            var blit = BlitScreenQuadCMD.create(currentTarget, this._opaqueTexture);
            blit.setContext(renderContext);
            blit.run();
            blit.recover();
        }
        render(shader = null, replacementTag = null) {
            if (!this.activeInHierarchy)
                return;
            var viewport = this.viewport;
            var needInternalRT = this._needInternalRenderTexture();
            var context = RenderContext3D._instance;
            var scene = context.scene = this._scene;
            scene._setCullCamera(this);
            context.pipelineMode = context.configPipeLineMode;
            context.replaceTag = replacementTag;
            context.customShader = shader;
            let texFormat = this._getRenderTextureFormat();
            if (needInternalRT) {
                if (this.msaa) {
                    this._internalRenderTexture = Laya.RenderTexture.createFromPool(viewport.width, viewport.height, texFormat, this._depthTextureFormat, false, 4, this.canblitDepth, this._needRenderGamma(texFormat));
                    this._internalRenderTexture.filterMode = Laya.FilterMode.Bilinear;
                }
                else {
                    this._internalRenderTexture = Laya.RenderTexture.createFromPool(viewport.width, viewport.height, texFormat, this._depthTextureFormat, false, 1, this.canblitDepth, this._needRenderGamma(texFormat));
                    this._internalRenderTexture.filterMode = Laya.FilterMode.Bilinear;
                }
            }
            else {
                this._internalRenderTexture = null;
            }
            scene._componentDriver.callPreRender();
            var needShadowCasterPass = this._renderShadowMap(scene, context);
            this._preRenderMainPass(context, scene, needInternalRT, viewport);
            this._renderMainPass(context, viewport, scene, shader, replacementTag, needInternalRT);
            this._aftRenderMainPass(needShadowCasterPass);
            scene._componentDriver.callPostRender();
        }
        viewportPointToRay(point, out) {
            this._rayViewport.x = this.viewport.x;
            this._rayViewport.y = this.viewport.y;
            this._rayViewport.width = Laya.ILaya.stage._width;
            this._rayViewport.height = Laya.ILaya.stage._height;
            Picker.calculateCursorRay(point, this._rayViewport, this._projectionMatrix, this.viewMatrix, null, out);
        }
        normalizedViewportPointToRay(point, out) {
            var finalPoint = Camera._tempVector20;
            var vp = this.normalizedViewport;
            point.x = point.x * Laya.Config3D.pixelRatio;
            point.y = point.y * Laya.Config3D.pixelRatio;
            finalPoint.x = point.x * vp.width;
            finalPoint.y = point.y * vp.height;
            Picker.calculateCursorRay(finalPoint, this.viewport, this._projectionMatrix, this.viewMatrix, null, out);
        }
        worldToViewportPoint(position, out) {
            Laya.Matrix4x4.multiply(this._projectionMatrix, this._viewMatrix, this._projectionViewMatrix);
            this.viewport.project(position, this._projectionViewMatrix, out);
            var r = Laya.Config3D.pixelRatio;
            let _wr = (out.x - this.viewport.x) / r;
            let _hr = (out.y - this.viewport.y) / r;
            out.x = _wr + this.viewport.x;
            out.y = _hr + this.viewport.y;
            out.x = (out.x / Laya.ILaya.stage.clientScaleX) | 0;
            out.y = (out.y / Laya.ILaya.stage.clientScaleY) | 0;
        }
        worldToNormalizedViewportPoint(position, out) {
            this.worldToViewportPoint(position, out);
            out.x = out.x / Laya.ILaya.stage.width;
            out.y = out.y / Laya.ILaya.stage.height;
        }
        convertScreenCoordToOrthographicCoord(source, out) {
            if (this._orthographic) {
                var clientWidth = this.clientWidth;
                var clientHeight = this.clientHeight;
                var ratioX = this.orthographicVerticalSize * this.aspectRatio / clientWidth;
                var ratioY = this.orthographicVerticalSize / clientHeight;
                out.x = (-clientWidth / 2 + source.x * Laya.ILaya.stage.clientScaleX) * ratioX;
                out.y = (clientHeight / 2 - source.y * Laya.ILaya.stage.clientScaleY) * ratioY;
                out.z = (this.nearPlane - this.farPlane) * (source.z + 1) / 2 - this.nearPlane;
                Laya.Vector3.transformCoordinate(out, this.transform.worldMatrix, out);
                return true;
            }
            else {
                return false;
            }
        }
        destroy(destroyChild = true) {
            this._needInternalRenderTexture() && (!this._internalRenderTexture._inPool) && Laya.RenderTexture.recoverToPool(this._internalRenderTexture);
            this._offScreenRenderTexture = null;
            this.transform.off(Laya.Event.TRANSFORM_CHANGED, this, this._onTransformChanged);
            Laya.ILaya.stage.off(Laya.Event.RESIZE, this, this._onScreenSizeChanged);
            this._cameraEventCommandBuffer = {};
            this._shaderValues.destroy();
            if (RenderContext3D._instance.camera == this) {
                RenderContext3D._instance.cameraShaderValue = null;
                RenderContext3D._instance.camera = null;
            }
            super.destroy(destroyChild);
        }
        addCommandBuffer(event, commandBuffer) {
            var commandBufferArray = this._cameraEventCommandBuffer[event];
            if (!commandBufferArray)
                commandBufferArray = this._cameraEventCommandBuffer[event] = [];
            if (commandBufferArray.indexOf(commandBuffer) < 0)
                commandBufferArray.push(commandBuffer);
            commandBuffer._camera = this;
            if (commandBuffer.casterShadow) {
                this._addCasterShadowCommandBuffer(commandBuffer);
            }
        }
        removeCommandBuffer(event, commandBuffer) {
            var commandBufferArray = this._cameraEventCommandBuffer[event];
            if (commandBufferArray) {
                var index = commandBufferArray.indexOf(commandBuffer);
                if (index != -1)
                    commandBufferArray.splice(index, 1);
                commandBuffer.casterShadow && this._removeCasterShadowCommandBuffer(commandBuffer);
            }
            else
                throw "Camera:unknown event.";
        }
        removeCommandBuffers(event) {
            if (this._cameraEventCommandBuffer[event])
                this._cameraEventCommandBuffer[event].length = 0;
        }
        _create() {
            return new Camera();
        }
    }
    Camera._tempVector20 = new Laya.Vector2();
    Camera._context3DViewPortCatch = new Viewport(0, 0, 0, 0);
    Camera._contextScissorPortCatch = new Laya.Vector4(0, 0, 0, 0);
    Camera.__updateMark = 0;

    class GradientMode {
    }
    GradientMode.Blend = 0;
    GradientMode.Fixed = 1;

    class Gradient {
        constructor(maxColorRGBKeyCount, maxColorAlphaKeyCount) {
            this._mode = 0;
            this._maxColorRGBKeysCount = 0;
            this._maxColorAlphaKeysCount = 0;
            this._colorRGBKeysCount = 0;
            this._colorAlphaKeysCount = 0;
            this._keyRanges = new Laya.Vector4(1, 0, 1, 0);
            this._alphaElements = null;
            this._rgbElements = null;
            this._maxColorRGBKeysCount = maxColorRGBKeyCount;
            this._maxColorAlphaKeysCount = maxColorAlphaKeyCount;
            this._rgbElements = new Float32Array(maxColorRGBKeyCount * 4);
            this._alphaElements = new Float32Array(maxColorAlphaKeyCount * 2);
        }
        get mode() {
            return this._mode;
        }
        set mode(value) {
            this._mode = value;
        }
        get colorRGBKeysCount() {
            return this._colorRGBKeysCount;
        }
        get colorAlphaKeysCount() {
            return this._colorAlphaKeysCount;
        }
        get maxColorRGBKeysCount() {
            return this._maxColorRGBKeysCount;
        }
        get maxColorAlphaKeysCount() {
            return this._maxColorAlphaKeysCount;
        }
        addColorRGB(key, value) {
            if (this._colorRGBKeysCount < this._maxColorRGBKeysCount) {
                var offset = this._colorRGBKeysCount * 4;
                this._rgbElements[offset] = key;
                this._rgbElements[offset + 1] = value.r;
                this._rgbElements[offset + 2] = value.g;
                this._rgbElements[offset + 3] = value.b;
                this._colorRGBKeysCount++;
            }
            else {
                console.warn("Gradient:warning:data count must lessEqual than " + this._maxColorRGBKeysCount);
            }
        }
        addColorAlpha(key, value) {
            if (this._colorAlphaKeysCount < this._maxColorAlphaKeysCount) {
                var offset = this._colorAlphaKeysCount * 2;
                this._alphaElements[offset] = key;
                this._alphaElements[offset + 1] = value;
                this._colorAlphaKeysCount++;
            }
            else {
                console.warn("Gradient:warning:data count must lessEqual than " + this._maxColorAlphaKeysCount);
            }
        }
        updateColorRGB(index, key, value) {
            if (index < this._colorRGBKeysCount) {
                var offset = index * 4;
                this._rgbElements[offset] = key;
                this._rgbElements[offset + 1] = value.r;
                this._rgbElements[offset + 2] = value.g;
                this._rgbElements[offset + 3] = value.b;
            }
            else {
                console.warn("Gradient:warning:index must lessEqual than colorRGBKeysCount:" + this._colorRGBKeysCount);
            }
        }
        updateColorAlpha(index, key, value) {
            if (index < this._colorAlphaKeysCount) {
                var offset = index * 2;
                this._alphaElements[offset] = key;
                this._alphaElements[offset + 1] = value;
            }
            else {
                console.warn("Gradient:warning:index must lessEqual than colorAlphaKeysCount:" + this._colorAlphaKeysCount);
            }
        }
        evaluateColorRGB(lerpFactor, out, startSearchIndex = 0, reverseSearch = false) {
            lerpFactor = Math.min(Math.max(lerpFactor, 0.0), 1.0);
            var rgbElements = this._rgbElements;
            var curIndex = startSearchIndex;
            if (reverseSearch) {
                for (var i = curIndex; i >= 0; i--) {
                    var offset = i * 4;
                    var left = rgbElements[offset];
                    if (lerpFactor === left) {
                        out.r = rgbElements[offset + 1];
                        out.g = rgbElements[offset + 2];
                        out.b = rgbElements[offset + 3];
                        return curIndex;
                    }
                    switch (this._mode) {
                        case GradientMode.Blend:
                            if (lerpFactor > left) {
                                var right = rgbElements[offset + 4];
                                if (lerpFactor > right)
                                    throw "Gradient:wrong startSearchIndex.";
                                var diff = right - left;
                                var y1 = right - lerpFactor;
                                var y2 = lerpFactor - left;
                                out.r = (y1 * rgbElements[offset + 1] + y2 * rgbElements[offset + 5]) / diff;
                                out.g = (y1 * rgbElements[offset + 2] + y2 * rgbElements[offset + 6]) / diff;
                                out.b = (y1 * rgbElements[offset + 3] + y2 * rgbElements[offset + 7]) / diff;
                                return curIndex;
                            }
                            else {
                                curIndex--;
                                continue;
                            }
                        case GradientMode.Fixed:
                            if (lerpFactor > left) {
                                if (lerpFactor > rgbElements[offset + 4])
                                    throw "Gradient:wrong startSearchIndex.";
                                out.r = rgbElements[offset + 5];
                                out.g = rgbElements[offset + 6];
                                out.b = rgbElements[offset + 7];
                                return curIndex;
                            }
                            else {
                                curIndex--;
                                continue;
                            }
                        default:
                            throw "Gradient:unknown mode.";
                    }
                }
            }
            else {
                for (var i = 0, n = this._rgbElements.length; i < n; i++) {
                    offset = i * 4;
                    var right = rgbElements[offset];
                    if (lerpFactor === right) {
                        out.r = rgbElements[offset + 1];
                        out.g = rgbElements[offset + 2];
                        out.b = rgbElements[offset + 3];
                        return curIndex;
                    }
                    switch (this._mode) {
                        case GradientMode.Blend:
                            if (lerpFactor < right) {
                                var left = rgbElements[offset - 4];
                                if (lerpFactor < left)
                                    throw "Gradient:wrong startSearchIndex.";
                                var diff = right - left;
                                var y1 = right - lerpFactor;
                                var y2 = lerpFactor - left;
                                out.r = (y1 * rgbElements[offset - 3] + y2 * rgbElements[offset + 1]) / diff;
                                out.g = (y1 * rgbElements[offset - 2] + y2 * rgbElements[offset + 2]) / diff;
                                out.b = (y1 * rgbElements[offset - 1] + y2 * rgbElements[offset + 3]) / diff;
                                return curIndex;
                            }
                            else {
                                curIndex++;
                                continue;
                            }
                        case GradientMode.Fixed:
                            if (lerpFactor < right) {
                                if (lerpFactor < rgbElements[offset - 4])
                                    throw "Gradient:wrong startSearchIndex.";
                                out.r = rgbElements[offset + 1];
                                out.g = rgbElements[offset + 2];
                                out.b = rgbElements[offset + 3];
                                return curIndex;
                            }
                            else {
                                curIndex++;
                                continue;
                            }
                        default:
                            throw "Gradient:unknown mode.";
                    }
                }
            }
            return curIndex;
        }
        evaluateColorAlpha(lerpFactor, outColor, startSearchIndex = 0, reverseSearch = false) {
            lerpFactor = Math.min(Math.max(lerpFactor, 0.0), 1.0);
            var alphaElements = this._alphaElements;
            var curIndex = startSearchIndex;
            if (reverseSearch) {
                for (var i = curIndex; i >= 0; i--) {
                    var offset = i * 2;
                    var left = alphaElements[offset];
                    if (lerpFactor === left) {
                        outColor.a = alphaElements[offset + 1];
                        return curIndex;
                    }
                    switch (this._mode) {
                        case GradientMode.Blend:
                            if (lerpFactor > left) {
                                var right = alphaElements[offset + 2];
                                if (lerpFactor > right)
                                    throw "Gradient:wrong startSearchIndex.";
                                var diff = right - left;
                                var x1 = right - lerpFactor;
                                var x2 = lerpFactor - left;
                                outColor.a = (x1 * alphaElements[offset + 1] + x2 * alphaElements[offset + 3]) / diff;
                                return curIndex;
                            }
                            else {
                                curIndex--;
                                continue;
                            }
                        case GradientMode.Fixed:
                            if (lerpFactor > left) {
                                if (lerpFactor > alphaElements[offset + 2])
                                    throw "Gradient:wrong startSearchIndex.";
                                outColor.a = alphaElements[offset + 3];
                                return curIndex;
                            }
                            else {
                                curIndex--;
                                continue;
                            }
                        default:
                            throw "Gradient:unknown mode.";
                    }
                }
            }
            else {
                for (var i = curIndex, n = this._alphaElements.length; i < n; i++) {
                    var offset = i * 2;
                    var right = alphaElements[offset];
                    if (lerpFactor === right) {
                        outColor.a = alphaElements[offset + 1];
                        return curIndex;
                    }
                    switch (this._mode) {
                        case GradientMode.Blend:
                            if (lerpFactor < right) {
                                var left = alphaElements[offset - 2];
                                if (lerpFactor < left)
                                    throw "Gradient:wrong startSearchIndex.";
                                var diff = right - left;
                                var x1 = right - lerpFactor;
                                var x2 = lerpFactor - left;
                                outColor.a = (x1 * alphaElements[offset - 1] + x2 * alphaElements[offset + 1]) / diff;
                                return curIndex;
                            }
                            else {
                                curIndex++;
                                continue;
                            }
                        case GradientMode.Fixed:
                            if (lerpFactor < right) {
                                if (lerpFactor < alphaElements[offset - 2])
                                    throw "Gradient:wrong startSearchIndex.";
                                outColor.a = alphaElements[offset + 1];
                                return curIndex;
                            }
                            else {
                                curIndex++;
                                continue;
                            }
                        default:
                            throw "Gradient:unknown mode.";
                    }
                }
            }
            return curIndex;
        }
        cloneTo(destObject) {
            var destGradientDataColor = destObject;
            var i, n;
            destGradientDataColor._colorAlphaKeysCount = this._colorAlphaKeysCount;
            let destAlphaElements = destGradientDataColor._alphaElements = new Float32Array(this._alphaElements.length);
            for (i = 0, n = this._alphaElements.length; i < n; i++)
                destAlphaElements[i] = this._alphaElements[i];
            destGradientDataColor._colorRGBKeysCount = this._colorRGBKeysCount;
            var destRGBElements = destGradientDataColor._rgbElements = new Float32Array(this._rgbElements.length);
            for (i = 0, n = this._rgbElements.length; i < n; i++)
                destRGBElements[i] = this._rgbElements[i];
        }
        clone() {
            var destGradientDataColor = new Gradient(this._maxColorRGBKeysCount, this._maxColorAlphaKeysCount);
            this.cloneTo(destGradientDataColor);
            return destGradientDataColor;
        }
    }

    class DirectionLightCom extends Light {
        constructor() {
            super();
            this._direction = new Laya.Vector3();
            this._shadowCascadesMode = exports.ShadowCascadesMode.NoCascades;
            this._shadowTwoCascadeSplits = 1.0 / 3.0;
            this._shadowFourCascadeSplits = new Laya.Vector3(1.0 / 15, 3.0 / 15.0, 7.0 / 15.0);
            this._lightType = exports.LightType.Directional;
        }
        get shadowCascadesMode() {
            return this._shadowCascadesMode;
        }
        set shadowCascadesMode(value) {
            this._shadowCascadesMode = value;
        }
        get shadowTwoCascadeSplits() {
            return this._shadowTwoCascadeSplits;
        }
        set shadowTwoCascadeSplits(value) {
            this._shadowTwoCascadeSplits = value;
        }
        get shadowFourCascadeSplits() {
            return this._shadowFourCascadeSplits;
        }
        set shadowFourCascadeSplits(value) {
            if (value.x > value.y || value.y > value.z || value.z > 1.0)
                throw "DiretionLight:Invalid value.";
            value.cloneTo(this._shadowFourCascadeSplits);
        }
        _addToLightQueue() {
            this.owner.scene._directionLights.add(this);
        }
        _removeFromLightQueue() {
            this.owner.scene._directionLights.remove(this);
        }
        _create() {
            return new DirectionLightCom();
        }
    }

    class LightSprite extends Sprite3D {
        constructor() {
            super();
        }
        get color() {
            return this._light.color;
        }
        set color(value) {
            this._light.color = value;
        }
        get mode() {
            return this._light.lightmapBakedType;
        }
        set mode(value) {
            this._light.lightmapBakedType = value;
        }
        get intensity() {
            return this._light.intensity;
        }
        set intensity(value) {
            this._light.intensity = value;
        }
        get shadowMode() {
            return this._light.shadowMode;
        }
        set shadowMode(value) {
            this._light.shadowMode = value;
        }
        get shadowDistance() {
            return this._light.shadowDistance;
        }
        set shadowDistance(value) {
            this._light.shadowDistance = value;
        }
        get shadowResolution() {
            return this._light.shadowResolution;
        }
        set shadowResolution(value) {
            this._light.shadowResolution = value;
        }
        get shadowDepthBias() {
            return this._light.shadowDepthBias;
        }
        set shadowDepthBias(value) {
            this._light.shadowDepthBias = value;
        }
        get shadowNormalBias() {
            return this._light.shadowNormalBias;
        }
        set shadowNormalBias(value) {
            this._light.shadowNormalBias = value;
        }
        get shadowStrength() {
            return this._light.shadowStrength;
        }
        set shadowStrength(value) {
            this._light.shadowStrength = value;
        }
        get shadowNearPlane() {
            return this._light.shadowNearPlane;
        }
        set shadowNearPlane(value) {
            this._light.shadowNearPlane = value;
        }
        get lightmapBakedType() {
            return this._light.lightmapBakedType;
        }
        set lightmapBakedType(value) {
            this._light.lightmapBakedType = value;
        }
        get lightWorldMatrix() {
            return this._light.lightWorldMatrix;
        }
        _parse(data, spriteMap) {
            super._parse(data, spriteMap);
            var colorData = data.color;
            this.color.r = colorData[0];
            this.color.g = colorData[1];
            this.color.b = colorData[2];
            this.intensity = data.intensity;
            this.lightmapBakedType = data.lightmapBakedType;
        }
        _cloneTo(destObject, rootSprite, dstSprite) {
            super._cloneTo(destObject, rootSprite, dstSprite);
            var spriteLight = destObject;
            spriteLight.color = this.color.clone();
            spriteLight.intensity = this.intensity;
            spriteLight.lightmapBakedType = this.lightmapBakedType;
        }
        _addToLightQueue() {
        }
        _removeFromLightQueue() {
        }
        _create() {
            return new Sprite3D();
        }
    }

    class DirectionLight extends LightSprite {
        constructor() {
            super();
            this._light = this.addComponent(DirectionLightCom);
        }
        get shadowCascadesMode() {
            return this._light._shadowCascadesMode;
        }
        set shadowCascadesMode(value) {
            this._light._shadowCascadesMode = value;
        }
        get shadowTwoCascadeSplits() {
            return this._light._shadowTwoCascadeSplits;
        }
        set shadowTwoCascadeSplits(value) {
            this._light._shadowTwoCascadeSplits = value;
        }
        get shadowFourCascadeSplits() {
            return this._light._shadowFourCascadeSplits;
        }
        set shadowFourCascadeSplits(value) {
            if (value.x > value.y || value.y > value.z || value.z > 1.0)
                throw "DiretionLight:Invalid value.";
            value.cloneTo(this._light._shadowFourCascadeSplits);
        }
        _create() {
            return new Sprite3D();
        }
    }

    class PointLightCom extends Light {
        constructor() {
            super();
            this._range = 6.0;
            this._lightType = exports.LightType.Point;
        }
        get range() {
            return this._range;
        }
        set range(value) {
            this._range = value;
        }
        _addToLightQueue() {
            this.owner.scene._pointLights.add(this);
        }
        _removeFromLightQueue() {
            this.owner.scene._pointLights.remove(this);
        }
        _parse(data, spriteMap) {
            super._parse(data, spriteMap);
            this.range = data.range;
        }
        _cloneTo(dest) {
            super._cloneTo(dest);
            var pointlight = dest;
            pointlight.range = this.range;
            pointlight._lightType = exports.LightType.Point;
        }
        _create() {
            return new PointLightCom();
        }
    }

    class PointLight extends LightSprite {
        constructor() {
            super();
            this._light = this.addComponent(PointLightCom);
            this._light.range = 6.0;
        }
        get range() {
            return this._light.range;
        }
        set range(value) {
            this._light.range = value;
        }
        _parse(data, spriteMap) {
            super._parse(data, spriteMap);
            this.range = data.range;
        }
        _cloneTo(destObject, rootSprite, dstSprite) {
            super._cloneTo(destObject, rootSprite, dstSprite);
        }
        _create() {
            return new Sprite3D();
        }
    }

    class SpotLightCom extends Light {
        constructor() {
            super();
            this._spotAngle = 30.0;
            this._range = 10.0;
            this._direction = new Laya.Vector3();
            this._lightType = exports.LightType.Spot;
        }
        get spotAngle() {
            return this._spotAngle;
        }
        set spotAngle(value) {
            this._spotAngle = Math.max(Math.min(value, 179), 0);
        }
        get range() {
            return this._range;
        }
        set range(value) {
            this._range = value;
        }
        _addToLightQueue() {
            this.owner.scene._spotLights.add(this);
        }
        _removeFromLightQueue() {
            this.owner.scene._spotLights.remove(this);
        }
        _parse(data, spriteMap) {
            super._parse(data, spriteMap);
            this.range = data.range;
            this.spotAngle = data.spotAngle;
        }
        _cloneTo(dest) {
            super._cloneTo(dest);
            var spotLight = dest;
            spotLight.range = this.range;
            spotLight.spotAngle = this.spotAngle;
        }
        _create() {
            return new SpotLightCom();
        }
    }

    class SpotLight extends LightSprite {
        constructor() {
            super();
            this._light = this.addComponent(SpotLightCom);
        }
        get spotAngle() {
            return this._light.spotAngle;
        }
        set spotAngle(value) {
            this._light.spotAngle = Math.max(Math.min(value, 179), 0);
        }
        get range() {
            return this._light.range;
        }
        set range(value) {
            this._light.range = value;
        }
        _parse(data, spriteMap) {
            super._parse(data, spriteMap);
            this.range = data.range;
            this.spotAngle = data.spotAngle;
        }
        _cloneTo(destObject, rootSprite, dstSprite) {
            super._cloneTo(destObject, rootSprite, dstSprite);
        }
        _create() {
            return new Sprite3D();
        }
    }

    class UnlitMaterial extends Material {
        constructor() {
            super();
            this.setShaderName("Unlit");
            this.renderMode = UnlitMaterial.RENDERMODE_OPAQUE;
            this.albedoIntensity = 1.0;
        }
        static __initDefine__() {
            UnlitMaterial.SHADERDEFINE_ALBEDOTEXTURE = Laya.Shader3D.getDefineByName("ALBEDOTEXTURE");
            UnlitMaterial.SHADERDEFINE_ENABLEVERTEXCOLOR = Laya.Shader3D.getDefineByName("ENABLEVERTEXCOLOR");
            UnlitMaterial.ALBEDOTEXTURE = Laya.Shader3D.propertyNameToID("u_AlbedoTexture");
            UnlitMaterial.ALBEDOCOLOR = Laya.Shader3D.propertyNameToID("u_AlbedoColor");
            UnlitMaterial.TILINGOFFSET = Laya.Shader3D.propertyNameToID("u_TilingOffset");
        }
        get albedoColor() {
            return this.getColorByIndex(UnlitMaterial.ALBEDOCOLOR);
        }
        set albedoColor(value) {
            this.setColorByIndex(UnlitMaterial.ALBEDOCOLOR, value.scale(this._albedoIntensity));
        }
        get albedoIntensity() {
            return this._albedoIntensity;
        }
        set albedoIntensity(value) {
            this._albedoIntensity = value;
        }
        get albedoTexture() {
            return this.getTextureByIndex(UnlitMaterial.ALBEDOTEXTURE);
        }
        set albedoTexture(value) {
            if (value)
                this.addDefine(UnlitMaterial.SHADERDEFINE_ALBEDOTEXTURE);
            else
                this.removeDefine(UnlitMaterial.SHADERDEFINE_ALBEDOTEXTURE);
            this.setTextureByIndex(UnlitMaterial.ALBEDOTEXTURE, value);
        }
        get tilingOffset() {
            return this.getVector4ByIndex(UnlitMaterial.TILINGOFFSET);
        }
        set tilingOffset(value) {
            if (value) {
                this.setVector4ByIndex(UnlitMaterial.TILINGOFFSET, value);
            }
            else {
                this.setVector4ByIndex(UnlitMaterial.TILINGOFFSET, new Laya.Vector4(1.0, 1.0, 0.0, 0.0));
            }
        }
        get enableVertexColor() {
            return this.hasDefine(UnlitMaterial.SHADERDEFINE_ENABLEVERTEXCOLOR);
        }
        set enableVertexColor(value) {
            if (value)
                this.addDefine(UnlitMaterial.SHADERDEFINE_ENABLEVERTEXCOLOR);
            else
                this.removeDefine(UnlitMaterial.SHADERDEFINE_ENABLEVERTEXCOLOR);
        }
        clone() {
            var dest = new UnlitMaterial();
            this.cloneTo(dest);
            return dest;
        }
        set renderMode(value) {
            switch (value) {
                case UnlitMaterial.RENDERMODE_OPAQUE:
                    this.alphaTest = false;
                    this.renderQueue = Material.RENDERQUEUE_OPAQUE;
                    this.depthWrite = true;
                    this.cull = Laya.RenderState.CULL_BACK;
                    this.blend = Laya.RenderState.BLEND_DISABLE;
                    this.depthTest = Laya.RenderState.DEPTHTEST_LESS;
                    break;
                case UnlitMaterial.RENDERMODE_CUTOUT:
                    this.renderQueue = Material.RENDERQUEUE_ALPHATEST;
                    this.alphaTest = true;
                    this.depthWrite = true;
                    this.cull = Laya.RenderState.CULL_BACK;
                    this.blend = Laya.RenderState.BLEND_DISABLE;
                    this.depthTest = Laya.RenderState.DEPTHTEST_LESS;
                    break;
                case UnlitMaterial.RENDERMODE_TRANSPARENT:
                    this.renderQueue = Material.RENDERQUEUE_TRANSPARENT;
                    this.alphaTest = false;
                    this.depthWrite = false;
                    this.cull = Laya.RenderState.CULL_BACK;
                    this.blend = Laya.RenderState.BLEND_ENABLE_ALL;
                    this.blendSrc = Laya.RenderState.BLENDPARAM_SRC_ALPHA;
                    this.blendDst = Laya.RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA;
                    this.depthTest = Laya.RenderState.DEPTHTEST_LESS;
                    break;
                default:
                    throw new Error("UnlitMaterial : renderMode value error.");
            }
        }
    }
    UnlitMaterial.RENDERMODE_OPAQUE = 0;
    UnlitMaterial.RENDERMODE_CUTOUT = 1;
    UnlitMaterial.RENDERMODE_TRANSPARENT = 2;
    UnlitMaterial.RENDERMODE_ADDTIVE = 3;

    class EffectMaterial extends Material {
        constructor() {
            super();
            this.setShaderName("Unlit");
            this.setVector4ByIndex(UnlitMaterial.TILINGOFFSET, new Laya.Vector4(1.0, 1.0, 0.0, 0.0));
            this.setColorByIndex(UnlitMaterial.ALBEDOCOLOR, new Laya.Color(1.0, 1.0, 1.0, 1.0));
            this.renderMode = EffectMaterial.RENDERMODE_ADDTIVE;
        }
        get color() {
            return this.getColorByIndex(UnlitMaterial.ALBEDOCOLOR);
        }
        set color(value) {
            this.setColorByIndex(UnlitMaterial.ALBEDOCOLOR, value);
        }
        get texture() {
            return this.getTextureByIndex(UnlitMaterial.ALBEDOTEXTURE);
        }
        set texture(value) {
            if (value)
                this.addDefine(UnlitMaterial.SHADERDEFINE_ALBEDOTEXTURE);
            else
                this.removeDefine(UnlitMaterial.SHADERDEFINE_ALBEDOTEXTURE);
            this.setTextureByIndex(UnlitMaterial.ALBEDOTEXTURE, value);
        }
        get tilingOffset() {
            return this.getVector4ByIndex(UnlitMaterial.TILINGOFFSET);
        }
        set tilingOffset(value) {
            if (value) {
                this.setVector4ByIndex(UnlitMaterial.TILINGOFFSET, value);
            }
            else {
                this.getVector4ByIndex(UnlitMaterial.TILINGOFFSET).setValue(1.0, 1.0, 0.0, 0.0);
            }
        }
        clone() {
            var dest = new EffectMaterial();
            this.cloneTo(dest);
            return dest;
        }
        set renderMode(value) {
            switch (value) {
                case EffectMaterial.RENDERMODE_ADDTIVE:
                    this.renderQueue = Material.RENDERQUEUE_TRANSPARENT;
                    this.alphaTest = false;
                    this.depthWrite = false;
                    this.cull = Laya.RenderState.CULL_NONE;
                    this.blend = Laya.RenderState.BLEND_ENABLE_ALL;
                    this.blendSrc = Laya.RenderState.BLENDPARAM_SRC_ALPHA;
                    this.blendDst = Laya.RenderState.BLENDPARAM_ONE;
                    this.depthTest = Laya.RenderState.DEPTHTEST_LEQUAL;
                    this.addDefine(Material.SHADERDEFINE_ADDTIVEFOG);
                    break;
                case EffectMaterial.RENDERMODE_ALPHABLENDED:
                    this.renderQueue = Material.RENDERQUEUE_TRANSPARENT;
                    this.alphaTest = false;
                    this.depthWrite = false;
                    this.cull = Laya.RenderState.CULL_NONE;
                    this.blend = Laya.RenderState.BLEND_ENABLE_ALL;
                    this.blendSrc = Laya.RenderState.BLENDPARAM_SRC_ALPHA;
                    this.blendDst = Laya.RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA;
                    this.depthTest = Laya.RenderState.DEPTHTEST_LEQUAL;
                    this.removeDefine(Material.SHADERDEFINE_ADDTIVEFOG);
                    break;
                default:
                    throw new Error("MeshEffectMaterial : renderMode value error.");
            }
        }
    }
    EffectMaterial.RENDERMODE_ADDTIVE = 0;
    EffectMaterial.RENDERMODE_ALPHABLENDED = 1;

    class ExtendTerrainMaterial extends Material {
        constructor() {
            super();
            this.setShaderName("ExtendTerrain");
            this.renderMode = ExtendTerrainMaterial.RENDERMODE_OPAQUE;
        }
        static __initDefine__() {
            ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM1 = Laya.Shader3D.getDefineByName("ExtendTerrain_DETAIL_NUM1");
            ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM2 = Laya.Shader3D.getDefineByName("ExtendTerrain_DETAIL_NUM2");
            ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM3 = Laya.Shader3D.getDefineByName("ExtendTerrain_DETAIL_NUM3");
            ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM4 = Laya.Shader3D.getDefineByName("ExtendTerrain_DETAIL_NUM4");
            ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM5 = Laya.Shader3D.getDefineByName("ExtendTerrain_DETAIL_NUM5");
            ExtendTerrainMaterial.SPLATALPHATEXTURE = Laya.Shader3D.propertyNameToID("u_SplatAlphaTexture");
            ExtendTerrainMaterial.DIFFUSETEXTURE1 = Laya.Shader3D.propertyNameToID("u_DiffuseTexture1");
            ExtendTerrainMaterial.DIFFUSETEXTURE2 = Laya.Shader3D.propertyNameToID("u_DiffuseTexture2");
            ExtendTerrainMaterial.DIFFUSETEXTURE3 = Laya.Shader3D.propertyNameToID("u_DiffuseTexture3");
            ExtendTerrainMaterial.DIFFUSETEXTURE4 = Laya.Shader3D.propertyNameToID("u_DiffuseTexture4");
            ExtendTerrainMaterial.DIFFUSETEXTURE5 = Laya.Shader3D.propertyNameToID("u_DiffuseTexture5");
            ExtendTerrainMaterial.DIFFUSESCALEOFFSET1 = Laya.Shader3D.propertyNameToID("u_DiffuseScaleOffset1");
            ExtendTerrainMaterial.DIFFUSESCALEOFFSET2 = Laya.Shader3D.propertyNameToID("u_DiffuseScaleOffset2");
            ExtendTerrainMaterial.DIFFUSESCALEOFFSET3 = Laya.Shader3D.propertyNameToID("u_DiffuseScaleOffset3");
            ExtendTerrainMaterial.DIFFUSESCALEOFFSET4 = Laya.Shader3D.propertyNameToID("u_DiffuseScaleOffset4");
            ExtendTerrainMaterial.DIFFUSESCALEOFFSET5 = Laya.Shader3D.propertyNameToID("u_DiffuseScaleOffset5");
        }
        get splatAlphaTexture() {
            return this._shaderValues.getTexture(ExtendTerrainMaterial.SPLATALPHATEXTURE);
        }
        set splatAlphaTexture(value) {
            this._shaderValues.setTexture(ExtendTerrainMaterial.SPLATALPHATEXTURE, value);
        }
        get diffuseTexture1() {
            return this._shaderValues.getTexture(ExtendTerrainMaterial.DIFFUSETEXTURE1);
        }
        set diffuseTexture1(value) {
            this._shaderValues.setTexture(ExtendTerrainMaterial.DIFFUSETEXTURE1, value);
            this._setDetailNum(1);
        }
        get diffuseTexture2() {
            return this._shaderValues.getTexture(ExtendTerrainMaterial.DIFFUSETEXTURE2);
        }
        set diffuseTexture2(value) {
            this._shaderValues.setTexture(ExtendTerrainMaterial.DIFFUSETEXTURE2, value);
            this._setDetailNum(2);
        }
        get diffuseTexture3() {
            return this._shaderValues.getTexture(ExtendTerrainMaterial.DIFFUSETEXTURE3);
        }
        set diffuseTexture3(value) {
            this._shaderValues.setTexture(ExtendTerrainMaterial.DIFFUSETEXTURE3, value);
            this._setDetailNum(3);
        }
        get diffuseTexture4() {
            return this._shaderValues.getTexture(ExtendTerrainMaterial.DIFFUSETEXTURE4);
        }
        set diffuseTexture4(value) {
            this._shaderValues.setTexture(ExtendTerrainMaterial.DIFFUSETEXTURE4, value);
            this._setDetailNum(4);
        }
        get diffuseTexture5() {
            return this._shaderValues.getTexture(ExtendTerrainMaterial.DIFFUSETEXTURE5);
        }
        set diffuseTexture5(value) {
            this._shaderValues.setTexture(ExtendTerrainMaterial.DIFFUSETEXTURE5, value);
            this._setDetailNum(5);
        }
        set diffuseScaleOffset1(scaleOffset1) {
            this._shaderValues.setVector(ExtendTerrainMaterial.DIFFUSESCALEOFFSET1, scaleOffset1);
        }
        set diffuseScaleOffset2(scaleOffset2) {
            this._shaderValues.setVector(ExtendTerrainMaterial.DIFFUSESCALEOFFSET2, scaleOffset2);
        }
        set diffuseScaleOffset3(scaleOffset3) {
            this._shaderValues.setVector(ExtendTerrainMaterial.DIFFUSESCALEOFFSET3, scaleOffset3);
        }
        set diffuseScaleOffset4(scaleOffset4) {
            this._shaderValues.setVector(ExtendTerrainMaterial.DIFFUSESCALEOFFSET4, scaleOffset4);
        }
        set diffuseScaleOffset5(scaleOffset5) {
            this._shaderValues.setVector(ExtendTerrainMaterial.DIFFUSESCALEOFFSET5, scaleOffset5);
        }
        set renderMode(value) {
            switch (value) {
                case ExtendTerrainMaterial.RENDERMODE_OPAQUE:
                    this.renderQueue = Material.RENDERQUEUE_OPAQUE;
                    this.depthWrite = true;
                    this.cull = Laya.RenderState.CULL_BACK;
                    this.blend = Laya.RenderState.BLEND_DISABLE;
                    this.depthTest = Laya.RenderState.DEPTHTEST_LESS;
                    break;
                case ExtendTerrainMaterial.RENDERMODE_TRANSPARENT:
                    this.renderQueue = Material.RENDERQUEUE_OPAQUE;
                    this.depthWrite = false;
                    this.cull = Laya.RenderState.CULL_BACK;
                    this.blend = Laya.RenderState.BLEND_ENABLE_ALL;
                    this.blendSrc = Laya.RenderState.BLENDPARAM_SRC_ALPHA;
                    this.blendDst = Laya.RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA;
                    this.depthTest = Laya.RenderState.DEPTHTEST_LEQUAL;
                    break;
                default:
                    throw new Error("ExtendTerrainMaterial:renderMode value error.");
            }
        }
        _setDetailNum(value) {
            switch (value) {
                case 1:
                    this._shaderValues.addDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM1);
                    this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM2);
                    this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM3);
                    this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM4);
                    this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM5);
                    break;
                case 2:
                    this._shaderValues.addDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM2);
                    this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM1);
                    this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM3);
                    this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM4);
                    this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM5);
                    break;
                case 3:
                    this._shaderValues.addDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM3);
                    this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM1);
                    this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM2);
                    this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM4);
                    this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM5);
                    break;
                case 4:
                    this._shaderValues.addDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM4);
                    this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM1);
                    this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM2);
                    this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM3);
                    this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM5);
                    break;
                case 5:
                    this._shaderValues.addDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM5);
                    this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM1);
                    this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM2);
                    this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM3);
                    this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM4);
                    break;
            }
        }
        clone() {
            var dest = new ExtendTerrainMaterial();
            this.cloneTo(dest);
            return dest;
        }
    }
    ExtendTerrainMaterial.RENDERMODE_OPAQUE = 1;
    ExtendTerrainMaterial.RENDERMODE_TRANSPARENT = 2;

    exports.PBRRenderQuality = void 0;
    (function (PBRRenderQuality) {
        PBRRenderQuality[PBRRenderQuality["High"] = 0] = "High";
        PBRRenderQuality[PBRRenderQuality["Low"] = 1] = "Low";
    })(exports.PBRRenderQuality || (exports.PBRRenderQuality = {}));

    exports.PBRRenderMode = void 0;
    (function (PBRRenderMode) {
        PBRRenderMode[PBRRenderMode["Opaque"] = 0] = "Opaque";
        PBRRenderMode[PBRRenderMode["Cutout"] = 1] = "Cutout";
        PBRRenderMode[PBRRenderMode["Fade"] = 2] = "Fade";
        PBRRenderMode[PBRRenderMode["Transparent"] = 3] = "Transparent";
    })(exports.PBRRenderMode || (exports.PBRRenderMode = {}));
    exports.PBRMaterialType = void 0;
    (function (PBRMaterialType) {
        PBRMaterialType[PBRMaterialType["Standard"] = 0] = "Standard";
        PBRMaterialType[PBRMaterialType["Anisotropy"] = 1] = "Anisotropy";
    })(exports.PBRMaterialType || (exports.PBRMaterialType = {}));
    class PBRMaterial extends Material {
        constructor() {
            super();
            this._shaderValues.setColor(PBRMaterial.ALBEDOCOLOR, new Laya.Color(1.0, 1.0, 1.0, 1.0));
            this._shaderValues.setColor(PBRMaterial.EMISSIONCOLOR, new Laya.Color(1.0, 1.0, 1.0, 1.0));
            this._shaderValues.setVector(PBRMaterial.TILINGOFFSET, new Laya.Vector4(1.0, 1.0, 0.0, 0.0));
            this._shaderValues.setNumber(PBRMaterial.SMOOTHNESS, 0.5);
            this._shaderValues.setNumber(PBRMaterial.SMOOTHNESSSCALE, 1.0);
            this._shaderValues.setNumber(PBRMaterial.OCCLUSIONSTRENGTH, 1.0);
            this._shaderValues.setNumber(PBRMaterial.NORMALSCALE, 1.0);
            this._shaderValues.setNumber(PBRMaterial.PARALLAXSCALE, 0.001);
            this._shaderValues.setNumber(Material.ALPHATESTVALUE, 0.5);
            this.renderMode = exports.PBRRenderMode.Opaque;
            this.materialType = exports.PBRMaterialType.Standard;
        }
        static __init__() {
            PBRMaterial.SHADERDEFINE_ALBEDOTEXTURE = Laya.Shader3D.getDefineByName("ALBEDOTEXTURE");
            PBRMaterial.SHADERDEFINE_NORMALTEXTURE = Laya.Shader3D.getDefineByName("NORMALTEXTURE");
            PBRMaterial.SHADERDEFINE_PARALLAXTEXTURE = Laya.Shader3D.getDefineByName("PARALLAXTEXTURE");
            PBRMaterial.SHADERDEFINE_OCCLUSIONTEXTURE = Laya.Shader3D.getDefineByName("OCCLUSIONTEXTURE");
            PBRMaterial.SHADERDEFINE_EMISSION = Laya.Shader3D.getDefineByName("EMISSION");
            PBRMaterial.SHADERDEFINE_EMISSIONTEXTURE = Laya.Shader3D.getDefineByName("EMISSIONTEXTURE");
            PBRMaterial.SHADERDEFINE_ANISOTROPY = Laya.Shader3D.getDefineByName("ANISOTROPIC");
            PBRMaterial.SHADERDEFINE_TANGENTTEXTURE = Laya.Shader3D.getDefineByName("TANGENTTEXTURE");
            PBRMaterial.SHADERDEFINE_TRANSPARENTBLEND = Laya.Shader3D.getDefineByName("TRANSPARENTBLEND");
            PBRMaterial.SHADERDEFINE_LAYA_PBR_BRDF_HIGH = Laya.Shader3D.getDefineByName("LAYA_PBR_BRDF_HIGH");
            PBRMaterial.SHADERDEFINE_LAYA_PBR_BRDF_LOW = Laya.Shader3D.getDefineByName("LAYA_PBR_BRDF_LOW");
            PBRMaterial.SHADERDEFINE_DETAILALBEDO = Laya.Shader3D.getDefineByName("DETAILTEXTURE");
            PBRMaterial.SHADERDEFINE_DETAILNORMAL = Laya.Shader3D.getDefineByName("DETAILNORMAL");
            PBRMaterial.SHADERDEFINE_ENABLEVERTEXCOLOR = Laya.Shader3D.getDefineByName("ENABLEVERTEXCOLOR");
            PBRMaterial.ALBEDOTEXTURE = Laya.Shader3D.propertyNameToID("u_AlbedoTexture");
            PBRMaterial.ALBEDOCOLOR = Laya.Shader3D.propertyNameToID("u_AlbedoColor");
            PBRMaterial.TILINGOFFSET = Laya.Shader3D.propertyNameToID("u_TilingOffset");
            PBRMaterial.NORMALTEXTURE = Laya.Shader3D.propertyNameToID("u_NormalTexture");
            PBRMaterial.NORMALSCALE = Laya.Shader3D.propertyNameToID("u_NormalScale");
            PBRMaterial.SMOOTHNESS = Laya.Shader3D.propertyNameToID("u_Smoothness");
            PBRMaterial.SMOOTHNESSSCALE = Laya.Shader3D.propertyNameToID("u_SmoothnessScale");
            PBRMaterial.OCCLUSIONTEXTURE = Laya.Shader3D.propertyNameToID("u_OcclusionTexture");
            PBRMaterial.OCCLUSIONSTRENGTH = Laya.Shader3D.propertyNameToID("u_OcclusionStrength");
            PBRMaterial.PARALLAXTEXTURE = Laya.Shader3D.propertyNameToID("u_ParallaxTexture");
            PBRMaterial.PARALLAXSCALE = Laya.Shader3D.propertyNameToID("u_ParallaxScale");
            PBRMaterial.EMISSIONTEXTURE = Laya.Shader3D.propertyNameToID("u_EmissionTexture");
            PBRMaterial.EMISSIONCOLOR = Laya.Shader3D.propertyNameToID("u_EmissionColor");
            PBRMaterial.EMISSIONIntensity = Laya.Shader3D.propertyNameToID("u_EmissionIntensity");
            PBRMaterial.ANISOTROPY = Laya.Shader3D.propertyNameToID("u_Anisotropy");
            PBRMaterial.TANGENTTEXTURE = Laya.Shader3D.propertyNameToID("u_TangentTexture");
            PBRMaterial.DETAILALBEDOTEXTURE = Laya.Shader3D.propertyNameToID("u_DetailAlbedoTexture");
            PBRMaterial.DETAILNORMALTEXTURE = Laya.Shader3D.propertyNameToID("u_DetailNormalTexture");
            PBRMaterial.DETAILTILLINGOFFSET = Laya.Shader3D.propertyNameToID("u_DetailTillingOffset");
            PBRMaterial.DETAILNORMALSCALE = Laya.Shader3D.propertyNameToID("u_DetailNormalScale");
        }
        get albedoColor() {
            return this._shaderValues.getColor(PBRMaterial.ALBEDOCOLOR);
        }
        set albedoColor(value) {
            this._shaderValues.setColor(PBRMaterial.ALBEDOCOLOR, value);
        }
        get albedoTexture() {
            return this._shaderValues.getTexture(PBRMaterial.ALBEDOTEXTURE);
        }
        set albedoTexture(value) {
            if (value)
                this._shaderValues.addDefine(PBRMaterial.SHADERDEFINE_ALBEDOTEXTURE);
            else
                this._shaderValues.removeDefine(PBRMaterial.SHADERDEFINE_ALBEDOTEXTURE);
            this._shaderValues.setTexture(PBRMaterial.ALBEDOTEXTURE, value);
        }
        get normalTexture() {
            return this._shaderValues.getTexture(PBRMaterial.NORMALTEXTURE);
        }
        set normalTexture(value) {
            if (value) {
                this._shaderValues.addDefine(PBRMaterial.SHADERDEFINE_NORMALTEXTURE);
            }
            else {
                this._shaderValues.removeDefine(PBRMaterial.SHADERDEFINE_NORMALTEXTURE);
            }
            this._shaderValues.setTexture(PBRMaterial.NORMALTEXTURE, value);
            this.resetNeedTBN();
        }
        get normalTextureScale() {
            return this._shaderValues.getNumber(PBRMaterial.NORMALSCALE);
        }
        set normalTextureScale(value) {
            this._shaderValues.setNumber(PBRMaterial.NORMALSCALE, value);
        }
        get parallaxTexture() {
            return this._shaderValues.getTexture(PBRMaterial.PARALLAXTEXTURE);
        }
        set parallaxTexture(value) {
            if (value)
                this._shaderValues.addDefine(PBRMaterial.SHADERDEFINE_PARALLAXTEXTURE);
            else
                this._shaderValues.removeDefine(PBRMaterial.SHADERDEFINE_PARALLAXTEXTURE);
            this._shaderValues.setTexture(PBRMaterial.PARALLAXTEXTURE, value);
        }
        get parallaxTextureScale() {
            return this._shaderValues.getNumber(PBRMaterial.PARALLAXSCALE);
        }
        set parallaxTextureScale(value) {
            this._shaderValues.setNumber(PBRMaterial.PARALLAXSCALE, Math.max(0.005, Math.min(0.08, value)));
        }
        get occlusionTexture() {
            return this._shaderValues.getTexture(PBRMaterial.OCCLUSIONTEXTURE);
        }
        set occlusionTexture(value) {
            if (value)
                this._shaderValues.addDefine(PBRMaterial.SHADERDEFINE_OCCLUSIONTEXTURE);
            else
                this._shaderValues.removeDefine(PBRMaterial.SHADERDEFINE_OCCLUSIONTEXTURE);
            this._shaderValues.setTexture(PBRMaterial.OCCLUSIONTEXTURE, value);
        }
        get occlusionTextureStrength() {
            return this._shaderValues.getNumber(PBRMaterial.OCCLUSIONSTRENGTH);
        }
        set occlusionTextureStrength(value) {
            this._shaderValues.setNumber(PBRMaterial.OCCLUSIONSTRENGTH, Math.max(0.0, Math.min(1.0, value)));
        }
        get smoothness() {
            return this._shaderValues.getNumber(PBRMaterial.SMOOTHNESS);
        }
        set smoothness(value) {
            this._shaderValues.setNumber(PBRMaterial.SMOOTHNESS, Math.max(0.0, Math.min(1.0, value)));
        }
        get smoothnessTextureScale() {
            return this._shaderValues.getNumber(PBRMaterial.SMOOTHNESSSCALE);
        }
        set smoothnessTextureScale(value) {
            this._shaderValues.setNumber(PBRMaterial.SMOOTHNESSSCALE, Math.max(0.0, Math.min(1.0, value)));
        }
        get enableVertexColor() {
            return this.hasDefine(PBRMaterial.SHADERDEFINE_ENABLEVERTEXCOLOR);
        }
        set enableVertexColor(value) {
            if (value)
                this.addDefine(PBRMaterial.SHADERDEFINE_ENABLEVERTEXCOLOR);
            else
                this.removeDefine(PBRMaterial.SHADERDEFINE_ENABLEVERTEXCOLOR);
        }
        get enableEmission() {
            return this._shaderValues.hasDefine(PBRMaterial.SHADERDEFINE_EMISSION);
        }
        set enableEmission(value) {
            if (value)
                this._shaderValues.addDefine(PBRMaterial.SHADERDEFINE_EMISSION);
            else
                this._shaderValues.removeDefine(PBRMaterial.SHADERDEFINE_EMISSION);
        }
        get emissionColor() {
            return this._shaderValues.getColor(PBRMaterial.EMISSIONCOLOR);
        }
        set emissionColor(value) {
            this._shaderValues.setColor(PBRMaterial.EMISSIONCOLOR, value);
        }
        set emissionIntensity(value) {
            this._shaderValues.setNumber(PBRMaterial.EMISSIONIntensity, value);
        }
        get emissionIntensity() {
            return this._shaderValues.getNumber(PBRMaterial.EMISSIONIntensity);
        }
        get emissionTexture() {
            return this._shaderValues.getTexture(PBRMaterial.EMISSIONTEXTURE);
        }
        set emissionTexture(value) {
            if (value)
                this._shaderValues.addDefine(PBRMaterial.SHADERDEFINE_EMISSIONTEXTURE);
            else
                this._shaderValues.removeDefine(PBRMaterial.SHADERDEFINE_EMISSIONTEXTURE);
            this._shaderValues.setTexture(PBRMaterial.EMISSIONTEXTURE, value);
        }
        get tilingOffset() {
            return this._shaderValues.getVector(PBRMaterial.TILINGOFFSET);
        }
        set tilingOffset(value) {
            if (value) {
                this._shaderValues.setVector(PBRMaterial.TILINGOFFSET, value);
            }
            else {
                this._shaderValues.getVector(PBRMaterial.TILINGOFFSET).setValue(1.0, 1.0, 0.0, 0.0);
            }
        }
        get detailAlbedoTexture() {
            return this._shaderValues.getTexture(PBRMaterial.DETAILALBEDOTEXTURE);
        }
        set detailAlbedoTexture(value) {
            if (value)
                this._shaderValues.addDefine(PBRMaterial.SHADERDEFINE_DETAILALBEDO);
            else
                this._shaderValues.removeDefine(PBRMaterial.SHADERDEFINE_DETAILALBEDO);
            this._shaderValues.setTexture(PBRMaterial.DETAILALBEDOTEXTURE, value);
        }
        get detailNormalTexture() {
            return this._shaderValues.getTexture(PBRMaterial.DETAILNORMALTEXTURE);
        }
        set detailNormalTexture(value) {
            if (value)
                this._shaderValues.addDefine(PBRMaterial.SHADERDEFINE_DETAILNORMAL);
            else
                this._shaderValues.removeDefine(PBRMaterial.SHADERDEFINE_DETAILNORMAL);
            this._shaderValues.setTexture(PBRMaterial.DETAILNORMALTEXTURE, value);
            this.resetNeedTBN();
        }
        get detailTilingOffset() {
            return this._shaderValues.getVector(PBRMaterial.DETAILTILLINGOFFSET);
        }
        set detailTilingOffset(value) {
            if (value) {
                this._shaderValues.setVector(PBRMaterial.DETAILTILLINGOFFSET, value);
            }
            else {
                this._shaderValues.getVector(PBRMaterial.DETAILTILLINGOFFSET).setValue(1.0, 1.0, 0.0, 0.0);
            }
        }
        get detailNormalScale() {
            return this._shaderValues.getNumber(PBRMaterial.DETAILNORMALSCALE);
        }
        set detailNormalScale(value) {
            this._shaderValues.setNumber(PBRMaterial.DETAILNORMALSCALE, value);
        }
        set renderMode(value) {
            switch (value) {
                case exports.PBRRenderMode.Opaque:
                    this.alphaTest = false;
                    this.renderQueue = Material.RENDERQUEUE_OPAQUE;
                    this.depthWrite = true;
                    this.cull = Laya.RenderState.CULL_BACK;
                    this.blend = Laya.RenderState.BLEND_DISABLE;
                    this.depthTest = Laya.RenderState.DEPTHTEST_LESS;
                    this._shaderValues.removeDefine(PBRMaterial.SHADERDEFINE_TRANSPARENTBLEND);
                    break;
                case exports.PBRRenderMode.Cutout:
                    this.renderQueue = Material.RENDERQUEUE_ALPHATEST;
                    this.alphaTest = true;
                    this.depthWrite = true;
                    this.cull = Laya.RenderState.CULL_BACK;
                    this.blend = Laya.RenderState.BLEND_DISABLE;
                    this.depthTest = Laya.RenderState.DEPTHTEST_LESS;
                    this._shaderValues.removeDefine(PBRMaterial.SHADERDEFINE_TRANSPARENTBLEND);
                    break;
                case exports.PBRRenderMode.Fade:
                    this.renderQueue = Material.RENDERQUEUE_TRANSPARENT;
                    this.alphaTest = false;
                    this.depthWrite = false;
                    this.cull = Laya.RenderState.CULL_BACK;
                    this.blend = Laya.RenderState.BLEND_ENABLE_ALL;
                    this.blendSrc = Laya.RenderState.BLENDPARAM_SRC_ALPHA;
                    this.blendDst = Laya.RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA;
                    this.depthTest = Laya.RenderState.DEPTHTEST_LESS;
                    this._shaderValues.removeDefine(PBRMaterial.SHADERDEFINE_TRANSPARENTBLEND);
                    break;
                case exports.PBRRenderMode.Transparent:
                    this.renderQueue = Material.RENDERQUEUE_TRANSPARENT;
                    this.alphaTest = false;
                    this.depthWrite = false;
                    this.cull = Laya.RenderState.CULL_BACK;
                    this.blend = Laya.RenderState.BLEND_ENABLE_ALL;
                    this.blendSrc = Laya.RenderState.BLENDPARAM_ONE;
                    this.blendDst = Laya.RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA;
                    this.depthTest = Laya.RenderState.DEPTHTEST_LESS;
                    this._shaderValues.addDefine(PBRMaterial.SHADERDEFINE_TRANSPARENTBLEND);
                    break;
                default:
                    throw new Error("PBRMaterial:unknown renderMode value.");
            }
        }
        resetNeedTBN() {
            if (!!this.normalTexture || !!this.detailNormalTexture || this.materialType == exports.PBRMaterialType.Anisotropy) {
                this._shaderValues.addDefine(Laya.Shader3D.getDefineByName("NEEDTBN"));
            }
            else {
                this._shaderValues.removeDefine(Laya.Shader3D.getDefineByName("NEEDTBN"));
            }
        }
        get anisotropy() {
            return this.getFloatByIndex(PBRMaterial.ANISOTROPY);
        }
        set anisotropy(value) {
            this.setFloatByIndex(PBRMaterial.ANISOTROPY, Math.min(1, Math.max(-1, value)));
        }
        get tangentTexture() {
            return this.getTextureByIndex(PBRMaterial.TANGENTTEXTURE);
        }
        set tangentTexture(value) {
            this.setTextureByIndex(PBRMaterial.TANGENTTEXTURE, value);
            if (value) {
                this.addDefine(PBRMaterial.SHADERDEFINE_TANGENTTEXTURE);
            }
            else {
                this.removeDefine(PBRMaterial.SHADERDEFINE_TANGENTTEXTURE);
            }
        }
        get materialType() {
            return this._materialType;
        }
        set materialType(value) {
            switch (value) {
                case exports.PBRMaterialType.Standard:
                    this.removeDefine(PBRMaterial.SHADERDEFINE_ANISOTROPY);
                    break;
                case exports.PBRMaterialType.Anisotropy:
                    this.addDefine(PBRMaterial.SHADERDEFINE_ANISOTROPY);
                    break;
            }
            this._materialType = value;
            this.resetNeedTBN();
        }
    }
    PBRMaterial.renderQuality = exports.PBRRenderQuality.High;

    exports.PBRMetallicSmoothnessSource = void 0;
    (function (PBRMetallicSmoothnessSource) {
        PBRMetallicSmoothnessSource[PBRMetallicSmoothnessSource["MetallicGlossTextureAlpha"] = 0] = "MetallicGlossTextureAlpha";
        PBRMetallicSmoothnessSource[PBRMetallicSmoothnessSource["AlbedoTextureAlpha"] = 1] = "AlbedoTextureAlpha";
    })(exports.PBRMetallicSmoothnessSource || (exports.PBRMetallicSmoothnessSource = {}));
    class PBRStandardMaterial extends PBRMaterial {
        constructor() {
            super();
            this._smoothnessSource = 0;
            this.setShaderName("PBR");
        }
        static __init__() {
            PBRStandardMaterial.SHADERDEFINE_METALLICGLOSSTEXTURE = Laya.Shader3D.getDefineByName("METALLICGLOSSTEXTURE");
            PBRStandardMaterial.SHADERDEFINE_SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA = Laya.Shader3D.getDefineByName("SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA");
            PBRStandardMaterial.METALLICGLOSSTEXTURE = Laya.Shader3D.propertyNameToID("u_MetallicGlossTexture");
            PBRStandardMaterial.METALLIC = Laya.Shader3D.propertyNameToID("u_Metallic");
        }
        get metallicGlossTexture() {
            return this._shaderValues.getTexture(PBRStandardMaterial.METALLICGLOSSTEXTURE);
        }
        set metallicGlossTexture(value) {
            if (value)
                this._shaderValues.addDefine(PBRStandardMaterial.SHADERDEFINE_METALLICGLOSSTEXTURE);
            else
                this._shaderValues.removeDefine(PBRStandardMaterial.SHADERDEFINE_METALLICGLOSSTEXTURE);
            this._shaderValues.setTexture(PBRStandardMaterial.METALLICGLOSSTEXTURE, value);
        }
        get metallic() {
            return this._shaderValues.getNumber(PBRStandardMaterial.METALLIC);
        }
        set metallic(value) {
            this._shaderValues.setNumber(PBRStandardMaterial.METALLIC, Math.max(0.0, Math.min(1.0, value)));
        }
        get smoothnessSource() {
            return this._smoothnessSource;
        }
        set smoothnessSource(value) {
            if (value)
                this._shaderValues.addDefine(PBRStandardMaterial.SHADERDEFINE_SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA);
            else
                this._shaderValues.removeDefine(PBRStandardMaterial.SHADERDEFINE_SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA);
            this._smoothnessSource = value;
        }
        clone() {
            var dest = new PBRStandardMaterial();
            this.cloneTo(dest);
            return dest;
        }
    }

    class SkyBoxMaterial extends Material {
        constructor() {
            super();
            this.setShaderName("SkyBox");
        }
        static __initDefine__() {
            SkyBoxMaterial.TINTCOLOR = Laya.Shader3D.propertyNameToID("u_TintColor");
            SkyBoxMaterial.EXPOSURE = Laya.Shader3D.propertyNameToID("u_Exposure");
            SkyBoxMaterial.ROTATION = Laya.Shader3D.propertyNameToID("u_Rotation");
            SkyBoxMaterial.TEXTURECUBE = Laya.Shader3D.propertyNameToID("u_CubeTexture");
        }
        get tintColor() {
            return this._shaderValues.getColor(SkyBoxMaterial.TINTCOLOR);
        }
        set tintColor(value) {
            this._shaderValues.setColor(SkyBoxMaterial.TINTCOLOR, value);
        }
        get exposure() {
            return this._shaderValues.getNumber(SkyBoxMaterial.EXPOSURE);
        }
        set exposure(value) {
            this._shaderValues.setNumber(SkyBoxMaterial.EXPOSURE, value);
        }
        get rotation() {
            return this._shaderValues.getNumber(SkyBoxMaterial.ROTATION);
        }
        set rotation(value) {
            this._shaderValues.setNumber(SkyBoxMaterial.ROTATION, value);
        }
        get textureCube() {
            return this._shaderValues.getTexture(SkyBoxMaterial.TEXTURECUBE);
        }
        set textureCube(value) {
            this._shaderValues.setTexture(SkyBoxMaterial.TEXTURECUBE, value);
        }
        clone() {
            var dest = new SkyBoxMaterial();
            this.cloneTo(dest);
            return dest;
        }
    }

    class SkyPanoramicMaterial extends Material {
        constructor() {
            super();
            this._textureHDRParams = new Laya.Vector4(1.0, 0.0, 0.0, 1.0);
            this.setShaderName("SkyPanoramic");
            this.setColorByIndex(SkyPanoramicMaterial.TINTCOLOR, new Laya.Color(0.5, 0.5, 0.5, 0.5));
            this.setFloatByIndex(SkyPanoramicMaterial.ROTATION, 0.0);
            this.setVector4ByIndex(SkyPanoramicMaterial.TEXTURE_HDR_PARAMS, this._textureHDRParams);
            this.exposure = 1.3;
        }
        static __init__() {
            SkyPanoramicMaterial.TINTCOLOR = Laya.Shader3D.propertyNameToID("u_TintColor");
            SkyPanoramicMaterial.EXPOSURE = Laya.Shader3D.propertyNameToID("u_Exposure");
            SkyPanoramicMaterial.ROTATION = Laya.Shader3D.propertyNameToID("u_Rotation");
            SkyPanoramicMaterial.TEXTURE = Laya.Shader3D.propertyNameToID("u_Texture");
        }
        get tintColor() {
            return this.getColorByIndex(SkyPanoramicMaterial.TINTCOLOR);
        }
        set tintColor(value) {
            this.setColorByIndex(SkyPanoramicMaterial.TINTCOLOR, value);
        }
        get exposure() {
            return this.getFloatByIndex(SkyPanoramicMaterial.EXPOSURE);
        }
        set exposure(value) {
            this.setFloatByIndex(SkyPanoramicMaterial.EXPOSURE, value);
        }
        get rotation() {
            return this.getFloatByIndex(SkyPanoramicMaterial.ROTATION);
        }
        set rotation(value) {
            this.setFloatByIndex(SkyPanoramicMaterial.ROTATION, value);
        }
        get panoramicTexture() {
            return this.getTextureByIndex(SkyPanoramicMaterial.TEXTURE);
        }
        set panoramicTexture(value) {
            this.setTextureByIndex(SkyPanoramicMaterial.TEXTURE, value);
        }
    }

    class SkyProceduralMaterial extends Material {
        constructor() {
            super();
            this.setShaderName("SkyProcedural");
            this.sunDisk = SkyProceduralMaterial.SUN_HIGH_QUALITY;
            this.sunSize = 0.04;
            this.sunSizeConvergence = 5;
            this.atmosphereThickness = 1.0;
            this.skyTint = new Laya.Color(0.5, 0.5, 0.5, 1.0);
            this.groundTint = new Laya.Color(0.369, 0.349, 0.341, 1.0);
            this.exposure = 1.3;
        }
        static __initDefine__() {
            SkyProceduralMaterial.SHADERDEFINE_SUN_HIGH_QUALITY = Laya.Shader3D.getDefineByName("SUN_HIGH_QUALITY");
            SkyProceduralMaterial.SHADERDEFINE_SUN_SIMPLE = Laya.Shader3D.getDefineByName("SUN_SIMPLE");
            SkyProceduralMaterial.SUNSIZE = Laya.Shader3D.propertyNameToID("u_SunSize");
            SkyProceduralMaterial.SUNSIZECONVERGENCE = Laya.Shader3D.propertyNameToID("u_SunSizeConvergence");
            SkyProceduralMaterial.ATMOSPHERETHICKNESS = Laya.Shader3D.propertyNameToID("u_AtmosphereThickness");
            SkyProceduralMaterial.SKYTINT = Laya.Shader3D.propertyNameToID("u_SkyTint");
            SkyProceduralMaterial.GROUNDTINT = Laya.Shader3D.propertyNameToID("u_GroundTint");
            SkyProceduralMaterial.EXPOSURE = Laya.Shader3D.propertyNameToID("u_Exposure");
        }
        get sunDisk() {
            return this._sunDisk;
        }
        set sunDisk(value) {
            switch (value) {
                case SkyProceduralMaterial.SUN_HIGH_QUALITY:
                    this._shaderValues.removeDefine(SkyProceduralMaterial.SHADERDEFINE_SUN_SIMPLE);
                    this._shaderValues.addDefine(SkyProceduralMaterial.SHADERDEFINE_SUN_HIGH_QUALITY);
                    break;
                case SkyProceduralMaterial.SUN_SIMPLE:
                    this._shaderValues.removeDefine(SkyProceduralMaterial.SHADERDEFINE_SUN_HIGH_QUALITY);
                    this._shaderValues.addDefine(SkyProceduralMaterial.SHADERDEFINE_SUN_SIMPLE);
                    break;
                case SkyProceduralMaterial.SUN_NODE:
                    this._shaderValues.removeDefine(SkyProceduralMaterial.SHADERDEFINE_SUN_HIGH_QUALITY);
                    this._shaderValues.removeDefine(SkyProceduralMaterial.SHADERDEFINE_SUN_SIMPLE);
                    break;
                default:
                    throw "SkyBoxProceduralMaterial: unknown sun value.";
            }
            this._sunDisk = value;
        }
        get sunSize() {
            return this._shaderValues.getNumber(SkyProceduralMaterial.SUNSIZE);
        }
        set sunSize(value) {
            value = Math.min(Math.max(0.0, value), 1.0);
            this._shaderValues.setNumber(SkyProceduralMaterial.SUNSIZE, value);
        }
        get sunSizeConvergence() {
            return this._shaderValues.getNumber(SkyProceduralMaterial.SUNSIZECONVERGENCE);
        }
        set sunSizeConvergence(value) {
            value = Math.min(Math.max(0.0, value), 20.0);
            this._shaderValues.setNumber(SkyProceduralMaterial.SUNSIZECONVERGENCE, value);
        }
        get atmosphereThickness() {
            return this._shaderValues.getNumber(SkyProceduralMaterial.ATMOSPHERETHICKNESS);
        }
        set atmosphereThickness(value) {
            value = Math.min(Math.max(0.0, value), 5.0);
            this._shaderValues.setNumber(SkyProceduralMaterial.ATMOSPHERETHICKNESS, value);
        }
        get skyTint() {
            return this._shaderValues.getColor(SkyProceduralMaterial.SKYTINT);
        }
        set skyTint(value) {
            this._shaderValues.setColor(SkyProceduralMaterial.SKYTINT, value);
        }
        get groundTint() {
            return this._shaderValues.getColor(SkyProceduralMaterial.GROUNDTINT);
        }
        set groundTint(value) {
            this._shaderValues.setColor(SkyProceduralMaterial.GROUNDTINT, value);
        }
        get exposure() {
            return this._shaderValues.getNumber(SkyProceduralMaterial.EXPOSURE);
        }
        set exposure(value) {
            value = Math.min(Math.max(0.0, value), 8.0);
            this._shaderValues.setNumber(SkyProceduralMaterial.EXPOSURE, value);
        }
        clone() {
            var dest = new SkyProceduralMaterial();
            this.cloneTo(dest);
            return dest;
        }
    }
    SkyProceduralMaterial.SUN_NODE = 0;
    SkyProceduralMaterial.SUN_SIMPLE = 1;
    SkyProceduralMaterial.SUN_HIGH_QUALITY = 2;

    class WaterPrimaryMaterial extends Material {
        constructor() {
            super();
            this.setShaderName("WaterPrimary");
            this._shaderValues.setVector(WaterPrimaryMaterial.HORIZONCOLOR, new Laya.Vector4(0.172, 0.463, 0.435, 0));
            this._shaderValues.setNumber(WaterPrimaryMaterial.WAVESCALE, 0.15);
            this._shaderValues.setVector(WaterPrimaryMaterial.WAVESPEED, new Laya.Vector4(19, 9, -16, -7));
        }
        static __initDefine__() {
            WaterPrimaryMaterial.SHADERDEFINE_MAINTEXTURE = Laya.Shader3D.getDefineByName("MAINTEXTURE");
            WaterPrimaryMaterial.SHADERDEFINE_NORMALTEXTURE = Laya.Shader3D.getDefineByName("NORMALTEXTURE");
            WaterPrimaryMaterial.HORIZONCOLOR = Laya.Shader3D.propertyNameToID("u_HorizonColor");
            WaterPrimaryMaterial.MAINTEXTURE = Laya.Shader3D.propertyNameToID("u_MainTexture");
            WaterPrimaryMaterial.NORMALTEXTURE = Laya.Shader3D.propertyNameToID("u_NormalTexture");
            WaterPrimaryMaterial.WAVESCALE = Laya.Shader3D.propertyNameToID("u_WaveScale");
            WaterPrimaryMaterial.WAVESPEED = Laya.Shader3D.propertyNameToID("u_WaveSpeed");
        }
        get horizonColor() {
            return this._shaderValues.getVector(WaterPrimaryMaterial.HORIZONCOLOR);
        }
        set horizonColor(value) {
            this._shaderValues.setVector(WaterPrimaryMaterial.HORIZONCOLOR, value);
        }
        get mainTexture() {
            return this._shaderValues.getTexture(WaterPrimaryMaterial.MAINTEXTURE);
        }
        set mainTexture(value) {
            if (value)
                this._shaderValues.addDefine(WaterPrimaryMaterial.SHADERDEFINE_MAINTEXTURE);
            else
                this._shaderValues.removeDefine(WaterPrimaryMaterial.SHADERDEFINE_MAINTEXTURE);
            this._shaderValues.setTexture(WaterPrimaryMaterial.MAINTEXTURE, value);
        }
        get normalTexture() {
            return this._shaderValues.getTexture(WaterPrimaryMaterial.NORMALTEXTURE);
        }
        set normalTexture(value) {
            if (value)
                this._shaderValues.addDefine(WaterPrimaryMaterial.SHADERDEFINE_NORMALTEXTURE);
            else
                this._shaderValues.removeDefine(WaterPrimaryMaterial.SHADERDEFINE_NORMALTEXTURE);
            this._shaderValues.setTexture(WaterPrimaryMaterial.NORMALTEXTURE, value);
        }
        get waveScale() {
            return this._shaderValues.getNumber(WaterPrimaryMaterial.WAVESCALE);
        }
        set waveScale(value) {
            this._shaderValues.setNumber(WaterPrimaryMaterial.WAVESCALE, value);
        }
        get waveSpeed() {
            return this._shaderValues.getVector(WaterPrimaryMaterial.WAVESPEED);
        }
        set waveSpeed(value) {
            this._shaderValues.setVector(WaterPrimaryMaterial.WAVESPEED, value);
        }
        clone() {
            var dest = new WaterPrimaryMaterial();
            this.cloneTo(dest);
            return dest;
        }
    }

    class MeshSprite3D extends RenderableSprite3D {
        constructor(mesh = null, name = null) {
            super(name);
            this._meshFilter = this.addComponent(MeshFilter);
            this._render = this.addComponent(MeshRenderer);
            (mesh) && (this._meshFilter.sharedMesh = mesh);
        }
        get meshFilter() {
            return this._meshFilter;
        }
        get meshRenderer() {
            return this._render;
        }
        _parse(data, spriteMap) {
            super._parse(data, spriteMap);
            var render = this.meshRenderer;
            var lightmapIndex = data.lightmapIndex;
            (lightmapIndex != null) && (render.lightmapIndex = lightmapIndex);
            var lightmapScaleOffsetArray = data.lightmapScaleOffset;
            (lightmapScaleOffsetArray) && (render.lightmapScaleOffset = new Laya.Vector4(lightmapScaleOffsetArray[0], lightmapScaleOffsetArray[1], lightmapScaleOffsetArray[2], lightmapScaleOffsetArray[3]));
            (data.meshPath != undefined) && (this.meshFilter.sharedMesh = Laya.Loader.getRes(data.meshPath));
            (data.enableRender != undefined) && (render._enabled = data.enableRender);
            (data.receiveShadows != undefined) && (render.receiveShadow = data.receiveShadows);
            (data.castShadow != undefined) && (render.castShadow = data.castShadow);
            var materials = data.materials;
            if (materials) {
                var sharedMaterials = render.sharedMaterials;
                var materialCount = materials.length;
                sharedMaterials.length = materialCount;
                for (var i = 0; i < materialCount; i++) {
                    sharedMaterials[i] = Laya.Loader.getRes(materials[i].path);
                }
                render.sharedMaterials = sharedMaterials;
            }
        }
        _cloneTo(destObject, rootSprite, dstSprite) {
            super._cloneTo(destObject, rootSprite, dstSprite);
        }
        _create() {
            return new Sprite3D();
        }
    }

    class Burst {
        constructor(time = 0, minCount = 0, maxCount = 0) {
            this._time = time;
            this._minCount = minCount;
            this._maxCount = maxCount;
        }
        get time() {
            return this._time;
        }
        get minCount() {
            return this._minCount;
        }
        get maxCount() {
            return this._maxCount;
        }
        cloneTo(destObject) {
            var destBurst = destObject;
            destBurst._time = this._time;
            destBurst._minCount = this._minCount;
            destBurst._maxCount = this._maxCount;
        }
        clone() {
            var destBurst = new Burst(this._time, this._minCount, this._maxCount);
            this.cloneTo(destBurst);
            return destBurst;
        }
    }

    class GradientColor {
        constructor() {
            this._type = 0;
            this._constant = null;
            this._constantMin = null;
            this._constantMax = null;
            this._gradient = null;
            this._gradientMin = null;
            this._gradientMax = null;
        }
        static createByConstant(constant) {
            var gradientColor = new GradientColor();
            gradientColor._type = 0;
            gradientColor._constant = constant;
            return gradientColor;
        }
        static createByGradient(gradient) {
            var gradientColor = new GradientColor();
            gradientColor._type = 1;
            gradientColor._gradient = gradient;
            return gradientColor;
        }
        static createByRandomTwoConstant(minConstant, maxConstant) {
            var gradientColor = new GradientColor();
            gradientColor._type = 2;
            gradientColor._constantMin = minConstant;
            gradientColor._constantMax = maxConstant;
            return gradientColor;
        }
        static createByRandomTwoGradient(minGradient, maxGradient) {
            var gradientColor = new GradientColor();
            gradientColor._type = 3;
            gradientColor._gradientMin = minGradient;
            gradientColor._gradientMax = maxGradient;
            return gradientColor;
        }
        get type() {
            return this._type;
        }
        get constant() {
            return this._constant;
        }
        get constantMin() {
            return this._constantMin;
        }
        get constantMax() {
            return this._constantMax;
        }
        get gradient() {
            return this._gradient;
        }
        get gradientMin() {
            return this._gradientMin;
        }
        get gradientMax() {
            return this._gradientMax;
        }
        cloneTo(destObject) {
            var destGradientColor = destObject;
            destGradientColor._type = this._type;
            this._constant.cloneTo(destGradientColor._constant);
            this._constantMin.cloneTo(destGradientColor._constantMin);
            this._constantMax.cloneTo(destGradientColor._constantMax);
            this._gradient.cloneTo(destGradientColor._gradient);
            this._gradientMin.cloneTo(destGradientColor._gradientMin);
            this._gradientMax.cloneTo(destGradientColor._gradientMax);
        }
        clone() {
            var destGradientColor = new GradientColor();
            this.cloneTo(destGradientColor);
            return destGradientColor;
        }
    }

    class ColorOverLifetime {
        constructor(color) {
            this._color = color;
        }
        get color() {
            return this._color;
        }
        cloneTo(destObject) {
            var destColorOverLifetime = destObject;
            this._color.cloneTo(destColorOverLifetime._color);
            destColorOverLifetime.enable = this.enable;
        }
        clone() {
            var destColor;
            switch (this._color.type) {
                case 0:
                    destColor = GradientColor.createByConstant(this._color.constant.clone());
                    break;
                case 1:
                    destColor = GradientColor.createByGradient(this._color.gradient.clone());
                    break;
                case 2:
                    destColor = GradientColor.createByRandomTwoConstant(this._color.constantMin.clone(), this._color.constantMax.clone());
                    break;
                case 3:
                    destColor = GradientColor.createByRandomTwoGradient(this._color.gradientMin.clone(), this._color.gradientMax.clone());
                    break;
            }
            var destColorOverLifetime = new ColorOverLifetime(destColor);
            destColorOverLifetime.enable = this.enable;
            return destColorOverLifetime;
        }
    }

    class Emission {
        constructor() {
            this._emissionRate = 10;
            this._emissionRateOverDistance = 0;
            this._destroyed = false;
            this._bursts = [];
        }
        set emissionRate(value) {
            if (value < 0)
                throw new Error("ParticleBaseShape:emissionRate value must large or equal than 0.");
            this._emissionRate = value;
        }
        get emissionRate() {
            return this._emissionRate;
        }
        get emissionRateOverDistance() {
            return this._emissionRateOverDistance;
        }
        set emissionRateOverDistance(value) {
            value = Math.max(0, value);
            this._emissionRateOverDistance = value;
        }
        get destroyed() {
            return this._destroyed;
        }
        destroy() {
            this._bursts = null;
            this._destroyed = true;
        }
        getBurstsCount() {
            return this._bursts.length;
        }
        getBurstByIndex(index) {
            return this._bursts[index];
        }
        addBurst(burst) {
            var burstsCount = this._bursts.length;
            if (burstsCount > 0)
                for (var i = 0; i < burstsCount; i++) {
                    if (this._bursts[i].time > burst.time)
                        this._bursts.splice(i, 0, burst);
                }
            this._bursts.push(burst);
        }
        removeBurst(burst) {
            var index = this._bursts.indexOf(burst);
            if (index !== -1) {
                this._bursts.splice(index, 1);
            }
        }
        removeBurstByIndex(index) {
            this._bursts.splice(index, 1);
        }
        clearBurst() {
            this._bursts.length = 0;
        }
        cloneTo(destObject) {
            var destEmission = destObject;
            var destBursts = destEmission._bursts;
            destBursts.length = this._bursts.length;
            for (var i = 0, n = this._bursts.length; i < n; i++) {
                var destBurst = destBursts[i];
                if (destBurst)
                    this._bursts[i].cloneTo(destBurst);
                else
                    destBursts[i] = this._bursts[i].clone();
            }
            destEmission._emissionRate = this._emissionRate;
            destEmission._emissionRateOverDistance = this._emissionRateOverDistance;
            destEmission.enable = this.enable;
        }
        clone() {
            var destEmission = new Emission();
            this.cloneTo(destEmission);
            return destEmission;
        }
    }

    class FrameOverTime {
        constructor() {
            this._type = 0;
            this._constant = 0;
            this._overTime = null;
            this._constantMin = 0;
            this._constantMax = 0;
            this._overTimeMin = null;
            this._overTimeMax = null;
        }
        static createByConstant(constant = 0) {
            var rotationOverLifetime = new FrameOverTime();
            rotationOverLifetime._type = 0;
            rotationOverLifetime._constant = constant;
            return rotationOverLifetime;
        }
        static createByOverTime(overTime) {
            var rotationOverLifetime = new FrameOverTime();
            rotationOverLifetime._type = 1;
            rotationOverLifetime._overTime = overTime;
            return rotationOverLifetime;
        }
        static createByRandomTwoConstant(constantMin = 0, constantMax = 0) {
            var rotationOverLifetime = new FrameOverTime();
            rotationOverLifetime._type = 2;
            rotationOverLifetime._constantMin = constantMin;
            rotationOverLifetime._constantMax = constantMax;
            return rotationOverLifetime;
        }
        static createByRandomTwoOverTime(gradientFrameMin, gradientFrameMax) {
            var rotationOverLifetime = new FrameOverTime();
            rotationOverLifetime._type = 3;
            rotationOverLifetime._overTimeMin = gradientFrameMin;
            rotationOverLifetime._overTimeMax = gradientFrameMax;
            return rotationOverLifetime;
        }
        get type() {
            return this._type;
        }
        get constant() {
            return this._constant;
        }
        get frameOverTimeData() {
            return this._overTime;
        }
        get constantMin() {
            return this._constantMin;
        }
        get constantMax() {
            return this._constantMax;
        }
        get frameOverTimeDataMin() {
            return this._overTimeMin;
        }
        get frameOverTimeDataMax() {
            return this._overTimeMax;
        }
        cloneTo(destObject) {
            var destFrameOverTime = destObject;
            destFrameOverTime._type = this._type;
            destFrameOverTime._constant = this._constant;
            (this._overTime) && (this._overTime.cloneTo(destFrameOverTime._overTime));
            destFrameOverTime._constantMin = this._constantMin;
            destFrameOverTime._constantMax = this._constantMax;
            (this._overTimeMin) && (this._overTimeMin.cloneTo(destFrameOverTime._overTimeMin));
            (this._overTimeMax) && (this._overTimeMax.cloneTo(destFrameOverTime._overTimeMax));
        }
        clone() {
            var destFrameOverTime = new FrameOverTime();
            this.cloneTo(destFrameOverTime);
            return destFrameOverTime;
        }
    }

    class GradientAngularVelocity {
        constructor() {
            this._type = 0;
            this._separateAxes = false;
            this._constant = 0;
            this._constantSeparate = null;
            this._gradient = null;
            this._gradientX = null;
            this._gradientY = null;
            this._gradientZ = null;
            this._gradientW = null;
            this._constantMin = 0;
            this._constantMax = 0;
            this._constantMinSeparate = null;
            this._constantMaxSeparate = null;
            this._gradientMin = null;
            this._gradientMax = null;
            this._gradientXMin = null;
            this._gradientXMax = null;
            this._gradientYMin = null;
            this._gradientYMax = null;
            this._gradientZMin = null;
            this._gradientZMax = null;
            this._gradientWMin = null;
            this._gradientWMax = null;
        }
        static createByConstant(constant) {
            var gradientAngularVelocity = new GradientAngularVelocity();
            gradientAngularVelocity._type = 0;
            gradientAngularVelocity._separateAxes = false;
            gradientAngularVelocity._constant = constant;
            return gradientAngularVelocity;
        }
        static createByConstantSeparate(separateConstant) {
            var gradientAngularVelocity = new GradientAngularVelocity();
            gradientAngularVelocity._type = 0;
            gradientAngularVelocity._separateAxes = true;
            gradientAngularVelocity._constantSeparate = separateConstant;
            return gradientAngularVelocity;
        }
        static createByGradient(gradient) {
            var gradientAngularVelocity = new GradientAngularVelocity();
            gradientAngularVelocity._type = 1;
            gradientAngularVelocity._separateAxes = false;
            gradientAngularVelocity._gradient = gradient;
            return gradientAngularVelocity;
        }
        static createByGradientSeparate(gradientX, gradientY, gradientZ) {
            var gradientAngularVelocity = new GradientAngularVelocity();
            gradientAngularVelocity._type = 1;
            gradientAngularVelocity._separateAxes = true;
            gradientAngularVelocity._gradientX = gradientX;
            gradientAngularVelocity._gradientY = gradientY;
            gradientAngularVelocity._gradientZ = gradientZ;
            return gradientAngularVelocity;
        }
        static createByRandomTwoConstant(constantMin, constantMax) {
            var gradientAngularVelocity = new GradientAngularVelocity();
            gradientAngularVelocity._type = 2;
            gradientAngularVelocity._separateAxes = false;
            gradientAngularVelocity._constantMin = constantMin;
            gradientAngularVelocity._constantMax = constantMax;
            return gradientAngularVelocity;
        }
        static createByRandomTwoConstantSeparate(separateConstantMin, separateConstantMax) {
            var gradientAngularVelocity = new GradientAngularVelocity();
            gradientAngularVelocity._type = 2;
            gradientAngularVelocity._separateAxes = true;
            gradientAngularVelocity._constantMinSeparate = separateConstantMin;
            gradientAngularVelocity._constantMaxSeparate = separateConstantMax;
            return gradientAngularVelocity;
        }
        static createByRandomTwoGradient(gradientMin, gradientMax) {
            var gradientAngularVelocity = new GradientAngularVelocity();
            gradientAngularVelocity._type = 3;
            gradientAngularVelocity._separateAxes = false;
            gradientAngularVelocity._gradientMin = gradientMin;
            gradientAngularVelocity._gradientMax = gradientMax;
            return gradientAngularVelocity;
        }
        static createByRandomTwoGradientSeparate(gradientXMin, gradientXMax, gradientYMin, gradientYMax, gradientZMin, gradientZMax, gradientWMin, gradientWMax) {
            var gradientAngularVelocity = new GradientAngularVelocity();
            gradientAngularVelocity._type = 3;
            gradientAngularVelocity._separateAxes = true;
            gradientAngularVelocity._gradientXMin = gradientXMin;
            gradientAngularVelocity._gradientXMax = gradientXMax;
            gradientAngularVelocity._gradientYMin = gradientYMin;
            gradientAngularVelocity._gradientYMax = gradientYMax;
            gradientAngularVelocity._gradientZMin = gradientZMin;
            gradientAngularVelocity._gradientZMax = gradientZMax;
            gradientAngularVelocity._gradientWMin = gradientWMin;
            gradientAngularVelocity._gradientWMax = gradientWMax;
            return gradientAngularVelocity;
        }
        get type() {
            return this._type;
        }
        get separateAxes() {
            return this._separateAxes;
        }
        get constant() {
            return this._constant;
        }
        get constantSeparate() {
            return this._constantSeparate;
        }
        get gradient() {
            return this._gradient;
        }
        get gradientX() {
            return this._gradientX;
        }
        get gradientY() {
            return this._gradientY;
        }
        get gradientZ() {
            return this._gradientZ;
        }
        get gradientW() {
            return this._gradientW;
        }
        get constantMin() {
            return this._constantMin;
        }
        get constantMax() {
            return this._constantMax;
        }
        get constantMinSeparate() {
            return this._constantMinSeparate;
        }
        get constantMaxSeparate() {
            return this._constantMaxSeparate;
        }
        get gradientMin() {
            return this._gradientMin;
        }
        get gradientMax() {
            return this._gradientMax;
        }
        get gradientXMin() {
            return this._gradientXMin;
        }
        get gradientXMax() {
            return this._gradientXMax;
        }
        get gradientYMin() {
            return this._gradientYMin;
        }
        get gradientYMax() {
            return this._gradientYMax;
        }
        get gradientZMin() {
            return this._gradientZMin;
        }
        get gradientZMax() {
            return this._gradientZMax;
        }
        get gradientWMin() {
            return this._gradientWMin;
        }
        get gradientWMax() {
            return this._gradientWMax;
        }
        cloneTo(destObject) {
            var destGradientAngularVelocity = destObject;
            destGradientAngularVelocity._type = this._type;
            destGradientAngularVelocity._separateAxes = this._separateAxes;
            destGradientAngularVelocity._constant = this._constant;
            this._constantSeparate.cloneTo(destGradientAngularVelocity._constantSeparate);
            this._gradient.cloneTo(destGradientAngularVelocity._gradient);
            this._gradientX.cloneTo(destGradientAngularVelocity._gradientX);
            this._gradientY.cloneTo(destGradientAngularVelocity._gradientY);
            this._gradientZ.cloneTo(destGradientAngularVelocity._gradientZ);
            destGradientAngularVelocity._constantMin = this._constantMin;
            destGradientAngularVelocity._constantMax = this._constantMax;
            this._constantMinSeparate.cloneTo(destGradientAngularVelocity._constantMinSeparate);
            this._constantMaxSeparate.cloneTo(destGradientAngularVelocity._constantMaxSeparate);
            this._gradientMin.cloneTo(destGradientAngularVelocity._gradientMin);
            this._gradientMax.cloneTo(destGradientAngularVelocity._gradientMax);
            this._gradientXMin.cloneTo(destGradientAngularVelocity._gradientXMin);
            this._gradientXMax.cloneTo(destGradientAngularVelocity._gradientXMax);
            this._gradientYMin.cloneTo(destGradientAngularVelocity._gradientYMin);
            this._gradientYMax.cloneTo(destGradientAngularVelocity._gradientYMax);
            this._gradientZMin.cloneTo(destGradientAngularVelocity._gradientZMin);
            this._gradientZMax.cloneTo(destGradientAngularVelocity._gradientZMax);
        }
        clone() {
            var destGradientAngularVelocity = new GradientAngularVelocity();
            this.cloneTo(destGradientAngularVelocity);
            return destGradientAngularVelocity;
        }
    }

    class GradientDataInt {
        constructor() {
            this._currentLength = 0;
            this._elements = new Float32Array(8);
        }
        get gradientCount() {
            return this._currentLength / 2;
        }
        add(key, value) {
            if (this._currentLength < 8) {
                if ((this._currentLength === 6) && ((key !== 1))) {
                    key = 1;
                    console.log("Warning:the forth key is  be force set to 1.");
                }
                this._elements[this._currentLength++] = key;
                this._elements[this._currentLength++] = value;
            }
            else {
                console.log("Warning:data count must lessEqual than 4");
            }
        }
        cloneTo(destObject) {
            var destGradientDataInt = destObject;
            destGradientDataInt._currentLength = this._currentLength;
            var destElements = destGradientDataInt._elements;
            for (var i = 0, n = this._elements.length; i < n; i++) {
                destElements[i] = this._elements[i];
            }
        }
        clone() {
            var destGradientDataInt = new GradientDataInt();
            this.cloneTo(destGradientDataInt);
            return destGradientDataInt;
        }
    }

    class GradientDataNumber {
        constructor() {
            this._currentLength = 0;
            this._elements = new Float32Array(8);
        }
        get gradientCount() {
            return this._currentLength / 2;
        }
        add(key, value) {
            if (this._currentLength < 8) {
                if ((this._currentLength === 6) && ((key !== 1))) {
                    key = 1;
                    console.log("GradientDataNumber warning:the forth key is  be force set to 1.");
                }
                this._elements[this._currentLength++] = key;
                this._elements[this._currentLength++] = value;
            }
            else {
                console.log("GradientDataNumber warning:data count must lessEqual than 4");
            }
        }
        getKeyByIndex(index) {
            return this._elements[index * 2];
        }
        getValueByIndex(index) {
            return this._elements[index * 2 + 1];
        }
        getAverageValue() {
            var total = 0;
            var count = 0;
            for (var i = 0, n = this._currentLength - 2; i < n; i += 2) {
                var subValue = this._elements[i + 1];
                subValue += this._elements[i + 3];
                subValue = subValue * (this._elements[i + 2] - this._elements[i]);
                total += subValue;
                count++;
            }
            return total / count;
        }
        cloneTo(destObject) {
            var destGradientDataNumber = destObject;
            destGradientDataNumber._currentLength = this._currentLength;
            var destElements = destGradientDataNumber._elements;
            for (var i = 0, n = this._elements.length; i < n; i++)
                destElements[i] = this._elements[i];
        }
        clone() {
            var destGradientDataNumber = new GradientDataNumber();
            this.cloneTo(destGradientDataNumber);
            return destGradientDataNumber;
        }
    }

    class GradientSize {
        constructor() {
            this._type = 0;
            this._separateAxes = false;
            this._gradient = null;
            this._gradientX = null;
            this._gradientY = null;
            this._gradientZ = null;
            this._constantMin = 0;
            this._constantMax = 0;
            this._constantMinSeparate = null;
            this._constantMaxSeparate = null;
            this._gradientMin = null;
            this._gradientMax = null;
            this._gradientXMin = null;
            this._gradientXMax = null;
            this._gradientYMin = null;
            this._gradientYMax = null;
            this._gradientZMin = null;
            this._gradientZMax = null;
        }
        static createByGradient(gradient) {
            var gradientSize = new GradientSize();
            gradientSize._type = 0;
            gradientSize._separateAxes = false;
            gradientSize._gradient = gradient;
            return gradientSize;
        }
        static createByGradientSeparate(gradientX, gradientY, gradientZ) {
            var gradientSize = new GradientSize();
            gradientSize._type = 0;
            gradientSize._separateAxes = true;
            gradientSize._gradientX = gradientX;
            gradientSize._gradientY = gradientY;
            gradientSize._gradientZ = gradientZ;
            return gradientSize;
        }
        static createByRandomTwoConstant(constantMin, constantMax) {
            var gradientSize = new GradientSize();
            gradientSize._type = 1;
            gradientSize._separateAxes = false;
            gradientSize._constantMin = constantMin;
            gradientSize._constantMax = constantMax;
            return gradientSize;
        }
        static createByRandomTwoConstantSeparate(constantMinSeparate, constantMaxSeparate) {
            var gradientSize = new GradientSize();
            gradientSize._type = 1;
            gradientSize._separateAxes = true;
            gradientSize._constantMinSeparate = constantMinSeparate;
            gradientSize._constantMaxSeparate = constantMaxSeparate;
            return gradientSize;
        }
        static createByRandomTwoGradient(gradientMin, gradientMax) {
            var gradientSize = new GradientSize();
            gradientSize._type = 2;
            gradientSize._separateAxes = false;
            gradientSize._gradientMin = gradientMin;
            gradientSize._gradientMax = gradientMax;
            return gradientSize;
        }
        static createByRandomTwoGradientSeparate(gradientXMin, gradientXMax, gradientYMin, gradientYMax, gradientZMin, gradientZMax) {
            var gradientSize = new GradientSize();
            gradientSize._type = 2;
            gradientSize._separateAxes = true;
            gradientSize._gradientXMin = gradientXMin;
            gradientSize._gradientXMax = gradientXMax;
            gradientSize._gradientYMin = gradientYMin;
            gradientSize._gradientYMax = gradientYMax;
            gradientSize._gradientZMin = gradientZMin;
            gradientSize._gradientZMax = gradientZMax;
            return gradientSize;
        }
        get type() {
            return this._type;
        }
        get separateAxes() {
            return this._separateAxes;
        }
        get gradient() {
            return this._gradient;
        }
        get gradientX() {
            return this._gradientX;
        }
        get gradientY() {
            return this._gradientY;
        }
        get gradientZ() {
            return this._gradientZ;
        }
        get constantMin() {
            return this._constantMin;
        }
        get constantMax() {
            return this._constantMax;
        }
        get constantMinSeparate() {
            return this._constantMinSeparate;
        }
        get constantMaxSeparate() {
            return this._constantMaxSeparate;
        }
        get gradientMin() {
            return this._gradientMin;
        }
        get gradientMax() {
            return this._gradientMax;
        }
        get gradientXMin() {
            return this._gradientXMin;
        }
        get gradientXMax() {
            return this._gradientXMax;
        }
        get gradientYMin() {
            return this._gradientYMin;
        }
        get gradientYMax() {
            return this._gradientYMax;
        }
        get gradientZMin() {
            return this._gradientZMin;
        }
        get gradientZMax() {
            return this._gradientZMax;
        }
        getMaxSizeInGradient(meshMode = false) {
            var i, n;
            var maxSize = -Number.MAX_VALUE;
            switch (this._type) {
                case 0:
                    if (this._separateAxes) {
                        for (i = 0, n = this._gradientX.gradientCount; i < n; i++)
                            maxSize = Math.max(maxSize, this._gradientX.getValueByIndex(i));
                        for (i = 0, n = this._gradientY.gradientCount; i < n; i++)
                            maxSize = Math.max(maxSize, this._gradientY.getValueByIndex(i));
                        if (meshMode) {
                            for (i = 0, n = this._gradientZ.gradientCount; i < n; i++) {
                                maxSize = Math.max(maxSize, this._gradientZ.getValueByIndex(i));
                            }
                        }
                    }
                    else {
                        for (i = 0, n = this._gradient.gradientCount; i < n; i++)
                            maxSize = Math.max(maxSize, this._gradient.getValueByIndex(i));
                    }
                    break;
                case 1:
                    if (this._separateAxes) {
                        maxSize = Math.max(this._constantMinSeparate.x, this._constantMaxSeparate.x);
                        maxSize = Math.max(maxSize, this._constantMinSeparate.y);
                        if (meshMode) {
                            maxSize = maxSize = Math.max(maxSize, this._constantMaxSeparate.z);
                        }
                    }
                    else {
                        maxSize = Math.max(this._constantMin, this._constantMax);
                    }
                    break;
                case 2:
                    if (this._separateAxes) {
                        for (i = 0, n = this._gradientXMin.gradientCount; i < n; i++)
                            maxSize = Math.max(maxSize, this._gradientXMin.getValueByIndex(i));
                        for (i = 0, n = this._gradientXMax.gradientCount; i < n; i++)
                            maxSize = Math.max(maxSize, this._gradientXMax.getValueByIndex(i));
                        for (i = 0, n = this._gradientYMin.gradientCount; i < n; i++)
                            maxSize = Math.max(maxSize, this._gradientYMin.getValueByIndex(i));
                        for (i = 0, n = this._gradientZMax.gradientCount; i < n; i++)
                            maxSize = Math.max(maxSize, this._gradientZMax.getValueByIndex(i));
                        if (meshMode) {
                            for (i = 0, n = this._gradientZMin.gradientCount; i < n; i++) {
                                maxSize = Math.max(maxSize, this._gradientZMin.getValueByIndex(i));
                            }
                            for (i = 0, n = this._gradientZMax.gradientCount; i < n; i++) {
                                maxSize = Math.max(maxSize, this._gradientZMax.getValueByIndex(i));
                            }
                        }
                    }
                    else {
                        for (i = 0, n = this._gradientMin.gradientCount; i < n; i++)
                            maxSize = Math.max(maxSize, this._gradientMin.getValueByIndex(i));
                        for (i = 0, n = this._gradientMax.gradientCount; i < n; i++)
                            maxSize = Math.max(maxSize, this._gradientMax.getValueByIndex(i));
                    }
                    break;
            }
            return maxSize;
        }
        cloneTo(destObject) {
            var destGradientSize = destObject;
            destGradientSize._type = this._type;
            destGradientSize._separateAxes = this._separateAxes;
            this._gradient.cloneTo(destGradientSize._gradient);
            this._gradientX.cloneTo(destGradientSize._gradientX);
            this._gradientY.cloneTo(destGradientSize._gradientY);
            this._gradientZ.cloneTo(destGradientSize._gradientZ);
            destGradientSize._constantMin = this._constantMin;
            destGradientSize._constantMax = this._constantMax;
            this._constantMinSeparate.cloneTo(destGradientSize._constantMinSeparate);
            this._constantMaxSeparate.cloneTo(destGradientSize._constantMaxSeparate);
            this._gradientMin.cloneTo(destGradientSize._gradientMin);
            this._gradientMax.cloneTo(destGradientSize._gradientMax);
            this._gradientXMin.cloneTo(destGradientSize._gradientXMin);
            this._gradientXMax.cloneTo(destGradientSize._gradientXMax);
            this._gradientYMin.cloneTo(destGradientSize._gradientYMin);
            this._gradientYMax.cloneTo(destGradientSize._gradientYMax);
            this._gradientZMin.cloneTo(destGradientSize._gradientZMin);
            this._gradientZMax.cloneTo(destGradientSize._gradientZMax);
        }
        clone() {
            var destGradientSize = new GradientSize();
            this.cloneTo(destGradientSize);
            return destGradientSize;
        }
    }

    class GradientVelocity {
        constructor() {
            this._type = 0;
            this._constant = null;
            this._gradientX = null;
            this._gradientY = null;
            this._gradientZ = null;
            this._constantMin = null;
            this._constantMax = null;
            this._gradientXMin = null;
            this._gradientXMax = null;
            this._gradientYMin = null;
            this._gradientYMax = null;
            this._gradientZMin = null;
            this._gradientZMax = null;
        }
        static createByConstant(constant) {
            var gradientVelocity = new GradientVelocity();
            gradientVelocity._type = 0;
            gradientVelocity._constant = constant;
            return gradientVelocity;
        }
        static createByGradient(gradientX, gradientY, gradientZ) {
            var gradientVelocity = new GradientVelocity();
            gradientVelocity._type = 1;
            gradientVelocity._gradientX = gradientX;
            gradientVelocity._gradientY = gradientY;
            gradientVelocity._gradientZ = gradientZ;
            return gradientVelocity;
        }
        static createByRandomTwoConstant(constantMin, constantMax) {
            var gradientVelocity = new GradientVelocity();
            gradientVelocity._type = 2;
            gradientVelocity._constantMin = constantMin;
            gradientVelocity._constantMax = constantMax;
            return gradientVelocity;
        }
        static createByRandomTwoGradient(gradientXMin, gradientXMax, gradientYMin, gradientYMax, gradientZMin, gradientZMax) {
            var gradientVelocity = new GradientVelocity();
            gradientVelocity._type = 3;
            gradientVelocity._gradientXMin = gradientXMin;
            gradientVelocity._gradientXMax = gradientXMax;
            gradientVelocity._gradientYMin = gradientYMin;
            gradientVelocity._gradientYMax = gradientYMax;
            gradientVelocity._gradientZMin = gradientZMin;
            gradientVelocity._gradientZMax = gradientZMax;
            return gradientVelocity;
        }
        get type() {
            return this._type;
        }
        get constant() {
            return this._constant;
        }
        get gradientX() {
            return this._gradientX;
        }
        get gradientY() {
            return this._gradientY;
        }
        get gradientZ() {
            return this._gradientZ;
        }
        get constantMin() {
            return this._constantMin;
        }
        get constantMax() {
            return this._constantMax;
        }
        get gradientXMin() {
            return this._gradientXMin;
        }
        get gradientXMax() {
            return this._gradientXMax;
        }
        get gradientYMin() {
            return this._gradientYMin;
        }
        get gradientYMax() {
            return this._gradientYMax;
        }
        get gradientZMin() {
            return this._gradientZMin;
        }
        get gradientZMax() {
            return this._gradientZMax;
        }
        cloneTo(destObject) {
            var destGradientVelocity = destObject;
            destGradientVelocity._type = this._type;
            this._constant.cloneTo(destGradientVelocity._constant);
            this._gradientX.cloneTo(destGradientVelocity._gradientX);
            this._gradientY.cloneTo(destGradientVelocity._gradientY);
            this._gradientZ.cloneTo(destGradientVelocity._gradientZ);
            this._constantMin.cloneTo(destGradientVelocity._constantMin);
            this._constantMax.cloneTo(destGradientVelocity._constantMax);
            this._gradientXMin.cloneTo(destGradientVelocity._gradientXMin);
            this._gradientXMax.cloneTo(destGradientVelocity._gradientXMax);
            this._gradientYMin.cloneTo(destGradientVelocity._gradientYMin);
            this._gradientYMax.cloneTo(destGradientVelocity._gradientYMax);
            this._gradientZMin.cloneTo(destGradientVelocity._gradientZMin);
            this._gradientZMax.cloneTo(destGradientVelocity._gradientZMax);
        }
        clone() {
            var destGradientVelocity = new GradientVelocity();
            this.cloneTo(destGradientVelocity);
            return destGradientVelocity;
        }
    }

    class RotationOverLifetime {
        constructor(angularVelocity) {
            this._angularVelocity = angularVelocity;
        }
        get angularVelocity() {
            return this._angularVelocity;
        }
        cloneTo(destObject) {
            var destRotationOverLifetime = destObject;
            this._angularVelocity.cloneTo(destRotationOverLifetime._angularVelocity);
            destRotationOverLifetime.enable = this.enable;
        }
        clone() {
            var destAngularVelocity;
            switch (this._angularVelocity.type) {
                case 0:
                    if (this._angularVelocity.separateAxes)
                        destAngularVelocity = GradientAngularVelocity.createByConstantSeparate(this._angularVelocity.constantSeparate.clone());
                    else
                        destAngularVelocity = GradientAngularVelocity.createByConstant(this._angularVelocity.constant);
                    break;
                case 1:
                    if (this._angularVelocity.separateAxes)
                        destAngularVelocity = GradientAngularVelocity.createByGradientSeparate(this._angularVelocity.gradientX.clone(), this._angularVelocity.gradientY.clone(), this._angularVelocity.gradientZ.clone());
                    else
                        destAngularVelocity = GradientAngularVelocity.createByGradient(this._angularVelocity.gradient.clone());
                    break;
                case 2:
                    if (this._angularVelocity.separateAxes)
                        destAngularVelocity = GradientAngularVelocity.createByRandomTwoConstantSeparate(this._angularVelocity.constantMinSeparate.clone(), this._angularVelocity.constantMaxSeparate.clone());
                    else
                        destAngularVelocity = GradientAngularVelocity.createByRandomTwoConstant(this._angularVelocity.constantMin, this._angularVelocity.constantMax);
                    break;
                case 3:
                    if (this._angularVelocity.separateAxes)
                        destAngularVelocity = GradientAngularVelocity.createByRandomTwoGradientSeparate(this._angularVelocity.gradientXMin.clone(), this._angularVelocity.gradientYMin.clone(), this._angularVelocity.gradientZMin.clone(), this._angularVelocity.gradientWMin.clone(), this._angularVelocity.gradientXMax.clone(), this._angularVelocity.gradientYMax.clone(), this._angularVelocity.gradientZMax.clone(), this._angularVelocity.gradientWMax.clone());
                    else
                        destAngularVelocity = GradientAngularVelocity.createByRandomTwoGradient(this._angularVelocity.gradientMin.clone(), this._angularVelocity.gradientMax.clone());
                    break;
            }
            var destRotationOverLifetime = new RotationOverLifetime(destAngularVelocity);
            destRotationOverLifetime.enable = this.enable;
            return destRotationOverLifetime;
        }
    }

    class BoundBox {
        constructor(min, max) {
            this.min = min;
            this.max = max;
        }
        _rotateExtents(extents, rotation, out) {
            var extentsX = extents.x;
            var extentsY = extents.y;
            var extentsZ = extents.z;
            var matElements = rotation.elements;
            out.x = Math.abs(matElements[0] * extentsX) + Math.abs(matElements[4] * extentsY) + Math.abs(matElements[8] * extentsZ);
            out.y = Math.abs(matElements[1] * extentsX) + Math.abs(matElements[5] * extentsY) + Math.abs(matElements[9] * extentsZ);
            out.z = Math.abs(matElements[2] * extentsX) + Math.abs(matElements[6] * extentsY) + Math.abs(matElements[10] * extentsZ);
        }
        getCorners(corners) {
            corners.length = 8;
            var minX = this.min.x;
            var minY = this.min.y;
            var minZ = this.min.z;
            var maxX = this.max.x;
            var maxY = this.max.y;
            var maxZ = this.max.z;
            corners[0] = new Laya.Vector3(minX, maxY, maxZ);
            corners[1] = new Laya.Vector3(maxX, maxY, maxZ);
            corners[2] = new Laya.Vector3(maxX, minY, maxZ);
            corners[3] = new Laya.Vector3(minX, minY, maxZ);
            corners[4] = new Laya.Vector3(minX, maxY, minZ);
            corners[5] = new Laya.Vector3(maxX, maxY, minZ);
            corners[6] = new Laya.Vector3(maxX, minY, minZ);
            corners[7] = new Laya.Vector3(minX, minY, minZ);
        }
        getCenter(out) {
            Laya.Vector3.add(this.min, this.max, out);
            Laya.Vector3.scale(out, 0.5, out);
        }
        getExtent(out) {
            Laya.Vector3.subtract(this.max, this.min, out);
            Laya.Vector3.scale(out, 0.5, out);
        }
        setCenterAndExtent(center, extent) {
            Laya.Vector3.subtract(center, extent, this.min);
            Laya.Vector3.add(center, extent, this.max);
        }
        tranform(matrix, out) {
            var center = BoundBox._tempVector30;
            var extent = BoundBox._tempVector31;
            this.getCenter(center);
            this.getExtent(extent);
            Laya.Vector3.transformCoordinate(center, matrix, center);
            this._rotateExtents(extent, matrix, extent);
            out.setCenterAndExtent(center, extent);
        }
        toDefault() {
            this.min.toDefault();
            this.max.toDefault();
        }
        static createfromPoints(points, out) {
            if (points == null)
                throw new Error("points");
            var min = out.min;
            var max = out.max;
            min.x = Number.MAX_VALUE;
            min.y = Number.MAX_VALUE;
            min.z = Number.MAX_VALUE;
            max.x = -Number.MAX_VALUE;
            max.y = -Number.MAX_VALUE;
            max.z = -Number.MAX_VALUE;
            for (var i = 0, n = points.length; i < n; ++i) {
                Laya.Vector3.min(min, points[i], min);
                Laya.Vector3.max(max, points[i], max);
            }
        }
        static merge(box1, box2, out) {
            Laya.Vector3.min(box1.min, box2.min, out.min);
            Laya.Vector3.max(box1.max, box2.max, out.max);
        }
        cloneTo(destObject) {
            var dest = destObject;
            this.min.cloneTo(dest.min);
            this.max.cloneTo(dest.max);
        }
        clone() {
            var dest = new BoundBox(new Laya.Vector3(), new Laya.Vector3());
            this.cloneTo(dest);
            return dest;
        }
    }
    BoundBox._tempVector30 = new Laya.Vector3();
    BoundBox._tempVector31 = new Laya.Vector3();

    exports.ParticleSystemShapeType = void 0;
    (function (ParticleSystemShapeType) {
        ParticleSystemShapeType[ParticleSystemShapeType["Box"] = 0] = "Box";
        ParticleSystemShapeType[ParticleSystemShapeType["Circle"] = 1] = "Circle";
        ParticleSystemShapeType[ParticleSystemShapeType["Cone"] = 2] = "Cone";
        ParticleSystemShapeType[ParticleSystemShapeType["Hemisphere"] = 3] = "Hemisphere";
        ParticleSystemShapeType[ParticleSystemShapeType["Sphere"] = 4] = "Sphere";
    })(exports.ParticleSystemShapeType || (exports.ParticleSystemShapeType = {}));
    class BaseShape {
        constructor() {
            this.enable = true;
            this.randomDirection = 0;
        }
        _getShapeBoundBox(boundBox) {
            throw new Error("BaseShape: must override it.");
        }
        _getSpeedBoundBox(boundBox) {
            throw new Error("BaseShape: must override it.");
        }
        generatePositionAndDirection(position, direction, rand = null, randomSeeds = null) {
            throw new Error("BaseShape: must override it.");
        }
        _calculateProceduralBounds(boundBox, emitterPosScale, minMaxBounds) {
            this._getShapeBoundBox(boundBox);
            var min = boundBox.min;
            var max = boundBox.max;
            Laya.Vector3.multiply(min, emitterPosScale, min);
            Laya.Vector3.multiply(max, emitterPosScale, max);
            var speedBounds = new BoundBox(new Laya.Vector3(), new Laya.Vector3());
            if (this.randomDirection) {
                speedBounds.min = new Laya.Vector3(-1, -1, -1);
                speedBounds.max = new Laya.Vector3(1, 1, 1);
            }
            else {
                this._getSpeedBoundBox(speedBounds);
            }
            var maxSpeedBound = new BoundBox(new Laya.Vector3(), new Laya.Vector3());
            var maxSpeedMin = maxSpeedBound.min;
            var maxSpeedMax = maxSpeedBound.max;
            Laya.Vector3.scale(speedBounds.min, minMaxBounds.y, maxSpeedMin);
            Laya.Vector3.scale(speedBounds.max, minMaxBounds.y, maxSpeedMax);
            Laya.Vector3.add(boundBox.min, maxSpeedMin, maxSpeedMin);
            Laya.Vector3.add(boundBox.max, maxSpeedMax, maxSpeedMax);
            Laya.Vector3.min(boundBox.min, maxSpeedMin, boundBox.min);
            Laya.Vector3.max(boundBox.max, maxSpeedMin, boundBox.max);
            var minSpeedBound = new BoundBox(new Laya.Vector3(), new Laya.Vector3());
            var minSpeedMin = minSpeedBound.min;
            var minSpeedMax = minSpeedBound.max;
            Laya.Vector3.scale(speedBounds.min, minMaxBounds.x, minSpeedMin);
            Laya.Vector3.scale(speedBounds.max, minMaxBounds.x, minSpeedMax);
            Laya.Vector3.min(minSpeedBound.min, minSpeedMax, maxSpeedMin);
            Laya.Vector3.max(minSpeedBound.min, minSpeedMax, maxSpeedMax);
            Laya.Vector3.min(boundBox.min, maxSpeedMin, boundBox.min);
            Laya.Vector3.max(boundBox.max, maxSpeedMin, boundBox.max);
        }
        cloneTo(destObject) {
            var destShape = destObject;
            destShape.enable = this.enable;
        }
        clone() {
            var destShape = new BaseShape();
            this.cloneTo(destShape);
            return destShape;
        }
    }

    class ShapeUtils {
        static _randomPointUnitArcCircle(arc, out, rand = null) {
            var angle;
            if (rand)
                angle = rand.getFloat() * arc;
            else
                angle = Math.random() * arc;
            out.x = Math.cos(angle);
            out.y = Math.sin(angle);
        }
        static _randomPointInsideUnitArcCircle(arc, out, rand = null) {
            ShapeUtils._randomPointUnitArcCircle(arc, out, rand);
            var range;
            if (rand)
                range = Math.pow(rand.getFloat(), 1.0 / 2.0);
            else
                range = Math.pow(Math.random(), 1.0 / 2.0);
            out.x = out.x * range;
            out.y = out.y * range;
        }
        static _randomPointUnitCircle(out, rand = null) {
            var angle;
            if (rand)
                angle = rand.getFloat() * Math.PI * 2;
            else
                angle = Math.random() * Math.PI * 2;
            out.x = Math.cos(angle);
            out.y = Math.sin(angle);
        }
        static _randomPointInsideUnitCircle(out, rand = null) {
            ShapeUtils._randomPointUnitCircle(out);
            var range;
            if (rand)
                range = Math.pow(rand.getFloat(), 1.0 / 2.0);
            else
                range = Math.pow(Math.random(), 1.0 / 2.0);
            out.x = out.x * range;
            out.y = out.y * range;
        }
        static _randomPointUnitSphere(out, rand = null) {
            var z;
            var a;
            if (rand) {
                z = out.z = rand.getFloat() * 2 - 1.0;
                a = rand.getFloat() * Math.PI * 2;
            }
            else {
                z = out.z = Math.random() * 2 - 1.0;
                a = Math.random() * Math.PI * 2;
            }
            var r = Math.sqrt(1.0 - z * z);
            out.x = r * Math.cos(a);
            out.y = r * Math.sin(a);
        }
        static _randomPointInsideUnitSphere(out, rand = null) {
            ShapeUtils._randomPointUnitSphere(out);
            var range;
            if (rand)
                range = Math.pow(rand.getFloat(), 1.0 / 3.0);
            else
                range = Math.pow(Math.random(), 1.0 / 3.0);
            out.x = out.x * range;
            out.y = out.y * range;
            out.z = out.z * range;
        }
        static _randomPointInsideHalfUnitBox(out, rand = null) {
            if (rand) {
                out.x = (rand.getFloat() - 0.5);
                out.y = (rand.getFloat() - 0.5);
                out.z = (rand.getFloat() - 0.5);
            }
            else {
                out.x = (Math.random() - 0.5);
                out.y = (Math.random() - 0.5);
                out.z = (Math.random() - 0.5);
            }
        }
        constructor() {
        }
    }

    class BoxShape extends BaseShape {
        constructor() {
            super();
            this.shapeType = exports.ParticleSystemShapeType.Box;
            this.x = 1.0;
            this.y = 1.0;
            this.z = 1.0;
        }
        _getShapeBoundBox(boundBox) {
            var min = boundBox.min;
            min.x = -this.x * 0.5;
            min.y = -this.y * 0.5;
            min.z = -this.z * 0.5;
            var max = boundBox.max;
            max.x = this.x * 0.5;
            max.y = this.y * 0.5;
            max.z = this.z * 0.5;
        }
        _getSpeedBoundBox(boundBox) {
            var min = boundBox.min;
            min.x = 0.0;
            min.y = 0.0;
            min.z = 0.0;
            var max = boundBox.max;
            max.x = 0.0;
            max.y = 1.0;
            max.z = 0.0;
        }
        generatePositionAndDirection(position, direction, rand = null, randomSeeds = null) {
            if (rand) {
                rand.seed = randomSeeds[16];
                ShapeUtils._randomPointInsideHalfUnitBox(position, rand);
                randomSeeds[16] = rand.seed;
            }
            else {
                ShapeUtils._randomPointInsideHalfUnitBox(position);
            }
            position.x = this.x * position.x;
            position.y = this.y * position.y;
            position.z = this.z * position.z;
            if (this.randomDirection) {
                if (rand) {
                    rand.seed = randomSeeds[17];
                    ShapeUtils._randomPointUnitSphere(direction, rand);
                    randomSeeds[17] = rand.seed;
                }
                else {
                    ShapeUtils._randomPointUnitSphere(direction);
                }
            }
            else {
                direction.x = 0.0;
                direction.y = 0.0;
                direction.z = 1.0;
            }
        }
        cloneTo(destObject) {
            super.cloneTo(destObject);
            var destShape = destObject;
            destShape.x = this.x;
            destShape.y = this.y;
            destShape.z = this.z;
            destShape.randomDirection = this.randomDirection;
        }
        clone() {
            var destShape = new BoxShape();
            this.cloneTo(destShape);
            return destShape;
        }
    }

    class CircleShape extends BaseShape {
        constructor() {
            super();
            this.shapeType = exports.ParticleSystemShapeType.Circle;
            this.radius = 1.0;
            this.arc = 360.0 / 180.0 * Math.PI;
            this.emitFromEdge = false;
        }
        set arcDEG(deg) {
            this.arc = deg / 180 * Math.PI;
        }
        get arcDEG() {
            return this.arc * 180 / Math.PI;
        }
        _getShapeBoundBox(boundBox) {
            var min = boundBox.min;
            min.x = min.z = -this.radius;
            min.y = 0;
            var max = boundBox.max;
            max.x = max.z = this.radius;
            max.y = 0;
        }
        _getSpeedBoundBox(boundBox) {
            var min = boundBox.min;
            min.x = min.y = -1;
            min.z = 0;
            var max = boundBox.max;
            max.x = max.y = 1;
            max.z = 0;
        }
        generatePositionAndDirection(position, direction, rand = null, randomSeeds = null) {
            var positionPoint = CircleShape._tempPositionPoint;
            if (rand) {
                rand.seed = randomSeeds[16];
                if (this.emitFromEdge)
                    ShapeUtils._randomPointUnitArcCircle(this.arc, CircleShape._tempPositionPoint, rand);
                else
                    ShapeUtils._randomPointInsideUnitArcCircle(this.arc, CircleShape._tempPositionPoint, rand);
                randomSeeds[16] = rand.seed;
            }
            else {
                if (this.emitFromEdge)
                    ShapeUtils._randomPointUnitArcCircle(this.arc, CircleShape._tempPositionPoint);
                else
                    ShapeUtils._randomPointInsideUnitArcCircle(this.arc, CircleShape._tempPositionPoint);
            }
            position.x = -positionPoint.x;
            position.y = positionPoint.y;
            position.z = 0;
            Laya.Vector3.scale(position, this.radius, position);
            if (this.randomDirection) {
                if (rand) {
                    rand.seed = randomSeeds[17];
                    ShapeUtils._randomPointUnitSphere(direction, rand);
                    randomSeeds[17] = rand.seed;
                }
                else {
                    ShapeUtils._randomPointUnitSphere(direction);
                }
            }
            else {
                position.cloneTo(direction);
            }
        }
        cloneTo(destObject) {
            super.cloneTo(destObject);
            var destShape = destObject;
            destShape.radius = this.radius;
            destShape.arc = this.arc;
            destShape.emitFromEdge = this.emitFromEdge;
            destShape.randomDirection = this.randomDirection;
        }
        clone() {
            var destShape = new CircleShape();
            this.cloneTo(destShape);
            return destShape;
        }
    }
    CircleShape._tempPositionPoint = new Laya.Vector2();

    class ConeShape extends BaseShape {
        constructor() {
            super();
            this.shapeType = exports.ParticleSystemShapeType.Cone;
            this.angle = 25.0 / 180.0 * Math.PI;
            this.radius = 1.0;
            this.length = 5.0;
            this.emitType = 0;
        }
        set angleDEG(deg) {
            this.angle = deg / 180 * Math.PI;
        }
        get angleDEG() {
            return this.angle * 180 / Math.PI;
        }
        _getShapeBoundBox(boundBox) {
            const coneRadius2 = this.radius + this.length * Math.sin(this.angle);
            const coneLength = this.length * Math.cos(this.angle);
            var min = boundBox.min;
            min.x = min.y = -coneRadius2;
            min.z = 0;
            var max = boundBox.max;
            max.x = max.y = coneRadius2;
            max.z = coneLength;
        }
        _getSpeedBoundBox(boundBox) {
            const sinA = Math.sin(this.angle);
            var min = boundBox.min;
            min.x = min.y = -sinA;
            min.z = 0;
            var max = boundBox.max;
            max.x = max.y = sinA;
            max.z = 1;
        }
        generatePositionAndDirection(position, direction, rand = null, randomSeeds = null) {
            var positionPointE = ConeShape._tempPositionPoint;
            var positionX;
            var positionY;
            var directionPointE;
            var dirCosA = Math.cos(this.angle);
            var dirSinA = Math.sin(this.angle);
            switch (this.emitType) {
                case 0:
                    if (rand) {
                        rand.seed = randomSeeds[16];
                        ShapeUtils._randomPointInsideUnitCircle(ConeShape._tempPositionPoint, rand);
                        randomSeeds[16] = rand.seed;
                    }
                    else {
                        ShapeUtils._randomPointInsideUnitCircle(ConeShape._tempPositionPoint);
                    }
                    positionX = positionPointE.x;
                    positionY = positionPointE.y;
                    position.x = positionX * this.radius;
                    position.y = positionY * this.radius;
                    position.z = 0;
                    if (this.randomDirection) {
                        if (rand) {
                            rand.seed = randomSeeds[17];
                            ShapeUtils._randomPointInsideUnitCircle(ConeShape._tempDirectionPoint, rand);
                            randomSeeds[17] = rand.seed;
                        }
                        else {
                            ShapeUtils._randomPointInsideUnitCircle(ConeShape._tempDirectionPoint);
                        }
                        directionPointE = ConeShape._tempDirectionPoint;
                        direction.x = directionPointE.x * dirSinA;
                        direction.y = directionPointE.y * dirSinA;
                    }
                    else {
                        direction.x = positionX * dirSinA;
                        direction.y = positionY * dirSinA;
                    }
                    direction.z = dirCosA;
                    break;
                case 1:
                    if (rand) {
                        rand.seed = randomSeeds[16];
                        ShapeUtils._randomPointUnitCircle(ConeShape._tempPositionPoint, rand);
                        randomSeeds[16] = rand.seed;
                    }
                    else {
                        ShapeUtils._randomPointUnitCircle(ConeShape._tempPositionPoint);
                    }
                    positionX = positionPointE.x;
                    positionY = positionPointE.y;
                    position.x = positionX * this.radius;
                    position.y = positionY * this.radius;
                    position.z = 0;
                    if (this.randomDirection) {
                        if (rand) {
                            rand.seed = randomSeeds[17];
                            ShapeUtils._randomPointInsideUnitCircle(ConeShape._tempDirectionPoint, rand);
                            randomSeeds[17] = rand.seed;
                        }
                        else {
                            ShapeUtils._randomPointInsideUnitCircle(ConeShape._tempDirectionPoint);
                        }
                        directionPointE = ConeShape._tempDirectionPoint;
                        direction.x = directionPointE.x * dirSinA;
                        direction.y = directionPointE.y * dirSinA;
                    }
                    else {
                        direction.x = positionX * dirSinA;
                        direction.y = positionY * dirSinA;
                    }
                    direction.z = dirCosA;
                    break;
                case 2:
                    if (rand) {
                        rand.seed = randomSeeds[16];
                        ShapeUtils._randomPointInsideUnitCircle(ConeShape._tempPositionPoint, rand);
                    }
                    else {
                        ShapeUtils._randomPointInsideUnitCircle(ConeShape._tempPositionPoint);
                    }
                    positionX = positionPointE.x;
                    positionY = positionPointE.y;
                    position.x = positionX * this.radius;
                    position.y = positionY * this.radius;
                    position.z = 0;
                    direction.x = positionX * dirSinA;
                    direction.y = positionY * dirSinA;
                    direction.z = dirCosA;
                    Laya.Vector3.normalize(direction, direction);
                    if (rand) {
                        Laya.Vector3.scale(direction, this.length * rand.getFloat(), direction);
                        randomSeeds[16] = rand.seed;
                    }
                    else {
                        Laya.Vector3.scale(direction, this.length * Math.random(), direction);
                    }
                    Laya.Vector3.add(position, direction, position);
                    if (this.randomDirection) {
                        if (rand) {
                            rand.seed = randomSeeds[17];
                            ShapeUtils._randomPointUnitSphere(direction, rand);
                            randomSeeds[17] = rand.seed;
                        }
                        else {
                            ShapeUtils._randomPointUnitSphere(direction);
                        }
                    }
                    break;
                case 3:
                    if (rand) {
                        rand.seed = randomSeeds[16];
                        ShapeUtils._randomPointUnitCircle(ConeShape._tempPositionPoint, rand);
                    }
                    else {
                        ShapeUtils._randomPointUnitCircle(ConeShape._tempPositionPoint);
                    }
                    positionX = positionPointE.x;
                    positionY = positionPointE.y;
                    position.x = positionX * this.radius;
                    position.y = positionY * this.radius;
                    position.z = 0;
                    direction.x = positionX * dirSinA;
                    direction.y = positionY * dirSinA;
                    direction.z = dirCosA;
                    Laya.Vector3.normalize(direction, direction);
                    if (rand) {
                        Laya.Vector3.scale(direction, this.length * rand.getFloat(), direction);
                        randomSeeds[16] = rand.seed;
                    }
                    else {
                        Laya.Vector3.scale(direction, this.length * Math.random(), direction);
                    }
                    Laya.Vector3.add(position, direction, position);
                    if (this.randomDirection) {
                        if (rand) {
                            rand.seed = randomSeeds[17];
                            ShapeUtils._randomPointUnitSphere(direction, rand);
                            randomSeeds[17] = rand.seed;
                        }
                        else {
                            ShapeUtils._randomPointUnitSphere(direction);
                        }
                    }
                    break;
                default:
                    throw new Error("ConeShape:emitType is invalid.");
            }
        }
        cloneTo(destObject) {
            super.cloneTo(destObject);
            var destShape = destObject;
            destShape.angle = this.angle;
            destShape.radius = this.radius;
            destShape.length = this.length;
            destShape.emitType = this.emitType;
            destShape.randomDirection = this.randomDirection;
        }
        clone() {
            var destShape = new ConeShape();
            this.cloneTo(destShape);
            return destShape;
        }
    }
    ConeShape._tempPositionPoint = new Laya.Vector2();
    ConeShape._tempDirectionPoint = new Laya.Vector2();

    class HemisphereShape extends BaseShape {
        constructor() {
            super();
            this.shapeType = exports.ParticleSystemShapeType.Hemisphere;
            this.radius = 1.0;
            this.emitFromShell = false;
        }
        _getShapeBoundBox(boundBox) {
            var min = boundBox.min;
            min.x = min.y = min.z = -this.radius;
            var max = boundBox.max;
            max.x = max.y = this.radius;
            max.z = 0;
        }
        _getSpeedBoundBox(boundBox) {
            var min = boundBox.min;
            min.x = min.y = -1;
            min.z = 0;
            var max = boundBox.max;
            max.x = max.y = max.z = 1;
        }
        generatePositionAndDirection(position, direction, rand = null, randomSeeds = null) {
            if (rand) {
                rand.seed = randomSeeds[16];
                if (this.emitFromShell)
                    ShapeUtils._randomPointUnitSphere(position, rand);
                else
                    ShapeUtils._randomPointInsideUnitSphere(position, rand);
                randomSeeds[16] = rand.seed;
            }
            else {
                if (this.emitFromShell)
                    ShapeUtils._randomPointUnitSphere(position);
                else
                    ShapeUtils._randomPointInsideUnitSphere(position);
            }
            Laya.Vector3.scale(position, this.radius, position);
            var z = position.z;
            (z < 0.0) && (position.z = z * -1.0);
            if (this.randomDirection) {
                if (rand) {
                    rand.seed = randomSeeds[17];
                    ShapeUtils._randomPointUnitSphere(direction, rand);
                    randomSeeds[17] = rand.seed;
                }
                else {
                    ShapeUtils._randomPointUnitSphere(direction);
                }
            }
            else {
                position.cloneTo(direction);
            }
        }
        cloneTo(destObject) {
            super.cloneTo(destObject);
            var destShape = destObject;
            destShape.radius = this.radius;
            destShape.emitFromShell = this.emitFromShell;
            destShape.randomDirection = this.randomDirection;
        }
        clone() {
            var destShape = new HemisphereShape();
            this.cloneTo(destShape);
            return destShape;
        }
    }

    class SphereShape extends BaseShape {
        constructor() {
            super();
            this.shapeType = exports.ParticleSystemShapeType.Sphere;
            this.radius = 1.0;
            this.emitFromShell = false;
        }
        _getShapeBoundBox(boundBox) {
            var min = boundBox.min;
            min.x = min.y = min.z = -this.radius;
            var max = boundBox.max;
            max.x = max.y = max.z = this.radius;
        }
        _getSpeedBoundBox(boundBox) {
            var min = boundBox.min;
            min.x = min.y = min.z = -1;
            var max = boundBox.max;
            max.x = max.y = max.z = 1;
        }
        generatePositionAndDirection(position, direction, rand = null, randomSeeds = null) {
            if (rand) {
                rand.seed = randomSeeds[16];
                if (this.emitFromShell)
                    ShapeUtils._randomPointUnitSphere(position, rand);
                else
                    ShapeUtils._randomPointInsideUnitSphere(position, rand);
                randomSeeds[16] = rand.seed;
            }
            else {
                if (this.emitFromShell)
                    ShapeUtils._randomPointUnitSphere(position);
                else
                    ShapeUtils._randomPointInsideUnitSphere(position);
            }
            Laya.Vector3.scale(position, this.radius, position);
            if (this.randomDirection) {
                if (rand) {
                    rand.seed = randomSeeds[17];
                    ShapeUtils._randomPointUnitSphere(direction, rand);
                    randomSeeds[17] = rand.seed;
                }
                else {
                    ShapeUtils._randomPointUnitSphere(direction);
                }
            }
            else {
                position.cloneTo(direction);
            }
        }
        cloneTo(destObject) {
            super.cloneTo(destObject);
            var destShape = destObject;
            destShape.radius = this.radius;
            destShape.emitFromShell = this.emitFromShell;
            destShape.randomDirection = this.randomDirection;
        }
        clone() {
            var destShape = new SphereShape();
            this.cloneTo(destShape);
            return destShape;
        }
    }

    class SizeOverLifetime {
        constructor(size) {
            this._size = size;
        }
        get size() {
            return this._size;
        }
        cloneTo(destObject) {
            var destSizeOverLifetime = destObject;
            this._size.cloneTo(destSizeOverLifetime._size);
            destSizeOverLifetime.enable = this.enable;
        }
        clone() {
            var destSize;
            switch (this._size.type) {
                case 0:
                    if (this._size.separateAxes)
                        destSize = GradientSize.createByGradientSeparate(this._size.gradientX.clone(), this._size.gradientY.clone(), this._size.gradientZ.clone());
                    else
                        destSize = GradientSize.createByGradient(this._size.gradient.clone());
                    break;
                case 1:
                    if (this._size.separateAxes)
                        destSize = GradientSize.createByRandomTwoConstantSeparate(this._size.constantMinSeparate.clone(), this._size.constantMaxSeparate.clone());
                    else
                        destSize = GradientSize.createByRandomTwoConstant(this._size.constantMin, this._size.constantMax);
                    break;
                case 2:
                    if (this._size.separateAxes)
                        destSize = GradientSize.createByRandomTwoGradientSeparate(this._size.gradientXMin.clone(), this._size.gradientYMin.clone(), this._size.gradientZMin.clone(), this._size.gradientXMax.clone(), this._size.gradientYMax.clone(), this._size.gradientZMax.clone());
                    else
                        destSize = GradientSize.createByRandomTwoGradient(this._size.gradientMin.clone(), this._size.gradientMax.clone());
                    break;
            }
            var destSizeOverLifetime = new SizeOverLifetime(destSize);
            destSizeOverLifetime.enable = this.enable;
            return destSizeOverLifetime;
        }
    }

    class StartFrame {
        constructor() {
            this._type = 0;
            this._constant = 0;
            this._constantMin = 0;
            this._constantMax = 0;
        }
        static createByConstant(constant = 0) {
            var rotationOverLifetime = new StartFrame();
            rotationOverLifetime._type = 0;
            rotationOverLifetime._constant = constant;
            return rotationOverLifetime;
        }
        static createByRandomTwoConstant(constantMin = 0, constantMax = 0) {
            var rotationOverLifetime = new StartFrame();
            rotationOverLifetime._type = 1;
            rotationOverLifetime._constantMin = constantMin;
            rotationOverLifetime._constantMax = constantMax;
            return rotationOverLifetime;
        }
        get type() {
            return this._type;
        }
        get constant() {
            return this._constant;
        }
        get constantMin() {
            return this._constantMin;
        }
        get constantMax() {
            return this._constantMax;
        }
        cloneTo(destObject) {
            var destStartFrame = destObject;
            destStartFrame._type = this._type;
            destStartFrame._constant = this._constant;
            destStartFrame._constantMin = this._constantMin;
            destStartFrame._constantMax = this._constantMax;
        }
        clone() {
            var destStartFrame = new StartFrame();
            this.cloneTo(destStartFrame);
            return destStartFrame;
        }
    }

    class TextureSheetAnimation {
        constructor(frame, startFrame) {
            this.type = 0;
            this.randomRow = false;
            this.rowIndex = 0;
            this.cycles = 0;
            this.enableUVChannels = 0;
            this.enable = false;
            this.tiles = new Laya.Vector2(1, 1);
            this.type = 0;
            this.randomRow = true;
            this.rowIndex = 0;
            this.cycles = 1;
            this.enableUVChannels = 1;
            this._frame = frame;
            this._startFrame = startFrame;
        }
        get frame() {
            return this._frame;
        }
        get startFrame() {
            return this._startFrame;
        }
        cloneTo(destObject) {
            var destTextureSheetAnimation = destObject;
            this.tiles.cloneTo(destTextureSheetAnimation.tiles);
            destTextureSheetAnimation.type = this.type;
            destTextureSheetAnimation.randomRow = this.randomRow;
            destTextureSheetAnimation.rowIndex = this.rowIndex;
            destTextureSheetAnimation.cycles = this.cycles;
            destTextureSheetAnimation.enableUVChannels = this.enableUVChannels;
            destTextureSheetAnimation.enable = this.enable;
            this._frame.cloneTo(destTextureSheetAnimation._frame);
            this._startFrame.cloneTo(destTextureSheetAnimation._startFrame);
        }
        clone() {
            var destFrame;
            switch (this._frame.type) {
                case 0:
                    destFrame = FrameOverTime.createByConstant(this._frame.constant);
                    break;
                case 1:
                    destFrame = FrameOverTime.createByOverTime(this._frame.frameOverTimeData.clone());
                    break;
                case 2:
                    destFrame = FrameOverTime.createByRandomTwoConstant(this._frame.constantMin, this._frame.constantMax);
                    break;
                case 3:
                    destFrame = FrameOverTime.createByRandomTwoOverTime(this._frame.frameOverTimeDataMin.clone(), this._frame.frameOverTimeDataMax.clone());
                    break;
            }
            var destStartFrame;
            switch (this._startFrame.type) {
                case 0:
                    destStartFrame = StartFrame.createByConstant(this._startFrame.constant);
                    break;
                case 1:
                    destStartFrame = StartFrame.createByRandomTwoConstant(this._startFrame.constantMin, this._startFrame.constantMax);
                    break;
            }
            var destTextureSheetAnimation = new TextureSheetAnimation(destFrame, destStartFrame);
            this.cloneTo(destTextureSheetAnimation);
            return destTextureSheetAnimation;
        }
    }

    class VelocityOverLifetime {
        constructor(velocity) {
            this.enable = false;
            this.space = 0;
            this._velocity = velocity;
        }
        get velocity() {
            return this._velocity;
        }
        cloneTo(destObject) {
            var destVelocityOverLifetime = destObject;
            this._velocity.cloneTo(destVelocityOverLifetime._velocity);
            destVelocityOverLifetime.enable = this.enable;
            destVelocityOverLifetime.space = this.space;
        }
        clone() {
            var destVelocity;
            switch (this._velocity.type) {
                case 0:
                    destVelocity = GradientVelocity.createByConstant(this._velocity.constant.clone());
                    break;
                case 1:
                    destVelocity = GradientVelocity.createByGradient(this._velocity.gradientX.clone(), this._velocity.gradientY.clone(), this._velocity.gradientZ.clone());
                    break;
                case 2:
                    destVelocity = GradientVelocity.createByRandomTwoConstant(this._velocity.constantMin.clone(), this._velocity.constantMax.clone());
                    break;
                case 3:
                    destVelocity = GradientVelocity.createByRandomTwoGradient(this._velocity.gradientXMin.clone(), this._velocity.gradientXMax.clone(), this._velocity.gradientYMin.clone(), this._velocity.gradientYMax.clone(), this._velocity.gradientZMin.clone(), this._velocity.gradientZMax.clone());
                    break;
            }
            var destVelocityOverLifetime = new VelocityOverLifetime(destVelocity);
            destVelocityOverLifetime.enable = this.enable;
            destVelocityOverLifetime.space = this.space;
            return destVelocityOverLifetime;
        }
    }

    class VertexShuriKenParticle {
        constructor() {
        }
    }
    VertexShuriKenParticle.PARTICLE_DIRECTIONTIME = 0;
    VertexShuriKenParticle.PARTICLE_POSITION0 = 1;
    VertexShuriKenParticle.PARTICLE_COLOR0 = 2;
    VertexShuriKenParticle.PARTICLE_TEXTURECOORDINATE0 = 3;
    VertexShuriKenParticle.PARTICLE_SHAPEPOSITIONSTARTLIFETIME = 4;
    VertexShuriKenParticle.PARTICLE_CORNERTEXTURECOORDINATE0 = 5;
    VertexShuriKenParticle.PARTICLE_STARTCOLOR0 = 6;
    VertexShuriKenParticle.PARTICLE_ENDCOLOR0 = 7;
    VertexShuriKenParticle.PARTICLE_STARTSIZE = 8;
    VertexShuriKenParticle.PARTICLE_STARTROTATION = 9;
    VertexShuriKenParticle.PARTICLE_STARTSPEED = 10;
    VertexShuriKenParticle.PARTICLE_RANDOM0 = 11;
    VertexShuriKenParticle.PARTICLE_RANDOM1 = 12;
    VertexShuriKenParticle.PARTICLE_SIMULATIONWORLDPOSTION = 13;
    VertexShuriKenParticle.PARTICLE_SIMULATIONWORLDROTATION = 14;
    VertexShuriKenParticle.PARTICLE_SIMULATIONUV = 15;

    class VertexShurikenParticleBillboard extends VertexShuriKenParticle {
        constructor(cornerTextureCoordinate, positionStartLifeTime, velocity, startColor, startSize, startRotation0, startRotation1, startRotation2, ageAddScale, time, startSpeed, randoms0, randoms1, simulationWorldPostion) {
            super();
            this._cornerTextureCoordinate = cornerTextureCoordinate;
            this._positionStartLifeTime = positionStartLifeTime;
            this._velocity = velocity;
            this._startColor = startColor;
            this._startSize = startSize;
            this._startRotation0 = startRotation0;
            this._startRotation1 = startRotation1;
            this._startRotation2 = startRotation2;
            this._startLifeTime = ageAddScale;
            this._time = time;
            this._startSpeed = startSpeed;
            this._randoms0 = randoms0;
            this._randoms1 = randoms1;
            this._simulationWorldPostion = simulationWorldPostion;
        }
        static get vertexDeclaration() {
            return VertexShurikenParticleBillboard._vertexDeclaration;
        }
        static get vertexInstanceMeshDeclaration() {
            return VertexShurikenParticleBillboard._vertexInstanceMeshDeclaration;
        }
        static get vertexInstanceParticleDeclaration() {
            return VertexShurikenParticleBillboard._vertexInstanceParticleDeclaration;
        }
        static get billboardVertexArray() {
            return VertexShurikenParticleBillboard._billboardVertexArray;
        }
        static get billboardIndexArray() {
            return VertexShurikenParticleBillboard._billboardIndexArray;
        }
        static set billboardIndexArray(value) {
            VertexShurikenParticleBillboard._billboardIndexArray = value;
        }
        static __init__() {
            VertexShurikenParticleBillboard._vertexDeclaration = new Laya.VertexDeclaration(168, [
                new Laya.VertexElement(0, Laya.VertexElementFormat.Vector4, VertexShuriKenParticle.PARTICLE_CORNERTEXTURECOORDINATE0),
                new Laya.VertexElement(16, Laya.VertexElementFormat.Vector4, VertexShuriKenParticle.PARTICLE_SHAPEPOSITIONSTARTLIFETIME),
                new Laya.VertexElement(32, Laya.VertexElementFormat.Vector4, VertexShuriKenParticle.PARTICLE_DIRECTIONTIME),
                new Laya.VertexElement(48, Laya.VertexElementFormat.Vector4, VertexShuriKenParticle.PARTICLE_STARTCOLOR0),
                new Laya.VertexElement(64, Laya.VertexElementFormat.Vector3, VertexShuriKenParticle.PARTICLE_STARTSIZE),
                new Laya.VertexElement(76, Laya.VertexElementFormat.Vector3, VertexShuriKenParticle.PARTICLE_STARTROTATION),
                new Laya.VertexElement(88, Laya.VertexElementFormat.Single, VertexShuriKenParticle.PARTICLE_STARTSPEED),
                new Laya.VertexElement(92, Laya.VertexElementFormat.Vector4, VertexShuriKenParticle.PARTICLE_RANDOM0),
                new Laya.VertexElement(108, Laya.VertexElementFormat.Vector4, VertexShuriKenParticle.PARTICLE_RANDOM1),
                new Laya.VertexElement(124, Laya.VertexElementFormat.Vector3, VertexShuriKenParticle.PARTICLE_SIMULATIONWORLDPOSTION),
                new Laya.VertexElement(136, Laya.VertexElementFormat.Vector4, VertexShuriKenParticle.PARTICLE_SIMULATIONWORLDROTATION),
                new Laya.VertexElement(152, Laya.VertexElementFormat.Vector4, VertexShuriKenParticle.PARTICLE_SIMULATIONUV)
            ]);
            VertexShurikenParticleBillboard._vertexInstanceMeshDeclaration = new Laya.VertexDeclaration(16, [
                new Laya.VertexElement(0, Laya.VertexElementFormat.Vector4, VertexShuriKenParticle.PARTICLE_CORNERTEXTURECOORDINATE0)
            ]);
            VertexShurikenParticleBillboard._vertexInstanceParticleDeclaration = new Laya.VertexDeclaration(152, [
                new Laya.VertexElement(0, Laya.VertexElementFormat.Vector4, VertexShuriKenParticle.PARTICLE_SHAPEPOSITIONSTARTLIFETIME),
                new Laya.VertexElement(16, Laya.VertexElementFormat.Vector4, VertexShuriKenParticle.PARTICLE_DIRECTIONTIME),
                new Laya.VertexElement(32, Laya.VertexElementFormat.Vector4, VertexShuriKenParticle.PARTICLE_STARTCOLOR0),
                new Laya.VertexElement(48, Laya.VertexElementFormat.Vector3, VertexShuriKenParticle.PARTICLE_STARTSIZE),
                new Laya.VertexElement(60, Laya.VertexElementFormat.Vector3, VertexShuriKenParticle.PARTICLE_STARTROTATION),
                new Laya.VertexElement(72, Laya.VertexElementFormat.Single, VertexShuriKenParticle.PARTICLE_STARTSPEED),
                new Laya.VertexElement(76, Laya.VertexElementFormat.Vector4, VertexShuriKenParticle.PARTICLE_RANDOM0),
                new Laya.VertexElement(92, Laya.VertexElementFormat.Vector4, VertexShuriKenParticle.PARTICLE_RANDOM1),
                new Laya.VertexElement(108, Laya.VertexElementFormat.Vector3, VertexShuriKenParticle.PARTICLE_SIMULATIONWORLDPOSTION),
                new Laya.VertexElement(120, Laya.VertexElementFormat.Vector4, VertexShuriKenParticle.PARTICLE_SIMULATIONWORLDROTATION),
                new Laya.VertexElement(136, Laya.VertexElementFormat.Vector4, VertexShuriKenParticle.PARTICLE_SIMULATIONUV)
            ]);
            VertexShurikenParticleBillboard._billboardIndexArray = new Uint16Array([
                0, 2, 1, 0, 3, 2
            ]);
            VertexShurikenParticleBillboard._billboardVertexArray = new Float32Array([
                -0.5, -0.5, 0, 1,
                0.5, -0.5, 1, 1,
                0.5, 0.5, 1, 0,
                -0.5, 0.5, 0, 0
            ]);
        }
        get cornerTextureCoordinate() {
            return this._cornerTextureCoordinate;
        }
        get positionStartLifeTime() {
            return this._positionStartLifeTime;
        }
        get velocity() {
            return this._velocity;
        }
        get startColor() {
            return this._startColor;
        }
        get startSize() {
            return this._startSize;
        }
        get startRotation0() {
            return this._startRotation0;
        }
        get startRotation1() {
            return this._startRotation1;
        }
        get startRotation2() {
            return this._startRotation2;
        }
        get startLifeTime() {
            return this._startLifeTime;
        }
        get time() {
            return this._time;
        }
        get startSpeed() {
            return this._startSpeed;
        }
        get random0() {
            return this._randoms0;
        }
        get random1() {
            return this._randoms1;
        }
        get simulationWorldPostion() {
            return this._simulationWorldPostion;
        }
    }

    class VertexShurikenParticleMesh extends VertexShuriKenParticle {
        constructor(cornerTextureCoordinate, positionStartLifeTime, velocity, startColor, startSize, startRotation0, startRotation1, startRotation2, ageAddScale, time, startSpeed, randoms0, randoms1, simulationWorldPostion) {
            super();
            this._cornerTextureCoordinate = cornerTextureCoordinate;
            this._positionStartLifeTime = positionStartLifeTime;
            this._velocity = velocity;
            this._startColor = startColor;
            this._startSize = startSize;
            this._startRotation0 = startRotation0;
            this._startRotation1 = startRotation1;
            this._startRotation2 = startRotation2;
            this._startLifeTime = ageAddScale;
            this._time = time;
            this._startSpeed = startSpeed;
            this._randoms0 = randoms0;
            this._randoms1 = randoms1;
            this._simulationWorldPostion = simulationWorldPostion;
        }
        static __init__() {
            VertexShurikenParticleMesh._vertexDeclaration = new Laya.VertexDeclaration(188, [new Laya.VertexElement(0, Laya.VertexElementFormat.Vector3, VertexShuriKenParticle.PARTICLE_POSITION0),
                new Laya.VertexElement(12, Laya.VertexElementFormat.Vector4, VertexShuriKenParticle.PARTICLE_COLOR0),
                new Laya.VertexElement(28, Laya.VertexElementFormat.Vector2, VertexShuriKenParticle.PARTICLE_TEXTURECOORDINATE0),
                new Laya.VertexElement(36, Laya.VertexElementFormat.Vector4, VertexShuriKenParticle.PARTICLE_SHAPEPOSITIONSTARTLIFETIME),
                new Laya.VertexElement(52, Laya.VertexElementFormat.Vector4, VertexShuriKenParticle.PARTICLE_DIRECTIONTIME),
                new Laya.VertexElement(68, Laya.VertexElementFormat.Vector4, VertexShuriKenParticle.PARTICLE_STARTCOLOR0),
                new Laya.VertexElement(84, Laya.VertexElementFormat.Vector3, VertexShuriKenParticle.PARTICLE_STARTSIZE),
                new Laya.VertexElement(96, Laya.VertexElementFormat.Vector3, VertexShuriKenParticle.PARTICLE_STARTROTATION),
                new Laya.VertexElement(108, Laya.VertexElementFormat.Single, VertexShuriKenParticle.PARTICLE_STARTSPEED),
                new Laya.VertexElement(112, Laya.VertexElementFormat.Vector4, VertexShuriKenParticle.PARTICLE_RANDOM0),
                new Laya.VertexElement(128, Laya.VertexElementFormat.Vector4, VertexShuriKenParticle.PARTICLE_RANDOM1),
                new Laya.VertexElement(144, Laya.VertexElementFormat.Vector3, VertexShuriKenParticle.PARTICLE_SIMULATIONWORLDPOSTION),
                new Laya.VertexElement(156, Laya.VertexElementFormat.Vector4, VertexShuriKenParticle.PARTICLE_SIMULATIONWORLDROTATION),
                new Laya.VertexElement(172, Laya.VertexElementFormat.Vector4, VertexShuriKenParticle.PARTICLE_SIMULATIONUV)]);
            VertexShurikenParticleMesh._vertexInstanceMeshDeclaration = new Laya.VertexDeclaration(36, [
                new Laya.VertexElement(0, Laya.VertexElementFormat.Vector3, VertexShuriKenParticle.PARTICLE_POSITION0),
                new Laya.VertexElement(12, Laya.VertexElementFormat.Vector4, VertexShuriKenParticle.PARTICLE_COLOR0),
                new Laya.VertexElement(28, Laya.VertexElementFormat.Vector2, VertexShuriKenParticle.PARTICLE_TEXTURECOORDINATE0)
            ]);
            VertexShurikenParticleMesh._vertexInstanceParticleDeclaration = new Laya.VertexDeclaration(152, [
                new Laya.VertexElement(0, Laya.VertexElementFormat.Vector4, VertexShuriKenParticle.PARTICLE_SHAPEPOSITIONSTARTLIFETIME),
                new Laya.VertexElement(16, Laya.VertexElementFormat.Vector4, VertexShuriKenParticle.PARTICLE_DIRECTIONTIME),
                new Laya.VertexElement(32, Laya.VertexElementFormat.Vector4, VertexShuriKenParticle.PARTICLE_STARTCOLOR0),
                new Laya.VertexElement(48, Laya.VertexElementFormat.Vector3, VertexShuriKenParticle.PARTICLE_STARTSIZE),
                new Laya.VertexElement(60, Laya.VertexElementFormat.Vector3, VertexShuriKenParticle.PARTICLE_STARTROTATION),
                new Laya.VertexElement(72, Laya.VertexElementFormat.Single, VertexShuriKenParticle.PARTICLE_STARTSPEED),
                new Laya.VertexElement(76, Laya.VertexElementFormat.Vector4, VertexShuriKenParticle.PARTICLE_RANDOM0),
                new Laya.VertexElement(92, Laya.VertexElementFormat.Vector4, VertexShuriKenParticle.PARTICLE_RANDOM1),
                new Laya.VertexElement(108, Laya.VertexElementFormat.Vector3, VertexShuriKenParticle.PARTICLE_SIMULATIONWORLDPOSTION),
                new Laya.VertexElement(120, Laya.VertexElementFormat.Vector4, VertexShuriKenParticle.PARTICLE_SIMULATIONWORLDROTATION),
                new Laya.VertexElement(136, Laya.VertexElementFormat.Vector4, VertexShuriKenParticle.PARTICLE_SIMULATIONUV)
            ]);
        }
        static get vertexDeclaration() {
            return VertexShurikenParticleMesh._vertexDeclaration;
        }
        static get vertexInstanceMeshDeclaration() {
            return VertexShurikenParticleMesh._vertexInstanceMeshDeclaration;
        }
        static get vertexInstanceParticleDeclaration() {
            return VertexShurikenParticleMesh._vertexInstanceParticleDeclaration;
        }
        get cornerTextureCoordinate() {
            return this._cornerTextureCoordinate;
        }
        get position() {
            return this._positionStartLifeTime;
        }
        get velocity() {
            return this._velocity;
        }
        get startColor() {
            return this._startColor;
        }
        get startSize() {
            return this._startSize;
        }
        get startRotation0() {
            return this._startRotation0;
        }
        get startRotation1() {
            return this._startRotation1;
        }
        get startRotation2() {
            return this._startRotation2;
        }
        get startLifeTime() {
            return this._startLifeTime;
        }
        get time() {
            return this._time;
        }
        get startSpeed() {
            return this._startSpeed;
        }
        get random0() {
            return this._randoms0;
        }
        get random1() {
            return this._randoms1;
        }
        get simulationWorldPostion() {
            return this._simulationWorldPostion;
        }
    }

    class Rand {
        constructor(seed) {
            this._temp = new Uint32Array(1);
            this.seeds = new Uint32Array(4);
            this.seeds[0] = seed;
            this.seeds[1] = this.seeds[0] * 0x6C078965 + 1;
            this.seeds[2] = this.seeds[1] * 0x6C078965 + 1;
            this.seeds[3] = this.seeds[2] * 0x6C078965 + 1;
        }
        static getFloatFromInt(v) {
            return (v & 0x007FFFFF) * (1.0 / 8388607.0);
        }
        static getByteFromInt(v) {
            return (v & 0x007FFFFF) >>> 15;
        }
        get seed() {
            return this.seeds[0];
        }
        set seed(seed) {
            this.seeds[0] = seed;
            this.seeds[1] = this.seeds[0] * 0x6C078965 + 1;
            this.seeds[2] = this.seeds[1] * 0x6C078965 + 1;
            this.seeds[3] = this.seeds[2] * 0x6C078965 + 1;
        }
        getUint() {
            this._temp[0] = this.seeds[0] ^ (this.seeds[0] << 11);
            this.seeds[0] = this.seeds[1];
            this.seeds[1] = this.seeds[2];
            this.seeds[2] = this.seeds[3];
            this.seeds[3] = (this.seeds[3] ^ (this.seeds[3] >>> 19)) ^ (this._temp[0] ^ (this._temp[0] >>> 8));
            return this.seeds[3];
        }
        getFloat() {
            this.getUint();
            return (this.seeds[3] & 0x007FFFFF) * (1.0 / 8388607.0);
        }
        getSignedFloat() {
            return this.getFloat() * 2.0 - 1.0;
        }
    }

    class ShuriKenParticle3DShaderDeclaration {
        static __init__() {
            ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_RENDERMODE_BILLBOARD = Laya.Shader3D.getDefineByName("SPHERHBILLBOARD");
            ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_RENDERMODE_STRETCHEDBILLBOARD = Laya.Shader3D.getDefineByName("STRETCHEDBILLBOARD");
            ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_RENDERMODE_HORIZONTALBILLBOARD = Laya.Shader3D.getDefineByName("HORIZONTALBILLBOARD");
            ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_RENDERMODE_VERTICALBILLBOARD = Laya.Shader3D.getDefineByName("VERTICALBILLBOARD");
            ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_COLORKEYCOUNT_8 = Laya.Shader3D.getDefineByName("COLORKEYCOUNT_8");
            ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_COLOROVERLIFETIME = Laya.Shader3D.getDefineByName("COLOROVERLIFETIME");
            ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_RANDOMCOLOROVERLIFETIME = Laya.Shader3D.getDefineByName("RANDOMCOLOROVERLIFETIME");
            ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_VELOCITYOVERLIFETIMECONSTANT = Laya.Shader3D.getDefineByName("VELOCITYOVERLIFETIMECONSTANT");
            ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_VELOCITYOVERLIFETIMECURVE = Laya.Shader3D.getDefineByName("VELOCITYOVERLIFETIMECURVE");
            ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCONSTANT = Laya.Shader3D.getDefineByName("VELOCITYOVERLIFETIMERANDOMCONSTANT");
            ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCURVE = Laya.Shader3D.getDefineByName("VELOCITYOVERLIFETIMERANDOMCURVE");
            ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_TEXTURESHEETANIMATIONCURVE = Laya.Shader3D.getDefineByName("TEXTURESHEETANIMATIONCURVE");
            ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_TEXTURESHEETANIMATIONRANDOMCURVE = Laya.Shader3D.getDefineByName("TEXTURESHEETANIMATIONRANDOMCURVE");
            ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_ROTATIONOVERLIFETIME = Laya.Shader3D.getDefineByName("ROTATIONOVERLIFETIME");
            ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_ROTATIONOVERLIFETIMESEPERATE = Laya.Shader3D.getDefineByName("ROTATIONOVERLIFETIMESEPERATE");
            ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_ROTATIONOVERLIFETIMECONSTANT = Laya.Shader3D.getDefineByName("ROTATIONOVERLIFETIMECONSTANT");
            ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_ROTATIONOVERLIFETIMECURVE = Laya.Shader3D.getDefineByName("ROTATIONOVERLIFETIMECURVE");
            ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCONSTANTS = Laya.Shader3D.getDefineByName("ROTATIONOVERLIFETIMERANDOMCONSTANTS");
            ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCURVES = Laya.Shader3D.getDefineByName("ROTATIONOVERLIFETIMERANDOMCURVES");
            ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_SIZEOVERLIFETIMECURVE = Laya.Shader3D.getDefineByName("SIZEOVERLIFETIMECURVE");
            ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_SIZEOVERLIFETIMECURVESEPERATE = Laya.Shader3D.getDefineByName("SIZEOVERLIFETIMECURVESEPERATE");
            ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVES = Laya.Shader3D.getDefineByName("SIZEOVERLIFETIMERANDOMCURVES");
            ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVESSEPERATE = Laya.Shader3D.getDefineByName("SIZEOVERLIFETIMERANDOMCURVESSEPERATE");
            ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_RENDERMODE_MESH = Laya.Shader3D.getDefineByName("RENDERMODE_MESH");
            ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_SHAPE = Laya.Shader3D.getDefineByName("SHAPE");
            ShuriKenParticle3DShaderDeclaration.WORLDPOSITION = Laya.Shader3D.propertyNameToID("u_WorldPosition");
            ShuriKenParticle3DShaderDeclaration.WORLDROTATION = Laya.Shader3D.propertyNameToID("u_WorldRotation");
            ShuriKenParticle3DShaderDeclaration.POSITIONSCALE = Laya.Shader3D.propertyNameToID("u_PositionScale");
            ShuriKenParticle3DShaderDeclaration.SIZESCALE = Laya.Shader3D.propertyNameToID("u_SizeScale");
            ShuriKenParticle3DShaderDeclaration.SCALINGMODE = Laya.Shader3D.propertyNameToID("u_ScalingMode");
            ShuriKenParticle3DShaderDeclaration.GRAVITY = Laya.Shader3D.propertyNameToID("u_Gravity");
            ShuriKenParticle3DShaderDeclaration.THREEDSTARTROTATION = Laya.Shader3D.propertyNameToID("u_ThreeDStartRotation");
            ShuriKenParticle3DShaderDeclaration.STRETCHEDBILLBOARDLENGTHSCALE = Laya.Shader3D.propertyNameToID("u_StretchedBillboardLengthScale");
            ShuriKenParticle3DShaderDeclaration.STRETCHEDBILLBOARDSPEEDSCALE = Laya.Shader3D.propertyNameToID("u_StretchedBillboardSpeedScale");
            ShuriKenParticle3DShaderDeclaration.SIMULATIONSPACE = Laya.Shader3D.propertyNameToID("u_SimulationSpace");
            ShuriKenParticle3DShaderDeclaration.CURRENTTIME = Laya.Shader3D.propertyNameToID("u_CurrentTime");
            ShuriKenParticle3DShaderDeclaration.DRAG = Laya.Shader3D.propertyNameToID("u_DragConstanct");
            ShuriKenParticle3DShaderDeclaration.VOLVELOCITYCONST = Laya.Shader3D.propertyNameToID("u_VOLVelocityConst");
            ShuriKenParticle3DShaderDeclaration.VOLVELOCITYGRADIENTX = Laya.Shader3D.propertyNameToID("u_VOLVelocityGradientX");
            ShuriKenParticle3DShaderDeclaration.VOLVELOCITYGRADIENTY = Laya.Shader3D.propertyNameToID("u_VOLVelocityGradientY");
            ShuriKenParticle3DShaderDeclaration.VOLVELOCITYGRADIENTZ = Laya.Shader3D.propertyNameToID("u_VOLVelocityGradientZ");
            ShuriKenParticle3DShaderDeclaration.VOLVELOCITYCONSTMAX = Laya.Shader3D.propertyNameToID("u_VOLVelocityConstMax");
            ShuriKenParticle3DShaderDeclaration.VOLVELOCITYGRADIENTXMAX = Laya.Shader3D.propertyNameToID("u_VOLVelocityGradientMaxX");
            ShuriKenParticle3DShaderDeclaration.VOLVELOCITYGRADIENTYMAX = Laya.Shader3D.propertyNameToID("u_VOLVelocityGradientMaxY");
            ShuriKenParticle3DShaderDeclaration.VOLVELOCITYGRADIENTZMAX = Laya.Shader3D.propertyNameToID("u_VOLVelocityGradientMaxZ");
            ShuriKenParticle3DShaderDeclaration.VOLSPACETYPE = Laya.Shader3D.propertyNameToID("u_VOLSpaceType");
            ShuriKenParticle3DShaderDeclaration.COLOROVERLIFEGRADIENTALPHAS = Laya.Shader3D.propertyNameToID("u_ColorOverLifeGradientAlphas");
            ShuriKenParticle3DShaderDeclaration.COLOROVERLIFEGRADIENTCOLORS = Laya.Shader3D.propertyNameToID("u_ColorOverLifeGradientColors");
            ShuriKenParticle3DShaderDeclaration.COLOROVERLIFEGRADIENTRANGES = Laya.Shader3D.propertyNameToID("u_ColorOverLifeGradientRanges");
            ShuriKenParticle3DShaderDeclaration.MAXCOLOROVERLIFEGRADIENTALPHAS = Laya.Shader3D.propertyNameToID("u_MaxColorOverLifeGradientAlphas");
            ShuriKenParticle3DShaderDeclaration.MAXCOLOROVERLIFEGRADIENTCOLORS = Laya.Shader3D.propertyNameToID("u_MaxColorOverLifeGradientColors");
            ShuriKenParticle3DShaderDeclaration.MAXCOLOROVERLIFEGRADIENTRANGES = Laya.Shader3D.propertyNameToID("u_MaxColorOverLifeGradientRanges");
            ShuriKenParticle3DShaderDeclaration.SOLSIZEGRADIENT = Laya.Shader3D.propertyNameToID("u_SOLSizeGradient");
            ShuriKenParticle3DShaderDeclaration.SOLSIZEGRADIENTX = Laya.Shader3D.propertyNameToID("u_SOLSizeGradientX");
            ShuriKenParticle3DShaderDeclaration.SOLSIZEGRADIENTY = Laya.Shader3D.propertyNameToID("u_SOLSizeGradientY");
            ShuriKenParticle3DShaderDeclaration.SOLSizeGradientZ = Laya.Shader3D.propertyNameToID("u_SOLSizeGradientZ");
            ShuriKenParticle3DShaderDeclaration.SOLSizeGradientMax = Laya.Shader3D.propertyNameToID("u_SOLSizeGradientMax");
            ShuriKenParticle3DShaderDeclaration.SOLSIZEGRADIENTXMAX = Laya.Shader3D.propertyNameToID("u_SOLSizeGradientMaxX");
            ShuriKenParticle3DShaderDeclaration.SOLSIZEGRADIENTYMAX = Laya.Shader3D.propertyNameToID("u_SOLSizeGradientMaxY");
            ShuriKenParticle3DShaderDeclaration.SOLSizeGradientZMAX = Laya.Shader3D.propertyNameToID("u_SOLSizeGradientMaxZ");
            ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYCONST = Laya.Shader3D.propertyNameToID("u_ROLAngularVelocityConst");
            ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYCONSTSEPRARATE = Laya.Shader3D.propertyNameToID("u_ROLAngularVelocityConstSeprarate");
            ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENT = Laya.Shader3D.propertyNameToID("u_ROLAngularVelocityGradient");
            ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENTX = Laya.Shader3D.propertyNameToID("u_ROLAngularVelocityGradientX");
            ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENTY = Laya.Shader3D.propertyNameToID("u_ROLAngularVelocityGradientY");
            ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENTZ = Laya.Shader3D.propertyNameToID("u_ROLAngularVelocityGradientZ");
            ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYCONSTMAX = Laya.Shader3D.propertyNameToID("u_ROLAngularVelocityConstMax");
            ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYCONSTMAXSEPRARATE = Laya.Shader3D.propertyNameToID("u_ROLAngularVelocityConstMaxSeprarate");
            ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENTMAX = Laya.Shader3D.propertyNameToID("u_ROLAngularVelocityGradientMax");
            ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENTXMAX = Laya.Shader3D.propertyNameToID("u_ROLAngularVelocityGradientMaxX");
            ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENTYMAX = Laya.Shader3D.propertyNameToID("u_ROLAngularVelocityGradientMaxY");
            ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENTZMAX = Laya.Shader3D.propertyNameToID("u_ROLAngularVelocityGradientMaxZ");
            ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENTWMAX = Laya.Shader3D.propertyNameToID("u_ROLAngularVelocityGradientMaxW");
            ShuriKenParticle3DShaderDeclaration.TEXTURESHEETANIMATIONCYCLES = Laya.Shader3D.propertyNameToID("u_TSACycles");
            ShuriKenParticle3DShaderDeclaration.TEXTURESHEETANIMATIONSUBUVLENGTH = Laya.Shader3D.propertyNameToID("u_TSASubUVLength");
            ShuriKenParticle3DShaderDeclaration.TEXTURESHEETANIMATIONGRADIENTUVS = Laya.Shader3D.propertyNameToID("u_TSAGradientUVs");
            ShuriKenParticle3DShaderDeclaration.TEXTURESHEETANIMATIONGRADIENTMAXUVS = Laya.Shader3D.propertyNameToID("u_TSAMaxGradientUVs");
            let uniformMap = Laya.LayaGL.renderOBJCreate.createGlobalUniformMap("Sprite3D");
            uniformMap.addShaderUniform(ShuriKenParticle3DShaderDeclaration.WORLDPOSITION, 'u_WorldPosition'),
                uniformMap.addShaderUniform(ShuriKenParticle3DShaderDeclaration.WORLDROTATION, 'u_WorldRotation');
            uniformMap.addShaderUniform(ShuriKenParticle3DShaderDeclaration.POSITIONSCALE, 'u_PositionScale');
            uniformMap.addShaderUniform(ShuriKenParticle3DShaderDeclaration.SIZESCALE, 'u_SizeScale');
            uniformMap.addShaderUniform(ShuriKenParticle3DShaderDeclaration.SCALINGMODE, 'u_ScalingMode');
            uniformMap.addShaderUniform(ShuriKenParticle3DShaderDeclaration.GRAVITY, 'u_Gravity');
            uniformMap.addShaderUniform(ShuriKenParticle3DShaderDeclaration.THREEDSTARTROTATION, 'u_ThreeDStartRotation');
            uniformMap.addShaderUniform(ShuriKenParticle3DShaderDeclaration.STRETCHEDBILLBOARDLENGTHSCALE, 'u_StretchedBillboardLengthScale');
            uniformMap.addShaderUniform(ShuriKenParticle3DShaderDeclaration.STRETCHEDBILLBOARDSPEEDSCALE, 'u_StretchedBillboardSpeedScale');
            uniformMap.addShaderUniform(ShuriKenParticle3DShaderDeclaration.SIMULATIONSPACE, 'u_SimulationSpace');
            uniformMap.addShaderUniform(ShuriKenParticle3DShaderDeclaration.CURRENTTIME, 'u_CurrentTime');
            uniformMap.addShaderUniform(ShuriKenParticle3DShaderDeclaration.COLOROVERLIFEGRADIENTALPHAS, 'u_ColorOverLifeGradientAlphas');
            uniformMap.addShaderUniform(ShuriKenParticle3DShaderDeclaration.COLOROVERLIFEGRADIENTCOLORS, 'u_ColorOverLifeGradientColors');
            uniformMap.addShaderUniform(ShuriKenParticle3DShaderDeclaration.COLOROVERLIFEGRADIENTRANGES, 'u_ColorOverLifeGradientRanges');
            uniformMap.addShaderUniform(ShuriKenParticle3DShaderDeclaration.MAXCOLOROVERLIFEGRADIENTALPHAS, 'u_MaxColorOverLifeGradientAlphas');
            uniformMap.addShaderUniform(ShuriKenParticle3DShaderDeclaration.MAXCOLOROVERLIFEGRADIENTCOLORS, 'u_MaxColorOverLifeGradientColors');
            uniformMap.addShaderUniform(ShuriKenParticle3DShaderDeclaration.MAXCOLOROVERLIFEGRADIENTRANGES, 'u_MaxColorOverLifeGradientRanges');
            uniformMap.addShaderUniform(ShuriKenParticle3DShaderDeclaration.VOLVELOCITYCONST, 'u_VOLVelocityConst');
            uniformMap.addShaderUniform(ShuriKenParticle3DShaderDeclaration.VOLVELOCITYGRADIENTX, 'u_VOLVelocityGradientX');
            uniformMap.addShaderUniform(ShuriKenParticle3DShaderDeclaration.VOLVELOCITYGRADIENTY, 'u_VOLVelocityGradientY');
            uniformMap.addShaderUniform(ShuriKenParticle3DShaderDeclaration.VOLVELOCITYGRADIENTZ, 'u_VOLVelocityGradientZ');
            uniformMap.addShaderUniform(ShuriKenParticle3DShaderDeclaration.VOLVELOCITYCONSTMAX, 'u_VOLVelocityConstMax');
            uniformMap.addShaderUniform(ShuriKenParticle3DShaderDeclaration.VOLVELOCITYGRADIENTXMAX, 'u_VOLVelocityGradientMaxX');
            uniformMap.addShaderUniform(ShuriKenParticle3DShaderDeclaration.VOLVELOCITYGRADIENTYMAX, 'u_VOLVelocityGradientMaxY');
            uniformMap.addShaderUniform(ShuriKenParticle3DShaderDeclaration.VOLVELOCITYGRADIENTZMAX, 'u_VOLVelocityGradientMaxZ');
            uniformMap.addShaderUniform(ShuriKenParticle3DShaderDeclaration.VOLSPACETYPE, 'u_VOLSpaceType');
            uniformMap.addShaderUniform(ShuriKenParticle3DShaderDeclaration.SOLSIZEGRADIENT, 'u_SOLSizeGradient');
            uniformMap.addShaderUniform(ShuriKenParticle3DShaderDeclaration.SOLSIZEGRADIENTX, 'u_SOLSizeGradientX');
            uniformMap.addShaderUniform(ShuriKenParticle3DShaderDeclaration.SOLSIZEGRADIENTY, 'u_SOLSizeGradientY');
            uniformMap.addShaderUniform(ShuriKenParticle3DShaderDeclaration.SOLSizeGradientZ, 'u_SOLSizeGradientZ');
            uniformMap.addShaderUniform(ShuriKenParticle3DShaderDeclaration.SOLSizeGradientMax, 'u_SOLSizeGradientMax');
            uniformMap.addShaderUniform(ShuriKenParticle3DShaderDeclaration.SOLSIZEGRADIENTXMAX, 'u_SOLSizeGradientMaxX');
            uniformMap.addShaderUniform(ShuriKenParticle3DShaderDeclaration.SOLSIZEGRADIENTYMAX, 'u_SOLSizeGradientMaxY');
            uniformMap.addShaderUniform(ShuriKenParticle3DShaderDeclaration.SOLSizeGradientZMAX, 'u_SOLSizeGradientMaxZ');
            uniformMap.addShaderUniform(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYCONST, 'u_ROLAngularVelocityConst');
            uniformMap.addShaderUniform(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYCONSTSEPRARATE, 'u_ROLAngularVelocityConstSeprarate');
            uniformMap.addShaderUniform(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENT, 'u_ROLAngularVelocityGradient');
            uniformMap.addShaderUniform(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENTX, 'u_ROLAngularVelocityGradientX');
            uniformMap.addShaderUniform(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENTY, 'u_ROLAngularVelocityGradientY');
            uniformMap.addShaderUniform(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENTZ, 'u_ROLAngularVelocityGradientZ');
            uniformMap.addShaderUniform(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYCONSTMAX, 'u_ROLAngularVelocityConstMax');
            uniformMap.addShaderUniform(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYCONSTMAXSEPRARATE, 'u_ROLAngularVelocityConstMaxSeprarate');
            uniformMap.addShaderUniform(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENTMAX, 'u_ROLAngularVelocityGradientMax');
            uniformMap.addShaderUniform(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENTXMAX, 'u_ROLAngularVelocityGradientMaxX');
            uniformMap.addShaderUniform(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENTYMAX, 'u_ROLAngularVelocityGradientMaxY');
            uniformMap.addShaderUniform(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENTZMAX, 'u_ROLAngularVelocityGradientMaxZ');
            uniformMap.addShaderUniform(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENTWMAX, 'u_ROLAngularVelocityGradientMaxW');
            uniformMap.addShaderUniform(ShuriKenParticle3DShaderDeclaration.TEXTURESHEETANIMATIONCYCLES, 'u_TSACycles');
            uniformMap.addShaderUniform(ShuriKenParticle3DShaderDeclaration.TEXTURESHEETANIMATIONSUBUVLENGTH, 'u_TSASubUVLength');
            uniformMap.addShaderUniform(ShuriKenParticle3DShaderDeclaration.TEXTURESHEETANIMATIONGRADIENTUVS, 'u_TSAGradientUVs');
            uniformMap.addShaderUniform(ShuriKenParticle3DShaderDeclaration.TEXTURESHEETANIMATIONGRADIENTMAXUVS, 'u_TSAMaxGradientUVs');
            uniformMap.addShaderUniform(ShuriKenParticle3DShaderDeclaration.DRAG, 'u_DragConstanct');
        }
    }

    class ShurikenParticleData {
        constructor() {
        }
        static _getStartLifetimeFromGradient(startLifeTimeGradient, emissionTime) {
            for (var i = 1, n = startLifeTimeGradient.gradientCount; i < n; i++) {
                var key = startLifeTimeGradient.getKeyByIndex(i);
                if (key >= emissionTime) {
                    var lastKey = startLifeTimeGradient.getKeyByIndex(i - 1);
                    var age = (emissionTime - lastKey) / (key - lastKey);
                    return Laya.MathUtil.lerp(startLifeTimeGradient.getValueByIndex(i - 1), startLifeTimeGradient.getValueByIndex(i), age);
                }
            }
            throw new Error("ShurikenParticleData: can't get value foam startLifeTimeGradient.");
        }
        static _randomInvertRoationArray(rotatonE, outE, randomizeRotationDirection, rand, randomSeeds) {
            var randDic;
            if (rand) {
                rand.seed = randomSeeds[6];
                randDic = rand.getFloat();
                randomSeeds[6] = rand.seed;
            }
            else {
                randDic = Math.random();
            }
            if (randDic < randomizeRotationDirection) {
                outE.x = -rotatonE.x;
                outE.y = -rotatonE.y;
                outE.z = -rotatonE.z;
            }
            else {
                outE.x = rotatonE.x;
                outE.y = rotatonE.y;
                outE.z = rotatonE.z;
            }
        }
        static _randomInvertRoation(rotaton, randomizeRotationDirection, rand, randomSeeds) {
            var randDic;
            if (rand) {
                rand.seed = randomSeeds[6];
                randDic = rand.getFloat();
                randomSeeds[6] = rand.seed;
            }
            else {
                randDic = Math.random();
            }
            if (randDic < randomizeRotationDirection)
                rotaton = -rotaton;
            return rotaton;
        }
        static create(particleSystem, particleRender) {
            var autoRandomSeed = particleSystem.autoRandomSeed;
            var rand = particleSystem._rand;
            var randomSeeds = particleSystem._randomSeeds;
            switch (particleSystem.startColorType) {
                case 0:
                    var constantStartColor = particleSystem.startColorConstant;
                    ShurikenParticleData.startColor.x = constantStartColor.x;
                    ShurikenParticleData.startColor.y = constantStartColor.y;
                    ShurikenParticleData.startColor.z = constantStartColor.z;
                    ShurikenParticleData.startColor.w = constantStartColor.w;
                    break;
                case 2:
                    if (autoRandomSeed) {
                        Laya.Vector4.lerp(particleSystem.startColorConstantMin, particleSystem.startColorConstantMax, Math.random(), ShurikenParticleData.startColor);
                    }
                    else {
                        rand.seed = randomSeeds[3];
                        Laya.Vector4.lerp(particleSystem.startColorConstantMin, particleSystem.startColorConstantMax, rand.getFloat(), ShurikenParticleData.startColor);
                        randomSeeds[3] = rand.seed;
                    }
                    break;
            }
            var colorOverLifetime = particleSystem.colorOverLifetime;
            if (colorOverLifetime && colorOverLifetime.enable) {
                var color = colorOverLifetime.color;
                switch (color.type) {
                    case 0:
                        ShurikenParticleData.startColor.x = ShurikenParticleData.startColor.x * color.constant.x;
                        ShurikenParticleData.startColor.y = ShurikenParticleData.startColor.y * color.constant.y;
                        ShurikenParticleData.startColor.z = ShurikenParticleData.startColor.z * color.constant.z;
                        ShurikenParticleData.startColor.w = ShurikenParticleData.startColor.w * color.constant.w;
                        break;
                    case 2:
                        var colorRandom;
                        if (autoRandomSeed) {
                            colorRandom = Math.random();
                        }
                        else {
                            rand.seed = randomSeeds[10];
                            colorRandom = rand.getFloat();
                            randomSeeds[10] = rand.seed;
                        }
                        var minConstantColor = color.constantMin;
                        var maxConstantColor = color.constantMax;
                        ShurikenParticleData.startColor.x = ShurikenParticleData.startColor.x * Laya.MathUtil.lerp(minConstantColor.x, maxConstantColor.x, colorRandom);
                        ShurikenParticleData.startColor.y = ShurikenParticleData.startColor.y * Laya.MathUtil.lerp(minConstantColor.y, maxConstantColor.y, colorRandom);
                        ShurikenParticleData.startColor.z = ShurikenParticleData.startColor.z * Laya.MathUtil.lerp(minConstantColor.z, maxConstantColor.z, colorRandom);
                        ShurikenParticleData.startColor.w = ShurikenParticleData.startColor.w * Laya.MathUtil.lerp(minConstantColor.w, maxConstantColor.w, colorRandom);
                        break;
                }
            }
            var particleSize = ShurikenParticleData.startSize;
            switch (particleSystem.startSizeType) {
                case 0:
                    if (particleSystem.threeDStartSize) {
                        var startSizeConstantSeparate = particleSystem.startSizeConstantSeparate;
                        particleSize[0] = startSizeConstantSeparate.x;
                        particleSize[1] = startSizeConstantSeparate.y;
                        particleSize[2] = startSizeConstantSeparate.z;
                    }
                    else {
                        particleSize[0] = particleSize[1] = particleSize[2] = particleSystem.startSizeConstant;
                    }
                    break;
                case 2:
                    if (particleSystem.threeDStartSize) {
                        var startSizeConstantMinSeparate = particleSystem.startSizeConstantMinSeparate;
                        var startSizeConstantMaxSeparate = particleSystem.startSizeConstantMaxSeparate;
                        if (autoRandomSeed) {
                            particleSize[0] = Laya.MathUtil.lerp(startSizeConstantMinSeparate.x, startSizeConstantMaxSeparate.x, Math.random());
                            particleSize[1] = Laya.MathUtil.lerp(startSizeConstantMinSeparate.y, startSizeConstantMaxSeparate.y, Math.random());
                            particleSize[2] = Laya.MathUtil.lerp(startSizeConstantMinSeparate.z, startSizeConstantMaxSeparate.z, Math.random());
                        }
                        else {
                            rand.seed = randomSeeds[4];
                            particleSize[0] = Laya.MathUtil.lerp(startSizeConstantMinSeparate.x, startSizeConstantMaxSeparate.x, rand.getFloat());
                            particleSize[1] = Laya.MathUtil.lerp(startSizeConstantMinSeparate.y, startSizeConstantMaxSeparate.y, rand.getFloat());
                            particleSize[2] = Laya.MathUtil.lerp(startSizeConstantMinSeparate.z, startSizeConstantMaxSeparate.z, rand.getFloat());
                            randomSeeds[4] = rand.seed;
                        }
                    }
                    else {
                        if (autoRandomSeed) {
                            particleSize[0] = particleSize[1] = particleSize[2] = Laya.MathUtil.lerp(particleSystem.startSizeConstantMin, particleSystem.startSizeConstantMax, Math.random());
                        }
                        else {
                            rand.seed = randomSeeds[4];
                            particleSize[0] = particleSize[1] = particleSize[2] = Laya.MathUtil.lerp(particleSystem.startSizeConstantMin, particleSystem.startSizeConstantMax, rand.getFloat());
                            randomSeeds[4] = rand.seed;
                        }
                    }
                    break;
            }
            var sizeOverLifetime = particleSystem.sizeOverLifetime;
            if (sizeOverLifetime && sizeOverLifetime.enable && sizeOverLifetime.size.type === 1) {
                var size = sizeOverLifetime.size;
                if (size.separateAxes) {
                    if (autoRandomSeed) {
                        particleSize[0] = particleSize[0] * Laya.MathUtil.lerp(size.constantMinSeparate.x, size.constantMaxSeparate.x, Math.random());
                        particleSize[1] = particleSize[1] * Laya.MathUtil.lerp(size.constantMinSeparate.y, size.constantMaxSeparate.y, Math.random());
                        particleSize[2] = particleSize[2] * Laya.MathUtil.lerp(size.constantMinSeparate.z, size.constantMaxSeparate.z, Math.random());
                    }
                    else {
                        rand.seed = randomSeeds[11];
                        particleSize[0] = particleSize[0] * Laya.MathUtil.lerp(size.constantMinSeparate.x, size.constantMaxSeparate.x, rand.getFloat());
                        particleSize[1] = particleSize[1] * Laya.MathUtil.lerp(size.constantMinSeparate.y, size.constantMaxSeparate.y, rand.getFloat());
                        particleSize[2] = particleSize[2] * Laya.MathUtil.lerp(size.constantMinSeparate.z, size.constantMaxSeparate.z, rand.getFloat());
                        randomSeeds[11] = rand.seed;
                    }
                }
                else {
                    var randomSize;
                    if (autoRandomSeed) {
                        randomSize = Laya.MathUtil.lerp(size.constantMin, size.constantMax, Math.random());
                    }
                    else {
                        rand.seed = randomSeeds[11];
                        randomSize = Laya.MathUtil.lerp(size.constantMin, size.constantMax, rand.getFloat());
                        randomSeeds[11] = rand.seed;
                    }
                    particleSize[0] = particleSize[0] * randomSize;
                    particleSize[1] = particleSize[1] * randomSize;
                    particleSize[2] = particleSize[2] * randomSize;
                }
            }
            var renderMode = particleRender.renderMode;
            if (renderMode !== 1) {
                switch (particleSystem.startRotationType) {
                    case 0:
                        if (particleSystem.threeDStartRotation) {
                            var startRotationConstantSeparate = particleSystem.startRotationConstantSeparate;
                            var randomRotationE = ShurikenParticleData._tempVector30;
                            ShurikenParticleData._randomInvertRoationArray(startRotationConstantSeparate, randomRotationE, particleSystem.randomizeRotationDirection, autoRandomSeed ? null : rand, randomSeeds);
                            ShurikenParticleData.startRotation[0] = randomRotationE.x;
                            ShurikenParticleData.startRotation[1] = randomRotationE.y;
                            if (renderMode !== 4)
                                ShurikenParticleData.startRotation[2] = -randomRotationE.z;
                            else
                                ShurikenParticleData.startRotation[2] = randomRotationE.z;
                        }
                        else {
                            ShurikenParticleData.startRotation[0] = ShurikenParticleData._randomInvertRoation(particleSystem.startRotationConstant, particleSystem.randomizeRotationDirection, autoRandomSeed ? null : rand, randomSeeds);
                            ShurikenParticleData.startRotation[1] = 0;
                            ShurikenParticleData.startRotation[2] = 0;
                        }
                        break;
                    case 2:
                        if (particleSystem.threeDStartRotation) {
                            var startRotationConstantMinSeparate = particleSystem.startRotationConstantMinSeparate;
                            var startRotationConstantMaxSeparate = particleSystem.startRotationConstantMaxSeparate;
                            var lerpRoationE = ShurikenParticleData._tempVector30;
                            if (autoRandomSeed) {
                                lerpRoationE.x = Laya.MathUtil.lerp(startRotationConstantMinSeparate.x, startRotationConstantMaxSeparate.x, Math.random());
                                lerpRoationE.y = Laya.MathUtil.lerp(startRotationConstantMinSeparate.y, startRotationConstantMaxSeparate.y, Math.random());
                                lerpRoationE.z = Laya.MathUtil.lerp(startRotationConstantMinSeparate.z, startRotationConstantMaxSeparate.z, Math.random());
                            }
                            else {
                                rand.seed = randomSeeds[5];
                                lerpRoationE.x = Laya.MathUtil.lerp(startRotationConstantMinSeparate.x, startRotationConstantMaxSeparate.x, rand.getFloat());
                                lerpRoationE.y = Laya.MathUtil.lerp(startRotationConstantMinSeparate.y, startRotationConstantMaxSeparate.y, rand.getFloat());
                                lerpRoationE.z = Laya.MathUtil.lerp(startRotationConstantMinSeparate.z, startRotationConstantMaxSeparate.z, rand.getFloat());
                                randomSeeds[5] = rand.seed;
                            }
                            ShurikenParticleData._randomInvertRoationArray(lerpRoationE, lerpRoationE, particleSystem.randomizeRotationDirection, autoRandomSeed ? null : rand, randomSeeds);
                            ShurikenParticleData.startRotation[0] = lerpRoationE.x;
                            ShurikenParticleData.startRotation[1] = lerpRoationE.y;
                            if (renderMode !== 4)
                                ShurikenParticleData.startRotation[2] = -lerpRoationE.z;
                            else
                                ShurikenParticleData.startRotation[2] = lerpRoationE.z;
                        }
                        else {
                            if (autoRandomSeed) {
                                ShurikenParticleData.startRotation[0] = ShurikenParticleData._randomInvertRoation(Laya.MathUtil.lerp(particleSystem.startRotationConstantMin, particleSystem.startRotationConstantMax, Math.random()), particleSystem.randomizeRotationDirection, autoRandomSeed ? null : rand, randomSeeds);
                            }
                            else {
                                rand.seed = randomSeeds[5];
                                ShurikenParticleData.startRotation[0] = ShurikenParticleData._randomInvertRoation(Laya.MathUtil.lerp(particleSystem.startRotationConstantMin, particleSystem.startRotationConstantMax, rand.getFloat()), particleSystem.randomizeRotationDirection, autoRandomSeed ? null : rand, randomSeeds);
                                randomSeeds[5] = rand.seed;
                            }
                        }
                        break;
                }
            }
            switch (particleSystem.startLifetimeType) {
                case 0:
                    ShurikenParticleData.startLifeTime = particleSystem.startLifetimeConstant;
                    break;
                case 1:
                    ShurikenParticleData.startLifeTime = ShurikenParticleData._getStartLifetimeFromGradient(particleSystem.startLifeTimeGradient, particleSystem.emissionTime);
                    break;
                case 2:
                    if (autoRandomSeed) {
                        ShurikenParticleData.startLifeTime = Laya.MathUtil.lerp(particleSystem.startLifetimeConstantMin, particleSystem.startLifetimeConstantMax, Math.random());
                    }
                    else {
                        rand.seed = randomSeeds[7];
                        ShurikenParticleData.startLifeTime = Laya.MathUtil.lerp(particleSystem.startLifetimeConstantMin, particleSystem.startLifetimeConstantMax, rand.getFloat());
                        randomSeeds[7] = rand.seed;
                    }
                    break;
                case 3:
                    var emissionTime = particleSystem.emissionTime;
                    if (autoRandomSeed) {
                        ShurikenParticleData.startLifeTime = Laya.MathUtil.lerp(ShurikenParticleData._getStartLifetimeFromGradient(particleSystem.startLifeTimeGradientMin, emissionTime), ShurikenParticleData._getStartLifetimeFromGradient(particleSystem.startLifeTimeGradientMax, emissionTime), Math.random());
                    }
                    else {
                        rand.seed = randomSeeds[7];
                        ShurikenParticleData.startLifeTime = Laya.MathUtil.lerp(ShurikenParticleData._getStartLifetimeFromGradient(particleSystem.startLifeTimeGradientMin, emissionTime), ShurikenParticleData._getStartLifetimeFromGradient(particleSystem.startLifeTimeGradientMax, emissionTime), rand.getFloat());
                        randomSeeds[7] = rand.seed;
                    }
                    break;
            }
            var textureSheetAnimation = particleSystem.textureSheetAnimation;
            var enableSheetAnimation = textureSheetAnimation && textureSheetAnimation.enable;
            if (enableSheetAnimation) {
                var title = textureSheetAnimation.tiles;
                var titleX = title.x, titleY = title.y;
                var subU = 1.0 / titleX, subV = 1.0 / titleY;
                var startFrameCount;
                var startFrame = textureSheetAnimation.startFrame;
                switch (startFrame.type) {
                    case 0:
                        startFrameCount = startFrame.constant;
                        break;
                    case 1:
                        if (autoRandomSeed) {
                            startFrameCount = Laya.MathUtil.lerp(startFrame.constantMin, startFrame.constantMax, Math.random());
                        }
                        else {
                            rand.seed = randomSeeds[14];
                            startFrameCount = Laya.MathUtil.lerp(startFrame.constantMin, startFrame.constantMax, rand.getFloat());
                            randomSeeds[14] = rand.seed;
                        }
                        break;
                }
                var frame = textureSheetAnimation.frame;
                var cycles = textureSheetAnimation.cycles;
                switch (frame.type) {
                    case 0:
                        startFrameCount += frame.constant * cycles;
                        break;
                    case 2:
                        if (autoRandomSeed) {
                            startFrameCount += Laya.MathUtil.lerp(frame.constantMin, frame.constantMax, Math.random()) * cycles;
                        }
                        else {
                            rand.seed = randomSeeds[15];
                            startFrameCount += Laya.MathUtil.lerp(frame.constantMin, frame.constantMax, rand.getFloat()) * cycles;
                            randomSeeds[15] = rand.seed;
                        }
                        break;
                }
                var startRow = 0;
                switch (textureSheetAnimation.type) {
                    case 0:
                        startRow = Math.floor(startFrameCount / titleX);
                        break;
                    case 1:
                        if (textureSheetAnimation.randomRow) {
                            if (autoRandomSeed) {
                                startRow = Math.floor(Math.random() * titleY);
                            }
                            else {
                                rand.seed = randomSeeds[13];
                                startRow = Math.floor(rand.getFloat() * titleY);
                                randomSeeds[13] = rand.seed;
                            }
                        }
                        else {
                            startRow = textureSheetAnimation.rowIndex;
                        }
                        break;
                }
                var startCol = Math.floor(startFrameCount % titleX);
                ShurikenParticleData.startUVInfo = ShurikenParticleData.startUVInfo;
                ShurikenParticleData.startUVInfo[0] = subU;
                ShurikenParticleData.startUVInfo[1] = subV;
                ShurikenParticleData.startUVInfo[2] = startCol * subU;
                ShurikenParticleData.startUVInfo[3] = startRow * subV;
            }
            else {
                ShurikenParticleData.startUVInfo = ShurikenParticleData.startUVInfo;
                ShurikenParticleData.startUVInfo[0] = 1.0;
                ShurikenParticleData.startUVInfo[1] = 1.0;
                ShurikenParticleData.startUVInfo[2] = 0.0;
                ShurikenParticleData.startUVInfo[3] = 0.0;
            }
        }
    }
    ShurikenParticleData._tempVector30 = new Laya.Vector3();
    ShurikenParticleData.startColor = new Laya.Vector4();
    ShurikenParticleData.startSize = new Float32Array(3);
    ShurikenParticleData.startRotation = new Float32Array(3);
    ShurikenParticleData.startUVInfo = new Float32Array(4);

    class ShurikenParticleSystem extends GeometryElement {
        constructor(render, meshTopology = Laya.MeshTopology.Triangles, drawType = Laya.DrawType.DrawElement) {
            super(meshTopology, drawType);
            this._bounds = null;
            this._gravityOffset = new Laya.Vector2();
            this._customBounds = null;
            this._useCustomBounds = false;
            this._owner = null;
            this._ownerRender = null;
            this._vertices = null;
            this._floatCountPerVertex = 0;
            this._startLifeTimeIndex = 0;
            this._timeIndex = 0;
            this._simulationUV_Index = 0;
            this._simulateUpdate = false;
            this._firstActiveElement = 0;
            this._firstNewElement = 0;
            this._firstFreeElement = 0;
            this._firstRetiredElement = 0;
            this._drawCounter = 0;
            this._bufferMaxParticles = 0;
            this._emission = null;
            this._shape = null;
            this._isEmitting = false;
            this._isPlaying = false;
            this._isPaused = false;
            this._playStartDelay = 0;
            this._frameRateTime = 0;
            this._emissionTime = 0;
            this._totalDelayTime = 0;
            this._emissionDistance = 0;
            this._emissionLastPosition = new Laya.Vector3();
            this._burstsIndex = 0;
            this._velocityOverLifetime = null;
            this._colorOverLifetime = null;
            this._sizeOverLifetime = null;
            this._rotationOverLifetime = null;
            this._textureSheetAnimation = null;
            this._startLifetimeType = 0;
            this._startLifetimeConstant = 0;
            this._startLifeTimeGradient = null;
            this._startLifetimeConstantMin = 0;
            this._startLifetimeConstantMax = 0;
            this._startLifeTimeGradientMin = null;
            this._startLifeTimeGradientMax = null;
            this._maxStartLifetime = 0;
            this._uvLength = new Laya.Vector2();
            this._vertexStride = 0;
            this._indexStride = 0;
            this._vertexBuffer = null;
            this._indexBuffer = null;
            this._bufferState = new Laya.BufferState();
            this._updateMask = 0;
            this._currentTime = 0;
            this._startUpdateLoopCount = 0;
            this._rand = null;
            this._randomSeeds = null;
            this.duration = 0;
            this.looping = false;
            this.prewarm = false;
            this.startDelayType = 0;
            this.startDelay = 0;
            this.startDelayMin = 0;
            this.startDelayMax = 0;
            this.startSpeedType = 0;
            this.startSpeedConstant = 0;
            this.startSpeedConstantMin = 0;
            this.startSpeedConstantMax = 0;
            this.dragType = 0;
            this.dragConstant = 0;
            this.dragSpeedConstantMin = 0;
            this.dragSpeedConstantMax = 0;
            this.threeDStartSize = false;
            this.startSizeType = 0;
            this.startSizeConstant = 0;
            this.startSizeConstantSeparate = null;
            this.startSizeConstantMin = 0;
            this.startSizeConstantMax = 0;
            this.startSizeConstantMinSeparate = null;
            this.startSizeConstantMaxSeparate = null;
            this.threeDStartRotation = false;
            this.startRotationType = 0;
            this.startRotationConstant = 0;
            this.startRotationConstantSeparate = null;
            this.startRotationConstantMin = 0;
            this.startRotationConstantMax = 0;
            this.startRotationConstantMinSeparate = null;
            this.startRotationConstantMaxSeparate = null;
            this.randomizeRotationDirection = 0;
            this.startColorType = 0;
            this.startColorConstant = new Laya.Vector4(1, 1, 1, 1);
            this.startColorConstantMin = new Laya.Vector4(0, 0, 0, 0);
            this.startColorConstantMax = new Laya.Vector4(1, 1, 1, 1);
            this.gravityModifier = 0;
            this.simulationSpace = 0;
            this.simulationSpeed = 1.0;
            this.scaleMode = 1;
            this.playOnAwake = false;
            this.randomSeed = null;
            this.autoRandomSeed = false;
            this.isPerformanceMode = false;
            this.indexFormat = Laya.IndexFormat.UInt16;
            this._firstActiveElement = 0;
            this._firstNewElement = 0;
            this._firstFreeElement = 0;
            this._firstRetiredElement = 0;
            this._owner = render.owner;
            this._ownerRender = render;
            this._useCustomBounds = false;
            this._currentTime = 0;
            this._bounds = new Bounds(new Laya.Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE), new Laya.Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE));
            this.bufferState = this._bufferState = new Laya.BufferState();
            this._isEmitting = false;
            this._isPlaying = false;
            this._isPaused = false;
            this._burstsIndex = 0;
            this._frameRateTime = 0;
            this._emissionTime = 0;
            this._totalDelayTime = 0;
            this._simulateUpdate = false;
            this._bufferMaxParticles = 1;
            this.duration = 5.0;
            this.looping = true;
            this.prewarm = false;
            this.startDelayType = 0;
            this.startDelay = 0.0;
            this.startDelayMin = 0.0;
            this.startDelayMax = 0.0;
            this._startLifetimeType = 0;
            this._startLifetimeConstant = 5.0;
            this._startLifeTimeGradient = new GradientDataNumber();
            this._startLifetimeConstantMin = 0.0;
            this._startLifetimeConstantMax = 5.0;
            this._startLifeTimeGradientMin = new GradientDataNumber();
            this._startLifeTimeGradientMax = new GradientDataNumber();
            this._maxStartLifetime = 5.0;
            this.startSpeedType = 0;
            this.startSpeedConstant = 5.0;
            this.startSpeedConstantMin = 0.0;
            this.startSpeedConstantMax = 5.0;
            this.dragType = 0;
            this.dragConstant = 0;
            this.dragSpeedConstantMin = 0;
            this.dragSpeedConstantMax = 0;
            this.threeDStartSize = false;
            this.startSizeType = 0;
            this.startSizeConstant = 1;
            this.startSizeConstantSeparate = new Laya.Vector3(1, 1, 1);
            this.startSizeConstantMin = 0;
            this.startSizeConstantMax = 1;
            this.startSizeConstantMinSeparate = new Laya.Vector3(0, 0, 0);
            this.startSizeConstantMaxSeparate = new Laya.Vector3(1, 1, 1);
            this.threeDStartRotation = false;
            this.startRotationType = 0;
            this.startRotationConstant = 0;
            this.startRotationConstantSeparate = new Laya.Vector3(0, 0, 0);
            this.startRotationConstantMin = 0.0;
            this.startRotationConstantMax = 0.0;
            this.startRotationConstantMinSeparate = new Laya.Vector3(0, 0, 0);
            this.startRotationConstantMaxSeparate = new Laya.Vector3(0, 0, 0);
            this.gravityModifier = 0.0;
            this.simulationSpace = 1;
            this.scaleMode = 1;
            this.playOnAwake = true;
            this._rand = new Rand(0);
            this.autoRandomSeed = true;
            this.randomSeed = new Uint32Array(1);
            this._randomSeeds = new Uint32Array(ShurikenParticleSystem._RANDOMOFFSET.length);
            this.isPerformanceMode = true;
            this._emission = new Emission();
            this._emission.enable = true;
        }
        get maxParticles() {
            return this._bufferMaxParticles - 1;
        }
        set maxParticles(value) {
            var newMaxParticles = value + 1;
            if (newMaxParticles !== this._bufferMaxParticles) {
                this._bufferMaxParticles = newMaxParticles;
                this._initBufferDatas();
            }
            this._updateParticlesSimulationRestart(0);
        }
        get emission() {
            return this._emission;
        }
        get aliveParticleCount() {
            if (this._firstNewElement >= this._firstRetiredElement)
                return this._firstNewElement - this._firstRetiredElement;
            else
                return this._bufferMaxParticles - this._firstRetiredElement + this._firstNewElement;
        }
        get emissionTime() {
            return this._emissionTime > this.duration ? this.duration : this._emissionTime;
        }
        get shape() {
            return this._shape;
        }
        set shape(value) {
            if (this._shape !== value) {
                if (value && value.enable)
                    this._ownerRender._shaderValues.addDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_SHAPE);
                else
                    this._ownerRender._shaderValues.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_SHAPE);
                this._shape = value;
            }
        }
        get isAlive() {
            if (this._isPlaying || this.aliveParticleCount > 0)
                return true;
            return false;
        }
        get isEmitting() {
            return this._isEmitting;
        }
        get isPlaying() {
            return this._isPlaying;
        }
        get isPaused() {
            return this._isPaused;
        }
        get startLifetimeType() {
            return this._startLifetimeType;
        }
        set startLifetimeType(value) {
            var i, n;
            switch (this.startLifetimeType) {
                case 0:
                    this._maxStartLifetime = this.startLifetimeConstant;
                    break;
                case 1:
                    this._maxStartLifetime = -Number.MAX_VALUE;
                    var startLifeTimeGradient = startLifeTimeGradient;
                    for (i = 0, n = startLifeTimeGradient.gradientCount; i < n; i++)
                        this._maxStartLifetime = Math.max(this._maxStartLifetime, startLifeTimeGradient.getValueByIndex(i));
                    break;
                case 2:
                    this._maxStartLifetime = Math.max(this.startLifetimeConstantMin, this.startLifetimeConstantMax);
                    break;
                case 3:
                    this._maxStartLifetime = -Number.MAX_VALUE;
                    var startLifeTimeGradientMin = startLifeTimeGradientMin;
                    for (i = 0, n = startLifeTimeGradientMin.gradientCount; i < n; i++)
                        this._maxStartLifetime = Math.max(this._maxStartLifetime, startLifeTimeGradientMin.getValueByIndex(i));
                    var startLifeTimeGradientMax = startLifeTimeGradientMax;
                    for (i = 0, n = startLifeTimeGradientMax.gradientCount; i < n; i++)
                        this._maxStartLifetime = Math.max(this._maxStartLifetime, startLifeTimeGradientMax.getValueByIndex(i));
                    break;
            }
            this._startLifetimeType = value;
        }
        get startLifetimeConstant() {
            return this._startLifetimeConstant;
        }
        set startLifetimeConstant(value) {
            if (this._startLifetimeType === 0)
                this._maxStartLifetime = value;
            this._startLifetimeConstant = value;
        }
        get startLifeTimeGradient() {
            return this._startLifeTimeGradient;
        }
        set startLifeTimeGradient(value) {
            if (this._startLifetimeType === 1) {
                this._maxStartLifetime = -Number.MAX_VALUE;
                for (var i = 0, n = value.gradientCount; i < n; i++)
                    this._maxStartLifetime = Math.max(this._maxStartLifetime, value.getValueByIndex(i));
            }
            this._startLifeTimeGradient = value;
        }
        get startLifetimeConstantMin() {
            return this._startLifetimeConstantMin;
        }
        set startLifetimeConstantMin(value) {
            if (this._startLifetimeType === 2)
                this._maxStartLifetime = Math.max(value, this._startLifetimeConstantMax);
            this._startLifetimeConstantMin = value;
        }
        get startLifetimeConstantMax() {
            return this._startLifetimeConstantMax;
        }
        set startLifetimeConstantMax(value) {
            if (this._startLifetimeType === 2)
                this._maxStartLifetime = Math.max(this._startLifetimeConstantMin, value);
            this._startLifetimeConstantMax = value;
        }
        get startLifeTimeGradientMin() {
            return this._startLifeTimeGradientMin;
        }
        set startLifeTimeGradientMin(value) {
            if (this._startLifetimeType === 3) {
                var i, n;
                this._maxStartLifetime = -Number.MAX_VALUE;
                for (i = 0, n = value.gradientCount; i < n; i++)
                    this._maxStartLifetime = Math.max(this._maxStartLifetime, value.getValueByIndex(i));
                for (i = 0, n = this._startLifeTimeGradientMax.gradientCount; i < n; i++)
                    this._maxStartLifetime = Math.max(this._maxStartLifetime, this._startLifeTimeGradientMax.getValueByIndex(i));
            }
            this._startLifeTimeGradientMin = value;
        }
        get startLifeTimeGradientMax() {
            return this._startLifeTimeGradientMax;
        }
        set startLifeTimeGradientMax(value) {
            if (this._startLifetimeType === 3) {
                var i, n;
                this._maxStartLifetime = -Number.MAX_VALUE;
                for (i = 0, n = this._startLifeTimeGradientMin.gradientCount; i < n; i++)
                    this._maxStartLifetime = Math.max(this._maxStartLifetime, this._startLifeTimeGradientMin.getValueByIndex(i));
                for (i = 0, n = value.gradientCount; i < n; i++)
                    this._maxStartLifetime = Math.max(this._maxStartLifetime, value.getValueByIndex(i));
            }
            this._startLifeTimeGradientMax = value;
        }
        get velocityOverLifetime() {
            return this._velocityOverLifetime;
        }
        set velocityOverLifetime(value) {
            var shaDat = this._ownerRender._shaderValues;
            if (value) {
                var velocity = value.velocity;
                var velocityType = velocity.type;
                if (value.enable) {
                    switch (velocityType) {
                        case 0:
                            shaDat.addDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_VELOCITYOVERLIFETIMECONSTANT);
                            break;
                        case 1:
                            shaDat.addDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_VELOCITYOVERLIFETIMECURVE);
                            break;
                        case 2:
                            shaDat.addDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCONSTANT);
                            break;
                        case 3:
                            shaDat.addDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCURVE);
                            break;
                    }
                }
                else {
                    shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_VELOCITYOVERLIFETIMECONSTANT);
                    shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_VELOCITYOVERLIFETIMECURVE);
                    shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCONSTANT);
                    shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCURVE);
                }
                switch (velocityType) {
                    case 0:
                        shaDat.setVector3(ShuriKenParticle3DShaderDeclaration.VOLVELOCITYCONST, velocity.constant);
                        break;
                    case 1:
                        shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.VOLVELOCITYGRADIENTX, velocity.gradientX._elements);
                        shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.VOLVELOCITYGRADIENTY, velocity.gradientY._elements);
                        shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.VOLVELOCITYGRADIENTZ, velocity.gradientZ._elements);
                        break;
                    case 2:
                        shaDat.setVector3(ShuriKenParticle3DShaderDeclaration.VOLVELOCITYCONST, velocity.constantMin);
                        shaDat.setVector3(ShuriKenParticle3DShaderDeclaration.VOLVELOCITYCONSTMAX, velocity.constantMax);
                        break;
                    case 3:
                        shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.VOLVELOCITYGRADIENTX, velocity.gradientXMin._elements);
                        shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.VOLVELOCITYGRADIENTXMAX, velocity.gradientXMax._elements);
                        shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.VOLVELOCITYGRADIENTY, velocity.gradientYMin._elements);
                        shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.VOLVELOCITYGRADIENTYMAX, velocity.gradientYMax._elements);
                        shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.VOLVELOCITYGRADIENTZ, velocity.gradientZMin._elements);
                        shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.VOLVELOCITYGRADIENTZMAX, velocity.gradientZMax._elements);
                        break;
                }
                shaDat.setInt(ShuriKenParticle3DShaderDeclaration.VOLSPACETYPE, value.space);
            }
            else {
                shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_VELOCITYOVERLIFETIMECONSTANT);
                shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_VELOCITYOVERLIFETIMECURVE);
                shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCONSTANT);
                shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCURVE);
            }
            this._velocityOverLifetime = value;
        }
        get colorOverLifetime() {
            return this._colorOverLifetime;
        }
        set colorOverLifetime(value) {
            var shaDat = this._ownerRender._shaderValues;
            if (value) {
                var color = value.color;
                if (value.enable) {
                    switch (color.type) {
                        case 1:
                            shaDat.addDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_COLOROVERLIFETIME);
                            shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_RANDOMCOLOROVERLIFETIME);
                            break;
                        case 3:
                            shaDat.addDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_RANDOMCOLOROVERLIFETIME);
                            shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_COLOROVERLIFETIME);
                            break;
                    }
                }
                else {
                    shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_COLOROVERLIFETIME);
                    shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_RANDOMCOLOROVERLIFETIME);
                }
                switch (color.type) {
                    case 1:
                        var gradientColor = color.gradient;
                        shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.COLOROVERLIFEGRADIENTALPHAS, gradientColor._alphaElements);
                        shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.COLOROVERLIFEGRADIENTCOLORS, gradientColor._rgbElements);
                        let ranges = gradientColor._keyRanges;
                        ranges.setValue(1, 0, 1, 0);
                        for (let index = 0; index < gradientColor.colorRGBKeysCount; index++) {
                            let colorKey = gradientColor._rgbElements[index * 4];
                            ranges.x = Math.min(ranges.x, colorKey);
                            ranges.y = Math.max(ranges.y, colorKey);
                        }
                        for (let index = 0; index < gradientColor.colorAlphaKeysCount; index++) {
                            let alphaKey = gradientColor._alphaElements[index * 2];
                            ranges.z = Math.min(ranges.z, alphaKey);
                            ranges.w = Math.max(ranges.w, alphaKey);
                        }
                        shaDat.setVector(ShuriKenParticle3DShaderDeclaration.COLOROVERLIFEGRADIENTRANGES, ranges);
                        if (gradientColor.maxColorAlphaKeysCount == 8) {
                            shaDat.addDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_COLORKEYCOUNT_8);
                        }
                        else {
                            shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_COLORKEYCOUNT_8);
                        }
                        break;
                    case 3:
                        var minGradientColor = color.gradientMin;
                        var maxGradientColor = color.gradientMax;
                        shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.COLOROVERLIFEGRADIENTALPHAS, minGradientColor._alphaElements);
                        shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.COLOROVERLIFEGRADIENTCOLORS, minGradientColor._rgbElements);
                        shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.MAXCOLOROVERLIFEGRADIENTALPHAS, maxGradientColor._alphaElements);
                        shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.MAXCOLOROVERLIFEGRADIENTCOLORS, maxGradientColor._rgbElements);
                        let minRanges = minGradientColor._keyRanges;
                        minRanges.setValue(1, 0, 1, 0);
                        for (let index = 0; index < minGradientColor.colorRGBKeysCount; index++) {
                            let colorKey = minGradientColor._rgbElements[index * 4];
                            minRanges.x = Math.min(minRanges.x, colorKey);
                            minRanges.y = Math.max(minRanges.y, colorKey);
                        }
                        for (let index = 0; index < minGradientColor.colorAlphaKeysCount; index++) {
                            let alphaKey = minGradientColor._alphaElements[index * 2];
                            minRanges.z = Math.min(minRanges.z, alphaKey);
                            minRanges.w = Math.max(minRanges.w, alphaKey);
                        }
                        shaDat.setVector(ShuriKenParticle3DShaderDeclaration.COLOROVERLIFEGRADIENTRANGES, minRanges);
                        let maxRanges = maxGradientColor._keyRanges;
                        maxRanges.setValue(1, 0, 1, 0);
                        for (let index = 0; index < maxGradientColor.colorRGBKeysCount; index++) {
                            let colorKey = maxGradientColor._rgbElements[index * 4];
                            maxRanges.x = Math.min(maxRanges.x, colorKey);
                            maxRanges.y = Math.max(maxRanges.y, colorKey);
                        }
                        for (let index = 0; index < maxGradientColor.colorAlphaKeysCount; index++) {
                            let alphaKey = maxGradientColor._alphaElements[index * 2];
                            maxRanges.z = Math.min(maxRanges.z, alphaKey);
                            maxRanges.w = Math.max(maxRanges.w, alphaKey);
                        }
                        shaDat.setVector(ShuriKenParticle3DShaderDeclaration.MAXCOLOROVERLIFEGRADIENTRANGES, maxRanges);
                        let maxkeyCount = Math.max(minGradientColor.maxColorAlphaKeysCount, maxGradientColor.maxColorAlphaKeysCount);
                        if (maxkeyCount == 8) {
                            shaDat.addDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_COLORKEYCOUNT_8);
                        }
                        else {
                            shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_COLORKEYCOUNT_8);
                        }
                        break;
                }
            }
            else {
                shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_COLOROVERLIFETIME);
                shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_RANDOMCOLOROVERLIFETIME);
                shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.COLOROVERLIFEGRADIENTALPHAS, gradientColor._alphaElements);
                shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.COLOROVERLIFEGRADIENTCOLORS, gradientColor._rgbElements);
                shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.COLOROVERLIFEGRADIENTALPHAS, minGradientColor._alphaElements);
                shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.COLOROVERLIFEGRADIENTCOLORS, minGradientColor._rgbElements);
                shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.MAXCOLOROVERLIFEGRADIENTALPHAS, maxGradientColor._alphaElements);
                shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.MAXCOLOROVERLIFEGRADIENTCOLORS, maxGradientColor._rgbElements);
            }
            this._colorOverLifetime = value;
        }
        get sizeOverLifetime() {
            return this._sizeOverLifetime;
        }
        set sizeOverLifetime(value) {
            var shaDat = this._ownerRender._shaderValues;
            if (value) {
                var size = value.size;
                var sizeSeparate = size.separateAxes;
                var sizeType = size.type;
                if (value.enable) {
                    switch (sizeType) {
                        case 0:
                            if (sizeSeparate)
                                shaDat.addDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_SIZEOVERLIFETIMECURVESEPERATE);
                            else
                                shaDat.addDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_SIZEOVERLIFETIMECURVE);
                            break;
                        case 2:
                            if (sizeSeparate)
                                shaDat.addDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVESSEPERATE);
                            else
                                shaDat.addDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVES);
                            break;
                    }
                }
                else {
                    shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_SIZEOVERLIFETIMECURVE);
                    shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_SIZEOVERLIFETIMECURVESEPERATE);
                    shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVES);
                    shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVESSEPERATE);
                }
                switch (sizeType) {
                    case 0:
                        if (sizeSeparate) {
                            shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.SOLSIZEGRADIENTX, size.gradientX._elements);
                            shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.SOLSIZEGRADIENTY, size.gradientY._elements);
                            shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.SOLSizeGradientZ, size.gradientZ._elements);
                        }
                        else {
                            shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.SOLSIZEGRADIENT, size.gradient._elements);
                        }
                        break;
                    case 2:
                        if (sizeSeparate) {
                            shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.SOLSIZEGRADIENTX, size.gradientXMin._elements);
                            shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.SOLSIZEGRADIENTXMAX, size.gradientXMax._elements);
                            shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.SOLSIZEGRADIENTY, size.gradientYMin._elements);
                            shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.SOLSIZEGRADIENTYMAX, size.gradientYMax._elements);
                            shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.SOLSizeGradientZ, size.gradientZMin._elements);
                            shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.SOLSizeGradientZMAX, size.gradientZMax._elements);
                        }
                        else {
                            shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.SOLSIZEGRADIENT, size.gradientMin._elements);
                            shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.SOLSizeGradientMax, size.gradientMax._elements);
                        }
                        break;
                }
            }
            else {
                shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_SIZEOVERLIFETIMECURVE);
                shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_SIZEOVERLIFETIMECURVESEPERATE);
                shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVES);
                shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVESSEPERATE);
            }
            this._sizeOverLifetime = value;
        }
        get rotationOverLifetime() {
            return this._rotationOverLifetime;
        }
        set rotationOverLifetime(value) {
            var shaDat = this._ownerRender._shaderValues;
            if (value) {
                var rotation = value.angularVelocity;
                if (!rotation)
                    return;
                var rotationSeparate = rotation.separateAxes;
                var rotationType = rotation.type;
                if (value.enable) {
                    if (rotationSeparate) {
                        shaDat.addDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_ROTATIONOVERLIFETIMESEPERATE);
                        shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_ROTATIONOVERLIFETIME);
                    }
                    else {
                        shaDat.addDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_ROTATIONOVERLIFETIME);
                        shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_ROTATIONOVERLIFETIMESEPERATE);
                    }
                    switch (rotationType) {
                        case 0:
                            shaDat.addDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_ROTATIONOVERLIFETIMECONSTANT);
                            shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_ROTATIONOVERLIFETIMECURVE);
                            shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCONSTANTS);
                            shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCURVES);
                            break;
                        case 1:
                            shaDat.addDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_ROTATIONOVERLIFETIMECURVE);
                            shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_ROTATIONOVERLIFETIMECONSTANT);
                            shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCONSTANTS);
                            shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCURVES);
                            break;
                        case 2:
                            shaDat.addDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCONSTANTS);
                            shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_ROTATIONOVERLIFETIMECONSTANT);
                            shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_ROTATIONOVERLIFETIMECURVE);
                            shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCURVES);
                            break;
                        case 3:
                            shaDat.addDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCURVES);
                            shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCONSTANTS);
                            shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_ROTATIONOVERLIFETIMECONSTANT);
                            shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_ROTATIONOVERLIFETIMECURVE);
                            break;
                    }
                }
                else {
                    shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_ROTATIONOVERLIFETIME);
                    shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_ROTATIONOVERLIFETIMESEPERATE);
                    shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_ROTATIONOVERLIFETIMECONSTANT);
                    shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_ROTATIONOVERLIFETIMECURVE);
                    shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCONSTANTS);
                    shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCURVES);
                }
                switch (rotationType) {
                    case 0:
                        if (rotationSeparate) {
                            shaDat.setVector3(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYCONSTSEPRARATE, rotation.constantSeparate);
                        }
                        else {
                            shaDat.setNumber(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYCONST, rotation.constant);
                        }
                        break;
                    case 1:
                        if (rotationSeparate) {
                            shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENTX, rotation.gradientX._elements);
                            shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENTY, rotation.gradientY._elements);
                            shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENTZ, rotation.gradientZ._elements);
                        }
                        else {
                            shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENT, rotation.gradient._elements);
                        }
                        break;
                    case 2:
                        if (rotationSeparate) {
                            shaDat.setVector3(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYCONSTSEPRARATE, rotation.constantMinSeparate);
                            shaDat.setVector3(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYCONSTMAXSEPRARATE, rotation.constantMaxSeparate);
                        }
                        else {
                            shaDat.setNumber(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYCONST, rotation.constantMin);
                            shaDat.setNumber(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYCONSTMAX, rotation.constantMax);
                        }
                        break;
                    case 3:
                        if (rotationSeparate) {
                            shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENTX, rotation.gradientXMin._elements);
                            shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENTXMAX, rotation.gradientXMax._elements);
                            shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENTY, rotation.gradientYMin._elements);
                            shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENTYMAX, rotation.gradientYMax._elements);
                            shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENTZ, rotation.gradientZMin._elements);
                            shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENTZMAX, rotation.gradientZMax._elements);
                        }
                        else {
                            shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENT, rotation.gradientMin._elements);
                            shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.ROLANGULARVELOCITYGRADIENTMAX, rotation.gradientMax._elements);
                        }
                        break;
                }
            }
            else {
                shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_ROTATIONOVERLIFETIME);
                shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_ROTATIONOVERLIFETIMESEPERATE);
                shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_ROTATIONOVERLIFETIMECONSTANT);
                shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_ROTATIONOVERLIFETIMECURVE);
                shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCONSTANTS);
                shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCURVES);
            }
            this._rotationOverLifetime = value;
        }
        get textureSheetAnimation() {
            return this._textureSheetAnimation;
        }
        set textureSheetAnimation(value) {
            var shaDat = this._ownerRender._shaderValues;
            if (value) {
                var frameOverTime = value.frame;
                var textureAniType = frameOverTime.type;
                if (value.enable) {
                    switch (textureAniType) {
                        case 1:
                            shaDat.addDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_TEXTURESHEETANIMATIONCURVE);
                            shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_TEXTURESHEETANIMATIONRANDOMCURVE);
                            break;
                        case 3:
                            shaDat.addDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_TEXTURESHEETANIMATIONRANDOMCURVE);
                            shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_TEXTURESHEETANIMATIONCURVE);
                            break;
                    }
                }
                else {
                    shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_TEXTURESHEETANIMATIONCURVE);
                    shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_TEXTURESHEETANIMATIONRANDOMCURVE);
                }
                if (textureAniType === 1 || textureAniType === 3) {
                    shaDat.setNumber(ShuriKenParticle3DShaderDeclaration.TEXTURESHEETANIMATIONCYCLES, value.cycles);
                    var title = value.tiles;
                    var _uvLengthE = this._uvLength;
                    _uvLengthE.x = 1.0 / title.x;
                    _uvLengthE.y = 1.0 / title.y;
                    shaDat.setVector2(ShuriKenParticle3DShaderDeclaration.TEXTURESHEETANIMATIONSUBUVLENGTH, this._uvLength);
                }
                switch (textureAniType) {
                    case 1:
                        shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.TEXTURESHEETANIMATIONGRADIENTUVS, frameOverTime.frameOverTimeData._elements);
                        break;
                    case 3:
                        shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.TEXTURESHEETANIMATIONGRADIENTUVS, frameOverTime.frameOverTimeDataMin._elements);
                        shaDat.setBuffer(ShuriKenParticle3DShaderDeclaration.TEXTURESHEETANIMATIONGRADIENTMAXUVS, frameOverTime.frameOverTimeDataMax._elements);
                        break;
                }
            }
            else {
                shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_TEXTURESHEETANIMATIONCURVE);
                shaDat.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_TEXTURESHEETANIMATIONRANDOMCURVE);
            }
            this._textureSheetAnimation = value;
        }
        _getVertexBuffer(index = 0) {
            if (index === 0)
                return this._vertexBuffer;
            else
                return null;
        }
        _getIndexBuffer() {
            return this._indexBuffer;
        }
        _generateBounds() {
            var particleRender = this._ownerRender;
            var boundsMin = this._bounds.getMin();
            var boundsMax = this._bounds.getMax();
            var time = 0;
            switch (this.startLifetimeType) {
                case 0:
                    time = this._startLifetimeConstant;
                    break;
                case 2:
                    time = this._startLifetimeConstantMax;
                    break;
            }
            var speedOrigan = 0;
            switch (this.startSpeedType) {
                case 0:
                    speedOrigan = this.startSpeedConstant;
                    break;
                case 2:
                    speedOrigan = this.startSpeedConstantMax;
                    break;
            }
            var maxSizeScale = 0;
            if (this.threeDStartSize) {
                switch (this.startSizeType) {
                    case 0:
                        maxSizeScale = Math.max(this.startSizeConstantSeparate.x, this.startSizeConstantSeparate.y, this.startSizeConstantSeparate.z);
                        break;
                    case 2:
                        maxSizeScale = Math.max(this.startSizeConstantMaxSeparate.x, this.startSizeConstantMaxSeparate.y, this.startSizeConstantMaxSeparate.z);
                        break;
                }
            }
            else {
                switch (this.startSizeType) {
                    case 0:
                        maxSizeScale = this.startSizeConstant;
                        break;
                    case 2:
                        maxSizeScale = this.startSizeConstantMax;
                        break;
                }
            }
            var zDirectionSpeed = ShurikenParticleSystem._tempVector30;
            var fDirectionSpeed = ShurikenParticleSystem._tempVector31;
            var zEmisionOffsetXYZ = ShurikenParticleSystem._tempVector32;
            var fEmisionOffsetXYZ = ShurikenParticleSystem._tempVector33;
            zDirectionSpeed.setValue(0, 0, 1);
            fDirectionSpeed.setValue(0, 0, 0);
            zEmisionOffsetXYZ.setValue(0, 0, 0);
            fEmisionOffsetXYZ.setValue(0, 0, 0);
            if (this.shape && this.shape.enable) {
                switch (this.shape.shapeType) {
                    case exports.ParticleSystemShapeType.Sphere:
                        var sphere = this.shape;
                        zDirectionSpeed.setValue(1, 1, 1);
                        fDirectionSpeed.setValue(1, 1, 1);
                        zEmisionOffsetXYZ.setValue(sphere.radius, sphere.radius, sphere.radius);
                        fEmisionOffsetXYZ.setValue(sphere.radius, sphere.radius, sphere.radius);
                        break;
                    case exports.ParticleSystemShapeType.Hemisphere:
                        var hemiShpere = this.shape;
                        zDirectionSpeed.setValue(1, 1, 1);
                        fDirectionSpeed.setValue(1, 1, 1);
                        zEmisionOffsetXYZ.setValue(hemiShpere.radius, hemiShpere.radius, hemiShpere.radius);
                        fEmisionOffsetXYZ.setValue(hemiShpere.radius, hemiShpere.radius, 0.0);
                        break;
                    case exports.ParticleSystemShapeType.Cone:
                        var cone = this.shape;
                        if (cone.emitType == 0 || cone.emitType == 1) {
                            var angle = cone.angle;
                            var sinAngle = Math.sin(angle);
                            zDirectionSpeed.setValue(sinAngle, sinAngle, 1.0);
                            fDirectionSpeed.setValue(sinAngle, sinAngle, 0.0);
                            zEmisionOffsetXYZ.setValue(cone.radius, cone.radius, 0.0);
                            fEmisionOffsetXYZ.setValue(cone.radius, cone.radius, 0.0);
                            break;
                        }
                        else if (cone.emitType == 2 || cone.emitType == 3) {
                            var angle = cone.angle;
                            var sinAngle = Math.sin(angle);
                            var coneLength = cone.length;
                            zDirectionSpeed.setValue(sinAngle, sinAngle, 1.0);
                            fDirectionSpeed.setValue(sinAngle, sinAngle, 0.0);
                            var tanAngle = Math.tan(angle);
                            var rPLCT = cone.radius + coneLength * tanAngle;
                            zEmisionOffsetXYZ.setValue(rPLCT, rPLCT, coneLength);
                            fEmisionOffsetXYZ.setValue(rPLCT, rPLCT, 0.0);
                        }
                        break;
                    case exports.ParticleSystemShapeType.Box:
                        var box = this.shape;
                        if (this.shape.randomDirection != 0) {
                            zDirectionSpeed.setValue(1, 1, 1);
                            fDirectionSpeed.setValue(1, 1, 1);
                        }
                        zEmisionOffsetXYZ.setValue(box.x / 2, box.y / 2, box.z / 2);
                        fEmisionOffsetXYZ.setValue(box.x / 2, box.y / 2, box.z / 2);
                        break;
                    case exports.ParticleSystemShapeType.Circle:
                        var circle = this.shape;
                        zDirectionSpeed.setValue(1, 1, 1);
                        fDirectionSpeed.setValue(1, 1, 1);
                        zEmisionOffsetXYZ.setValue(circle.radius, circle.radius, 0);
                        fEmisionOffsetXYZ.setValue(circle.radius, circle.radius, 0);
                        break;
                }
            }
            var meshSize = 0;
            var meshMode = particleRender.renderMode == 4;
            switch (particleRender.renderMode) {
                case 0:
                case 1:
                case 2:
                case 3:
                    meshSize = ShurikenParticleSystem.halfKSqrtOf2;
                    break;
                case 4:
                    var meshBounds = particleRender.mesh.bounds;
                    meshSize = Math.sqrt(Math.pow(meshBounds.getExtent().x, 2.0) + Math.pow(meshBounds.getExtent().y, 2.0) + Math.pow(meshBounds.getExtent().z, 2.0));
                    break;
            }
            var endSizeOffset = ShurikenParticleSystem._tempVector36;
            endSizeOffset.setValue(1, 1, 1);
            if (this.sizeOverLifetime && this.sizeOverLifetime.enable) {
                var gradientSize = this.sizeOverLifetime.size;
                var maxSize = gradientSize.getMaxSizeInGradient(meshMode);
                endSizeOffset.setValue(maxSize, maxSize, maxSize);
            }
            var offsetSize = meshSize * maxSizeScale;
            Laya.Vector3.scale(endSizeOffset, offsetSize, endSizeOffset);
            var speedZOffset = ShurikenParticleSystem._tempVector34;
            var speedFOffset = ShurikenParticleSystem._tempVector35;
            if (speedOrigan > 0) {
                Laya.Vector3.scale(zDirectionSpeed, speedOrigan, speedZOffset);
                Laya.Vector3.scale(fDirectionSpeed, speedOrigan, speedFOffset);
            }
            else {
                Laya.Vector3.scale(zDirectionSpeed, -speedOrigan, speedFOffset);
                Laya.Vector3.scale(fDirectionSpeed, -speedOrigan, speedZOffset);
            }
            if (this.velocityOverLifetime && this.velocityOverLifetime.enable) {
                var gradientVelocity = this.velocityOverLifetime.velocity;
                var velocitySpeedOffset = ShurikenParticleSystem._tempVector37;
                velocitySpeedOffset.setValue(0, 0, 0);
                switch (gradientVelocity.type) {
                    case 0:
                        gradientVelocity.constant.cloneTo(velocitySpeedOffset);
                        break;
                    case 2:
                        gradientVelocity.constantMax.cloneTo(velocitySpeedOffset);
                        break;
                    case 1:
                        var curveX = gradientVelocity.gradientX.getAverageValue();
                        var curveY = gradientVelocity.gradientY.getAverageValue();
                        var curveZ = gradientVelocity.gradientZ.getAverageValue();
                        velocitySpeedOffset.setValue(curveX, curveY, curveZ);
                        break;
                    case 3:
                        var xMax = gradientVelocity.gradientXMax.getAverageValue();
                        var yMax = gradientVelocity.gradientYMax.getAverageValue();
                        var zMax = gradientVelocity.gradientZMax.getAverageValue();
                        velocitySpeedOffset.setValue(xMax, yMax, zMax);
                        break;
                }
                if (this.velocityOverLifetime.space == 1) {
                    Laya.Vector3.transformV3ToV3(velocitySpeedOffset, this._owner.transform.worldMatrix, velocitySpeedOffset);
                }
                Laya.Vector3.add(speedZOffset, velocitySpeedOffset, speedZOffset);
                Laya.Vector3.subtract(speedFOffset, velocitySpeedOffset, speedFOffset);
                Laya.Vector3.max(speedZOffset, Laya.Vector3.ZERO, speedZOffset);
                Laya.Vector3.max(speedFOffset, Laya.Vector3.ZERO, speedFOffset);
            }
            Laya.Vector3.scale(speedZOffset, time, speedZOffset);
            Laya.Vector3.scale(speedFOffset, time, speedFOffset);
            var gravity = this.gravityModifier;
            if (gravity != 0) {
                var gravityOffset = 0.5 * ShurikenParticleSystem.g * gravity * time * time;
                var speedZOffsetY = speedZOffset.y - gravityOffset;
                var speedFOffsetY = speedFOffset.y + gravityOffset;
                speedZOffsetY = speedZOffsetY > 0 ? speedZOffsetY : 0;
                speedFOffsetY = speedFOffsetY > 0 ? speedFOffsetY : 0;
                this._gravityOffset.setValue(speedZOffset.y - speedZOffsetY, speedFOffsetY - speedFOffset.y);
            }
            Laya.Vector3.add(speedZOffset, endSizeOffset, boundsMax);
            Laya.Vector3.add(boundsMax, zEmisionOffsetXYZ, boundsMax);
            Laya.Vector3.add(speedFOffset, endSizeOffset, boundsMin);
            Laya.Vector3.add(boundsMin, fEmisionOffsetXYZ, boundsMin);
            Laya.Vector3.scale(boundsMin, -1, boundsMin);
            this._bounds.setMin(boundsMin);
            this._bounds.setMax(boundsMax);
        }
        get customBounds() {
            return this._customBounds;
        }
        set customBounds(value) {
            if (value) {
                this._useCustomBounds = true;
                if (!this._customBounds) {
                    this._customBounds = new Bounds(new Laya.Vector3(), new Laya.Vector3());
                    this._ownerRender.geometryBounds = this._customBounds;
                }
                this._customBounds = value;
            }
            else {
                this._useCustomBounds = false;
                this._customBounds = null;
                this._ownerRender.geometryBounds = null;
            }
        }
        _simulationSupported() {
            if (this.simulationSpace == 0 && this.emission.emissionRateOverDistance > 0) {
                return false;
            }
            return true;
        }
        _updateEmission() {
            if (!this.isAlive)
                return;
            if (this._simulateUpdate) {
                this._simulateUpdate = false;
            }
            else {
                var elapsedTime = ((this._startUpdateLoopCount !== Laya.Stat.loopCount && !this._isPaused) && this._owner._scene) ? this._owner._scene.timer._delta / 1000.0 : 0;
                elapsedTime = Math.min(ShurikenParticleSystem._maxElapsedTime, elapsedTime * this.simulationSpeed);
                this._updateParticles(elapsedTime);
            }
        }
        _updateParticles(elapsedTime) {
            if (this._ownerRender.renderMode === 4 && !this._ownerRender.mesh)
                return;
            this._currentTime += elapsedTime;
            this._retireActiveParticles();
            this._freeRetiredParticles();
            this._totalDelayTime += elapsedTime;
            if (this._totalDelayTime < this._playStartDelay) {
                return;
            }
            if (this._emission.enable && this._isEmitting && !this._isPaused) {
                this._advanceTime(elapsedTime, this._currentTime);
                if (this.emission.emissionRateOverDistance > 0) {
                    this._advanceDistance(this._currentTime);
                }
            }
        }
        _updateParticlesSimulationRestart(time) {
            this._firstActiveElement = 0;
            this._firstNewElement = 0;
            this._firstFreeElement = 0;
            this._firstRetiredElement = 0;
            this._burstsIndex = 0;
            this._frameRateTime = time;
            this._emissionTime = 0;
            this._emissionDistance = 0;
            this._totalDelayTime = 0;
            this._currentTime = time;
            var delayTime = time;
            if (delayTime < this._playStartDelay) {
                this._totalDelayTime = delayTime;
                return;
            }
            if (this._emission.enable) {
                this._advanceTime(time, time);
                if (this.emission.emissionRateOverDistance > 0) {
                    this._advanceDistance(this._currentTime);
                }
            }
        }
        _retireActiveParticles() {
            const epsilon = 0.0001;
            while (this._firstActiveElement != this._firstNewElement) {
                var index = this._firstActiveElement * this._floatCountPerVertex * this._vertexStride;
                var timeIndex = index + this._timeIndex;
                var particleAge = this._currentTime - this._vertices[timeIndex];
                if (particleAge + epsilon < this._vertices[index + this._startLifeTimeIndex])
                    break;
                this._vertices[timeIndex] = this._drawCounter;
                this._firstActiveElement++;
                if (this._firstActiveElement >= this._bufferMaxParticles)
                    this._firstActiveElement = 0;
            }
        }
        _freeRetiredParticles() {
            while (this._firstRetiredElement != this._firstActiveElement) {
                this._drawCounter - this._vertices[this._firstRetiredElement * this._floatCountPerVertex * this._vertexStride + this._timeIndex];
                this._firstRetiredElement++;
                if (this._firstRetiredElement >= this._bufferMaxParticles)
                    this._firstRetiredElement = 0;
            }
        }
        _burst(fromTime, toTime) {
            var totalEmitCount = 0;
            var bursts = this._emission._bursts;
            for (var n = bursts.length; this._burstsIndex < n; this._burstsIndex++) {
                var burst = bursts[this._burstsIndex];
                var burstTime = burst.time;
                if (fromTime <= burstTime && burstTime < toTime) {
                    var emitCount;
                    if (this.autoRandomSeed) {
                        emitCount = Laya.MathUtil.lerp(burst.minCount, burst.maxCount, Math.random());
                    }
                    else {
                        this._rand.seed = this._randomSeeds[0];
                        emitCount = Laya.MathUtil.lerp(burst.minCount, burst.maxCount, this._rand.getFloat());
                        this._randomSeeds[0] = this._rand.seed;
                    }
                    totalEmitCount += emitCount;
                }
                else {
                    break;
                }
            }
            return totalEmitCount;
        }
        _advanceTime(elapsedTime, emitTime) {
            var i;
            var lastEmissionTime = this._emissionTime;
            this._emissionTime += elapsedTime;
            var totalEmitCount = 0;
            if (this._emissionTime > this.duration) {
                if (this.looping) {
                    totalEmitCount += this._burst(lastEmissionTime, this._emissionTime);
                    this._emissionTime -= this.duration;
                    this._burstsIndex = 0;
                    totalEmitCount += this._burst(0, this._emissionTime);
                }
                else {
                    totalEmitCount = Math.min(this.maxParticles - this.aliveParticleCount, totalEmitCount);
                    for (i = 0; i < totalEmitCount; i++)
                        this.emit(emitTime);
                    this._isPlaying = false;
                    this.stop();
                    return;
                }
            }
            else {
                totalEmitCount += this._burst(lastEmissionTime, this._emissionTime);
            }
            totalEmitCount = Math.min(this.maxParticles - this.aliveParticleCount, totalEmitCount);
            for (i = 0; i < totalEmitCount; i++)
                this.emit(emitTime);
            var emissionRate = this.emission.emissionRate;
            if (emissionRate > 0) {
                var minEmissionTime = 1 / emissionRate;
                this._frameRateTime += minEmissionTime;
                this._frameRateTime = this._currentTime - (this._currentTime - this._frameRateTime) % this._maxStartLifetime;
                while (this._frameRateTime <= emitTime) {
                    if (this.emit(this._frameRateTime))
                        this._frameRateTime += minEmissionTime;
                    else
                        break;
                }
                this._frameRateTime = Math.floor(emitTime / minEmissionTime) * minEmissionTime;
            }
        }
        _advanceDistance(emitTime) {
            let position = this._owner.transform.position;
            let offsetDistance = Laya.Vector3.distance(position, this._emissionLastPosition);
            let rateOverDistance = this.emission.emissionRateOverDistance;
            let distance = this._emissionDistance + offsetDistance;
            let ed = 1.0 / rateOverDistance;
            if (distance > ed) {
                let emitCount = distance * rateOverDistance;
                emitCount = Math.floor(emitCount);
                emitCount = Math.min(this.maxParticles - this.aliveParticleCount, emitCount);
                for (let index = 0; index < emitCount; index++) {
                    this.emit(emitTime);
                }
                this._emissionDistance = 0;
            }
            else {
                this._emissionDistance = distance;
            }
            position.cloneTo(this._emissionLastPosition);
        }
        _initBufferDatas() {
            if (this._vertexBuffer) {
                var memorySize = this._vertexBuffer._byteLength + this._indexBuffer.indexCount * 2;
                this._vertexBuffer.destroy();
                this._indexBuffer.destroy();
                Laya.Resource._addMemory(-memorySize, -memorySize);
            }
            var render = this._ownerRender;
            var renderMode = render.renderMode;
            if (renderMode !== -1 && this.maxParticles > 0) {
                var indices, i, j, m, indexOffset, perPartOffset, vertexDeclaration;
                var vbMemorySize = 0, memorySize = 0;
                var mesh = render.mesh;
                if (renderMode === 4) {
                    if (mesh) {
                        vertexDeclaration = VertexShurikenParticleMesh.vertexDeclaration;
                        this._floatCountPerVertex = vertexDeclaration.vertexStride / 4;
                        this._simulationUV_Index = vertexDeclaration.getVertexElementByUsage(VertexShuriKenParticle.PARTICLE_SIMULATIONUV).offset / 4;
                        this._startLifeTimeIndex = 12;
                        this._timeIndex = 16;
                        this._vertexStride = mesh._vertexCount;
                        var totalVertexCount = this._bufferMaxParticles * this._vertexStride;
                        var vbCount = Math.floor(totalVertexCount / 65535) + 1;
                        var lastVBVertexCount = totalVertexCount % 65535;
                        if (vbCount > 1) {
                            throw new Error("ShurikenParticleSystem:the maxParticleCount multiply mesh vertexCount is large than 65535.");
                        }
                        vbMemorySize = vertexDeclaration.vertexStride * lastVBVertexCount;
                        this._vertexBuffer = Laya.LayaGL.renderOBJCreate.createVertexBuffer3D(vbMemorySize, Laya.BufferUsage.Dynamic, false);
                        this._vertexBuffer.vertexDeclaration = vertexDeclaration;
                        this._vertices = new Float32Array(this._floatCountPerVertex * lastVBVertexCount);
                        this._indexStride = mesh._indexBuffer.indexCount;
                        var indexDatas = mesh._indexBuffer.getData();
                        var indexCount = this._bufferMaxParticles * this._indexStride;
                        this._indexBuffer = Laya.LayaGL.renderOBJCreate.createIndexBuffer3D(Laya.IndexFormat.UInt16, indexCount, Laya.BufferUsage.Static, false);
                        indices = new Uint16Array(indexCount);
                        memorySize = vbMemorySize + indexCount * 2;
                        indexOffset = 0;
                        for (i = 0; i < this._bufferMaxParticles; i++) {
                            var indexValueOffset = i * this._vertexStride;
                            for (j = 0, m = indexDatas.length; j < m; j++)
                                indices[indexOffset++] = indexValueOffset + indexDatas[j];
                        }
                        this._indexBuffer.setData(indices);
                        this._bufferState.applyState([this._vertexBuffer], this._indexBuffer);
                        this.bufferState = this._bufferState;
                    }
                }
                else {
                    vertexDeclaration = VertexShurikenParticleBillboard.vertexDeclaration;
                    this._floatCountPerVertex = vertexDeclaration.vertexStride / 4;
                    this._startLifeTimeIndex = 7;
                    this._simulationUV_Index = vertexDeclaration.getVertexElementByUsage(VertexShuriKenParticle.PARTICLE_SIMULATIONUV).offset / 4;
                    this._timeIndex = 11;
                    this._vertexStride = 4;
                    vbMemorySize = vertexDeclaration.vertexStride * this._bufferMaxParticles * this._vertexStride;
                    this._vertexBuffer = Laya.LayaGL.renderOBJCreate.createVertexBuffer3D(vbMemorySize, Laya.BufferUsage.Dynamic, false);
                    this._vertexBuffer.vertexDeclaration = vertexDeclaration;
                    this._vertices = new Float32Array(this._floatCountPerVertex * this._bufferMaxParticles * this._vertexStride);
                    for (i = 0; i < this._bufferMaxParticles; i++) {
                        perPartOffset = i * this._floatCountPerVertex * this._vertexStride;
                        this._vertices[perPartOffset] = -0.5;
                        this._vertices[perPartOffset + 1] = -0.5;
                        this._vertices[perPartOffset + 2] = 0;
                        this._vertices[perPartOffset + 3] = 1;
                        perPartOffset += this._floatCountPerVertex;
                        this._vertices[perPartOffset] = 0.5;
                        this._vertices[perPartOffset + 1] = -0.5;
                        this._vertices[perPartOffset + 2] = 1;
                        this._vertices[perPartOffset + 3] = 1;
                        perPartOffset += this._floatCountPerVertex;
                        this._vertices[perPartOffset] = 0.5;
                        this._vertices[perPartOffset + 1] = 0.5;
                        this._vertices[perPartOffset + 2] = 1;
                        this._vertices[perPartOffset + 3] = 0;
                        perPartOffset += this._floatCountPerVertex;
                        this._vertices[perPartOffset] = -0.5;
                        this._vertices[perPartOffset + 1] = 0.5;
                        this._vertices[perPartOffset + 2] = 0;
                        this._vertices[perPartOffset + 3] = 0;
                    }
                    this._indexStride = 6;
                    this._indexBuffer = Laya.LayaGL.renderOBJCreate.createIndexBuffer3D(Laya.IndexFormat.UInt16, this._bufferMaxParticles * 6, Laya.BufferUsage.Static, false);
                    indices = new Uint16Array(this._bufferMaxParticles * 6);
                    for (i = 0; i < this._bufferMaxParticles; i++) {
                        indexOffset = i * 6;
                        var firstVertex = i * this._vertexStride, secondVertex = firstVertex + 2;
                        indices[indexOffset++] = firstVertex;
                        indices[indexOffset++] = secondVertex;
                        indices[indexOffset++] = firstVertex + 1;
                        indices[indexOffset++] = firstVertex;
                        indices[indexOffset++] = firstVertex + 3;
                        indices[indexOffset++] = secondVertex;
                    }
                    this._indexBuffer.setData(indices);
                    memorySize = vbMemorySize + this._bufferMaxParticles * 6 * 2;
                    this._bufferState.applyState([this._vertexBuffer], this._indexBuffer);
                    this.bufferState = this._bufferState;
                }
                Laya.Resource._addMemory(memorySize, memorySize);
            }
        }
        destroy() {
            super.destroy();
            if (this._vertexBuffer) {
                var memorySize = this._vertexBuffer._byteLength;
                Laya.Resource._addMemory(-memorySize, -memorySize);
                this._vertexBuffer.destroy();
                this._vertexBuffer = null;
            }
            if (this._indexBuffer) {
                var memorySize = this._indexBuffer._byteLength;
                Laya.Resource._addMemory(-memorySize, -memorySize);
                this._indexBuffer.destroy();
                this._indexBuffer = null;
            }
            this._emission.destroy();
            this._bounds = null;
            this._customBounds = null;
            this._bufferState = null;
            this._owner = null;
            this._vertices = null;
            this._indexBuffer = null;
            this._emission = null;
            this._shape = null;
            this.startLifeTimeGradient = null;
            this.startLifeTimeGradientMin = null;
            this.startLifeTimeGradientMax = null;
            this.startSizeConstantSeparate = null;
            this.startSizeConstantMinSeparate = null;
            this.startSizeConstantMaxSeparate = null;
            this.startRotationConstantSeparate = null;
            this.startRotationConstantMinSeparate = null;
            this.startRotationConstantMaxSeparate = null;
            this.startColorConstant = null;
            this.startColorConstantMin = null;
            this.startColorConstantMax = null;
            this._velocityOverLifetime = null;
            this._colorOverLifetime = null;
            this._sizeOverLifetime = null;
            this._rotationOverLifetime = null;
            this._textureSheetAnimation = null;
        }
        emit(time) {
            var position = ShurikenParticleSystem._tempPosition;
            var direction = ShurikenParticleSystem._tempDirection;
            if (this._shape && this._shape.enable) {
                if (this.autoRandomSeed)
                    this._shape.generatePositionAndDirection(position, direction);
                else
                    this._shape.generatePositionAndDirection(position, direction, this._rand, this._randomSeeds);
            }
            else {
                position.x = position.y = position.z = 0;
                direction.x = direction.y = 0;
                direction.z = 1;
            }
            return this.addParticle(position, direction, time);
        }
        addParticle(position, direction, time) {
            Laya.Vector3.normalize(direction, direction);
            var nextFreeParticle = this._firstFreeElement + 1;
            if (nextFreeParticle >= this._bufferMaxParticles)
                nextFreeParticle = 0;
            if (nextFreeParticle === this._firstRetiredElement)
                return false;
            var transform = this._owner.transform;
            ShurikenParticleData.create(this, this._ownerRender);
            var particleAge = this._currentTime - time;
            if (particleAge >= ShurikenParticleData.startLifeTime)
                return true;
            var pos, rot;
            if (this.simulationSpace == 0) {
                pos = transform.position;
                rot = transform.rotation;
            }
            var startSpeed;
            switch (this.startSpeedType) {
                case 0:
                    startSpeed = this.startSpeedConstant;
                    break;
                case 2:
                    if (this.autoRandomSeed) {
                        startSpeed = Laya.MathUtil.lerp(this.startSpeedConstantMin, this.startSpeedConstantMax, Math.random());
                    }
                    else {
                        this._rand.seed = this._randomSeeds[8];
                        startSpeed = Laya.MathUtil.lerp(this.startSpeedConstantMin, this.startSpeedConstantMax, this._rand.getFloat());
                        this._randomSeeds[8] = this._rand.seed;
                    }
                    break;
            }
            var randomVelocityX, randomVelocityY, randomVelocityZ, randomColor, randomSize, randomRotation, randomTextureAnimation;
            var needRandomVelocity = this._velocityOverLifetime && this._velocityOverLifetime.enable;
            if (needRandomVelocity) {
                var velocityType = this._velocityOverLifetime.velocity.type;
                if (velocityType === 2 || velocityType === 3) {
                    if (this.autoRandomSeed) {
                        randomVelocityX = Math.random();
                        randomVelocityY = Math.random();
                        randomVelocityZ = Math.random();
                    }
                    else {
                        this._rand.seed = this._randomSeeds[9];
                        randomVelocityX = this._rand.getFloat();
                        randomVelocityY = this._rand.getFloat();
                        randomVelocityZ = this._rand.getFloat();
                        this._randomSeeds[9] = this._rand.seed;
                    }
                }
                else {
                    needRandomVelocity = false;
                }
            }
            else {
                needRandomVelocity = false;
            }
            var needRandomColor = this._colorOverLifetime && this._colorOverLifetime.enable;
            if (needRandomColor) {
                var colorType = this._colorOverLifetime.color.type;
                if (colorType === 3) {
                    if (this.autoRandomSeed) {
                        randomColor = Math.random();
                    }
                    else {
                        this._rand.seed = this._randomSeeds[10];
                        randomColor = this._rand.getFloat();
                        this._randomSeeds[10] = this._rand.seed;
                    }
                }
                else {
                    needRandomColor = false;
                }
            }
            else {
                needRandomColor = false;
            }
            var needRandomSize = this._sizeOverLifetime && this._sizeOverLifetime.enable;
            if (needRandomSize) {
                var sizeType = this._sizeOverLifetime.size.type;
                if (sizeType === 3) {
                    if (this.autoRandomSeed) {
                        randomSize = Math.random();
                    }
                    else {
                        this._rand.seed = this._randomSeeds[11];
                        randomSize = this._rand.getFloat();
                        this._randomSeeds[11] = this._rand.seed;
                    }
                }
                else {
                    needRandomSize = false;
                }
            }
            else {
                needRandomSize = false;
            }
            var needRandomRotation = this._rotationOverLifetime && this._rotationOverLifetime.enable;
            if (needRandomRotation) {
                var rotationType = this._rotationOverLifetime.angularVelocity.type;
                if (rotationType === 2 || rotationType === 3) {
                    if (this.autoRandomSeed) {
                        randomRotation = Math.random();
                    }
                    else {
                        this._rand.seed = this._randomSeeds[12];
                        randomRotation = this._rand.getFloat();
                        this._randomSeeds[12] = this._rand.seed;
                    }
                }
                else {
                    needRandomRotation = false;
                }
            }
            else {
                needRandomRotation = false;
            }
            var needRandomTextureAnimation = this._textureSheetAnimation && this._textureSheetAnimation.enable;
            if (needRandomTextureAnimation) {
                var textureAnimationType = this._textureSheetAnimation.frame.type;
                if (textureAnimationType === 3) {
                    if (this.autoRandomSeed) {
                        randomTextureAnimation = Math.random();
                    }
                    else {
                        this._rand.seed = this._randomSeeds[15];
                        randomTextureAnimation = this._rand.getFloat();
                        this._randomSeeds[15] = this._rand.seed;
                    }
                }
                else {
                    needRandomTextureAnimation = false;
                }
            }
            else {
                needRandomTextureAnimation = false;
            }
            var startIndex = this._firstFreeElement * this._floatCountPerVertex * this._vertexStride;
            var subU = ShurikenParticleData.startUVInfo[0];
            var subV = ShurikenParticleData.startUVInfo[1];
            var startU = ShurikenParticleData.startUVInfo[2];
            var startV = ShurikenParticleData.startUVInfo[3];
            var meshVertices, meshVertexStride, meshPosOffset, meshCorOffset, meshUVOffset, meshVertexIndex;
            var render = this._ownerRender;
            if (render.renderMode === 4) {
                var meshVB = render.mesh._vertexBuffer;
                meshVertices = meshVB.getFloat32Data();
                var meshVertexDeclaration = meshVB.vertexDeclaration;
                meshPosOffset = meshVertexDeclaration.getVertexElementByUsage(Laya.VertexMesh.MESH_POSITION0)._offset / 4;
                var colorElement = meshVertexDeclaration.getVertexElementByUsage(Laya.VertexMesh.MESH_COLOR0);
                meshCorOffset = colorElement ? colorElement._offset / 4 : -1;
                var uvElement = meshVertexDeclaration.getVertexElementByUsage(Laya.VertexMesh.MESH_TEXTURECOORDINATE0);
                meshUVOffset = uvElement ? uvElement._offset / 4 : -1;
                meshVertexStride = meshVertexDeclaration.vertexStride / 4;
                meshVertexIndex = 0;
            }
            for (var i = startIndex, n = startIndex + this._floatCountPerVertex * this._vertexStride; i < n; i += this._floatCountPerVertex) {
                var offset;
                if (render.renderMode === 4) {
                    offset = i;
                    var vertexOffset = meshVertexStride * (meshVertexIndex++);
                    var meshOffset = vertexOffset + meshPosOffset;
                    this._vertices[offset++] = meshVertices[meshOffset++];
                    this._vertices[offset++] = meshVertices[meshOffset++];
                    this._vertices[offset++] = meshVertices[meshOffset];
                    if (meshCorOffset === -1) {
                        this._vertices[offset++] = 1.0;
                        this._vertices[offset++] = 1.0;
                        this._vertices[offset++] = 1.0;
                        this._vertices[offset++] = 1.0;
                    }
                    else {
                        meshOffset = vertexOffset + meshCorOffset;
                        this._vertices[offset++] = meshVertices[meshOffset++];
                        this._vertices[offset++] = meshVertices[meshOffset++];
                        this._vertices[offset++] = meshVertices[meshOffset++];
                        this._vertices[offset++] = meshVertices[meshOffset];
                    }
                    if (meshUVOffset === -1) {
                        this._vertices[offset++] = 0.0;
                        this._vertices[offset++] = 0.0;
                    }
                    else {
                        meshOffset = vertexOffset + meshUVOffset;
                        this._vertices[offset++] = meshVertices[meshOffset++];
                        this._vertices[offset++] = meshVertices[meshOffset];
                    }
                }
                else {
                    offset = i + 4;
                }
                this._vertices[offset++] = position.x;
                this._vertices[offset++] = position.y;
                this._vertices[offset++] = position.z;
                this._vertices[offset++] = ShurikenParticleData.startLifeTime;
                this._vertices[offset++] = direction.x;
                this._vertices[offset++] = direction.y;
                this._vertices[offset++] = direction.z;
                this._vertices[offset++] = time;
                this._vertices[offset++] = ShurikenParticleData.startColor.x;
                this._vertices[offset++] = ShurikenParticleData.startColor.y;
                this._vertices[offset++] = ShurikenParticleData.startColor.z;
                this._vertices[offset++] = ShurikenParticleData.startColor.w;
                this._vertices[offset++] = ShurikenParticleData.startSize[0];
                this._vertices[offset++] = ShurikenParticleData.startSize[1];
                this._vertices[offset++] = ShurikenParticleData.startSize[2];
                this._vertices[offset++] = ShurikenParticleData.startRotation[0];
                this._vertices[offset++] = ShurikenParticleData.startRotation[1];
                this._vertices[offset++] = ShurikenParticleData.startRotation[2];
                this._vertices[offset++] = startSpeed;
                needRandomColor && (this._vertices[offset + 1] = randomColor);
                needRandomSize && (this._vertices[offset + 2] = randomSize);
                needRandomRotation && (this._vertices[offset + 3] = randomRotation);
                needRandomTextureAnimation && (this._vertices[offset + 4] = randomTextureAnimation);
                if (needRandomVelocity) {
                    this._vertices[offset + 5] = randomVelocityX;
                    this._vertices[offset + 6] = randomVelocityY;
                    this._vertices[offset + 7] = randomVelocityZ;
                }
                switch (this.simulationSpace) {
                    case 0:
                        offset += 8;
                        this._vertices[offset++] = pos.x;
                        this._vertices[offset++] = pos.y;
                        this._vertices[offset++] = pos.z;
                        this._vertices[offset++] = rot.x;
                        this._vertices[offset++] = rot.y;
                        this._vertices[offset++] = rot.z;
                        this._vertices[offset++] = rot.w;
                        break;
                    case 1:
                        break;
                    default:
                        throw new Error("ShurikenParticleMaterial: SimulationSpace value is invalid.");
                }
                offset = i + this._simulationUV_Index;
                this._vertices[offset++] = startU;
                this._vertices[offset++] = startV;
                this._vertices[offset++] = subU;
                this._vertices[offset] = subV;
            }
            this._firstFreeElement = nextFreeParticle;
            return true;
        }
        addNewParticlesToVertexBuffer() {
            var start;
            var byteStride = this._vertexStride * this._floatCountPerVertex * 4;
            if (this._firstNewElement < this._firstFreeElement) {
                start = this._firstNewElement * byteStride;
                this._vertexBuffer.setData(this._vertices.buffer, start, start, (this._firstFreeElement - this._firstNewElement) * byteStride);
            }
            else {
                start = this._firstNewElement * byteStride;
                this._vertexBuffer.setData(this._vertices.buffer, start, start, (this._bufferMaxParticles - this._firstNewElement) * byteStride);
                if (this._firstFreeElement > 0) {
                    this._vertexBuffer.setData(this._vertices.buffer, 0, 0, this._firstFreeElement * byteStride);
                }
            }
            this._firstNewElement = this._firstFreeElement;
        }
        _getType() {
            return ShurikenParticleSystem._type;
        }
        _prepareRender(state) {
            if (this._updateMask != Laya.Stat.loopCount) {
                this._updateMask = Laya.Stat.loopCount;
                this._updateEmission();
                if (this._firstNewElement != this._firstFreeElement)
                    this.addNewParticlesToVertexBuffer();
                this._drawCounter++;
            }
            if (this._firstActiveElement != this._firstFreeElement)
                return true;
            else
                return false;
        }
        _updateRenderParams(state) {
            var indexCount;
            this.clearRenderParams();
            if (this._firstActiveElement < this._firstFreeElement) {
                indexCount = (this._firstFreeElement - this._firstActiveElement) * this._indexStride;
                this.setDrawElemenParams(indexCount, 2 * this._firstActiveElement * this._indexStride);
            }
            else {
                indexCount = (this._bufferMaxParticles - this._firstActiveElement) * this._indexStride;
                this.setDrawElemenParams(indexCount, 2 * this._firstActiveElement * this._indexStride);
                if (this._firstFreeElement > 0) {
                    indexCount = this._firstFreeElement * this._indexStride;
                    this.setDrawElemenParams(indexCount, 0);
                }
            }
        }
        play() {
            this._burstsIndex = 0;
            this._isEmitting = true;
            this._isPlaying = true;
            this._isPaused = false;
            this._emissionTime = 0;
            this._emissionDistance = 0;
            this._owner.transform.position.cloneTo(this._emissionLastPosition);
            this._totalDelayTime = 0;
            if (!this.autoRandomSeed) {
                for (var i = 0, n = this._randomSeeds.length; i < n; i++)
                    this._randomSeeds[i] = this.randomSeed[0] + ShurikenParticleSystem._RANDOMOFFSET[i];
            }
            switch (this.startDelayType) {
                case 0:
                    this._playStartDelay = this.startDelay;
                    break;
                case 1:
                    if (this.autoRandomSeed) {
                        this._playStartDelay = Laya.MathUtil.lerp(this.startDelayMin, this.startDelayMax, Math.random());
                    }
                    else {
                        this._rand.seed = this._randomSeeds[2];
                        this._playStartDelay = Laya.MathUtil.lerp(this.startDelayMin, this.startDelayMax, this._rand.getFloat());
                        this._randomSeeds[2] = this._rand.seed;
                    }
                    break;
                default:
                    throw new Error("Utils3D: startDelayType is invalid.");
            }
            this._frameRateTime = this._currentTime + this._playStartDelay;
            this._startUpdateLoopCount = Laya.Stat.loopCount;
        }
        pause() {
            this._isPaused = true;
        }
        simulate(time, restart = true) {
            this._simulateUpdate = true;
            if (restart) {
                this._updateParticlesSimulationRestart(time);
            }
            else {
                this._isPaused = false;
                this._updateParticles(time);
            }
            this.pause();
        }
        stop() {
            this._burstsIndex = 0;
            this._isEmitting = false;
            this._emissionTime = 0;
        }
        cloneTo(destObject) {
            var dest = destObject;
            dest._useCustomBounds = this._useCustomBounds;
            (this._customBounds) && (this._customBounds.cloneTo(dest._customBounds));
            dest.duration = this.duration;
            dest.looping = this.looping;
            dest.prewarm = this.prewarm;
            dest.startDelayType = this.startDelayType;
            dest.startDelay = this.startDelay;
            dest.startDelayMin = this.startDelayMin;
            dest.startDelayMax = this.startDelayMax;
            dest._maxStartLifetime = this._maxStartLifetime;
            dest.startLifetimeType = this.startLifetimeType;
            dest.startLifetimeConstant = this.startLifetimeConstant;
            this.startLifeTimeGradient.cloneTo(dest.startLifeTimeGradient);
            dest.startLifetimeConstantMin = this.startLifetimeConstantMin;
            dest.startLifetimeConstantMax = this.startLifetimeConstantMax;
            this.startLifeTimeGradientMin.cloneTo(dest.startLifeTimeGradientMin);
            this.startLifeTimeGradientMax.cloneTo(dest.startLifeTimeGradientMax);
            dest.startSpeedType = this.startSpeedType;
            dest.startSpeedConstant = this.startSpeedConstant;
            dest.startSpeedConstantMin = this.startSpeedConstantMin;
            dest.startSpeedConstantMax = this.startSpeedConstantMax;
            dest.dragType = this.dragType;
            dest.dragConstant = this.dragConstant;
            dest.dragSpeedConstantMax = this.dragSpeedConstantMax;
            dest.dragSpeedConstantMin = this.dragSpeedConstantMin;
            dest.threeDStartSize = this.threeDStartSize;
            dest.startSizeType = this.startSizeType;
            dest.startSizeConstant = this.startSizeConstant;
            this.startSizeConstantSeparate.cloneTo(dest.startSizeConstantSeparate);
            dest.startSizeConstantMin = this.startSizeConstantMin;
            dest.startSizeConstantMax = this.startSizeConstantMax;
            this.startSizeConstantMinSeparate.cloneTo(dest.startSizeConstantMinSeparate);
            this.startSizeConstantMaxSeparate.cloneTo(dest.startSizeConstantMaxSeparate);
            dest.threeDStartRotation = this.threeDStartRotation;
            dest.startRotationType = this.startRotationType;
            dest.startRotationConstant = this.startRotationConstant;
            this.startRotationConstantSeparate.cloneTo(dest.startRotationConstantSeparate);
            dest.startRotationConstantMin = this.startRotationConstantMin;
            dest.startRotationConstantMax = this.startRotationConstantMax;
            this.startRotationConstantMinSeparate.cloneTo(dest.startRotationConstantMinSeparate);
            this.startRotationConstantMaxSeparate.cloneTo(dest.startRotationConstantMaxSeparate);
            dest.randomizeRotationDirection = this.randomizeRotationDirection;
            dest.startColorType = this.startColorType;
            this.startColorConstant.cloneTo(dest.startColorConstant);
            this.startColorConstantMin.cloneTo(dest.startColorConstantMin);
            this.startColorConstantMax.cloneTo(dest.startColorConstantMax);
            dest.gravityModifier = this.gravityModifier;
            dest.simulationSpace = this.simulationSpace;
            dest.simulationSpeed = this.simulationSpeed;
            dest.scaleMode = this.scaleMode;
            dest.playOnAwake = this.playOnAwake;
            dest.autoRandomSeed = this.autoRandomSeed;
            dest.randomSeed[0] = this.randomSeed[0];
            dest.maxParticles = this.maxParticles;
            (this._emission) && (dest._emission = this._emission.clone());
            (this.shape) && (dest.shape = this.shape.clone());
            (this.velocityOverLifetime) && (dest.velocityOverLifetime = this.velocityOverLifetime.clone());
            (this.colorOverLifetime) && (dest.colorOverLifetime = this.colorOverLifetime.clone());
            (this.sizeOverLifetime) && (dest.sizeOverLifetime = this.sizeOverLifetime.clone());
            (this.rotationOverLifetime) && (dest.rotationOverLifetime = this.rotationOverLifetime.clone());
            (this.textureSheetAnimation) && (dest.textureSheetAnimation = this.textureSheetAnimation.clone());
            dest.isPerformanceMode = this.isPerformanceMode;
            dest._isEmitting = this._isEmitting;
            dest._isPlaying = this._isPlaying;
            dest._isPaused = this._isPaused;
            dest._playStartDelay = this._playStartDelay;
            dest._frameRateTime = this._frameRateTime;
            dest._emissionTime = this._emissionTime;
            dest._totalDelayTime = this._totalDelayTime;
            dest._burstsIndex = this._burstsIndex;
        }
        clone() {
            var dest = new ShurikenParticleSystem(null);
            this.cloneTo(dest);
            return dest;
        }
    }
    ShurikenParticleSystem._RANDOMOFFSET = new Uint32Array([0x23571a3e, 0xc34f56fe, 0x13371337, 0x12460f3b, 0x6aed452e, 0xdec4aea1, 0x96aa4de3, 0x8d2c8431, 0xf3857f6f, 0xe0fbd834, 0x13740583, 0x591bc05c, 0x40eb95e4, 0xbc524e5f, 0xaf502044, 0xa614b381, 0x1034e524, 0xfc524e5f]);
    ShurikenParticleSystem.halfKSqrtOf2 = 1.42 * 0.5;
    ShurikenParticleSystem.g = 9.8;
    ShurikenParticleSystem._maxElapsedTime = 1.0 / 3.0;
    ShurikenParticleSystem._tempVector30 = new Laya.Vector3();
    ShurikenParticleSystem._tempVector31 = new Laya.Vector3();
    ShurikenParticleSystem._tempVector32 = new Laya.Vector3();
    ShurikenParticleSystem._tempVector33 = new Laya.Vector3();
    ShurikenParticleSystem._tempVector34 = new Laya.Vector3();
    ShurikenParticleSystem._tempVector35 = new Laya.Vector3();
    ShurikenParticleSystem._tempVector36 = new Laya.Vector3();
    ShurikenParticleSystem._tempVector37 = new Laya.Vector3();
    ShurikenParticleSystem._tempPosition = new Laya.Vector3();
    ShurikenParticleSystem._tempDirection = new Laya.Vector3();
    ShurikenParticleSystem._type = GeometryElement._typeCounter++;

    class ShurikenParticleInstanceSystem extends ShurikenParticleSystem {
        constructor(render) {
            super(render, Laya.MeshTopology.Triangles, Laya.DrawType.DrawElementInstance);
            this._instanceParticleVertexBuffer = null;
            this._instanceVertex = null;
        }
        _initMeshVertex(vertex, mesh) {
            let meshVertexBuffer = mesh._vertexBuffer;
            let meshVertices = meshVertexBuffer.getFloat32Data();
            let meshVertexDeclaration = meshVertexBuffer.vertexDeclaration;
            let meshPosOffset = meshVertexDeclaration.getVertexElementByUsage(Laya.VertexMesh.MESH_POSITION0)._offset / 4;
            let colorElement = meshVertexDeclaration.getVertexElementByUsage(Laya.VertexMesh.MESH_COLOR0);
            let meshColorOffset = colorElement ? colorElement._offset / 4 : -1;
            let uvElement = meshVertexDeclaration.getVertexElementByUsage(Laya.VertexMesh.MESH_TEXTURECOORDINATE0);
            let meshUVOffset = uvElement ? uvElement._offset / 4 : -1;
            let meshVertexStride = meshVertexDeclaration.vertexStride / 4;
            let meshVertexIndex = 0;
            let vertexCount = mesh.vertexCount;
            let perParticleDataCount = this._vertexBuffer.vertexDeclaration.vertexStride / 4;
            for (let index = 0; index < vertexCount; index++) {
                let startIndex = index * perParticleDataCount;
                let indexOffset = startIndex;
                let vertexOffset = meshVertexStride * meshVertexIndex++;
                let positionOffset = vertexOffset + meshPosOffset;
                vertex[indexOffset++] = meshVertices[positionOffset++];
                vertex[indexOffset++] = meshVertices[positionOffset++];
                vertex[indexOffset++] = meshVertices[positionOffset++];
                if (meshColorOffset == -1) {
                    vertex[indexOffset++] = 1;
                    vertex[indexOffset++] = 1;
                    vertex[indexOffset++] = 1;
                    vertex[indexOffset++] = 1;
                }
                else {
                    let colorOffset = vertexOffset + meshColorOffset;
                    vertex[indexOffset++] = meshVertices[colorOffset++];
                    vertex[indexOffset++] = meshVertices[colorOffset++];
                    vertex[indexOffset++] = meshVertices[colorOffset++];
                    vertex[indexOffset++] = meshVertices[colorOffset++];
                }
                if (meshUVOffset == -1) {
                    vertex[indexOffset++] = 0;
                    vertex[indexOffset++] = 0;
                }
                else {
                    let uvOffset = vertexOffset + meshUVOffset;
                    vertex[indexOffset++] = meshVertices[uvOffset++];
                    vertex[indexOffset++] = meshVertices[uvOffset++];
                }
            }
        }
        _initBufferDatas() {
            if (this._vertexBuffer) {
                this._vertexBuffer.destroy();
                this._instanceParticleVertexBuffer.destroy();
                this._indexBuffer.destroy();
            }
            let render = this._ownerRender;
            let renderMode = render.renderMode;
            if (renderMode == -1 || this.maxParticles <= 0) {
                return;
            }
            if (renderMode == 4) {
                let mesh = render.mesh;
                if (mesh) {
                    let meshDeclaration = VertexShurikenParticleMesh.vertexInstanceMeshDeclaration;
                    let particleDeclaration = VertexShurikenParticleMesh.vertexInstanceParticleDeclaration;
                    this._meshIndexCount = mesh.indexCount;
                    this._simulationUV_Index = particleDeclaration.getVertexElementByUsage(VertexShuriKenParticle.PARTICLE_SIMULATIONUV).offset / 4;
                    this._floatCountPerParticleData = particleDeclaration.vertexStride / 4;
                    this._startLifeTimeIndex = particleDeclaration.getVertexElementByUsage(VertexShuriKenParticle.PARTICLE_SHAPEPOSITIONSTARTLIFETIME)._offset / 4 + 3;
                    this._timeIndex = particleDeclaration.getVertexElementByUsage(VertexShuriKenParticle.PARTICLE_DIRECTIONTIME)._offset / 4 + 3;
                    let indexCount = mesh.indexCount;
                    this._indexBuffer = Laya.LayaGL.renderOBJCreate.createIndexBuffer3D(mesh.indexFormat, indexCount, Laya.BufferUsage.Static, false);
                    this._indexBuffer.setData(mesh._indexBuffer.getData());
                    let meshVertexCount = mesh.vertexCount;
                    let vbSize = meshDeclaration.vertexStride * meshVertexCount;
                    this._vertexBuffer = Laya.LayaGL.renderOBJCreate.createVertexBuffer3D(vbSize, Laya.BufferUsage.Static, false);
                    this._vertexBuffer.vertexDeclaration = meshDeclaration;
                    let meshVertex = new Float32Array(vbSize / 4);
                    this._initMeshVertex(meshVertex, mesh);
                    this._vertexBuffer.setData(meshVertex.buffer);
                    let particleCount = this._bufferMaxParticles;
                    let particleVbSize = particleCount * particleDeclaration.vertexStride;
                    this._instanceVertex = new Float32Array(particleVbSize / 4);
                    this._instanceParticleVertexBuffer = Laya.LayaGL.renderOBJCreate.createVertexBuffer3D(particleVbSize, Laya.BufferUsage.Dynamic, false);
                    this._instanceParticleVertexBuffer.vertexDeclaration = particleDeclaration;
                    this._instanceParticleVertexBuffer.setData(this._instanceVertex.buffer);
                    this._instanceParticleVertexBuffer.instanceBuffer = true;
                    this._bufferState.applyState([this._vertexBuffer, this._instanceParticleVertexBuffer], this._indexBuffer);
                }
            }
            else {
                let billboardDeclaration = VertexShurikenParticleBillboard.vertexInstanceMeshDeclaration;
                let particleDeclaration = VertexShurikenParticleBillboard.vertexInstanceParticleDeclaration;
                this._meshIndexCount = 6;
                this._simulationUV_Index = particleDeclaration.getVertexElementByUsage(VertexShuriKenParticle.PARTICLE_SIMULATIONUV).offset / 4;
                this._floatCountPerParticleData = particleDeclaration.vertexStride / 4;
                this._startLifeTimeIndex = particleDeclaration.getVertexElementByUsage(VertexShuriKenParticle.PARTICLE_SHAPEPOSITIONSTARTLIFETIME)._offset / 4 + 3;
                this._timeIndex = particleDeclaration.getVertexElementByUsage(VertexShuriKenParticle.PARTICLE_DIRECTIONTIME)._offset / 4 + 3;
                let indexArray = VertexShurikenParticleBillboard.billboardIndexArray;
                let indexCount = indexArray.length;
                this._indexBuffer = Laya.LayaGL.renderOBJCreate.createIndexBuffer3D(Laya.IndexFormat.UInt16, indexCount, Laya.BufferUsage.Static, false);
                this._indexBuffer.setData(indexArray);
                let meshVBSize = this._meshIndexCount * billboardDeclaration.vertexStride;
                this._vertexBuffer = Laya.LayaGL.renderOBJCreate.createVertexBuffer3D(meshVBSize, Laya.BufferUsage.Static, false);
                this._vertexBuffer.vertexDeclaration = billboardDeclaration;
                this._vertexBuffer.setData(VertexShurikenParticleBillboard.billboardVertexArray.buffer);
                let particleCount = this._bufferMaxParticles;
                let particleVbSize = particleCount * particleDeclaration.vertexStride;
                this._instanceVertex = new Float32Array(particleVbSize / 4);
                this._instanceParticleVertexBuffer = Laya.LayaGL.renderOBJCreate.createVertexBuffer3D(particleVbSize, Laya.BufferUsage.Dynamic, false);
                this._instanceParticleVertexBuffer.vertexDeclaration = particleDeclaration;
                this._instanceParticleVertexBuffer.setData(this._instanceVertex.buffer);
                this._instanceParticleVertexBuffer.instanceBuffer = true;
                this._bufferState.applyState([this._vertexBuffer, this._instanceParticleVertexBuffer], this._indexBuffer);
            }
        }
        _retireActiveParticles() {
            const epsilon = 0.0001;
            let firstActive = this._firstActiveElement;
            while (this._firstActiveElement != this._firstNewElement) {
                let index = this._firstActiveElement * this._floatCountPerParticleData;
                let timeIndex = index + this._timeIndex;
                let particleAge = this._currentTime - this._instanceVertex[timeIndex];
                if (particleAge + epsilon < this._instanceVertex[index + this._startLifeTimeIndex]) {
                    break;
                }
                this._instanceVertex[timeIndex] = this._drawCounter;
                this._firstActiveElement++;
                if (this._firstActiveElement >= this._bufferMaxParticles) {
                    this._firstActiveElement = 0;
                }
            }
            if (this._firstActiveElement != firstActive) {
                let byteStride = this._floatCountPerParticleData * 4;
                if (this._firstActiveElement < this._firstFreeElement) {
                    let activeStart = this._firstActiveElement * byteStride;
                    this._instanceParticleVertexBuffer.setData(this._instanceVertex.buffer, 0, activeStart, (this._firstFreeElement - this._firstActiveElement) * byteStride);
                }
                else {
                    let start = this._firstActiveElement * byteStride;
                    let a = this._bufferMaxParticles - this._firstActiveElement;
                    this._instanceParticleVertexBuffer.setData(this._instanceVertex.buffer, 0, start, a * byteStride);
                    if (this._firstFreeElement > 0) {
                        this._instanceParticleVertexBuffer.setData(this._instanceVertex.buffer, a * byteStride, 0, this._firstFreeElement * byteStride);
                    }
                }
            }
        }
        _freeRetiredParticles() {
            while (this._firstRetiredElement != this._firstActiveElement) {
                this._drawCounter - this._instanceVertex[this._firstRetiredElement * this._floatCountPerParticleData + this._timeIndex];
                this._firstRetiredElement++;
                if (this._firstRetiredElement >= this._bufferMaxParticles)
                    this._firstRetiredElement = 0;
            }
        }
        addParticle(position, direction, time) {
            Laya.Vector3.normalize(direction, direction);
            let nextFreeParticle = this._firstFreeElement + 1;
            if (nextFreeParticle >= this._bufferMaxParticles) {
                nextFreeParticle = 0;
            }
            if (nextFreeParticle == this._firstRetiredElement) {
                return false;
            }
            let transform = this._owner.transform;
            ShurikenParticleData.create(this, this._ownerRender);
            let particleAge = this._currentTime - time;
            if (particleAge >= ShurikenParticleData.startLifeTime) {
                return true;
            }
            let pos, rot;
            if (this.simulationSpace == 0) {
                pos = transform.position;
                rot = transform.rotation;
            }
            let startSpeed = 0;
            switch (this.startSpeedType) {
                case 0:
                    startSpeed = this.startSpeedConstant;
                    break;
                case 2:
                    if (this.autoRandomSeed) {
                        startSpeed = Laya.MathUtil.lerp(this.startSpeedConstantMin, this.startSpeedConstantMax, Math.random());
                    }
                    else {
                        this._rand.seed = this._randomSeeds[8];
                        startSpeed = Laya.MathUtil.lerp(this.startSpeedConstantMin, this.startSpeedConstantMax, this._rand.getFloat());
                        this._randomSeeds[8] = this._rand.seed;
                    }
                    break;
            }
            let randomVelocityX, randomVelocityY, randomVelocityZ;
            let needRandomVelocity = this._velocityOverLifetime && this._velocityOverLifetime.enable;
            if (needRandomVelocity) {
                let velocityType = this._velocityOverLifetime.velocity.type;
                if (velocityType == 2 || velocityType == 3) {
                    if (this.autoRandomSeed) {
                        randomVelocityX = Math.random();
                        randomVelocityY = Math.random();
                        randomVelocityZ = Math.random();
                    }
                    else {
                        this._rand.seed = this._randomSeeds[9];
                        randomVelocityX = this._rand.getFloat();
                        randomVelocityY = this._rand.getFloat();
                        randomVelocityZ = this._rand.getFloat();
                        this._randomSeeds[9] = this._rand.seed;
                    }
                }
                else {
                    needRandomVelocity = false;
                }
            }
            else {
                needRandomVelocity = false;
            }
            let randomColor;
            let needRandomColor = this._colorOverLifetime && this._colorOverLifetime.enable;
            if (needRandomColor) {
                let colorType = this._colorOverLifetime.color.type;
                if (colorType == 3) {
                    if (this.autoRandomSeed) {
                        randomColor = Math.random();
                    }
                    else {
                        this._rand.seed = this._randomSeeds[10];
                        randomColor = this._rand.getFloat();
                        this._randomSeeds[10] = this._rand.seed;
                    }
                }
                else {
                    needRandomColor = false;
                }
            }
            else {
                needRandomColor = false;
            }
            let randomSize;
            let needRandomSize = this._sizeOverLifetime && this._sizeOverLifetime.enable;
            if (needRandomSize) {
                let sizeType = this._sizeOverLifetime.size.type;
                if (sizeType == 3) {
                    if (this.autoRandomSeed) {
                        randomSize = Math.random();
                    }
                    else {
                        this._rand.seed = this._randomSeeds[11];
                        randomSize = this._rand.getFloat();
                        this.randomSeed[11] = this._rand.seed;
                    }
                }
                else {
                    needRandomSize = false;
                }
            }
            else {
                needRandomSize = false;
            }
            let randomRotation;
            let needRandomRotation = this._rotationOverLifetime && this._rotationOverLifetime.enable;
            if (needRandomRotation) {
                let rotationType = this._rotationOverLifetime.angularVelocity.type;
                if (rotationType == 2 || rotationType == 3) {
                    if (this.autoRandomSeed) {
                        randomRotation = Math.random();
                    }
                    else {
                        this._rand.seed = this._randomSeeds[12];
                        randomRotation = this._rand.getFloat();
                        this._randomSeeds[12] = this._rand.seed;
                    }
                }
                else {
                    needRandomRotation = false;
                }
            }
            else {
                needRandomRotation = false;
            }
            let randomTextureAnimation;
            let needRandomTextureAnimation = this._textureSheetAnimation && this._textureSheetAnimation.enable;
            if (needRandomTextureAnimation) {
                let textureAnimationType = this._textureSheetAnimation.frame.type;
                if (textureAnimationType == 3) {
                    if (this.autoRandomSeed) {
                        randomTextureAnimation = Math.random();
                    }
                    else {
                        this._rand.seed = this._randomSeeds[15];
                        randomTextureAnimation = this._rand.getFloat();
                        this._randomSeeds[15] = this._rand.seed;
                    }
                }
                else {
                    needRandomTextureAnimation = false;
                }
            }
            else {
                needRandomTextureAnimation = false;
            }
            let subU = ShurikenParticleData.startUVInfo[0];
            let subV = ShurikenParticleData.startUVInfo[1];
            let startU = ShurikenParticleData.startUVInfo[2];
            let startV = ShurikenParticleData.startUVInfo[3];
            let render = this._ownerRender;
            if (render.renderMode == 4) ;
            let startIndex = this._firstFreeElement * this._floatCountPerParticleData;
            let offset = startIndex;
            this._instanceVertex[offset++] = position.x;
            this._instanceVertex[offset++] = position.y;
            this._instanceVertex[offset++] = position.z;
            this._instanceVertex[offset++] = ShurikenParticleData.startLifeTime;
            this._instanceVertex[offset++] = direction.x;
            this._instanceVertex[offset++] = direction.y;
            this._instanceVertex[offset++] = direction.z;
            this._instanceVertex[offset++] = time;
            this._instanceVertex[offset++] = ShurikenParticleData.startColor.x;
            this._instanceVertex[offset++] = ShurikenParticleData.startColor.y;
            this._instanceVertex[offset++] = ShurikenParticleData.startColor.z;
            this._instanceVertex[offset++] = ShurikenParticleData.startColor.w;
            this._instanceVertex[offset++] = ShurikenParticleData.startSize[0];
            this._instanceVertex[offset++] = ShurikenParticleData.startSize[1];
            this._instanceVertex[offset++] = ShurikenParticleData.startSize[2];
            this._instanceVertex[offset++] = ShurikenParticleData.startRotation[0];
            this._instanceVertex[offset++] = ShurikenParticleData.startRotation[1];
            this._instanceVertex[offset++] = ShurikenParticleData.startRotation[2];
            this._instanceVertex[offset++] = startSpeed;
            needRandomColor && (this._instanceVertex[offset + 1] = randomColor);
            needRandomSize && (this._instanceVertex[offset + 2] = randomSize);
            needRandomRotation && (this._instanceVertex[offset + 3] = randomRotation);
            needRandomTextureAnimation && (this._instanceVertex[offset + 4] = randomTextureAnimation);
            if (needRandomVelocity) {
                this._instanceVertex[offset + 5] = randomVelocityX;
                this._instanceVertex[offset + 6] = randomVelocityY;
                this._instanceVertex[offset + 7] = randomVelocityZ;
            }
            switch (this.simulationSpace) {
                case 0:
                    offset += 8;
                    this._instanceVertex[offset++] = pos.x;
                    this._instanceVertex[offset++] = pos.y;
                    this._instanceVertex[offset++] = pos.z;
                    this._instanceVertex[offset++] = rot.x;
                    this._instanceVertex[offset++] = rot.y;
                    this._instanceVertex[offset++] = rot.z;
                    this._instanceVertex[offset++] = rot.w;
                    break;
                case 1:
                    break;
                default:
                    throw new Error("ShurikenParticleMaterial: SimulationSpace value is invalid.");
            }
            offset = startIndex + this._simulationUV_Index;
            this._instanceVertex[offset++] = startU;
            this._instanceVertex[offset++] = startV;
            this._instanceVertex[offset++] = subU;
            this._instanceVertex[offset++] = subV;
            this._firstFreeElement = nextFreeParticle;
            return true;
        }
        addNewParticlesToVertexBuffer() {
            let byteStride = this._floatCountPerParticleData * 4;
            if (this._firstActiveElement < this._firstFreeElement) {
                let start = this._firstActiveElement * byteStride;
                this._instanceParticleVertexBuffer.setData(this._instanceVertex.buffer, 0, start, (this._firstFreeElement - this._firstActiveElement) * byteStride);
            }
            else {
                let start = this._firstActiveElement * byteStride;
                let a = this._bufferMaxParticles - this._firstActiveElement;
                this._instanceParticleVertexBuffer.setData(this._instanceVertex.buffer, 0, start, a * byteStride);
                if (this._firstFreeElement > 0) {
                    this._instanceParticleVertexBuffer.setData(this._instanceVertex.buffer, a * byteStride, 0, this._firstFreeElement * byteStride);
                }
            }
            this._firstNewElement = this._firstFreeElement;
        }
        _updateRenderParams(stage) {
            this.clearRenderParams();
            if (this._firstActiveElement < this._firstFreeElement) {
                let indexCount = this._firstFreeElement - this._firstActiveElement;
                this.setDrawElemenParams(this._meshIndexCount, 0);
                this.instanceCount = indexCount;
            }
            else {
                let indexCount = this._bufferMaxParticles - this._firstActiveElement;
                if (this._firstFreeElement > 0) {
                    indexCount += this._firstFreeElement;
                }
                this.setDrawElemenParams(this._meshIndexCount, 0);
                this.instanceCount = indexCount;
            }
        }
        destroy() {
            super.destroy();
            if (this._indexBuffer) {
                this._indexBuffer.destroy();
            }
            if (this._vertexBuffer) {
                this._vertexBuffer.destroy();
            }
            if (this._instanceParticleVertexBuffer) {
                this._instanceParticleVertexBuffer.destroy();
            }
            this._instanceVertex = null;
            this._meshIndexCount = null;
            this._meshFloatCountPreVertex = null;
        }
    }

    class ShurikenParticleMaterial extends Material {
        constructor() {
            super();
            this.setShaderName("PARTICLESHURIKEN");
            this.renderMode = ShurikenParticleMaterial.RENDERMODE_ALPHABLENDED;
        }
        static __initDefine__() {
            ShurikenParticleMaterial.SHADERDEFINE_DIFFUSEMAP = Laya.Shader3D.getDefineByName("DIFFUSEMAP");
            ShurikenParticleMaterial.SHADERDEFINE_TINTCOLOR = Laya.Shader3D.getDefineByName("TINTCOLOR");
            ShurikenParticleMaterial.SHADERDEFINE_ADDTIVEFOG = Laya.Shader3D.getDefineByName("ADDTIVEFOG");
            ShurikenParticleMaterial.DIFFUSETEXTURE = Laya.Shader3D.propertyNameToID("u_texture");
            ShurikenParticleMaterial.TINTCOLOR = Laya.Shader3D.propertyNameToID("u_Tintcolor");
            ShurikenParticleMaterial.TILINGOFFSET = Laya.Shader3D.propertyNameToID("u_TilingOffset");
        }
        get color() {
            return this._shaderValues.getColor(ShurikenParticleMaterial.TINTCOLOR);
        }
        set color(value) {
            if (value)
                this._shaderValues.addDefine(ShurikenParticleMaterial.SHADERDEFINE_TINTCOLOR);
            else
                this._shaderValues.removeDefine(ShurikenParticleMaterial.SHADERDEFINE_TINTCOLOR);
            this._shaderValues.setColor(ShurikenParticleMaterial.TINTCOLOR, value);
        }
        get tilingOffset() {
            return this._shaderValues.getVector(ShurikenParticleMaterial.TILINGOFFSET);
        }
        set tilingOffset(value) {
            if (value) {
                this._shaderValues.setVector(ShurikenParticleMaterial.TILINGOFFSET, value);
            }
            else {
                this._shaderValues.getVector(ShurikenParticleMaterial.TILINGOFFSET).setValue(1.0, 1.0, 0.0, 0.0);
            }
        }
        get texture() {
            return this._shaderValues.getTexture(ShurikenParticleMaterial.DIFFUSETEXTURE);
        }
        set texture(value) {
            if (value)
                this._shaderValues.addDefine(ShurikenParticleMaterial.SHADERDEFINE_DIFFUSEMAP);
            else
                this._shaderValues.removeDefine(ShurikenParticleMaterial.SHADERDEFINE_DIFFUSEMAP);
            this._shaderValues.setTexture(ShurikenParticleMaterial.DIFFUSETEXTURE, value);
        }
        clone() {
            var dest = new ShurikenParticleMaterial();
            this.cloneTo(dest);
            return dest;
        }
        set renderMode(value) {
            switch (value) {
                case ShurikenParticleMaterial.RENDERMODE_ADDTIVE:
                    this.renderQueue = Material.RENDERQUEUE_TRANSPARENT;
                    this.depthWrite = false;
                    this.cull = Laya.RenderState.CULL_NONE;
                    this.blend = Laya.RenderState.BLEND_ENABLE_ALL;
                    this.blendSrc = Laya.RenderState.BLENDPARAM_SRC_ALPHA;
                    this.blendDst = Laya.RenderState.BLENDPARAM_ONE;
                    this.alphaTest = false;
                    this._shaderValues.addDefine(ShurikenParticleMaterial.SHADERDEFINE_ADDTIVEFOG);
                    break;
                case ShurikenParticleMaterial.RENDERMODE_ALPHABLENDED:
                    this.renderQueue = Material.RENDERQUEUE_TRANSPARENT;
                    this.depthWrite = false;
                    this.cull = Laya.RenderState.CULL_NONE;
                    this.blend = Laya.RenderState.BLEND_ENABLE_ALL;
                    this.blendSrc = Laya.RenderState.BLENDPARAM_SRC_ALPHA;
                    this.blendDst = Laya.RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA;
                    this.alphaTest = false;
                    this._shaderValues.removeDefine(ShurikenParticleMaterial.SHADERDEFINE_ADDTIVEFOG);
                    break;
                default:
                    throw new Error("ShurikenParticleMaterial : renderMode value error.");
            }
        }
        get tilingOffsetX() {
            return this._MainTex_STX;
        }
        set tilingOffsetX(x) {
            this._MainTex_STX = x;
        }
        get tilingOffsetY() {
            return this._MainTex_STY;
        }
        set tilingOffsetY(y) {
            this._MainTex_STY = y;
        }
        get tilingOffsetZ() {
            return this._MainTex_STZ;
        }
        set tilingOffsetZ(z) {
            this._MainTex_STZ = z;
        }
        get tilingOffsetW() {
            return this._MainTex_STW;
        }
        set tilingOffsetW(w) {
            this._MainTex_STW = w;
        }
        get _TintColor() {
            return this.color;
        }
        set _TintColor(value) {
            this.color = value;
        }
        get _TintColorR() {
            return this.color.r;
        }
        set _TintColorR(value) {
            this.color.r = value;
        }
        get _TintColorG() {
            return this.color.g;
        }
        set _TintColorG(value) {
            this.color.g = value;
        }
        get _TintColorB() {
            return this.color.b;
        }
        set _TintColorB(value) {
            this.color.b = value;
        }
        get _TintColorA() {
            return this.color.a;
        }
        set _TintColorA(value) {
            this.color.a = value;
        }
        get _MainTex_ST() {
            return this._shaderValues.getVector(ShurikenParticleMaterial.TILINGOFFSET);
        }
        set _MainTex_ST(value) {
            var tilOff = this._shaderValues.getVector(ShurikenParticleMaterial.TILINGOFFSET);
            tilOff.setValue(value.x, value.y, value.z, value.w);
            this.tilingOffset = tilOff;
        }
        get _MainTex_STX() {
            return this._shaderValues.getVector(ShurikenParticleMaterial.TILINGOFFSET).x;
        }
        set _MainTex_STX(x) {
            var tilOff = this._shaderValues.getVector(ShurikenParticleMaterial.TILINGOFFSET);
            tilOff.x = x;
            this.tilingOffset = tilOff;
        }
        get _MainTex_STY() {
            return this._shaderValues.getVector(ShurikenParticleMaterial.TILINGOFFSET).y;
        }
        set _MainTex_STY(y) {
            var tilOff = this._shaderValues.getVector(ShurikenParticleMaterial.TILINGOFFSET);
            tilOff.y = y;
            this.tilingOffset = tilOff;
        }
        get _MainTex_STZ() {
            return this._shaderValues.getVector(ShurikenParticleMaterial.TILINGOFFSET).z;
        }
        set _MainTex_STZ(z) {
            var tilOff = this._shaderValues.getVector(ShurikenParticleMaterial.TILINGOFFSET);
            tilOff.z = z;
            this.tilingOffset = tilOff;
        }
        get _MainTex_STW() {
            return this._shaderValues.getVector(ShurikenParticleMaterial.TILINGOFFSET).w;
        }
        set _MainTex_STW(w) {
            var tilOff = this._shaderValues.getVector(ShurikenParticleMaterial.TILINGOFFSET);
            tilOff.w = w;
            this.tilingOffset = tilOff;
        }
        get colorR() {
            return this._TintColorR;
        }
        set colorR(value) {
            this._TintColorR = value;
        }
        get colorG() {
            return this._TintColorG;
        }
        set colorG(value) {
            this._TintColorG = value;
        }
        get colorB() {
            return this._TintColorB;
        }
        set colorB(value) {
            this._TintColorB = value;
        }
        get colorA() {
            return this._TintColorA;
        }
        set colorA(value) {
            this._TintColorA = value;
        }
    }
    ShurikenParticleMaterial.RENDERMODE_ALPHABLENDED = 0;
    ShurikenParticleMaterial.RENDERMODE_ADDTIVE = 1;

    class ShurikenParticleRenderer extends BaseRender {
        constructor() {
            super();
            this._finalGravity = new Laya.Vector3();
            this._dragConstant = new Laya.Vector2();
            this._mesh = null;
            this.stretchedBillboardCameraSpeedScale = 0;
            this.stretchedBillboardSpeedScale = 0;
            this.stretchedBillboardLengthScale = 2;
            this.renderMode = 0;
            this._supportOctree = false;
        }
        get particleSystem() {
            return this._particleSystem;
        }
        get renderMode() {
            return this._renderMode;
        }
        set renderMode(value) {
            if (this._renderMode !== value) {
                var defineDatas = this._shaderValues;
                switch (this._renderMode) {
                    case 0:
                        defineDatas.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_RENDERMODE_BILLBOARD);
                        break;
                    case 1:
                        defineDatas.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_RENDERMODE_STRETCHEDBILLBOARD);
                        break;
                    case 2:
                        defineDatas.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_RENDERMODE_HORIZONTALBILLBOARD);
                        break;
                    case 3:
                        defineDatas.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_RENDERMODE_VERTICALBILLBOARD);
                        break;
                    case 4:
                        defineDatas.removeDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_RENDERMODE_MESH);
                        break;
                }
                this._renderMode = value;
                switch (value) {
                    case 0:
                        defineDatas.addDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_RENDERMODE_BILLBOARD);
                        break;
                    case 1:
                        defineDatas.addDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_RENDERMODE_STRETCHEDBILLBOARD);
                        break;
                    case 2:
                        defineDatas.addDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_RENDERMODE_HORIZONTALBILLBOARD);
                        break;
                    case 3:
                        defineDatas.addDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_RENDERMODE_VERTICALBILLBOARD);
                        break;
                    case 4:
                        defineDatas.addDefine(ShuriKenParticle3DShaderDeclaration.SHADERDEFINE_RENDERMODE_MESH);
                        break;
                    default:
                        throw new Error("ShurikenParticleRender: unknown renderMode Value.");
                }
                var parSys = this._particleSystem;
                (parSys) && (parSys._initBufferDatas());
            }
        }
        get mesh() {
            return this._mesh;
        }
        set mesh(value) {
            if (this._mesh !== value) {
                (this._mesh) && (this._mesh._removeReference());
                this._mesh = value;
                (value) && (value._addReference());
                this._particleSystem._initBufferDatas();
            }
        }
        _onAdded() {
            super._onAdded();
            if (!Laya.LayaGL.renderEngine.getCapable(Laya.RenderCapable.DrawElement_Instance)) {
                this._particleSystem = new ShurikenParticleSystem(this);
            }
            else
                this._particleSystem = new ShurikenParticleInstanceSystem(this);
            var elements = this._renderElements;
            var element = elements[0] = new RenderElement();
            element.setTransform(this.owner._transform);
            element.render = this;
            element.setGeometry(this._particleSystem);
            element.material = ShurikenParticleMaterial.defaultMaterial;
        }
        _onEnable() {
            super._onEnable();
            Laya.Stat.particleRenderNode++;
            (this._particleSystem.playOnAwake && Laya.LayaEnv.isPlaying) && (this._particleSystem.play());
        }
        _onDisable() {
            super._onDisable();
            Laya.Stat.particleRenderNode--;
            (this._particleSystem.isAlive) && (this._particleSystem.simulate(0, true));
        }
        _calculateBoundingBox() {
            var particleSystem = this._particleSystem;
            var bounds;
            if (particleSystem._useCustomBounds) {
                bounds = particleSystem.customBounds;
                bounds._tranform(this.owner.transform.worldMatrix, this._bounds);
            }
            else if (particleSystem._simulationSupported()) {
                particleSystem._generateBounds();
                bounds = particleSystem._bounds;
                bounds._tranform(this.owner.transform.worldMatrix, this._bounds);
                if (particleSystem.gravityModifier != 0) {
                    var max = this._bounds.getMax();
                    var min = this._bounds.getMin();
                    var gravityOffset = particleSystem._gravityOffset;
                    max.y -= gravityOffset.x;
                    min.y -= gravityOffset.y;
                    this._bounds.setMax(max);
                    this._bounds.setMin(min);
                }
            }
            else {
                var min = this._bounds.getMin();
                min.setValue(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
                this._bounds.setMin(min);
                var max = this._bounds.getMax();
                max.setValue(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
                this._bounds.setMax(max);
            }
        }
        _needRender(boundFrustum, context) {
            if (!Laya.Stat.enableParticle)
                return false;
            if (boundFrustum) {
                if (boundFrustum.intersects(this.bounds)) {
                    if (this._particleSystem.isAlive)
                        return true;
                    else
                        return false;
                }
                else {
                    return false;
                }
            }
            else {
                return true;
            }
        }
        _renderUpdate(context, transfrom) {
            var particleSystem = this._particleSystem;
            var sv = this._shaderValues;
            var transform = this.owner.transform;
            switch (particleSystem.simulationSpace) {
                case 0:
                    break;
                case 1:
                    sv.setVector3(ShuriKenParticle3DShaderDeclaration.WORLDPOSITION, transform.position);
                    sv.setShaderData(ShuriKenParticle3DShaderDeclaration.WORLDROTATION, Laya.ShaderDataType.Vector4, transform.rotation);
                    break;
                default:
                    throw new Error("ShurikenParticleMaterial: SimulationSpace value is invalid.");
            }
            switch (particleSystem.scaleMode) {
                case 0:
                    var scale = transform.getWorldLossyScale();
                    sv.setVector3(ShuriKenParticle3DShaderDeclaration.POSITIONSCALE, scale);
                    sv.setVector3(ShuriKenParticle3DShaderDeclaration.SIZESCALE, scale);
                    break;
                case 1:
                    var localScale = transform.localScale;
                    sv.setVector3(ShuriKenParticle3DShaderDeclaration.POSITIONSCALE, localScale);
                    sv.setVector3(ShuriKenParticle3DShaderDeclaration.SIZESCALE, localScale);
                    break;
                case 2:
                    sv.setVector3(ShuriKenParticle3DShaderDeclaration.POSITIONSCALE, transform.getWorldLossyScale());
                    sv.setVector3(ShuriKenParticle3DShaderDeclaration.SIZESCALE, Laya.Vector3.ONE);
                    break;
            }
            switch (particleSystem.dragType) {
                case 0:
                    this._dragConstant.setValue(particleSystem.dragSpeedConstantMin, particleSystem.dragSpeedConstantMin);
                    sv.setVector2(ShuriKenParticle3DShaderDeclaration.DRAG, this._dragConstant);
                    break;
                case 2:
                    this._dragConstant.setValue(particleSystem.dragSpeedConstantMin, particleSystem.dragSpeedConstantMax);
                    sv.setVector2(ShuriKenParticle3DShaderDeclaration.DRAG, this._dragConstant);
                    break;
                default:
                    this._dragConstant.setValue(0, 0);
                    break;
            }
            Laya.Vector3.scale(Physics3DUtils.gravity, particleSystem.gravityModifier, this._finalGravity);
            sv.setVector3(ShuriKenParticle3DShaderDeclaration.GRAVITY, this._finalGravity);
            sv.setInt(ShuriKenParticle3DShaderDeclaration.SIMULATIONSPACE, particleSystem.simulationSpace);
            sv.setBool(ShuriKenParticle3DShaderDeclaration.THREEDSTARTROTATION, particleSystem.threeDStartRotation);
            sv.setInt(ShuriKenParticle3DShaderDeclaration.SCALINGMODE, particleSystem.scaleMode);
            sv.setNumber(ShuriKenParticle3DShaderDeclaration.STRETCHEDBILLBOARDLENGTHSCALE, this.stretchedBillboardLengthScale);
            sv.setNumber(ShuriKenParticle3DShaderDeclaration.STRETCHEDBILLBOARDSPEEDSCALE, this.stretchedBillboardSpeedScale);
            sv.setNumber(ShuriKenParticle3DShaderDeclaration.CURRENTTIME, particleSystem._currentTime);
        }
        get bounds() {
            if (this.boundsChange) {
                this._calculateBoundingBox();
                this.boundsChange = false;
            }
            return this._bounds;
        }
        _cloneTo(dest) {
            let parRender = dest;
            this._particleSystem.cloneTo(parRender._particleSystem);
            parRender.sharedMaterial = this.sharedMaterial;
            parRender.renderMode = this.renderMode;
            parRender.mesh = this.mesh;
            parRender.stretchedBillboardCameraSpeedScale = this.stretchedBillboardCameraSpeedScale;
            parRender.stretchedBillboardSpeedScale = this.stretchedBillboardSpeedScale;
            parRender.stretchedBillboardLengthScale = this.stretchedBillboardLengthScale;
            parRender.sortingFudge = this.sortingFudge;
        }
        _onDestroy() {
            (this._mesh) && (this._mesh._removeReference(), this._mesh = null);
            this._particleSystem.destroy();
            this._particleSystem = null;
            super._onDestroy();
        }
    }

    class ShuriKenParticle3D extends RenderableSprite3D {
        constructor() {
            super(null);
            this._render = this.addComponent(ShurikenParticleRenderer);
            this._particleSystem = this._render._particleSystem;
        }
        get particleSystem() {
            return this._particleSystem;
        }
        get particleRenderer() {
            return this._render;
        }
        _parseModule(module, moduleData) {
            for (var t in moduleData) {
                switch (t) {
                    case "bases":
                        var bases = moduleData.bases;
                        for (var k in bases)
                            module[k] = bases[k];
                        break;
                    case "vector2s":
                        var vector2s = moduleData.vector2s;
                        for (var k in vector2s) {
                            var vec2 = module[k];
                            var vec2Data = vector2s[k];
                            vec2.setValue(vec2Data[0], vec2Data[1]);
                            module[k] = vec2;
                        }
                        break;
                    case "vector3s":
                        var vector3s = moduleData.vector3s;
                        for (var k in vector3s) {
                            var vec3 = module[k];
                            var vec3Data = vector3s[k];
                            vec3.setValue(vec3Data[0], vec3Data[1], vec3Data[2]);
                            module[k] = vec3;
                        }
                        break;
                    case "vector4s":
                        var vector4s = moduleData.vector4s;
                        for (var k in vector4s) {
                            var vec4 = module[k];
                            var vec4Data = vector4s[k];
                            vec4.setValue(vec4Data[0], vec4Data[1], vec4Data[2], vec4Data[3]);
                            module[k] = vec4;
                        }
                        break;
                    case "gradientDataNumbers":
                        var gradientDataNumbers = moduleData.gradientDataNumbers;
                        for (var k in gradientDataNumbers) {
                            var gradientNumber = module[k];
                            var gradientNumberData = moduleData[k];
                            for (var i = 0, n = gradientNumberData.length; i < n; i++) {
                                var valueData = gradientNumberData[i];
                                gradientNumber.add(valueData.key, valueData.value);
                            }
                            module[k] = gradientNumber;
                        }
                        break;
                    case "resources":
                        var resources = moduleData.resources;
                        for (var k in resources) {
                            let res = Laya.Loader.getRes(resources[k]);
                            if (res && (res instanceof Laya.Texture)) {
                                res = res.bitmap;
                            }
                            module[k] = res;
                        }
                        break;
                    case "bursts":
                        var burstsData = moduleData.bursts;
                        for (var i = 0, n = burstsData.length; i < n; i++) {
                            var brust = burstsData[i];
                            module.addBurst(new Burst(brust.time, brust.min, brust.max));
                        }
                        break;
                    case "randomSeed":
                        module.randomSeed[0] = moduleData.randomSeed;
                        break;
                    case "shapeType":
                    case "type":
                    case "color":
                    case "size":
                    case "frame":
                    case "startFrame":
                    case "angularVelocity":
                    case "velocity":
                        break;
                    default:
                        throw "ShurikenParticle3D:unknown type.";
                }
            }
        }
        _parse(data, spriteMap) {
            super._parse(data, spriteMap);
            if (data.main) {
                var particleSystem = this.particleSystem;
                var particleRender = this.particleRenderer;
                this._parseModule(particleRender, data.renderer);
                this._parseModule(particleSystem, data.main);
                this._parseModule(particleSystem.emission, data.emission);
                var shapeData = data.shape;
                if (shapeData) {
                    var shape;
                    switch (shapeData.shapeType) {
                        case 0:
                            shape = new SphereShape();
                            break;
                        case 1:
                            shape = new HemisphereShape();
                            break;
                        case 2:
                            shape = new ConeShape();
                            break;
                        case 3:
                            shape = new BoxShape();
                            break;
                        case 7:
                            shape = new CircleShape();
                            break;
                        default:
                            throw "ShuriKenParticle3D:unknown shape type.";
                    }
                    this._parseModule(shape, shapeData);
                    particleSystem.shape = shape;
                }
                var velocityOverLifetimeData = data.velocityOverLifetime;
                if (velocityOverLifetimeData) {
                    var velocityData = velocityOverLifetimeData.velocity;
                    var velocity;
                    switch (velocityData.type) {
                        case 0:
                            var constantData = velocityData.constant;
                            velocity = GradientVelocity.createByConstant(constantData ? new Laya.Vector3(constantData[0], constantData[1], constantData[2]) : new Laya.Vector3(0, 0, 0));
                            break;
                        case 1:
                            velocity = GradientVelocity.createByGradient(this._initParticleVelocity(velocityData.gradientX), this._initParticleVelocity(velocityData.gradientY), this._initParticleVelocity(velocityData.gradientZ));
                            break;
                        case 2:
                            var constantMinData = velocityData.constantMin;
                            var constantMaxData = velocityData.constantMax;
                            velocity = GradientVelocity.createByRandomTwoConstant(constantMinData ? new Laya.Vector3(constantMinData[0], constantMinData[1], constantMinData[2]) : new Laya.Vector3(0, 0, 0), constantMaxData ? new Laya.Vector3(constantMaxData[0], constantMaxData[1], constantMaxData[2]) : new Laya.Vector3(0, 0, 0));
                            break;
                        case 3:
                            velocity = GradientVelocity.createByRandomTwoGradient(this._initParticleVelocity(velocityData.gradientXMin), this._initParticleVelocity(velocityData.gradientXMax), this._initParticleVelocity(velocityData.gradientYMin), this._initParticleVelocity(velocityData.gradientYMax), this._initParticleVelocity(velocityData.gradientZMin), this._initParticleVelocity(velocityData.gradientZMax));
                            break;
                    }
                    var velocityOverLifetime = new VelocityOverLifetime(velocity);
                    this._parseModule(velocityOverLifetime, velocityOverLifetimeData);
                    particleSystem.velocityOverLifetime = velocityOverLifetime;
                }
                var colorOverLifetimeData = data.colorOverLifetime;
                if (colorOverLifetimeData) {
                    var colorData = colorOverLifetimeData.color;
                    let maxKeyCount = colorData.maxKeyCount;
                    var color;
                    switch (colorData.type) {
                        case 0:
                            var constColorData = colorData.constant;
                            color = GradientColor.createByConstant(constColorData ? new Laya.Vector4(constColorData[0], constColorData[1], constColorData[2], constColorData[3]) : new Laya.Vector4(0, 0, 0, 0));
                            break;
                        case 1:
                            color = GradientColor.createByGradient(this._initParticleColor(colorData.gradient, maxKeyCount));
                            break;
                        case 2:
                            var minConstColorData = colorData.constantMin;
                            var maxConstColorData = colorData.constantMax;
                            color = GradientColor.createByRandomTwoConstant(minConstColorData ? new Laya.Vector4(minConstColorData[0], minConstColorData[1], minConstColorData[2], minConstColorData[3]) : new Laya.Vector4(0, 0, 0, 0), minConstColorData ? new Laya.Vector4(maxConstColorData[0], maxConstColorData[1], maxConstColorData[2], maxConstColorData[3]) : new Laya.Vector4(0, 0, 0, 0));
                            break;
                        case 3:
                            color = GradientColor.createByRandomTwoGradient(this._initParticleColor(colorData.gradientMin, maxKeyCount), this._initParticleColor(colorData.gradientMax, maxKeyCount));
                            break;
                    }
                    var colorOverLifetime = new ColorOverLifetime(color);
                    this._parseModule(colorOverLifetime, colorOverLifetimeData);
                    particleSystem.colorOverLifetime = colorOverLifetime;
                }
                var sizeOverLifetimeData = data.sizeOverLifetime;
                if (sizeOverLifetimeData) {
                    var sizeData = sizeOverLifetimeData.size;
                    var size;
                    switch (sizeData.type) {
                        case 0:
                            if (sizeData.separateAxes) {
                                size = GradientSize.createByGradientSeparate(this._initParticleSize(sizeData.gradientX), this._initParticleSize(sizeData.gradientY), this._initParticleSize(sizeData.gradientZ));
                            }
                            else {
                                size = GradientSize.createByGradient(this._initParticleSize(sizeData.gradient));
                            }
                            break;
                        case 1:
                            if (sizeData.separateAxes) {
                                var constantMinSeparateData = sizeData.constantMinSeparate;
                                var constantMaxSeparateData = sizeData.constantMaxSeparate;
                                size = GradientSize.createByRandomTwoConstantSeparate(constantMinSeparateData ? new Laya.Vector3(constantMinSeparateData[0], constantMinSeparateData[1], constantMinSeparateData[2]) : new Laya.Vector3(0, 0, 0), constantMaxSeparateData ? new Laya.Vector3(constantMaxSeparateData[0], constantMaxSeparateData[1], constantMaxSeparateData[2]) : new Laya.Vector3(0, 0, 0));
                            }
                            else {
                                size = GradientSize.createByRandomTwoConstant(sizeData.constantMin || 0, sizeData.constantMax || 0);
                            }
                            break;
                        case 2:
                            if (sizeData.separateAxes) {
                                size = GradientSize.createByRandomTwoGradientSeparate(this._initParticleSize(sizeData.gradientXMin), this._initParticleSize(sizeData.gradientYMin), this._initParticleSize(sizeData.gradientZMin), this._initParticleSize(sizeData.gradientXMax), this._initParticleSize(sizeData.gradientYMax), this._initParticleSize(sizeData.gradientZMax));
                            }
                            else {
                                size = GradientSize.createByRandomTwoGradient(this._initParticleSize(sizeData.gradientMin), this._initParticleSize(sizeData.gradientMax));
                            }
                            break;
                    }
                    var sizeOverLifetime = new SizeOverLifetime(size);
                    this._parseModule(sizeOverLifetime, sizeOverLifetimeData);
                    particleSystem.sizeOverLifetime = sizeOverLifetime;
                }
                var rotationOverLifetimeData = data.rotationOverLifetime;
                if (rotationOverLifetimeData) {
                    var angularVelocityData = rotationOverLifetimeData.angularVelocity;
                    var angularVelocity;
                    switch (angularVelocityData.type) {
                        case 0:
                            if (angularVelocityData.separateAxes) {
                                var conSep = angularVelocityData.constantSeparate;
                                angularVelocity = GradientAngularVelocity.createByConstantSeparate(conSep ? new Laya.Vector3(conSep[0], conSep[1], conSep[2]) : new Laya.Vector3(0, 0, Math.PI / 4));
                            }
                            else {
                                angularVelocity = GradientAngularVelocity.createByConstant(angularVelocityData.constant || Math.PI / 4);
                            }
                            break;
                        case 1:
                            if (angularVelocityData.separateAxes) {
                                angularVelocity = GradientAngularVelocity.createByGradientSeparate(this._initParticleRotation(angularVelocityData.gradientX), this._initParticleRotation(angularVelocityData.gradientY), this._initParticleRotation(angularVelocityData.gradientZ));
                            }
                            else {
                                angularVelocity = GradientAngularVelocity.createByGradient(this._initParticleRotation(angularVelocityData.gradient));
                            }
                            break;
                        case 2:
                            if (angularVelocityData.separateAxes) {
                                var minSep = angularVelocityData.constantMinSeparate;
                                var maxSep = angularVelocityData.constantMaxSeparate;
                                angularVelocity = GradientAngularVelocity.createByRandomTwoConstantSeparate(minSep ? new Laya.Vector3(minSep[0], minSep[1], minSep[2]) : new Laya.Vector3(0, 0, 0), maxSep ? new Laya.Vector3(maxSep[0], maxSep[1], maxSep[2]) : new Laya.Vector3(0, 0, Math.PI / 4));
                            }
                            else {
                                angularVelocity = GradientAngularVelocity.createByRandomTwoConstant(angularVelocityData.constantMin || 0, angularVelocityData.constantMax || Math.PI / 4);
                            }
                            break;
                        case 3:
                            if (angularVelocityData.separateAxes) ;
                            else {
                                angularVelocity = GradientAngularVelocity.createByRandomTwoGradient(this._initParticleRotation(angularVelocityData.gradientMin), this._initParticleRotation(angularVelocityData.gradientMax));
                            }
                            break;
                    }
                    var rotationOverLifetime = new RotationOverLifetime(angularVelocity);
                    this._parseModule(rotationOverLifetime, rotationOverLifetimeData);
                    particleSystem.rotationOverLifetime = rotationOverLifetime;
                }
                var textureSheetAnimationData = data.textureSheetAnimation;
                if (textureSheetAnimationData) {
                    var frameData = textureSheetAnimationData.frame;
                    var frameOverTime;
                    switch (frameData.type) {
                        case 0:
                            frameOverTime = FrameOverTime.createByConstant(frameData.constant);
                            break;
                        case 1:
                            frameOverTime = FrameOverTime.createByOverTime(this._initParticleFrame(frameData.overTime));
                            break;
                        case 2:
                            frameOverTime = FrameOverTime.createByRandomTwoConstant(frameData.constantMin, frameData.constantMax);
                            break;
                        case 3:
                            frameOverTime = FrameOverTime.createByRandomTwoOverTime(this._initParticleFrame(frameData.overTimeMin), this._initParticleFrame(frameData.overTimeMax));
                            break;
                    }
                    var startFrameData = textureSheetAnimationData.startFrame;
                    var startFrame;
                    switch (startFrameData.type) {
                        case 0:
                            startFrame = StartFrame.createByConstant(startFrameData.constant);
                            break;
                        case 1:
                            startFrame = StartFrame.createByRandomTwoConstant(startFrameData.constantMin, startFrameData.constantMax);
                            break;
                    }
                    var textureSheetAnimation = new TextureSheetAnimation(frameOverTime, startFrame);
                    this._parseModule(textureSheetAnimation, textureSheetAnimationData);
                    particleSystem.textureSheetAnimation = textureSheetAnimation;
                }
            }
            else {
                this._parseOld(data);
            }
        }
        destroy(destroyChild = true) {
            if (this._destroyed)
                return;
            super.destroy(destroyChild);
        }
        _create() {
            return new Sprite3D();
        }
        _parseOld(data) {
            const anglelToRad = Math.PI / 180.0;
            var i, n;
            var particleRender = this.particleRenderer;
            var material;
            var materialData = data.material;
            (materialData) && (material = Laya.Loader.getRes(materialData.path));
            particleRender.sharedMaterial = material;
            var meshPath = data.meshPath;
            (meshPath) && (particleRender.mesh = Laya.Loader.getRes(meshPath));
            particleRender.renderMode = data.renderMode;
            particleRender.stretchedBillboardCameraSpeedScale = data.stretchedBillboardCameraSpeedScale;
            particleRender.stretchedBillboardSpeedScale = data.stretchedBillboardSpeedScale;
            particleRender.stretchedBillboardLengthScale = data.stretchedBillboardLengthScale;
            particleRender.sortingFudge = data.sortingFudge ? data.sortingFudge : 0.0;
            var particleSystem = this.particleSystem;
            particleSystem.isPerformanceMode = data.isPerformanceMode;
            particleSystem.duration = data.duration;
            particleSystem.looping = data.looping;
            particleSystem.prewarm = data.prewarm;
            particleSystem.startDelayType = data.startDelayType;
            particleSystem.startDelay = data.startDelay;
            particleSystem.startDelayMin = data.startDelayMin;
            particleSystem.startDelayMax = data.startDelayMax;
            particleSystem.startLifetimeType = data.startLifetimeType;
            particleSystem.startLifetimeConstant = data.startLifetimeConstant;
            particleSystem.startLifeTimeGradient = ShuriKenParticle3D._initStartLife(data.startLifetimeGradient);
            particleSystem.startLifetimeConstantMin = data.startLifetimeConstantMin;
            particleSystem.startLifetimeConstantMax = data.startLifetimeConstantMax;
            particleSystem.startLifeTimeGradientMin = ShuriKenParticle3D._initStartLife(data.startLifetimeGradientMin);
            particleSystem.startLifeTimeGradientMax = ShuriKenParticle3D._initStartLife(data.startLifetimeGradientMax);
            particleSystem.startSpeedType = data.startSpeedType;
            particleSystem.startSpeedConstant = data.startSpeedConstant;
            particleSystem.startSpeedConstantMin = data.startSpeedConstantMin;
            particleSystem.startSpeedConstantMax = data.startSpeedConstantMax;
            particleSystem.threeDStartSize = data.threeDStartSize;
            particleSystem.startSizeType = data.startSizeType;
            particleSystem.startSizeConstant = data.startSizeConstant;
            var startSizeConstantSeparateArray = data.startSizeConstantSeparate;
            var startSizeConstantSeparateElement = particleSystem.startSizeConstantSeparate;
            startSizeConstantSeparateElement.x = startSizeConstantSeparateArray[0];
            startSizeConstantSeparateElement.y = startSizeConstantSeparateArray[1];
            startSizeConstantSeparateElement.z = startSizeConstantSeparateArray[2];
            particleSystem.startSizeConstantMin = data.startSizeConstantMin;
            particleSystem.startSizeConstantMax = data.startSizeConstantMax;
            var startSizeConstantMinSeparateArray = data.startSizeConstantMinSeparate;
            var startSizeConstantMinSeparateElement = particleSystem.startSizeConstantMinSeparate;
            startSizeConstantMinSeparateElement.x = startSizeConstantMinSeparateArray[0];
            startSizeConstantMinSeparateElement.y = startSizeConstantMinSeparateArray[1];
            startSizeConstantMinSeparateElement.z = startSizeConstantMinSeparateArray[2];
            var startSizeConstantMaxSeparateArray = data.startSizeConstantMaxSeparate;
            var startSizeConstantMaxSeparateElement = particleSystem.startSizeConstantMaxSeparate;
            startSizeConstantMaxSeparateElement.x = startSizeConstantMaxSeparateArray[0];
            startSizeConstantMaxSeparateElement.y = startSizeConstantMaxSeparateArray[1];
            startSizeConstantMaxSeparateElement.z = startSizeConstantMaxSeparateArray[2];
            particleSystem.threeDStartRotation = data.threeDStartRotation;
            particleSystem.startRotationType = data.startRotationType;
            particleSystem.startRotationConstant = data.startRotationConstant * anglelToRad;
            var startRotationConstantSeparateArray = data.startRotationConstantSeparate;
            var startRotationConstantSeparateElement = particleSystem.startRotationConstantSeparate;
            startRotationConstantSeparateElement.x = startRotationConstantSeparateArray[0] * anglelToRad;
            startRotationConstantSeparateElement.y = startRotationConstantSeparateArray[1] * anglelToRad;
            startRotationConstantSeparateElement.z = startRotationConstantSeparateArray[2] * anglelToRad;
            particleSystem.startRotationConstantMin = data.startRotationConstantMin * anglelToRad;
            particleSystem.startRotationConstantMax = data.startRotationConstantMax * anglelToRad;
            var startRotationConstantMinSeparateArray = data.startRotationConstantMinSeparate;
            var startRotationConstantMinSeparateElement = particleSystem.startRotationConstantMinSeparate;
            startRotationConstantMinSeparateElement.x = startRotationConstantMinSeparateArray[0] * anglelToRad;
            startRotationConstantMinSeparateElement.y = startRotationConstantMinSeparateArray[1] * anglelToRad;
            startRotationConstantMinSeparateElement.z = startRotationConstantMinSeparateArray[2] * anglelToRad;
            var startRotationConstantMaxSeparateArray = data.startRotationConstantMaxSeparate;
            var startRotationConstantMaxSeparateElement = particleSystem.startRotationConstantMaxSeparate;
            startRotationConstantMaxSeparateElement.x = startRotationConstantMaxSeparateArray[0] * anglelToRad;
            startRotationConstantMaxSeparateElement.y = startRotationConstantMaxSeparateArray[1] * anglelToRad;
            startRotationConstantMaxSeparateElement.z = startRotationConstantMaxSeparateArray[2] * anglelToRad;
            particleSystem.randomizeRotationDirection = data.randomizeRotationDirection;
            particleSystem.startColorType = data.startColorType;
            var startColorConstantArray = data.startColorConstant;
            var startColorConstantElement = particleSystem.startColorConstant;
            startColorConstantElement.x = startColorConstantArray[0];
            startColorConstantElement.y = startColorConstantArray[1];
            startColorConstantElement.z = startColorConstantArray[2];
            startColorConstantElement.w = startColorConstantArray[3];
            var startColorConstantMinArray = data.startColorConstantMin;
            var startColorConstantMinElement = particleSystem.startColorConstantMin;
            startColorConstantMinElement.x = startColorConstantMinArray[0];
            startColorConstantMinElement.y = startColorConstantMinArray[1];
            startColorConstantMinElement.z = startColorConstantMinArray[2];
            startColorConstantMinElement.w = startColorConstantMinArray[3];
            var startColorConstantMaxArray = data.startColorConstantMax;
            var startColorConstantMaxElement = particleSystem.startColorConstantMax;
            startColorConstantMaxElement.x = startColorConstantMaxArray[0];
            startColorConstantMaxElement.y = startColorConstantMaxArray[1];
            startColorConstantMaxElement.z = startColorConstantMaxArray[2];
            startColorConstantMaxElement.w = startColorConstantMaxArray[3];
            particleSystem.gravityModifier = data.gravityModifier;
            particleSystem.simulationSpace = data.simulationSpace;
            (data.simulationSpeed !== undefined) && (particleSystem.simulationSpeed = data.simulationSpeed);
            particleSystem.scaleMode = data.scaleMode;
            particleSystem.playOnAwake = data.playOnAwake;
            particleSystem.maxParticles = data.maxParticles;
            var autoRandomSeed = data.autoRandomSeed;
            (autoRandomSeed != null) && (particleSystem.autoRandomSeed = autoRandomSeed);
            var randomSeed = data.randomSeed;
            (randomSeed != null) && (particleSystem.randomSeed[0] = randomSeed);
            var emissionData = data.emission;
            var emission = particleSystem.emission;
            if (emissionData) {
                emission.emissionRate = emissionData.emissionRate;
                var burstsData = emissionData.bursts;
                if (burstsData)
                    for (i = 0, n = burstsData.length; i < n; i++) {
                        var brust = burstsData[i];
                        emission.addBurst(new Burst(brust.time, brust.min, brust.max));
                    }
                emission.enable = emissionData.enable;
            }
            else {
                emission.enable = false;
            }
            var shapeData = data.shape;
            if (shapeData) {
                var shape;
                switch (shapeData.shapeType) {
                    case 0:
                        var sphereShape;
                        shape = sphereShape = new SphereShape();
                        sphereShape.radius = shapeData.sphereRadius;
                        sphereShape.emitFromShell = shapeData.sphereEmitFromShell;
                        sphereShape.randomDirection = shapeData.sphereRandomDirection;
                        break;
                    case 1:
                        var hemiSphereShape;
                        shape = hemiSphereShape = new HemisphereShape();
                        hemiSphereShape.radius = shapeData.hemiSphereRadius;
                        hemiSphereShape.emitFromShell = shapeData.hemiSphereEmitFromShell;
                        hemiSphereShape.randomDirection = shapeData.hemiSphereRandomDirection;
                        break;
                    case 2:
                        var coneShape;
                        shape = coneShape = new ConeShape();
                        coneShape.angle = shapeData.coneAngle * anglelToRad;
                        coneShape.radius = shapeData.coneRadius;
                        coneShape.length = shapeData.coneLength;
                        coneShape.emitType = shapeData.coneEmitType;
                        coneShape.randomDirection = shapeData.coneRandomDirection;
                        break;
                    case 3:
                        var boxShape;
                        shape = boxShape = new BoxShape();
                        boxShape.x = shapeData.boxX;
                        boxShape.y = shapeData.boxY;
                        boxShape.z = shapeData.boxZ;
                        boxShape.randomDirection = shapeData.boxRandomDirection;
                        break;
                    case 7:
                        var circleShape;
                        shape = circleShape = new CircleShape();
                        circleShape.radius = shapeData.circleRadius;
                        circleShape.arc = shapeData.circleArc * anglelToRad;
                        circleShape.emitFromEdge = shapeData.circleEmitFromEdge;
                        circleShape.randomDirection = shapeData.circleRandomDirection;
                        break;
                    default:
                        var tempShape;
                        shape = tempShape = new CircleShape();
                        tempShape.radius = shapeData.circleRadius;
                        tempShape.arc = shapeData.circleArc * anglelToRad;
                        tempShape.emitFromEdge = shapeData.circleEmitFromEdge;
                        tempShape.randomDirection = shapeData.circleRandomDirection;
                        break;
                }
                shape.enable = shapeData.enable;
                particleSystem.shape = shape;
            }
            var velocityOverLifetimeData = data.velocityOverLifetime;
            if (velocityOverLifetimeData) {
                var velocityData = velocityOverLifetimeData.velocity;
                var velocity;
                switch (velocityData.type) {
                    case 0:
                        var constantData = velocityData.constant;
                        velocity = GradientVelocity.createByConstant(new Laya.Vector3(constantData[0], constantData[1], constantData[2]));
                        break;
                    case 1:
                        velocity = GradientVelocity.createByGradient(this._initParticleVelocity(velocityData.gradientX), this._initParticleVelocity(velocityData.gradientY), this._initParticleVelocity(velocityData.gradientZ));
                        break;
                    case 2:
                        var constantMinData = velocityData.constantMin;
                        var constantMaxData = velocityData.constantMax;
                        velocity = GradientVelocity.createByRandomTwoConstant(new Laya.Vector3(constantMinData[0], constantMinData[1], constantMinData[2]), new Laya.Vector3(constantMaxData[0], constantMaxData[1], constantMaxData[2]));
                        break;
                    case 3:
                        velocity = GradientVelocity.createByRandomTwoGradient(this._initParticleVelocity(velocityData.gradientXMin), this._initParticleVelocity(velocityData.gradientXMax), this._initParticleVelocity(velocityData.gradientYMin), this._initParticleVelocity(velocityData.gradientYMax), this._initParticleVelocity(velocityData.gradientZMin), this._initParticleVelocity(velocityData.gradientZMax));
                        break;
                }
                var velocityOverLifetime = new VelocityOverLifetime(velocity);
                velocityOverLifetime.space = velocityOverLifetimeData.space;
                velocityOverLifetime.enable = velocityOverLifetimeData.enable;
                particleSystem.velocityOverLifetime = velocityOverLifetime;
            }
            var colorOverLifetimeData = data.colorOverLifetime;
            if (colorOverLifetimeData) {
                var colorData = colorOverLifetimeData.color;
                var color;
                switch (colorData.type) {
                    case 0:
                        var constColorData = colorData.constant;
                        color = GradientColor.createByConstant(new Laya.Vector4(constColorData[0], constColorData[1], constColorData[2], constColorData[3]));
                        break;
                    case 1:
                        color = GradientColor.createByGradient(this._initParticleColor(colorData.gradient));
                        break;
                    case 2:
                        var minConstColorData = colorData.constantMin;
                        var maxConstColorData = colorData.constantMax;
                        color = GradientColor.createByRandomTwoConstant(new Laya.Vector4(minConstColorData[0], minConstColorData[1], minConstColorData[2], minConstColorData[3]), new Laya.Vector4(maxConstColorData[0], maxConstColorData[1], maxConstColorData[2], maxConstColorData[3]));
                        break;
                    case 3:
                        color = GradientColor.createByRandomTwoGradient(this._initParticleColor(colorData.gradientMin), this._initParticleColor(colorData.gradientMax));
                        break;
                }
                var colorOverLifetime = new ColorOverLifetime(color);
                colorOverLifetime.enable = colorOverLifetimeData.enable;
                particleSystem.colorOverLifetime = colorOverLifetime;
            }
            var sizeOverLifetimeData = data.sizeOverLifetime;
            if (sizeOverLifetimeData) {
                var sizeData = sizeOverLifetimeData.size;
                var size;
                switch (sizeData.type) {
                    case 0:
                        if (sizeData.separateAxes) {
                            size = GradientSize.createByGradientSeparate(this._initParticleSize(sizeData.gradientX), this._initParticleSize(sizeData.gradientY), this._initParticleSize(sizeData.gradientZ));
                        }
                        else {
                            size = GradientSize.createByGradient(this._initParticleSize(sizeData.gradient));
                        }
                        break;
                    case 1:
                        if (sizeData.separateAxes) {
                            var constantMinSeparateData = sizeData.constantMinSeparate;
                            var constantMaxSeparateData = sizeData.constantMaxSeparate;
                            size = GradientSize.createByRandomTwoConstantSeparate(new Laya.Vector3(constantMinSeparateData[0], constantMinSeparateData[1], constantMinSeparateData[2]), new Laya.Vector3(constantMaxSeparateData[0], constantMaxSeparateData[1], constantMaxSeparateData[2]));
                        }
                        else {
                            size = GradientSize.createByRandomTwoConstant(sizeData.constantMin, sizeData.constantMax);
                        }
                        break;
                    case 2:
                        if (sizeData.separateAxes) {
                            size = GradientSize.createByRandomTwoGradientSeparate(this._initParticleSize(sizeData.gradientXMin), this._initParticleSize(sizeData.gradientYMin), this._initParticleSize(sizeData.gradientZMin), this._initParticleSize(sizeData.gradientXMax), this._initParticleSize(sizeData.gradientYMax), this._initParticleSize(sizeData.gradientZMax));
                        }
                        else {
                            size = GradientSize.createByRandomTwoGradient(this._initParticleSize(sizeData.gradientMin), this._initParticleSize(sizeData.gradientMax));
                        }
                        break;
                }
                var sizeOverLifetime = new SizeOverLifetime(size);
                sizeOverLifetime.enable = sizeOverLifetimeData.enable;
                particleSystem.sizeOverLifetime = sizeOverLifetime;
            }
            var rotationOverLifetimeData = data.rotationOverLifetime;
            if (rotationOverLifetimeData) {
                var angularVelocityData = rotationOverLifetimeData.angularVelocity;
                var angularVelocity;
                switch (angularVelocityData.type) {
                    case 0:
                        if (angularVelocityData.separateAxes) {
                            var conSep = angularVelocityData.constantSeparate;
                            angularVelocity = GradientAngularVelocity.createByConstantSeparate(new Laya.Vector3(conSep[0] * anglelToRad, conSep[1] * anglelToRad, conSep[2] * anglelToRad));
                        }
                        else {
                            angularVelocity = GradientAngularVelocity.createByConstant(angularVelocityData.constant * anglelToRad);
                        }
                        break;
                    case 1:
                        if (angularVelocityData.separateAxes) {
                            angularVelocity = GradientAngularVelocity.createByGradientSeparate(this._initParticleRotation(angularVelocityData.gradientX), this._initParticleRotation(angularVelocityData.gradientY), this._initParticleRotation(angularVelocityData.gradientZ));
                        }
                        else {
                            angularVelocity = GradientAngularVelocity.createByGradient(this._initParticleRotation(angularVelocityData.gradient));
                        }
                        break;
                    case 2:
                        if (angularVelocityData.separateAxes) {
                            var minSep = angularVelocityData.constantMinSeparate;
                            var maxSep = angularVelocityData.constantMaxSeparate;
                            angularVelocity = GradientAngularVelocity.createByRandomTwoConstantSeparate(new Laya.Vector3(minSep[0] * anglelToRad, minSep[1] * anglelToRad, minSep[2] * anglelToRad), new Laya.Vector3(maxSep[0] * anglelToRad, maxSep[1] * anglelToRad, maxSep[2] * anglelToRad));
                        }
                        else {
                            angularVelocity = GradientAngularVelocity.createByRandomTwoConstant(angularVelocityData.constantMin * anglelToRad, angularVelocityData.constantMax * anglelToRad);
                        }
                        break;
                    case 3:
                        if (angularVelocityData.separateAxes) ;
                        else {
                            angularVelocity = GradientAngularVelocity.createByRandomTwoGradient(this._initParticleRotation(angularVelocityData.gradientMin), this._initParticleRotation(angularVelocityData.gradientMax));
                        }
                        break;
                }
                var rotationOverLifetime = new RotationOverLifetime(angularVelocity);
                rotationOverLifetime.enable = rotationOverLifetimeData.enable;
                particleSystem.rotationOverLifetime = rotationOverLifetime;
            }
            var textureSheetAnimationData = data.textureSheetAnimation;
            if (textureSheetAnimationData) {
                var frameData = textureSheetAnimationData.frame;
                var frameOverTime;
                switch (frameData.type) {
                    case 0:
                        frameOverTime = FrameOverTime.createByConstant(frameData.constant);
                        break;
                    case 1:
                        frameOverTime = FrameOverTime.createByOverTime(this._initParticleFrame(frameData.overTime));
                        break;
                    case 2:
                        frameOverTime = FrameOverTime.createByRandomTwoConstant(frameData.constantMin, frameData.constantMax);
                        break;
                    case 3:
                        frameOverTime = FrameOverTime.createByRandomTwoOverTime(this._initParticleFrame(frameData.overTimeMin), this._initParticleFrame(frameData.overTimeMax));
                        break;
                }
                var startFrameData = textureSheetAnimationData.startFrame;
                var startFrame;
                switch (startFrameData.type) {
                    case 0:
                        startFrame = StartFrame.createByConstant(startFrameData.constant);
                        break;
                    case 1:
                        startFrame = StartFrame.createByRandomTwoConstant(startFrameData.constantMin, startFrameData.constantMax);
                        break;
                }
                var textureSheetAnimation = new TextureSheetAnimation(frameOverTime, startFrame);
                textureSheetAnimation.enable = textureSheetAnimationData.enable;
                var tilesData = textureSheetAnimationData.tiles;
                textureSheetAnimation.tiles = new Laya.Vector2(tilesData[0], tilesData[1]);
                textureSheetAnimation.type = textureSheetAnimationData.type;
                textureSheetAnimation.randomRow = textureSheetAnimationData.randomRow;
                var rowIndex = textureSheetAnimationData.rowIndex;
                (rowIndex !== undefined) && (textureSheetAnimation.rowIndex = rowIndex);
                textureSheetAnimation.cycles = textureSheetAnimationData.cycles;
                particleSystem.textureSheetAnimation = textureSheetAnimation;
            }
        }
        _initParticleColor(gradientColorData, maxkeyCount = 4) {
            var gradientColor = new Gradient(maxkeyCount, maxkeyCount);
            if (!gradientColorData) {
                gradientColor.addColorAlpha(0, 1);
                gradientColor.addColorAlpha(1, 1);
                gradientColor.addColorRGB(0, new Laya.Color(1.0, 1.0, 1.0, 1.0));
                gradientColor.addColorRGB(1, new Laya.Color(1.0, 1.0, 1.0, 1.0));
            }
            else {
                var alphasData = gradientColorData.alphas;
                var i, n;
                if (!alphasData) {
                    gradientColor.addColorAlpha(0, 1);
                    gradientColor.addColorAlpha(1, 1);
                }
                else {
                    for (i = 0, n = alphasData.length; i < n; i++) {
                        if (i == maxkeyCount - 1 && n > maxkeyCount) {
                            i = n - 1;
                            console.warn(`GradientDataColor warning:alpha data length is large than ${maxkeyCount}, will ignore the middle data.`);
                        }
                        var alphaData = alphasData[i];
                        gradientColor.addColorAlpha(alphaData.key, alphaData.value);
                    }
                }
                var rgbsData = gradientColorData.rgbs;
                if (!rgbsData) {
                    gradientColor.addColorRGB(0, new Laya.Color(1.0, 1.0, 1.0, 1.0));
                    gradientColor.addColorRGB(1, new Laya.Color(1.0, 1.0, 1.0, 1.0));
                }
                else {
                    for (i = 0, n = rgbsData.length; i < n; i++) {
                        if (i == maxkeyCount - 1 && n > maxkeyCount) {
                            i = n - 1;
                            console.warn(`GradientDataColor warning:rgb data length is large than ${maxkeyCount}, will ignore the middle data.`);
                        }
                        var rgbData = rgbsData[i];
                        var rgbValue = rgbData.value;
                        gradientColor.addColorRGB(rgbData.key, new Laya.Color(rgbValue[0], rgbValue[1], rgbValue[2], 1.0));
                    }
                }
            }
            return gradientColor;
        }
        _initParticleFrame(overTimeFramesData) {
            var overTimeFrame = new GradientDataInt();
            if (overTimeFramesData) {
                var framesData = overTimeFramesData.frames;
                for (var i = 0, n = framesData.length; i < n; i++) {
                    var frameData = framesData[i];
                    overTimeFrame.add(frameData.key, frameData.value);
                }
            }
            else {
                overTimeFrame.add(0, 0);
                overTimeFrame.add(1, 1);
            }
            return overTimeFrame;
        }
        static _initStartLife(gradientData) {
            var gradient = new GradientDataNumber();
            var startLifetimesData = gradientData.startLifetimes;
            for (var i = 0, n = startLifetimesData.length; i < n; i++) {
                var valueData = startLifetimesData[i];
                gradient.add(valueData.key, valueData.value);
            }
            return gradient;
        }
        _initParticleVelocity(gradientData) {
            var gradient = new GradientDataNumber();
            var velocitysData = gradientData.velocitys;
            for (var i = 0, n = velocitysData.length; i < n; i++) {
                var valueData = velocitysData[i];
                gradient.add(valueData.key, valueData.value);
            }
            return gradient;
        }
        _initParticleSize(gradientSizeData) {
            var gradientSize = new GradientDataNumber();
            if (gradientSizeData) {
                var sizesData = gradientSizeData.sizes;
                for (var i = 0, n = sizesData.length; i < n; i++) {
                    var valueData = sizesData[i];
                    gradientSize.add(valueData.key, valueData.value);
                }
            }
            else {
                gradientSize.add(0, 0);
                gradientSize.add(1, 1);
            }
            return gradientSize;
        }
        _initParticleRotation(gradientData) {
            var gradient = new GradientDataNumber();
            var angularVelocitysData = gradientData.angularVelocitys;
            for (var i = 0, n = angularVelocitysData.length; i < n; i++) {
                var valueData = angularVelocitysData[i];
                gradient.add(valueData.key, valueData.value / 180.0 * Math.PI);
            }
            return gradient;
        }
    }

    class SkinnedMeshSprite3DShaderDeclaration {
    }

    class SkinRenderElement extends RenderElement {
        constructor() {
            super();
        }
        set render(value) {
            this._baseRender = value;
            this._renderElementOBJ._renderShaderData = value._shaderValues;
        }
        get render() {
            return this._baseRender;
        }
        setSkinData(value) {
            this._renderElementOBJ.skinnedData = value;
        }
        _createRenderElementOBJ() {
            this._renderElementOBJ = Laya.LayaGL.renderOBJCreate.createSkinRenderElement();
        }
        _render(context) {
            this._renderElementOBJ._render(context);
        }
    }

    class SkinnedMeshRenderer extends MeshRenderer {
        constructor() {
            super();
            this._bones = [];
            this._inverseBindPosesBufferForNative = null;
            this._skinnedMatrixCachesBufferForNative = null;
            this._bonesTransformForNative = null;
            this._localBounds = new Bounds(Laya.Vector3.ZERO, Laya.Vector3.ZERO);
            this._shaderValues.addDefine(SkinnedMeshSprite3DShaderDeclaration.SHADERDEFINE_BONE);
        }
        get localBounds() {
            return this._localBounds;
        }
        set localBounds(value) {
            this._localBounds = value;
            this.geometryBounds = this._localBounds;
        }
        get rootBone() {
            return this._cacheRootBone;
        }
        set rootBone(value) {
            if (this._cacheRootBone != value) {
                if (this._cacheRootBone)
                    this._cacheRootBone.transform.off(Laya.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange);
                else
                    this.owner.transform.off(Laya.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange);
                if (value)
                    value.transform.on(Laya.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange);
                else
                    this.owner.transform.on(Laya.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange);
                this._cacheRootBone = value;
                this._onWorldMatNeedChange(Transform3D.TRANSFORM_WORLDPOSITION | Transform3D.TRANSFORM_WORLDQUATERNION | Transform3D.TRANSFORM_WORLDSCALE);
                let count = this._renderElements.length;
                for (var i = 0; i < count; i++) {
                    var renderElement = this._renderElements[i];
                    renderElement.setTransform(value.transform);
                }
            }
        }
        get bones() {
            return this._bones;
        }
        _computeSkinnedData() {
            if (this._cacheMesh) {
                var bindPoses = this._cacheMesh._inverseBindPoses;
                var pathMarks = this._cacheMesh._skinnedMatrixCaches;
                for (var i = 0, n = this._cacheMesh.subMeshCount; i < n; i++) {
                    var subMeshBoneIndices = this._cacheMesh.getSubMesh(i)._boneIndicesList;
                    var subData = this._skinnedData[i];
                    for (var j = 0, m = subMeshBoneIndices.length; j < m; j++) {
                        var boneIndices = subMeshBoneIndices[j];
                        this._computeSubSkinnedData(bindPoses, boneIndices, subData[j], pathMarks);
                    }
                }
            }
        }
        _computeSubSkinnedData(bindPoses, boneIndices, data, matrixCaches) {
            for (let k = 0, q = boneIndices.length; k < q; k++) {
                let index = boneIndices[k];
                if (this._skinnedDataLoopMarks[index] === Laya.Stat.loopCount) {
                    let c = matrixCaches[index];
                    let preData = this._skinnedData[c.subMeshIndex][c.batchIndex];
                    let srcIndex = c.batchBoneIndex * 16;
                    let dstIndex = k * 16;
                    for (let d = 0; d < 16; d++)
                        data[dstIndex + d] = preData[srcIndex + d];
                }
                else {
                    let bone = this._bones[index];
                    if (bone)
                        Utils3D._mulMatrixArray(bone.transform.worldMatrix.elements, bindPoses[index].elements, 0, data, k * 16);
                    this._skinnedDataLoopMarks[index] = Laya.Stat.loopCount;
                }
            }
        }
        _computeSkinnedDataForNative() {
            if (this._cacheMesh) {
                var bindPoses = this._cacheMesh._inverseBindPoses;
                var pathMarks = this._cacheMesh._skinnedMatrixCaches;
                if (this._inverseBindPosesBufferForNative == null) {
                    this._inverseBindPosesBufferForNative = new Float32Array(bindPoses.length * 16);
                    var offset = 0;
                    for (var i = 0, n = bindPoses.length; i < n; i++) {
                        this._inverseBindPosesBufferForNative.set(bindPoses[i].elements, offset);
                        offset += 16;
                    }
                }
                if (this._skinnedMatrixCachesBufferForNative == null) {
                    this._skinnedMatrixCachesBufferForNative = new Int32Array(pathMarks.length * 3);
                    var j = 0;
                    for (var i = 0, n = pathMarks.length; i < n; i++) {
                        if (!pathMarks[i]) {
                            break;
                        }
                        this._skinnedMatrixCachesBufferForNative[j] = pathMarks[i].subMeshIndex;
                        this._skinnedMatrixCachesBufferForNative[j + 1] = pathMarks[i].batchIndex;
                        this._skinnedMatrixCachesBufferForNative[j + 2] = pathMarks[i].batchBoneIndex;
                        j += 3;
                    }
                }
                if (this._bonesTransformForNative == null) {
                    this._bonesTransformForNative = [];
                    for (var i = 0, n = this._bones.length; i < n; i++) {
                        let bone = this._bones[i];
                        if (bone) {
                            this._bonesTransformForNative[i] = bone.transform._nativeObj;
                        }
                        else {
                            this._bonesTransformForNative[i] = null;
                        }
                    }
                }
                for (var i = 0, n = this._cacheMesh.subMeshCount; i < n; i++) {
                    var subMeshBoneIndices = this._cacheMesh.getSubMesh(i)._boneIndicesList;
                    var subData = this._skinnedData[i];
                    for (var j = 0, m = subMeshBoneIndices.length; j < m; j++) {
                        var boneIndices = subMeshBoneIndices[j];
                        window.conch.computeSubSkinnedDataForNative(this._inverseBindPosesBufferForNative, boneIndices, subData[j], this._skinnedMatrixCachesBufferForNative, this._bonesTransformForNative, this._skinnedDataLoopMarks, this._skinnedData);
                    }
                }
            }
        }
        _needRender(boundFrustum, context) {
            if (!Laya.Stat.enableSkin)
                return false;
            return super._needRender(boundFrustum, context);
        }
        _createRenderElement() {
            let renderelement = new SkinRenderElement();
            return renderelement;
        }
        _onSkinMeshChange(mesh) {
            if (mesh && this._mesh != mesh) {
                this._changeVertexDefine(mesh);
                this._mesh = mesh;
                var count = mesh.subMeshCount;
                this._renderElements.length = count;
                for (var i = 0; i < count; i++) {
                    var renderElement = this._renderElements[i];
                    if (!renderElement) {
                        var material = this.sharedMaterials[i];
                        renderElement = this._renderElements[i] = this._renderElements[i] ? this._renderElements[i] : this._createRenderElement();
                        if (this._cacheRootBone) {
                            renderElement.setTransform(this._cacheRootBone._transform);
                        }
                        else {
                            renderElement.setTransform(this.owner._transform);
                        }
                        renderElement.render = this;
                        renderElement.material = material ? material : BlinnPhongMaterial.defaultMaterial;
                    }
                    renderElement.setGeometry(mesh.getSubMesh(i));
                }
            }
            else if (!mesh) {
                this._renderElements.length = 0;
                this._mesh = null;
                this._changeVertexDefine(null);
            }
            this.boundsChange = true;
        }
        _onMeshChange(value) {
            this._onSkinMeshChange(value);
            if (!value)
                return;
            this._cacheMesh = value;
            var subMeshCount = value.subMeshCount;
            this._skinnedData = [];
            this._skinnedDataLoopMarks = new Uint32Array(value._inverseBindPoses.length);
            for (var i = 0; i < subMeshCount; i++) {
                var subBoneIndices = value.getSubMesh(i)._boneIndicesList;
                var subCount = subBoneIndices.length;
                var subData = this._skinnedData[i] = [];
                for (var j = 0; j < subCount; j++)
                    subData[j] = new Float32Array(subBoneIndices[j].length * 16);
                this._renderElements[i].setSkinData(subData);
            }
        }
        _calculateBoundingBox() {
            if (this._cacheRootBone)
                this._localBounds._tranform(this._cacheRootBone.transform.worldMatrix, this._bounds);
            else
                this._localBounds._tranform(this.owner.transform.worldMatrix, this._bounds);
        }
        _setBelongScene(scene) {
            super._setBelongScene(scene);
            Laya.Stat.skinRenderNode++;
        }
        _setUnBelongScene() {
            super._setUnBelongScene();
            Laya.Stat.skinRenderNode--;
        }
        _renderUpdate(context, transform) {
            if (this.bones.length > 0) {
                this._computeSkinnedData();
                this._shaderValues.setMatrix4x4(Sprite3D.WORLDMATRIX, Laya.Matrix4x4.DEFAULT);
            }
            else {
                this._shaderValues.setMatrix4x4(Sprite3D.WORLDMATRIX, transform.worldMatrix);
            }
        }
        _cloneTo(dest) {
            let render = dest;
            render._inverseBindPosesBufferForNative = null;
            render._skinnedMatrixCachesBufferForNative = null;
            render._bonesTransformForNative = null;
            let getCommomParent = (rootNode, rootCheckNode) => {
                let nodeArray = [];
                let node = rootNode;
                while (!!node) {
                    if (node instanceof Sprite3D)
                        nodeArray.push(node);
                    node = node.parent;
                }
                let checkNode = rootCheckNode;
                while (!!checkNode && nodeArray.indexOf(checkNode) == -1) {
                    checkNode = checkNode.parent;
                }
                return checkNode;
            };
            let cloneHierachFun = (rootNode, rootCheckNode, destNode) => {
                let rootparent = getCommomParent(rootNode, rootCheckNode);
                if (!rootparent)
                    return null;
                let path = [];
                Utils3D._getHierarchyPath(rootparent, rootNode, path);
                let pathcheck = [];
                Utils3D._getHierarchyPath(rootparent, rootCheckNode, pathcheck);
                let destParent = Utils3D._getParentNodeByHierarchyPath(destNode, path);
                if (!destParent)
                    return null;
                return Utils3D._getNodeByHierarchyPath(destParent, pathcheck);
            };
            var rootBone = this.rootBone;
            if (rootBone) {
                let node = cloneHierachFun(this.owner, this.rootBone, render.owner);
                if (node)
                    render.rootBone = node;
                else
                    render.rootBone = rootBone;
            }
            var bones = this.bones;
            var destBone = render.bones;
            let n = destBone.length = bones.length;
            for (var i = 0; i < n; i++) {
                let ceckNode = bones[i];
                destBone[i] = cloneHierachFun(this.owner, ceckNode, render.owner);
            }
            var lbb = this.localBounds;
            (lbb) && (lbb.cloneTo(render.localBounds));
            (render.localBounds) && (render.localBounds = render.localBounds);
            super._cloneTo(dest);
        }
        _onDestroy() {
            if (this._cacheRootBone)
                (!this._cacheRootBone._destroyed) && (this._cacheRootBone.transform.off(Laya.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange));
            else
                (this.owner && !this.owner._destroyed) && (this.owner.transform.off(Laya.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange));
            super._onDestroy();
        }
    }

    class SimpleSkinnedMeshRenderer extends SkinnedMeshRenderer {
        constructor() {
            super();
            this._simpleAnimatorParams = new Laya.Vector4();
            this._simpleAnimatorOffset = new Laya.Vector2();
            this._shaderValues.addDefine(SkinnedMeshSprite3DShaderDeclaration.SHADERDEFINE_SIMPLEBONE);
            this._shaderValues.addDefine(SkinnedMeshSprite3DShaderDeclaration.SHADERDEFINE_BONE);
        }
        get simpleAnimatorTexture() {
            return this._simpleAnimatorTexture;
        }
        set simpleAnimatorTexture(value) {
            this._simpleAnimatorTexture = value;
            this._simpleAnimatorTextureSize = value.width;
            this._shaderValues.setTexture(SimpleSkinnedMeshRenderer.SIMPLE_SIMPLEANIMATORTEXTURE, value);
            value._addReference();
            this._shaderValues.setNumber(SimpleSkinnedMeshRenderer.SIMPLE_SIMPLEANIMATORTEXTURESIZE, this._simpleAnimatorTextureSize);
        }
        get simpleAnimatorOffset() {
            return this._simpleAnimatorOffset;
        }
        set simpleAnimatorOffset(value) {
            value.cloneTo(this._simpleAnimatorOffset);
        }
        _createRenderElement() {
            let renderelement = new SubMeshRenderElement();
            return renderelement;
        }
        _computeAnimatorParamsData() {
            if (this._cacheMesh) {
                this._simpleAnimatorParams.x = this._simpleAnimatorOffset.x;
                this._simpleAnimatorParams.y = Math.round(this._simpleAnimatorOffset.y) * this._bonesNums * 4;
            }
        }
        _onMeshChange(value) {
            this._onSkinMeshChange(value);
            if (!value)
                return;
            this._cacheMesh = value;
        }
        _renderUpdate(context, transform) {
            var element = context.renderElement;
            switch (element.renderType) {
                case RenderElement.RENDERTYPE_NORMAL:
                    if (this.rootBone) {
                        var worldMat = this.rootBone.transform.worldMatrix;
                        if (this._subUniformBufferData) {
                            let oriMat = this._shaderValues.getMatrix4x4(Sprite3D.WORLDMATRIX);
                            this._subUniformBufferData._needUpdate = oriMat ? !oriMat.equalsOtherMatrix(worldMat) : true;
                        }
                        this._setShaderValue(Sprite3D.WORLDMATRIX, Laya.ShaderDataType.Matrix4x4, worldMat);
                    }
                    else {
                        this._setShaderValue(Sprite3D.WORLDMATRIX, Laya.ShaderDataType.Matrix4x4, transform.worldMatrix);
                    }
                    this._computeAnimatorParamsData();
                    this._shaderValues.setVector(SimpleSkinnedMeshRenderer.SIMPLE_SIMPLEANIMATORPARAMS, this._simpleAnimatorParams);
                    break;
            }
        }
        _renderUpdateWithCamera(context, transform) {
        }
        _cloneTo(dest) {
            let render = dest;
            render.simpleAnimatorOffset = this.simpleAnimatorOffset;
            render.simpleAnimatorTexture = this.simpleAnimatorTexture;
            render._bonesNums = this._bonesNums;
            super._cloneTo(dest);
        }
        _onDestroy() {
            if (this._cacheRootBone)
                (!this._cacheRootBone._destroyed) && (this._cacheRootBone.transform.off(Laya.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange));
            (this._simpleAnimatorTexture) && this._simpleAnimatorTexture._removeReference();
            this._simpleAnimatorTexture = null;
            super._onDestroy();
        }
    }

    class SimpleSkinnedMeshSprite3D extends RenderableSprite3D {
        constructor(mesh = null, name = null) {
            super(name);
            this._meshFilter = this.addComponent(MeshFilter);
            this._render = this.addComponent(SimpleSkinnedMeshRenderer);
            (mesh) && (this._meshFilter.sharedMesh = mesh);
        }
        static __init__() {
            SimpleSkinnedMeshRenderer.SIMPLE_SIMPLEANIMATORPARAMS = SimpleSkinnedMeshSprite3D.SIMPLE_SIMPLEANIMATORPARAMS;
            SimpleSkinnedMeshRenderer.SIMPLE_SIMPLEANIMATORTEXTURE = SimpleSkinnedMeshSprite3D.SIMPLE_SIMPLEANIMATORTEXTURE;
            SimpleSkinnedMeshRenderer.SIMPLE_SIMPLEANIMATORTEXTURESIZE = SimpleSkinnedMeshSprite3D.SIMPLE_SIMPLEANIMATORTEXTURESIZE;
            SimpleSkinnedMeshSprite3D.SIMPLE_SIMPLEANIMATORTEXTURE = Laya.Shader3D.propertyNameToID("u_SimpleAnimatorTexture");
            SimpleSkinnedMeshSprite3D.SIMPLE_SIMPLEANIMATORPARAMS = Laya.Shader3D.propertyNameToID("u_SimpleAnimatorParams");
            SimpleSkinnedMeshSprite3D.SIMPLE_SIMPLEANIMATORTEXTURESIZE = Laya.Shader3D.propertyNameToID("u_SimpleAnimatorTextureSize");
            const commandUniform = Laya.LayaGL.renderOBJCreate.createGlobalUniformMap("Sprite3D");
            commandUniform.addShaderUniform(SimpleSkinnedMeshSprite3D.SIMPLE_SIMPLEANIMATORTEXTURE, "u_SimpleAnimatorTexture");
            commandUniform.addShaderUniform(SimpleSkinnedMeshSprite3D.SIMPLE_SIMPLEANIMATORPARAMS, "u_SimpleAnimatorParams");
            commandUniform.addShaderUniform(SimpleSkinnedMeshSprite3D.SIMPLE_SIMPLEANIMATORTEXTURESIZE, "u_SimpleAnimatorTextureSize");
        }
        get meshFilter() {
            return this._meshFilter;
        }
        get simpleSkinnedMeshRenderer() {
            return this._render;
        }
        _parse(data, spriteMap) {
            super._parse(data, spriteMap);
            var render = this.simpleSkinnedMeshRenderer;
            var lightmapIndex = data.lightmapIndex;
            (lightmapIndex != null) && (render.lightmapIndex = lightmapIndex);
            var lightmapScaleOffsetArray = data.lightmapScaleOffset;
            (lightmapScaleOffsetArray) && (render.lightmapScaleOffset = new Laya.Vector4(lightmapScaleOffsetArray[0], lightmapScaleOffsetArray[1], lightmapScaleOffsetArray[2], lightmapScaleOffsetArray[3]));
            (data.enableRender != undefined) && (render.enabled = data.enableRender);
            (data.receiveShadows != undefined) && (render.receiveShadow = data.receiveShadows);
            (data.castShadow != undefined) && (render.castShadow = data.castShadow);
            var meshPath;
            meshPath = data.meshPath;
            if (meshPath) {
                var mesh = Laya.Loader.getRes(meshPath);
                (mesh) && (this.meshFilter.sharedMesh = mesh);
            }
            var materials = data.materials;
            if (materials) {
                var sharedMaterials = render.sharedMaterials;
                var materialCount = materials.length;
                sharedMaterials.length = materialCount;
                for (var i = 0; i < materialCount; i++) {
                    sharedMaterials[i] = Laya.Loader.getRes(materials[i].path);
                }
                render.sharedMaterials = sharedMaterials;
            }
            var boundBox = data.boundBox;
            var min = boundBox.min;
            var max = boundBox.max;
            render.localBounds.setMin(new Laya.Vector3(min[0], min[1], min[2]));
            render.localBounds.setMax(new Laya.Vector3(max[0], max[1], max[2]));
            render.localBounds = render.localBounds;
            if (spriteMap) {
                var rootBoneData = data.rootBone;
                render.rootBone = spriteMap[rootBoneData];
                var bonesData = data.bones;
                var n;
                for (i = 0, n = bonesData.length; i < n; i++)
                    render.bones.push(spriteMap[bonesData[i]]);
                render._bonesNums = data.bonesNums ? data.bonesNums : render.bones.length;
            }
            var animatorTexture = data.animatorTexture;
            if (animatorTexture) {
                var animatortexture = Laya.Loader.getRes(animatorTexture);
                render.simpleAnimatorTexture = animatortexture;
            }
        }
        _cloneTo(destObject, srcRoot, dstRoot) {
            super._cloneTo(destObject, srcRoot, dstRoot);
        }
        destroy(destroyChild = true) {
            if (this._destroyed)
                return;
            super.destroy(destroyChild);
            this._meshFilter.destroy();
        }
        _create() {
            return new Sprite3D();
        }
    }
    SimpleSkinnedMeshSprite3D._tempArray0 = [];

    class SkinnedMeshSprite3D extends RenderableSprite3D {
        constructor(mesh = null, name = null) {
            super(name);
            this._meshFilter = this.addComponent(MeshFilter);
            this._render = this.addComponent(SkinnedMeshRenderer);
            (mesh) && (this._meshFilter.sharedMesh = mesh);
        }
        static __init__() {
            SkinnedMeshSprite3DShaderDeclaration.SHADERDEFINE_BONE = Laya.Shader3D.getDefineByName("BONE");
            SkinnedMeshSprite3DShaderDeclaration.SHADERDEFINE_SIMPLEBONE = Laya.Shader3D.getDefineByName("SIMPLEBONE");
            const commandUniform = Laya.LayaGL.renderOBJCreate.createGlobalUniformMap("Custom");
            SkinnedMeshSprite3D.BONES = Laya.Shader3D.propertyNameToID("u_Bones");
            commandUniform.addShaderUniform(SkinnedMeshSprite3D.BONES, "u_Bones");
        }
        get meshFilter() {
            return this._meshFilter;
        }
        get skinnedMeshRenderer() {
            return this._render;
        }
        _parse(data, spriteMap) {
            super._parse(data, spriteMap);
            var render = this.skinnedMeshRenderer;
            var lightmapIndex = data.lightmapIndex;
            (lightmapIndex != null) && (render.lightmapIndex = lightmapIndex);
            var lightmapScaleOffsetArray = data.lightmapScaleOffset;
            (lightmapScaleOffsetArray) && (render.lightmapScaleOffset = new Laya.Vector4(lightmapScaleOffsetArray[0], lightmapScaleOffsetArray[1], lightmapScaleOffsetArray[2], lightmapScaleOffsetArray[3]));
            (data.enableRender != undefined) && (render.enabled = data.enableRender);
            (data.receiveShadows != undefined) && (render.receiveShadow = data.receiveShadows);
            (data.castShadow != undefined) && (render.castShadow = data.castShadow);
            var meshPath;
            meshPath = data.meshPath;
            if (meshPath) {
                var mesh = Laya.Loader.getRes(meshPath);
                (mesh) && (this.meshFilter.sharedMesh = mesh);
            }
            var materials = data.materials;
            if (materials) {
                var sharedMaterials = render.sharedMaterials;
                var materialCount = materials.length;
                sharedMaterials.length = materialCount;
                for (var i = 0; i < materialCount; i++) {
                    sharedMaterials[i] = Laya.Loader.getRes(materials[i].path);
                }
                render.sharedMaterials = sharedMaterials;
            }
            var boundBox = data.boundBox;
            var min = boundBox.min;
            var max = boundBox.max;
            render.localBounds.setMin(new Laya.Vector3(min[0], min[1], min[2]));
            render.localBounds.setMax(new Laya.Vector3(max[0], max[1], max[2]));
            render.localBounds = render.localBounds;
            if (spriteMap) {
                var rootBoneData = data.rootBone;
                render.rootBone = spriteMap[rootBoneData];
                var bonesData = data.bones;
                var n;
                for (i = 0, n = bonesData.length; i < n; i++)
                    render.bones.push(spriteMap[bonesData[i]]);
            }
        }
        _cloneTo(destObject, srcRoot, dstRoot) {
            super._cloneTo(destObject, srcRoot, dstRoot);
        }
        destroy(destroyChild = true) {
            if (this._destroyed)
                return;
            super.destroy(destroyChild);
            this._meshFilter.destroy();
        }
        _create() {
            return new Sprite3D();
        }
    }
    SkinnedMeshSprite3D._tempArray0 = [];

    class TrailTextureMode {
    }
    TrailTextureMode.Stretch = 0;
    TrailTextureMode.Tile = 1;

    exports.TrailAlignment = void 0;
    (function (TrailAlignment) {
        TrailAlignment[TrailAlignment["View"] = 0] = "View";
        TrailAlignment[TrailAlignment["TransformZ"] = 1] = "TransformZ";
    })(exports.TrailAlignment || (exports.TrailAlignment = {}));

    class VertexTrail {
        static get vertexDeclaration1() {
            return VertexTrail._vertexDeclaration1;
        }
        static get vertexDeclaration2() {
            return VertexTrail._vertexDeclaration2;
        }
        get vertexDeclaration() {
            return VertexTrail._vertexDeclaration1;
        }
        static __init__() {
            VertexTrail._vertexDeclaration1 = new Laya.VertexDeclaration(32, [new Laya.VertexElement(0, Laya.VertexElementFormat.Vector3, VertexTrail.TRAIL_POSITION0),
                new Laya.VertexElement(12, Laya.VertexElementFormat.Vector3, VertexTrail.TRAIL_OFFSETVECTOR),
                new Laya.VertexElement(24, Laya.VertexElementFormat.Single, VertexTrail.TRAIL_TIME0),
                new Laya.VertexElement(28, Laya.VertexElementFormat.Single, VertexTrail.TRAIL_TEXTURECOORDINATE0Y)]);
            VertexTrail._vertexDeclaration2 = new Laya.VertexDeclaration(20, [new Laya.VertexElement(0, Laya.VertexElementFormat.Single, VertexTrail.TRAIL_TEXTURECOORDINATE0X),
                new Laya.VertexElement(4, Laya.VertexElementFormat.Color, VertexTrail.TRAIL_COLOR)]);
        }
    }
    VertexTrail.TRAIL_POSITION0 = 0;
    VertexTrail.TRAIL_OFFSETVECTOR = 1;
    VertexTrail.TRAIL_TIME0 = 2;
    VertexTrail.TRAIL_TEXTURECOORDINATE0Y = 3;
    VertexTrail.TRAIL_TEXTURECOORDINATE0X = 4;
    VertexTrail.TRAIL_COLOR = 5;

    class TrailGeometry extends GeometryElement {
        constructor(owner) {
            super(Laya.MeshTopology.TriangleStrip, Laya.DrawType.DrawArray);
            this._floatCountPerVertices1 = 8;
            this._floatCountPerVertices2 = 5;
            this._increaseSegementCount = 16;
            this._activeIndex = 0;
            this._endIndex = 0;
            this._needAddFirstVertex = false;
            this._isTempEndVertex = false;
            this._vertices1 = null;
            this._vertices2 = null;
            this._lastFixedVertexPosition = new Laya.Vector3();
            this.tmpColor = new Laya.Color();
            this._disappearBoundsMode = false;
            this._owner = owner;
            this.bufferState = new Laya.BufferState();
            this._segementCount = this._increaseSegementCount;
            this._resizeData(this._segementCount, this.bufferState);
        }
        _resizeData(segementCount, bufferState) {
            this._subBirthTime = new Float32Array(segementCount);
            this._subDistance = new Float64Array(segementCount);
            var vertexCount = segementCount * 2;
            var vertexDeclaration1 = VertexTrail.vertexDeclaration1;
            var vertexDeclaration2 = VertexTrail.vertexDeclaration2;
            var vertexBuffers = [];
            var vertexbuffer1Size = vertexCount * vertexDeclaration1.vertexStride;
            var vertexbuffer2Size = vertexCount * vertexDeclaration2.vertexStride;
            var memorySize = vertexbuffer1Size + vertexbuffer2Size;
            this._vertices1 = new Float32Array(vertexCount * this._floatCountPerVertices1);
            this._vertices2 = new Float32Array(vertexCount * this._floatCountPerVertices2);
            this._vertexBuffer1 = Laya.LayaGL.renderOBJCreate.createVertexBuffer3D(vertexbuffer1Size, Laya.BufferUsage.Dynamic, false);
            this._vertexBuffer1.vertexDeclaration = vertexDeclaration1;
            this._vertexBuffer2 = Laya.LayaGL.renderOBJCreate.createVertexBuffer3D(vertexbuffer2Size, Laya.BufferUsage.Dynamic, false);
            this._vertexBuffer2.vertexDeclaration = vertexDeclaration2;
            vertexBuffers.push(this._vertexBuffer1);
            vertexBuffers.push(this._vertexBuffer2);
            bufferState.applyState(vertexBuffers, null);
            Laya.Resource._addMemory(memorySize, memorySize);
        }
        _resetData() {
            var count = this._endIndex - this._activeIndex;
            var oldVertices1 = new Float32Array(this._vertices1.buffer, this._floatCountPerVertices1 * 2 * this._activeIndex * 4, this._floatCountPerVertices1 * 2 * count);
            var oldVertices2 = new Float32Array(this._vertices2.buffer, this._floatCountPerVertices2 * 2 * this._activeIndex * 4, this._floatCountPerVertices2 * 2 * count);
            var oldSubDistance = new Float64Array(this._subDistance.buffer, this._activeIndex * 8, count);
            var oldSubBirthTime = new Float32Array(this._subBirthTime.buffer, this._activeIndex * 4, count);
            if (count === this._segementCount) {
                var memorySize = this._vertexBuffer1._byteLength + this._vertexBuffer2._byteLength;
                Laya.Resource._addMemory(-memorySize, -memorySize);
                this._vertexBuffer1.destroy();
                this._vertexBuffer2.destroy();
                this._segementCount += this._increaseSegementCount;
                this._resizeData(this._segementCount, this.bufferState);
            }
            this._vertices1.set(oldVertices1, 0);
            this._vertices2.set(oldVertices2, 0);
            this._subDistance.set(oldSubDistance, 0);
            this._subBirthTime.set(oldSubBirthTime, 0);
            this._endIndex = count;
            this._activeIndex = 0;
            this._vertexBuffer1.setData(this._vertices1.buffer, 0, this._floatCountPerVertices1 * 2 * this._activeIndex * 4, this._floatCountPerVertices1 * 2 * count * 4);
            this._vertexBuffer2.setData(this._vertices2.buffer, 0, this._floatCountPerVertices2 * 2 * this._activeIndex * 4, this._floatCountPerVertices2 * 2 * count * 4);
        }
        _updateTrail(camera, lastPosition, position) {
            if (!Laya.Vector3.equals(lastPosition, position)) {
                if ((this._endIndex - this._activeIndex) === 0)
                    this._addTrailByFirstPosition(camera, position);
                else
                    this._addTrailByNextPosition(camera, position);
            }
        }
        _addTrailByFirstPosition(camera, position) {
            (this._endIndex === this._segementCount) && (this._resetData());
            this._subDistance[this._endIndex] = 0;
            this._subBirthTime[this._endIndex] = this._owner._curtime;
            this._endIndex++;
            position.cloneTo(this._lastFixedVertexPosition);
            this._needAddFirstVertex = true;
        }
        _addTrailByNextPosition(camera, position) {
            var delVector3 = TrailGeometry._tempVector30;
            var pointAtoBVector3 = TrailGeometry._tempVector31;
            switch (this._owner.alignment) {
                case exports.TrailAlignment.View:
                    var cameraMatrix = camera.viewMatrix;
                    Laya.Vector3.transformCoordinate(position, cameraMatrix, TrailGeometry._tempVector33);
                    Laya.Vector3.transformCoordinate(this._lastFixedVertexPosition, cameraMatrix, TrailGeometry._tempVector34);
                    Laya.Vector3.subtract(TrailGeometry._tempVector33, TrailGeometry._tempVector34, delVector3);
                    Laya.Vector3.cross(TrailGeometry._tempVector33, delVector3, pointAtoBVector3);
                    break;
                case exports.TrailAlignment.TransformZ:
                    Laya.Vector3.subtract(position, this._lastFixedVertexPosition, delVector3);
                    var forward = TrailGeometry._tempVector32;
                    this._owner._ownerRender.owner.transform.getForward(forward);
                    Laya.Vector3.cross(delVector3, forward, pointAtoBVector3);
                    break;
            }
            Laya.Vector3.normalize(pointAtoBVector3, pointAtoBVector3);
            Laya.Vector3.scale(pointAtoBVector3, this._owner.widthMultiplier / 2, pointAtoBVector3);
            var delLength = Laya.Vector3.scalarLength(delVector3);
            var tempEndIndex;
            var offset;
            if (this._needAddFirstVertex) {
                this._updateVerticesByPositionData(position, pointAtoBVector3, this._endIndex - 1);
                this._needAddFirstVertex = false;
            }
            if (delLength - this._owner.minVertexDistance >= Laya.MathUtils3D.zeroTolerance) {
                if (this._isTempEndVertex) {
                    tempEndIndex = this._endIndex - 1;
                    offset = delLength - this._subDistance[tempEndIndex];
                    this._updateVerticesByPosition(position, pointAtoBVector3, delLength, tempEndIndex);
                    this._owner._totalLength += offset;
                }
                else {
                    (this._endIndex === this._segementCount) && (this._resetData());
                    this._updateVerticesByPosition(position, pointAtoBVector3, delLength, this._endIndex);
                    this._owner._totalLength += delLength;
                    this._endIndex++;
                }
                position.cloneTo(this._lastFixedVertexPosition);
                this._isTempEndVertex = false;
            }
            else {
                if (this._isTempEndVertex) {
                    tempEndIndex = this._endIndex - 1;
                    offset = delLength - this._subDistance[tempEndIndex];
                    this._updateVerticesByPosition(position, pointAtoBVector3, delLength, tempEndIndex);
                    this._owner._totalLength += offset;
                }
                else {
                    (this._endIndex === this._segementCount) && (this._resetData());
                    this._updateVerticesByPosition(position, pointAtoBVector3, delLength, this._endIndex);
                    this._owner._totalLength += delLength;
                    this._endIndex++;
                }
                this._isTempEndVertex = true;
            }
        }
        _updateVerticesByPositionData(position, pointAtoBVector3, index) {
            var vertexOffset = this._floatCountPerVertices1 * 2 * index;
            var curtime = this._owner._curtime;
            this._vertices1[vertexOffset] = position.x;
            this._vertices1[vertexOffset + 1] = position.y;
            this._vertices1[vertexOffset + 2] = position.z;
            this._vertices1[vertexOffset + 3] = -pointAtoBVector3.x;
            this._vertices1[vertexOffset + 4] = -pointAtoBVector3.y;
            this._vertices1[vertexOffset + 5] = -pointAtoBVector3.z;
            this._vertices1[vertexOffset + 6] = curtime;
            this._vertices1[vertexOffset + 7] = 1.0;
            this._vertices1[vertexOffset + 8] = position.x;
            this._vertices1[vertexOffset + 9] = position.y;
            this._vertices1[vertexOffset + 10] = position.z;
            this._vertices1[vertexOffset + 11] = pointAtoBVector3.x;
            this._vertices1[vertexOffset + 12] = pointAtoBVector3.y;
            this._vertices1[vertexOffset + 13] = pointAtoBVector3.z;
            this._vertices1[vertexOffset + 14] = curtime;
            this._vertices1[vertexOffset + 15] = 0.0;
            var bounds = this._owner._ownerRender.bounds;
            var min = bounds.getMin();
            var max = bounds.getMax();
            var up = TrailGeometry._tempVector35;
            var down = TrailGeometry._tempVector36;
            var out = TrailGeometry._tempVector32;
            Laya.Vector3.add(position, pointAtoBVector3, up);
            Laya.Vector3.subtract(position, pointAtoBVector3, down);
            Laya.Vector3.min(down, up, out);
            Laya.Vector3.min(min, out, min);
            bounds.setMin(min);
            Laya.Vector3.max(up, down, out);
            Laya.Vector3.max(max, out, max);
            bounds.setMax(max);
            var floatCount = this._floatCountPerVertices1 * 2;
            this._vertexBuffer1.setData(this._vertices1.buffer, vertexOffset * 4, vertexOffset * 4, floatCount * 4);
        }
        _updateVerticesByPosition(position, pointAtoBVector3, delDistance, index) {
            this._updateVerticesByPositionData(position, pointAtoBVector3, index);
            this._subDistance[index] = delDistance;
            this._subBirthTime[index] = this._owner._curtime;
        }
        _updateVertexBufferUV() {
            var bounds;
            var min, max;
            if (this._disappearBoundsMode) {
                bounds = this._owner._ownerRender.bounds;
                var sprite3dPosition = this._owner._ownerRender.owner.transform.position;
                bounds.setMin(sprite3dPosition);
                bounds.setMax(sprite3dPosition);
                min = bounds.getMin();
                max = bounds.getMax();
            }
            var vertexCount = this._endIndex;
            var curLength = 0;
            var gradient = this._owner.colorGradient;
            var startAlphaIndex = gradient.colorAlphaKeysCount - 1;
            var startColorIndex = gradient.colorRGBKeysCount - 1;
            var totalLength = this._owner._totalLength;
            var stride = this._floatCountPerVertices2 * 2;
            for (var i = this._activeIndex; i < vertexCount; i++) {
                (i !== this._activeIndex) && (curLength += this._subDistance[i]);
                var uvX;
                var lerpFactor;
                if (this._owner.textureMode == TrailTextureMode.Stretch) {
                    uvX = 1.0 - curLength / totalLength;
                    lerpFactor = uvX;
                }
                else {
                    lerpFactor = 1.0 - curLength / totalLength;
                    uvX = 1.0 - (totalLength - curLength);
                }
                startColorIndex = gradient.evaluateColorRGB(lerpFactor, this.tmpColor, startColorIndex, true);
                startAlphaIndex = gradient.evaluateColorAlpha(lerpFactor, this.tmpColor, startAlphaIndex, true);
                var index = i * stride;
                this._vertices2[index + 0] = uvX;
                this._vertices2[index + 1] = this.tmpColor.r;
                this._vertices2[index + 2] = this.tmpColor.g;
                this._vertices2[index + 3] = this.tmpColor.b;
                this._vertices2[index + 4] = this.tmpColor.a;
                this._vertices2[index + 5] = uvX;
                this._vertices2[index + 6] = this.tmpColor.r;
                this._vertices2[index + 7] = this.tmpColor.g;
                this._vertices2[index + 8] = this.tmpColor.b;
                this._vertices2[index + 9] = this.tmpColor.a;
                if (this._disappearBoundsMode) {
                    var posOffset = this._floatCountPerVertices1 * 2 * i;
                    var pos = TrailGeometry._tempVector32;
                    var up = TrailGeometry._tempVector33;
                    var side = TrailGeometry._tempVector34;
                    pos.setValue(this._vertices1[posOffset + 0], this._vertices1[posOffset + 1], this._vertices1[posOffset + 2]);
                    up.setValue(this._vertices1[posOffset + 3], this._vertices1[posOffset + 4], this._vertices1[posOffset + 5]);
                    Laya.Vector3.add(pos, up, side);
                    Laya.Vector3.min(side, min, min);
                    Laya.Vector3.max(side, max, max);
                    Laya.Vector3.subtract(pos, up, side);
                    Laya.Vector3.min(side, min, min);
                    Laya.Vector3.max(side, max, max);
                }
            }
            if (this._disappearBoundsMode) {
                bounds.setMin(min);
                bounds.setMax(max);
                this._disappearBoundsMode = false;
            }
            var offset = this._activeIndex * stride;
            this._vertexBuffer2.setData(this._vertices2.buffer, offset * 4, offset * 4, (vertexCount * stride - offset) * 4);
        }
        _updateDisappear() {
            var count = this._endIndex;
            for (var i = this._activeIndex; i < count; i++) {
                if (this._owner._curtime - this._subBirthTime[i] >= this._owner.time + Laya.MathUtils3D.zeroTolerance) {
                    var nextIndex = i + 1;
                    if (nextIndex !== count)
                        this._owner._totalLength -= this._subDistance[nextIndex];
                    if (this._isTempEndVertex && (nextIndex === count - 1)) {
                        var fixedPos = this._lastFixedVertexPosition;
                        fixedPos.x = this._vertices1[0];
                        fixedPos.y = this._vertices1[1];
                        fixedPos.z = this._vertices1[2];
                        this._isTempEndVertex = false;
                    }
                    this._activeIndex++;
                    this._disappearBoundsMode = true;
                }
                else {
                    break;
                }
            }
        }
        _getType() {
            return TrailGeometry._type;
        }
        _prepareRender(state) {
            return this._endIndex - this._activeIndex > 1;
        }
        _updateRenderParams(state) {
            this.clearRenderParams();
            var start = this._activeIndex * 2;
            var count = this._endIndex * 2 - start;
            this.setDrawArrayParams(start, count);
        }
        destroy() {
            super.destroy();
            var memorySize = this._vertexBuffer1._byteLength + this._vertexBuffer2._byteLength;
            Laya.Resource._addMemory(-memorySize, -memorySize);
            this.bufferState.destroy();
            this._vertexBuffer1.destroy();
            this._vertexBuffer2.destroy();
            this.bufferState = null;
            this._vertices1 = null;
            this._vertexBuffer1 = null;
            this._vertices2 = null;
            this._vertexBuffer2 = null;
            this._subBirthTime = null;
            this._subDistance = null;
            this._lastFixedVertexPosition = null;
            this._disappearBoundsMode = false;
        }
        clear() {
            this._activeIndex = 0;
            this._endIndex = 0;
            this._disappearBoundsMode = false;
            this._subBirthTime.fill(0);
            this._subDistance.fill(0);
            this._segementCount = 0;
            this._isTempEndVertex = false;
            this._needAddFirstVertex = false;
            this._lastFixedVertexPosition.setValue(0, 0, 0);
        }
    }
    TrailGeometry.ALIGNMENT_VIEW = 0;
    TrailGeometry.ALIGNMENT_TRANSFORM_Z = 1;
    TrailGeometry._tempVector30 = new Laya.Vector3();
    TrailGeometry._tempVector31 = new Laya.Vector3();
    TrailGeometry._tempVector32 = new Laya.Vector3();
    TrailGeometry._tempVector33 = new Laya.Vector3();
    TrailGeometry._tempVector34 = new Laya.Vector3();
    TrailGeometry._tempVector35 = new Laya.Vector3();
    TrailGeometry._tempVector36 = new Laya.Vector3();
    TrailGeometry._type = GeometryElement._typeCounter++;

    class TrailMaterial extends Material {
        constructor() {
            super();
            this.setShaderName("Trail");
            this.materialRenderMode = exports.MaterialRenderMode.RENDERMODE_ALPHABLENDED;
        }
        static __initDefine__() {
            TrailMaterial.MAINTEXTURE = Laya.Shader3D.propertyNameToID("u_MainTexture");
            TrailMaterial.TINTCOLOR = Laya.Shader3D.propertyNameToID("u_MainColor");
            TrailMaterial.TILINGOFFSET = Laya.Shader3D.propertyNameToID("u_TilingOffset");
        }
        get color() {
            return this._shaderValues.getColor(TrailMaterial.TINTCOLOR);
        }
        set color(value) {
            this._shaderValues.setColor(TrailMaterial.TINTCOLOR, value);
        }
        get texture() {
            return this._shaderValues.getTexture(TrailMaterial.MAINTEXTURE);
        }
        set texture(value) {
            if (value)
                this._shaderValues.addDefine(TrailMaterial.SHADERDEFINE_MAINTEXTURE);
            else
                this._shaderValues.removeDefine(TrailMaterial.SHADERDEFINE_MAINTEXTURE);
            this._shaderValues.setTexture(TrailMaterial.MAINTEXTURE, value);
        }
        get tilingOffset() {
            return this._shaderValues.getVector(TrailMaterial.TILINGOFFSET);
        }
        set tilingOffset(value) {
            if (value) {
                this._shaderValues.setVector(TrailMaterial.TILINGOFFSET, value);
            }
            else {
                this._shaderValues.getVector(TrailMaterial.TILINGOFFSET).setValue(1.0, 1.0, 0.0, 0.0);
            }
        }
        clone() {
            var dest = new TrailMaterial();
            this.cloneTo(dest);
            return dest;
        }
        set renderMode(value) {
            switch (value) {
                case TrailMaterial.RENDERMODE_ADDTIVE:
                    this.renderQueue = Material.RENDERQUEUE_TRANSPARENT;
                    this.depthWrite = false;
                    this.cull = Laya.RenderState.CULL_NONE;
                    this.blend = Laya.RenderState.BLEND_ENABLE_ALL;
                    this.blendSrc = Laya.RenderState.BLENDPARAM_SRC_ALPHA;
                    this.blendDst = Laya.RenderState.BLENDPARAM_ONE;
                    this.alphaTest = false;
                    this._shaderValues.addDefine(TrailMaterial.SHADERDEFINE_ADDTIVEFOG);
                    break;
                case TrailMaterial.RENDERMODE_ALPHABLENDED:
                    this.renderQueue = Material.RENDERQUEUE_TRANSPARENT;
                    this.depthWrite = false;
                    this.cull = Laya.RenderState.CULL_NONE;
                    this.blend = Laya.RenderState.BLEND_ENABLE_ALL;
                    this.blendSrc = Laya.RenderState.BLENDPARAM_SRC_ALPHA;
                    this.blendDst = Laya.RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA;
                    this.alphaTest = false;
                    this._shaderValues.removeDefine(TrailMaterial.SHADERDEFINE_ADDTIVEFOG);
                    break;
                default:
                    throw new Error("ShurikenParticleMaterial : renderMode value error.");
            }
        }
    }
    TrailMaterial.RENDERMODE_ALPHABLENDED = 0;
    TrailMaterial.RENDERMODE_ADDTIVE = 1;

    class TrailFilter {
        constructor(owner) {
            this._textureMode = TrailTextureMode.Stretch;
            this._totalLength = 0;
            this._lastPosition = new Laya.Vector3();
            this._curtime = 0;
            this.alignment = exports.TrailAlignment.View;
            this._ownerRender = owner;
            this._initDefaultData();
            this.addRenderElement();
        }
        static __init__() {
            TrailFilter.CURTIME = Laya.Shader3D.propertyNameToID("u_CurTime");
            TrailFilter.LIFETIME = Laya.Shader3D.propertyNameToID("u_LifeTime");
            TrailFilter.WIDTHCURVE = Laya.Shader3D.propertyNameToID("u_WidthCurve");
            TrailFilter.WIDTHCURVEKEYLENGTH = Laya.Shader3D.propertyNameToID("u_WidthCurveKeyLength");
            const spriteParms = Laya.LayaGL.renderOBJCreate.createGlobalUniformMap("Sprite3D");
            spriteParms.addShaderUniform(TrailFilter.CURTIME, "u_CurTime");
            spriteParms.addShaderUniform(TrailFilter.LIFETIME, "u_LifeTime");
            spriteParms.addShaderUniform(TrailFilter.WIDTHCURVE, "u_WidthCurve");
            spriteParms.addShaderUniform(TrailFilter.WIDTHCURVEKEYLENGTH, "u_WidthCurveKeyLength");
        }
        get time() {
            return this._time;
        }
        set time(value) {
            this._time = value;
            this._ownerRender._shaderValues.setNumber(TrailFilter.LIFETIME, value);
        }
        get minVertexDistance() {
            return this._minVertexDistance;
        }
        set minVertexDistance(value) {
            this._minVertexDistance = value;
        }
        get widthMultiplier() {
            return this._widthMultiplier;
        }
        set widthMultiplier(value) {
            this._widthMultiplier = value;
        }
        get widthCurve() {
            return this._widthCurve;
        }
        set widthCurve(value) {
            this._widthCurve = value;
            var widthCurveFloatArray = new Float32Array(value.length * 4);
            var i, j, index = 0;
            for (i = 0, j = value.length; i < j; i++) {
                widthCurveFloatArray[index++] = value[i].time;
                widthCurveFloatArray[index++] = value[i].inTangent;
                widthCurveFloatArray[index++] = value[i].outTangent;
                widthCurveFloatArray[index++] = value[i].value;
            }
            this._ownerRender._shaderValues.setBuffer(TrailFilter.WIDTHCURVE, widthCurveFloatArray);
            this._ownerRender._shaderValues.setInt(TrailFilter.WIDTHCURVEKEYLENGTH, value.length);
        }
        get colorGradient() {
            return this._colorGradient;
        }
        set colorGradient(value) {
            this._colorGradient = value;
        }
        get textureMode() {
            return this._textureMode;
        }
        set textureMode(value) {
            this._textureMode = value;
        }
        addRenderElement() {
            var render = this._ownerRender;
            var elements = render._renderElements;
            var material = render.sharedMaterials[0];
            (material) || (material = TrailMaterial.defaultMaterial);
            var element = new RenderElement();
            element.setTransform(this._ownerRender.owner._transform);
            element.render = render;
            element.material = material;
            this._trialGeometry = new TrailGeometry(this);
            element.setGeometry(this._trialGeometry);
            elements.push(element);
        }
        _update(state) {
            var render = this._ownerRender;
            const scene = this._ownerRender.owner.scene;
            if (!scene)
                return;
            this._curtime += scene.timer._delta / 1000;
            render._shaderValues.setNumber(TrailFilter.CURTIME, this._curtime);
            var curPos = this._ownerRender.owner.transform.position;
            var element = render._renderElements[0]._geometry;
            element._updateDisappear();
            element._updateTrail(state.camera, this._lastPosition, curPos);
            element._updateVertexBufferUV();
            curPos.cloneTo(this._lastPosition);
        }
        _initDefaultData() {
            this.time = 5.0;
            this.minVertexDistance = 0.1;
            this.widthMultiplier = 1;
            this.textureMode = TrailTextureMode.Stretch;
            var widthKeyFrames = [];
            var widthKeyFrame1 = new FloatKeyframe();
            widthKeyFrame1.time = 0;
            widthKeyFrame1.inTangent = 0;
            widthKeyFrame1.outTangent = 0;
            widthKeyFrame1.value = 1;
            widthKeyFrames.push(widthKeyFrame1);
            var widthKeyFrame2 = new FloatKeyframe();
            widthKeyFrame2.time = 1;
            widthKeyFrame2.inTangent = 0;
            widthKeyFrame2.outTangent = 0;
            widthKeyFrame2.value = 1;
            widthKeyFrames.push(widthKeyFrame2);
            this.widthCurve = widthKeyFrames;
            var gradient = new Gradient(2, 2);
            gradient.mode = GradientMode.Blend;
            gradient.addColorRGB(0, Laya.Color.WHITE);
            gradient.addColorRGB(1, Laya.Color.WHITE);
            gradient.addColorAlpha(0, 1);
            gradient.addColorAlpha(1, 1);
            this.colorGradient = gradient;
        }
        destroy() {
            this._trialGeometry.destroy();
            this._trialGeometry = null;
            this._widthCurve = null;
            this._colorGradient = null;
        }
        clear() {
            this._trialGeometry.clear();
            this._lastPosition.setValue(0, 0, 0);
            this._curtime = 0;
            this._totalLength = 0;
        }
    }

    class TrailRenderer extends BaseRender {
        constructor() {
            super();
            this._projectionViewWorldMatrix = new Laya.Matrix4x4();
            this._supportOctree = false;
        }
        _onAdded() {
            this._trailFilter = new TrailFilter(this);
        }
        get time() {
            return this._trailFilter.time;
        }
        set time(value) {
            this._trailFilter.time = value;
        }
        get minVertexDistance() {
            return this._trailFilter.minVertexDistance;
        }
        set minVertexDistance(value) {
            this._trailFilter.minVertexDistance = value;
        }
        get widthMultiplier() {
            return this._trailFilter.widthMultiplier;
        }
        set widthMultiplier(value) {
            this._trailFilter.widthMultiplier = value;
        }
        get widthCurve() {
            return this._trailFilter.widthCurve;
        }
        set widthCurve(value) {
            this._trailFilter.widthCurve = value;
        }
        get colorGradient() {
            return this._trailFilter.colorGradient;
        }
        set colorGradient(value) {
            this._trailFilter.colorGradient = value;
        }
        get textureMode() {
            return this._trailFilter.textureMode;
        }
        set textureMode(value) {
            this._trailFilter.textureMode = value;
        }
        get alignment() {
            return this._trailFilter.alignment;
        }
        set alignment(value) {
            this._trailFilter.alignment = value;
        }
        _onEnable() {
            super._onEnable();
            this.owner._transform.position.cloneTo(this._trailFilter._lastPosition);
        }
        onUpdate() {
            this._calculateBoundingBox();
        }
        get bounds() {
            return this._bounds;
        }
        _calculateBoundingBox() {
            let context = RenderContext3D._instance;
            this.boundsChange = false;
            this._trailFilter._update(context);
        }
        _renderUpdate(state, transform) {
            super._renderUpdate(state, transform);
        }
        clear() {
            this._trailFilter.clear();
        }
        _onDestroy() {
            this._trailFilter.destroy();
            super._onDestroy();
        }
        _cloneTo(dest) {
            super._cloneTo(dest);
            let render = dest;
            render.time = this.time;
            render.minVertexDistance = this.minVertexDistance;
            var widthCurve = [];
            var widthCurveData = this.widthCurve;
            for (let i = 0, n = this.widthCurve.length; i < n; i++) {
                widthCurve.push(widthCurveData[i].clone());
            }
            render.widthCurve = widthCurve;
            render.colorGradient = this.colorGradient.clone();
            render.textureMode = this.textureMode;
            render.alignment = this.alignment;
        }
    }

    class TrailSprite3D extends RenderableSprite3D {
        constructor(name = null) {
            super(name);
            this._render = this.addComponent(TrailRenderer);
            this._geometryFilter = this._render._trailFilter;
        }
        static __init__() { }
        get trailFilter() {
            return this._geometryFilter;
        }
        get trailRenderer() {
            return this._render;
        }
        _parse(data, spriteMap) {
            super._parse(data, spriteMap);
            var render = this._render;
            var filter = this._geometryFilter;
            var i, j;
            var materials = data.materials;
            if (materials) {
                var sharedMaterials = render.sharedMaterials;
                var materialCount = materials.length;
                sharedMaterials.length = materialCount;
                for (i = 0; i < materialCount; i++)
                    sharedMaterials[i] = Laya.Loader.getRes(materials[i].path);
                render.sharedMaterials = sharedMaterials;
            }
            filter.time = data.time;
            filter.minVertexDistance = data.minVertexDistance;
            filter.widthMultiplier = data.widthMultiplier;
            filter.textureMode = data.textureMode;
            (data.alignment != null) && (filter.alignment = data.alignment);
            var widthCurve = [];
            var widthCurveData = data.widthCurve;
            for (i = 0, j = widthCurveData.length; i < j; i++) {
                var trailkeyframe = new FloatKeyframe();
                trailkeyframe.time = widthCurveData[i].time;
                trailkeyframe.inTangent = widthCurveData[i].inTangent;
                trailkeyframe.outTangent = widthCurveData[i].outTangent;
                trailkeyframe.value = widthCurveData[i].value;
                widthCurve.push(trailkeyframe);
            }
            filter.widthCurve = widthCurve;
            var colorGradientData = data.colorGradient;
            var colorKeys = colorGradientData.colorKeys;
            var alphaKeys = colorGradientData.alphaKeys;
            var colorGradient = new Gradient(colorKeys.length, alphaKeys.length);
            colorGradient.mode = colorGradientData.mode;
            for (i = 0, j = colorKeys.length; i < j; i++) {
                var colorKey = colorKeys[i];
                colorGradient.addColorRGB(colorKey.time, new Laya.Color(colorKey.value[0], colorKey.value[1], colorKey.value[2], 1.0));
            }
            for (i = 0, j = alphaKeys.length; i < j; i++) {
                var alphaKey = alphaKeys[i];
                colorGradient.addColorAlpha(alphaKey.time, alphaKey.value);
            }
            filter.colorGradient = colorGradient;
        }
        _cloneTo(destObject, srcSprite, dstSprite) {
            super._cloneTo(destObject, srcSprite, dstSprite);
        }
        clear() {
            this._render.clear();
        }
        _create() {
            return new Sprite3D();
        }
    }

    class InstanceRenderElement extends RenderElement {
        constructor() {
            super();
            this.setGeometry(new MeshInstanceGeometry(null));
            this._instanceBatchElementList = new Laya.SingletonList();
            this._isUpdataData = true;
        }
        static create() {
            let elemet = InstanceRenderElement._pool.length > 0 ? InstanceRenderElement._pool.pop() : new InstanceRenderElement();
            elemet._isInPool = false;
            elemet.clear();
            return elemet;
        }
        getInvertFront() {
            return false;
        }
        _createRenderElementOBJ() {
            this._renderElementOBJ = Laya.LayaGL.renderOBJCreate.createInstanceRenderElement();
        }
        compileShader(context) {
            var passes = this._subShader._passes;
            this._renderElementOBJ._clearShaderInstance();
            for (var j = 0, m = passes.length; j < m; j++) {
                var pass = passes[j];
                if (pass._pipelineMode !== context.pipelineMode)
                    continue;
                var comDef = RenderElement._compileDefine;
                context.sceneShaderData._defineDatas.cloneTo(comDef);
                this.render && comDef.addDefineDatas(this.render._shaderValues._defineDatas);
                comDef.addDefineDatas(this._renderElementOBJ._materialShaderData._defineDatas);
                comDef.add(MeshSprite3DShaderDeclaration.SHADERDEFINE_GPU_INSTANCE);
                var shaderIns = pass.withCompile(comDef);
                this._renderElementOBJ._addShaderInstance(shaderIns);
            }
        }
        _renderUpdatePre(context) {
            var sceneMark = ILaya3D.Scene3D._updateMark;
            var transform = this.transform;
            context.renderElement = this;
            var modelDataRender = (!!this.render) ? (sceneMark !== this.render._sceneUpdateMark || this.renderType !== this.render._updateRenderType) : false;
            if (modelDataRender) {
                this.render._renderUpdate(context, transform);
                this.render._sceneUpdateMark = sceneMark;
            }
            var updateMark = Camera._updateMark;
            {
                this.render._renderUpdateWithCamera(context, transform);
                this.oriRendertype = this.render._updateRenderType;
                this.render._updateMark = updateMark;
                this.render._updateRenderType = this.renderType;
                if (this._isUpdataData) {
                    let mesh = this._geometry.subMesh._mesh;
                    this.updateInstanceData(mesh);
                    this._isUpdataData = false;
                }
            }
            const subUbo = (!!this.render) ? this.render._subUniformBufferData : false;
            if (subUbo) {
                subUbo._needUpdate && BaseRender._transLargeUbO.updateSubData(subUbo);
            }
            this._renderElementOBJ._isRender = this._geometry._prepareRender(context);
            this._geometry._updateRenderParams(context);
            this.compileShader(context._contextOBJ);
            this._geometry.instanceCount = this._instanceBatchElementList.length;
            this._renderElementOBJ._invertFront = this.getInvertFront();
        }
        updateInstanceData(mesh) {
            mesh._setInstanceBuffer();
            this._renderElementOBJ.clear();
            this._geometry.bufferState = mesh._instanceBufferState;
            switch (mesh._instanceBufferStateType) {
                case Mesh.MESH_INSTANCEBUFFER_TYPE_SIMPLEANIMATOR:
                    var worldMatrixData = this._renderElementOBJ.getUpdateData(0, 16 * InstanceRenderElement.maxInstanceCount);
                    this._renderElementOBJ.addUpdateBuffer(mesh._instanceWorldVertexBuffer, 16);
                    var insBatches = this._instanceBatchElementList;
                    var elements = insBatches.elements;
                    var count = insBatches.length;
                    this._renderElementOBJ.drawCount = count;
                    let bone = elements[0].render.rootBone;
                    if (bone) {
                        for (var i = 0; i < count; i++) {
                            var mat = (elements[i].render).rootBone._transform.worldMatrix;
                            worldMatrixData.set(mat.elements, i * 16);
                        }
                    }
                    else {
                        for (var i = 0; i < count; i++)
                            worldMatrixData.set(elements[i].transform.worldMatrix.elements, i * 16);
                    }
                    var simpleAnimatorData = this._renderElementOBJ.getUpdateData(1, 4 * InstanceRenderElement.maxInstanceCount);
                    if (bone) {
                        for (var i = 0; i < count; i++) {
                            var render = (elements[i].render);
                            render._computeAnimatorParamsData();
                            var simpleAnimatorParams = render._simpleAnimatorParams;
                            var offset = i * 4;
                            simpleAnimatorData[offset] = simpleAnimatorParams.x;
                            simpleAnimatorData[offset + 1] = simpleAnimatorParams.y;
                        }
                    }
                    else {
                        for (var i = 0; i < count; i++) {
                            simpleAnimatorData[offset] = 0;
                            simpleAnimatorData[offset + 1] = 0;
                        }
                    }
                    this._renderElementOBJ.addUpdateBuffer(mesh._instanceSimpleAniVertexBuffer, 4);
                    break;
                case Mesh.MESH_INSTANCEBUFFER_TYPE_NORMAL:
                    var worldMatrixData = this._renderElementOBJ.getUpdateData(0, 16 * InstanceRenderElement.maxInstanceCount);
                    this._renderElementOBJ.addUpdateBuffer(mesh._instanceWorldVertexBuffer, 16);
                    var insBatches = this._instanceBatchElementList;
                    var elements = insBatches.elements;
                    var count = insBatches.length;
                    this._renderElementOBJ.drawCount = count;
                    for (var i = 0; i < count; i++)
                        worldMatrixData.set(elements[i].transform.worldMatrix.elements, i * 16);
                    break;
            }
        }
        clear() {
            this._instanceBatchElementList.length = 0;
        }
        recover() {
            InstanceRenderElement._pool.push(this);
            this.render._updateRenderType = this.oriRendertype;
            this._isInPool = true;
        }
    }
    InstanceRenderElement.maxInstanceCount = 1024;
    InstanceRenderElement._pool = [];

    class SubMesh extends GeometryElement {
        constructor(mesh) {
            super(Laya.MeshTopology.Triangles, Laya.DrawType.DrawElement);
            this.indexFormat = mesh.indexFormat;
            if (mesh.indexFormat === Laya.IndexFormat.UInt32 && !Laya.LayaGL.renderEngine.getCapable(Laya.RenderCapable.Element_Index_Uint32)) {
                console.warn("SubMesh:this device do not support IndexFormat.UInt32.");
                return;
            }
            this._mesh = mesh;
            this._boneIndicesList = [];
            this._subIndexBufferStart = [];
            this._subIndexBufferCount = [];
        }
        get indexCount() {
            return this._indexCount;
        }
        _setIndexRange(indexStart, indexCount, indexFormat = Laya.IndexFormat.UInt16) {
            this._indexStart = indexStart;
            this._indexCount = indexCount;
            if (this._indexBuffer.canRead) {
                if (indexFormat == Laya.IndexFormat.UInt16) {
                    this._indices = new Uint16Array(this._indexBuffer.getData().buffer, indexStart * 2, indexCount);
                }
                else {
                    this._indices = new Uint32Array(this._indexBuffer.getData().buffer, indexStart * 4, indexCount);
                }
            }
        }
        _getType() {
            return SubMesh._type;
        }
        _prepareRender(state) {
            this._mesh._uploadVerticesData();
            return true;
        }
        _updateRenderParams(state) {
            var mesh = this._mesh;
            var skinnedDatas = (state.renderElement && !!(state.renderElement.render)) ? state.renderElement.render._skinnedData : null;
            var byteCount;
            switch (mesh.indexFormat) {
                case Laya.IndexFormat.UInt32:
                    byteCount = 4;
                    break;
                case Laya.IndexFormat.UInt16:
                    byteCount = 2;
                    break;
                case Laya.IndexFormat.UInt8:
                    byteCount = 1;
                    break;
            }
            this.clearRenderParams();
            this.bufferState = mesh._bufferState;
            if (skinnedDatas) {
                for (var i = 0, n = this._boneIndicesList.length; i < n; i++) {
                    this.setDrawElemenParams(this._subIndexBufferCount[i], this._subIndexBufferStart[i] * byteCount);
                }
            }
            else {
                this.setDrawElemenParams(this._indexCount, this._indexStart * byteCount);
            }
        }
        getIndices() {
            if (this._mesh._isReadable)
                return this._indices.slice();
            else
                throw "SubMesh:can't get indices on subMesh,mesh's isReadable must be true.";
        }
        setIndices(indices) {
            this._indexBuffer.setData(indices, this._indexStart, 0, this._indexCount);
        }
        destroy() {
            if (this._destroyed)
                return;
            super.destroy();
            this._indexBuffer.destroy();
            this._indexBuffer = null;
            this._mesh = null;
            this._boneIndicesList = null;
            this._subIndexBufferStart = null;
            this._subIndexBufferCount = null;
        }
    }
    SubMesh._type = GeometryElement._typeCounter++;

    class skinnedMatrixCache {
        constructor(subMeshIndex, batchIndex, batchBoneIndex) {
            this.subMeshIndex = subMeshIndex;
            this.batchIndex = batchIndex;
            this.batchBoneIndex = batchBoneIndex;
        }
    }
    class Mesh extends Laya.Resource {
        constructor(isReadable = true) {
            super();
            this._tempVector30 = new Laya.Vector3();
            this._tempVector31 = new Laya.Vector3();
            this._tempVector32 = new Laya.Vector3();
            this._minVerticesUpdate = -1;
            this._maxVerticesUpdate = -1;
            this._needUpdateBounds = true;
            this._bufferState = new Laya.BufferState();
            this._instanceBufferStateType = 0;
            this._vertexBuffer = null;
            this._indexBuffer = null;
            this._skinnedMatrixCaches = [];
            this._vertexCount = 0;
            this._indexFormat = Laya.IndexFormat.UInt16;
            this._bounds = new Bounds(new Laya.Vector3(), new Laya.Vector3());
            this._isReadable = isReadable;
            this._subMeshes = [];
            this.destoryedImmediately = false;
        }
        static __init__() {
            var physics3D = Physics3D._bullet;
            if (physics3D) {
                Mesh._nativeTempVector30 = physics3D.btVector3_create(0, 0, 0);
                Mesh._nativeTempVector31 = physics3D.btVector3_create(0, 0, 0);
                Mesh._nativeTempVector32 = physics3D.btVector3_create(0, 0, 0);
            }
        }
        static load(url, complete) {
            Laya.ILaya.loader.load(url, complete, null, Laya.Loader.MESH);
        }
        get inverseAbsoluteBindPoses() {
            return this._inverseBindPoses;
        }
        get vertexCount() {
            return this._vertexCount;
        }
        get indexCount() {
            return this._indexBuffer.indexCount;
        }
        get subMeshCount() {
            return this._subMeshes.length;
        }
        get bounds() {
            return this._bounds;
        }
        set bounds(value) {
            if (this._bounds !== value)
                value.cloneTo(this._bounds);
        }
        get indexFormat() {
            return this._indexFormat;
        }
        set indexFormat(value) {
            this._indexFormat = value;
            this._subMeshes.forEach(element => {
                element.indexFormat = value;
            });
        }
        _getPositionElement(vertexBuffer) {
            var vertexElements = vertexBuffer.vertexDeclaration._vertexElements;
            for (var i = 0, n = vertexElements.length; i < n; i++) {
                var vertexElement = vertexElements[i];
                if (vertexElement._elementFormat === Laya.VertexElementFormat.Vector3 && vertexElement._elementUsage === Laya.VertexMesh.MESH_POSITION0)
                    return vertexElement;
            }
            return null;
        }
        _getVerticeElementData(data, elementUsage) {
            data.length = this._vertexCount;
            var verDec = this._vertexBuffer.vertexDeclaration;
            var element = verDec.getVertexElementByUsage(elementUsage);
            if (element) {
                var uint8Vertices = this._vertexBuffer.getUint8Data();
                var floatVertices = this._vertexBuffer.getFloat32Data();
                var uint8VerStr = verDec.vertexStride;
                var floatVerStr = uint8VerStr / 4;
                var uint8EleOffset = element._offset;
                var floatEleOffset = uint8EleOffset / 4;
                switch (elementUsage) {
                    case Laya.VertexMesh.MESH_TEXTURECOORDINATE0:
                    case Laya.VertexMesh.MESH_TEXTURECOORDINATE1:
                        for (var i = 0; i < this._vertexCount; i++) {
                            var offset = floatVerStr * i + floatEleOffset;
                            data[i] = new Laya.Vector2(floatVertices[offset], floatVertices[offset + 1]);
                        }
                        break;
                    case Laya.VertexMesh.MESH_POSITION0:
                    case Laya.VertexMesh.MESH_NORMAL0:
                        for (var i = 0; i < this._vertexCount; i++) {
                            var offset = floatVerStr * i + floatEleOffset;
                            data[i] = new Laya.Vector3(floatVertices[offset], floatVertices[offset + 1], floatVertices[offset + 2]);
                        }
                        break;
                    case Laya.VertexMesh.MESH_TANGENT0:
                    case Laya.VertexMesh.MESH_BLENDWEIGHT0:
                        for (var i = 0; i < this._vertexCount; i++) {
                            var offset = floatVerStr * i + floatEleOffset;
                            data[i] = new Laya.Vector4(floatVertices[offset], floatVertices[offset + 1], floatVertices[offset + 2], floatVertices[offset + 3]);
                        }
                        break;
                    case Laya.VertexMesh.MESH_COLOR0:
                        for (var i = 0; i < this._vertexCount; i++) {
                            var offset = floatVerStr * i + floatEleOffset;
                            data[i] = new Laya.Color(floatVertices[offset], floatVertices[offset + 1], floatVertices[offset + 2], floatVertices[offset + 3]);
                        }
                        break;
                    case Laya.VertexMesh.MESH_BLENDINDICES0:
                        for (var i = 0; i < this._vertexCount; i++) {
                            var offset = uint8VerStr * i + uint8EleOffset;
                            data[i] = new Laya.Vector4(uint8Vertices[offset], uint8Vertices[offset + 1], uint8Vertices[offset + 2], uint8Vertices[offset + 3]);
                        }
                        break;
                    default:
                        throw "Mesh:Unknown elementUsage.";
                }
            }
        }
        _setVerticeElementData(data, elementUsage) {
            var verDec = this._vertexBuffer.vertexDeclaration;
            var element = verDec.getVertexElementByUsage(elementUsage);
            if (element) {
                var uint8Vertices = this._vertexBuffer.getUint8Data();
                var floatVertices = this._vertexBuffer.getFloat32Data();
                var uint8VerStr = verDec.vertexStride;
                var float8VerStr = uint8VerStr / 4;
                var uint8EleOffset = element._offset;
                var floatEleOffset = uint8EleOffset / 4;
                switch (elementUsage) {
                    case Laya.VertexMesh.MESH_TEXTURECOORDINATE0:
                    case Laya.VertexMesh.MESH_TEXTURECOORDINATE1:
                        for (var i = 0, n = data.length; i < n; i++) {
                            var offset = float8VerStr * i + floatEleOffset;
                            var vec2 = data[i];
                            floatVertices[offset] = vec2.x;
                            floatVertices[offset + 1] = vec2.y;
                        }
                        break;
                    case Laya.VertexMesh.MESH_POSITION0:
                    case Laya.VertexMesh.MESH_NORMAL0:
                        for (var i = 0, n = data.length; i < n; i++) {
                            var offset = float8VerStr * i + floatEleOffset;
                            var vec3 = data[i];
                            floatVertices[offset] = vec3.x;
                            floatVertices[offset + 1] = vec3.y;
                            floatVertices[offset + 2] = vec3.z;
                        }
                        break;
                    case Laya.VertexMesh.MESH_TANGENT0:
                    case Laya.VertexMesh.MESH_BLENDWEIGHT0:
                        for (var i = 0, n = data.length; i < n; i++) {
                            var offset = float8VerStr * i + floatEleOffset;
                            var vec4 = data[i];
                            floatVertices[offset] = vec4.x;
                            floatVertices[offset + 1] = vec4.y;
                            floatVertices[offset + 2] = vec4.z;
                            floatVertices[offset + 3] = vec4.w;
                        }
                        break;
                    case Laya.VertexMesh.MESH_COLOR0:
                        for (var i = 0, n = data.length; i < n; i++) {
                            var offset = float8VerStr * i + floatEleOffset;
                            var cor = data[i];
                            floatVertices[offset] = cor.r;
                            floatVertices[offset + 1] = cor.g;
                            floatVertices[offset + 2] = cor.b;
                            floatVertices[offset + 3] = cor.a;
                        }
                        break;
                    case Laya.VertexMesh.MESH_BLENDINDICES0:
                        for (var i = 0, n = data.length; i < n; i++) {
                            var offset = uint8VerStr * i + uint8EleOffset;
                            var vec4 = data[i];
                            uint8Vertices[offset] = vec4.x;
                            uint8Vertices[offset + 1] = vec4.y;
                            uint8Vertices[offset + 2] = vec4.z;
                            uint8Vertices[offset + 3] = vec4.w;
                        }
                        break;
                    default:
                        throw "Mesh:Unknown elementUsage.";
                }
                this._minVerticesUpdate = 0;
                this._maxVerticesUpdate = Number.MAX_SAFE_INTEGER;
            }
            else {
                console.warn("Mesh: the mesh don't have  this VertexElement.");
            }
        }
        _disposeResource() {
            for (var i = 0, n = this._subMeshes.length; i < n; i++)
                this._subMeshes[i].destroy();
            this._btTriangleMesh && Physics3D._bullet.btStridingMeshInterface_destroy(this._btTriangleMesh);
            this._vertexBuffer && this._vertexBuffer.destroy();
            this._indexBuffer && this._indexBuffer.destroy();
            this._bufferState.destroy();
            this._instanceBufferState && this._instanceBufferState.destroy();
            this._instanceWorldVertexBuffer && this._instanceWorldVertexBuffer.destroy();
            this._instanceSimpleAniVertexBuffer && this._instanceSimpleAniVertexBuffer.destroy();
            this.instanceWorldMatrixData && (this.instanceWorldMatrixData = null);
            this.instanceSimpleAnimatorData && (this.instanceSimpleAnimatorData = null);
            this._setCPUMemory(0);
            this._setGPUMemory(0);
            this._bufferState = null;
            this._instanceBufferState = null;
            this._vertexBuffer = null;
            this._indexBuffer = null;
            this._subMeshes = null;
            this._btTriangleMesh = null;
            this._indexBuffer = null;
            this._boneNames = null;
            this._inverseBindPoses = null;
        }
        _setSubMeshes(subMeshes) {
            this._subMeshes = subMeshes;
            for (var i = 0, n = subMeshes.length; i < n; i++)
                subMeshes[i]._indexInMesh = i;
        }
        _setBuffer(vertexBuffer, indexBuffer) {
            var bufferState = this._bufferState;
            bufferState.applyState([vertexBuffer], indexBuffer);
        }
        _setInstanceBuffer() {
            if (this._instanceBufferState)
                return;
            var instanceBufferState = this._instanceBufferState = new Laya.BufferState();
            var instanceBufferStateType = this._instanceBufferStateType;
            let vertexArray = [];
            vertexArray.push(this._vertexBuffer);
            let instanceBuffer3D = this._instanceWorldVertexBuffer = Laya.LayaGL.renderOBJCreate.createVertexBuffer3D(InstanceRenderElement.maxInstanceCount * 16 * 4, Laya.BufferUsage.Dynamic, false);
            instanceBuffer3D.vertexDeclaration = Laya.VertexMesh.instanceWorldMatrixDeclaration;
            instanceBuffer3D.instanceBuffer = true;
            vertexArray.push(instanceBuffer3D);
            this.instanceWorldMatrixData = new Float32Array(InstanceRenderElement.maxInstanceCount * 16);
            switch (instanceBufferStateType) {
                case Mesh.MESH_INSTANCEBUFFER_TYPE_SIMPLEANIMATOR:
                    let instanceSimpleAnimatorBuffer = this._instanceSimpleAniVertexBuffer = Laya.LayaGL.renderOBJCreate.createVertexBuffer3D(InstanceRenderElement.maxInstanceCount * 4 * 4, Laya.BufferUsage.Dynamic, false);
                    instanceSimpleAnimatorBuffer.vertexDeclaration = Laya.VertexMesh.instanceSimpleAnimatorDeclaration;
                    instanceSimpleAnimatorBuffer.instanceBuffer = true;
                    this.instanceSimpleAnimatorData = new Float32Array(InstanceRenderElement.maxInstanceCount * 4);
                    vertexArray.push(instanceSimpleAnimatorBuffer);
                    break;
            }
            instanceBufferState.applyState(vertexArray, this._indexBuffer);
        }
        _getPhysicMesh() {
            var bt = Physics3D._bullet;
            var triangleMesh = bt.btTriangleMesh_create();
            var nativePositio0 = Mesh._nativeTempVector30;
            var nativePositio1 = Mesh._nativeTempVector31;
            var nativePositio2 = Mesh._nativeTempVector32;
            var position0 = this._tempVector30;
            var position1 = this._tempVector31;
            var position2 = this._tempVector32;
            var vertexBuffer = this._vertexBuffer;
            var positionElement = this._getPositionElement(vertexBuffer);
            var verticesData = vertexBuffer.getFloat32Data();
            var floatCount = vertexBuffer.vertexDeclaration.vertexStride / 4;
            var posOffset = positionElement._offset / 4;
            var indices = this._indexBuffer.getData();
            for (var i = 0, n = indices.length; i < n; i += 3) {
                var p0Index = indices[i] * floatCount + posOffset;
                var p1Index = indices[i + 1] * floatCount + posOffset;
                var p2Index = indices[i + 2] * floatCount + posOffset;
                position0.setValue(verticesData[p0Index], verticesData[p0Index + 1], verticesData[p0Index + 2]);
                position1.setValue(verticesData[p1Index], verticesData[p1Index + 1], verticesData[p1Index + 2]);
                position2.setValue(verticesData[p2Index], verticesData[p2Index + 1], verticesData[p2Index + 2]);
                Utils3D._convertToBulletVec3(position0, nativePositio0);
                Utils3D._convertToBulletVec3(position1, nativePositio1);
                Utils3D._convertToBulletVec3(position2, nativePositio2);
                bt.btTriangleMesh_addTriangle(triangleMesh, nativePositio0, nativePositio1, nativePositio2, false);
            }
            this._btTriangleMesh = triangleMesh;
            return this._btTriangleMesh;
        }
        _uploadVerticesData() {
            var min = this._minVerticesUpdate;
            var max = this._maxVerticesUpdate;
            if (min !== -1 && max !== -1) {
                var offset = min;
                this._vertexBuffer.setData(this._vertexBuffer.getUint8Data().buffer, offset, offset, max - min);
                this._minVerticesUpdate = -1;
                this._maxVerticesUpdate = -1;
            }
        }
        getSubMesh(index) {
            return this._subMeshes[index];
        }
        getPositions(positions) {
            if (this._isReadable)
                this._getVerticeElementData(positions, Laya.VertexMesh.MESH_POSITION0);
            else
                throw "Mesh:can't get positions on mesh,isReadable must be true.";
        }
        setPositions(positions) {
            if (this._isReadable) {
                this._setVerticeElementData(positions, Laya.VertexMesh.MESH_POSITION0);
                this._needUpdateBounds = true;
            }
            else {
                throw "Mesh:setPosition() need isReadable must be true or use setVertices().";
            }
        }
        getColors(colors) {
            if (this._isReadable)
                this._getVerticeElementData(colors, Laya.VertexMesh.MESH_COLOR0);
            else
                throw "Mesh:can't get colors on mesh,isReadable must be true.";
        }
        setColors(colors) {
            if (this._isReadable)
                this._setVerticeElementData(colors, Laya.VertexMesh.MESH_COLOR0);
            else
                throw "Mesh:setColors() need isReadable must be true or use setVertices().";
        }
        getUVs(uvs, channel = 0) {
            if (this._isReadable) {
                switch (channel) {
                    case 0:
                        this._getVerticeElementData(uvs, Laya.VertexMesh.MESH_TEXTURECOORDINATE0);
                        break;
                    case 1:
                        this._getVerticeElementData(uvs, Laya.VertexMesh.MESH_TEXTURECOORDINATE1);
                        break;
                    default:
                        throw "Mesh:Invalid channel.";
                }
            }
            else {
                throw "Mesh:can't get uvs on mesh,isReadable must be true.";
            }
        }
        setUVs(uvs, channel = 0) {
            if (this._isReadable) {
                switch (channel) {
                    case 0:
                        this._setVerticeElementData(uvs, Laya.VertexMesh.MESH_TEXTURECOORDINATE0);
                        break;
                    case 1:
                        this._setVerticeElementData(uvs, Laya.VertexMesh.MESH_TEXTURECOORDINATE1);
                        break;
                    default:
                        throw "Mesh:Invalid channel.";
                }
            }
            else {
                throw "Mesh:setUVs() need isReadable must be true or use setVertices().";
            }
        }
        getNormals(normals) {
            if (this._isReadable)
                this._getVerticeElementData(normals, Laya.VertexMesh.MESH_NORMAL0);
            else
                throw "Mesh:can't get colors on mesh,isReadable must be true.";
        }
        setNormals(normals) {
            if (this._isReadable)
                this._setVerticeElementData(normals, Laya.VertexMesh.MESH_NORMAL0);
            else
                throw "Mesh:setNormals() need must be true or use setVertices().";
        }
        getTangents(tangents) {
            if (this._isReadable)
                this._getVerticeElementData(tangents, Laya.VertexMesh.MESH_TANGENT0);
            else
                throw "Mesh:can't get colors on mesh,isReadable must be true.";
        }
        setTangents(tangents) {
            if (this._isReadable)
                this._setVerticeElementData(tangents, Laya.VertexMesh.MESH_TANGENT0);
            else
                throw "Mesh:setTangents() need isReadable must be true or use setVertices().";
        }
        getBoneWeights(boneWeights) {
            if (this._isReadable)
                this._getVerticeElementData(boneWeights, Laya.VertexMesh.MESH_BLENDWEIGHT0);
            else
                throw "Mesh:can't get boneWeights on mesh,isReadable must be true.";
        }
        setBoneWeights(boneWeights) {
            if (this._isReadable)
                this._setVerticeElementData(boneWeights, Laya.VertexMesh.MESH_BLENDWEIGHT0);
            else
                throw "Mesh:setBoneWeights() need isReadable must be true or use setVertices().";
        }
        getBoneIndices(boneIndices) {
            if (this._isReadable)
                this._getVerticeElementData(boneIndices, Laya.VertexMesh.MESH_BLENDINDICES0);
            else
                throw "Mesh:can't get boneIndices on mesh,isReadable must be true.";
        }
        setBoneIndices(boneIndices) {
            if (this._isReadable)
                this._setVerticeElementData(boneIndices, Laya.VertexMesh.MESH_BLENDINDICES0);
            else
                throw "Mesh:setBoneIndices() need isReadable must be true or use setVertices().";
        }
        markAsUnreadbale() {
            this._uploadVerticesData();
            this._vertexBuffer.markAsUnreadbale();
            this._isReadable = false;
        }
        getVertexDeclaration() {
            return this._vertexBuffer._vertexDeclaration;
        }
        getVertices() {
            if (this._isReadable)
                return this._vertexBuffer.getUint8Data().buffer.slice(0);
            else
                throw "Mesh:can't get vertices on mesh,isReadable must be true.";
        }
        setVertices(vertices) {
            this._vertexBuffer.setData(vertices);
            this._needUpdateBounds = true;
        }
        getIndices() {
            if (this._isReadable)
                return this._indexBuffer.getData().slice();
            else
                throw "Mesh:can't get indices on subMesh,mesh's isReadable must be true.";
        }
        setIndices(indices) {
            var format;
            if (indices instanceof Uint32Array)
                format = Laya.IndexFormat.UInt32;
            else if (indices instanceof Uint16Array)
                format = Laya.IndexFormat.UInt16;
            else if (indices instanceof Uint8Array)
                format = Laya.IndexFormat.UInt8;
            var indexBuffer = this._indexBuffer;
            if (this._indexFormat !== format || indexBuffer.indexCount !== indices.length) {
                indexBuffer.destroy();
                this._indexBuffer = indexBuffer = Laya.LayaGL.renderOBJCreate.createIndexBuffer3D(format, indices.length, Laya.BufferUsage.Static, this._isReadable);
            }
            indexBuffer.setData(indices);
            this.indexFormat = format;
        }
        calculateBounds() {
            if (this._isReadable) {
                if (this._needUpdateBounds) {
                    var min = this._tempVector30;
                    var max = this._tempVector31;
                    min.x = min.y = min.z = Number.MAX_VALUE;
                    max.x = max.y = max.z = -Number.MAX_VALUE;
                    var vertexBuffer = this._vertexBuffer;
                    var positionElement = this._getPositionElement(vertexBuffer);
                    var verticesData = vertexBuffer.getFloat32Data();
                    var floatCount = vertexBuffer.vertexDeclaration.vertexStride / 4;
                    var posOffset = positionElement._offset / 4;
                    for (var j = 0, m = verticesData.length; j < m; j += floatCount) {
                        var ofset = j + posOffset;
                        var pX = verticesData[ofset];
                        var pY = verticesData[ofset + 1];
                        var pZ = verticesData[ofset + 2];
                        min.x = Math.min(min.x, pX);
                        min.y = Math.min(min.y, pY);
                        min.z = Math.min(min.z, pZ);
                        max.x = Math.max(max.x, pX);
                        max.y = Math.max(max.y, pY);
                        max.z = Math.max(max.z, pZ);
                    }
                    this._bounds.setMin(min);
                    this._bounds.setMax(max);
                    this._needUpdateBounds = false;
                }
            }
            else {
                throw "Mesh:can't calculate bounds on subMesh,mesh's isReadable must be true.";
            }
        }
        cloneTo(destObject) {
            var destMesh = destObject;
            var vb = this._vertexBuffer;
            var destVB = Laya.LayaGL.renderOBJCreate.createVertexBuffer3D(vb._byteLength, vb.bufferUsage, vb.canRead);
            destVB.vertexDeclaration = vb.vertexDeclaration;
            destVB.setData(vb.getUint8Data().slice().buffer);
            destMesh._vertexBuffer = destVB;
            destMesh._vertexCount = this._vertexCount;
            var ib = this._indexBuffer;
            var destIB = Laya.LayaGL.renderOBJCreate.createIndexBuffer3D(Laya.IndexFormat.UInt16, ib.indexCount, ib.bufferUsage, ib.canRead);
            destIB.setData(ib.getData().slice());
            destMesh._indexBuffer = destIB;
            destMesh._setBuffer(destMesh._vertexBuffer, destIB);
            destMesh._instanceBufferStateType = this._instanceBufferStateType;
            destMesh._setCPUMemory(this.cpuMemory);
            destMesh._setGPUMemory(this.gpuMemory);
            var i;
            var boneNames = this._boneNames;
            if (boneNames) {
                var destBoneNames = destMesh._boneNames = [];
                for (i = 0; i < boneNames.length; i++)
                    destBoneNames[i] = boneNames[i];
            }
            var inverseBindPoses = this._inverseBindPoses;
            if (inverseBindPoses) {
                var destInverseBindPoses = destMesh._inverseBindPoses = [];
                for (i = 0; i < inverseBindPoses.length; i++)
                    destInverseBindPoses[i] = inverseBindPoses[i];
            }
            var cacheLength = this._skinnedMatrixCaches.length;
            destMesh._skinnedMatrixCaches.length = cacheLength;
            for (i = 0; i < cacheLength; i++) {
                var skinnedCache = this._skinnedMatrixCaches[i];
                if (skinnedCache)
                    destMesh._skinnedMatrixCaches[i] = new skinnedMatrixCache(skinnedCache.subMeshIndex, skinnedCache.batchIndex, skinnedCache.batchBoneIndex);
            }
            for (i = 0; i < this.subMeshCount; i++) {
                var subMesh = this._subMeshes[i];
                var subIndexBufferStart = subMesh._subIndexBufferStart;
                var subIndexBufferCount = subMesh._subIndexBufferCount;
                var boneIndicesList = subMesh._boneIndicesList;
                var destSubmesh = new SubMesh(destMesh);
                destSubmesh._subIndexBufferStart.length = subIndexBufferStart.length;
                destSubmesh._subIndexBufferCount.length = subIndexBufferCount.length;
                destSubmesh._boneIndicesList.length = boneIndicesList.length;
                for (var j = 0; j < subIndexBufferStart.length; j++)
                    destSubmesh._subIndexBufferStart[j] = subIndexBufferStart[j];
                for (j = 0; j < subIndexBufferCount.length; j++)
                    destSubmesh._subIndexBufferCount[j] = subIndexBufferCount[j];
                for (j = 0; j < boneIndicesList.length; j++)
                    destSubmesh._boneIndicesList[j] = new Uint16Array(boneIndicesList[j]);
                destSubmesh._indexBuffer = destIB;
                destSubmesh._indexStart = subMesh._indexStart;
                destSubmesh._indexCount = subMesh._indexCount;
                destSubmesh._indices = new Uint16Array(destIB.getData().buffer, subMesh._indexStart * 2, subMesh._indexCount);
                var vertexBuffer = destMesh._vertexBuffer;
                destSubmesh._vertexBuffer = vertexBuffer;
                destMesh._subMeshes.push(destSubmesh);
            }
            destMesh._setSubMeshes(destMesh._subMeshes);
        }
        clone() {
            var dest = new Mesh();
            this.cloneTo(dest);
            return dest;
        }
    }
    Mesh.MESH_INSTANCEBUFFER_TYPE_NORMAL = 0;
    Mesh.MESH_INSTANCEBUFFER_TYPE_SIMPLEANIMATOR = 1;

    exports.AreaShape = void 0;
    (function (AreaShape) {
        AreaShape[AreaShape["rectangle"] = 0] = "rectangle";
        AreaShape[AreaShape["ellipse"] = 1] = "ellipse";
    })(exports.AreaShape || (exports.AreaShape = {}));
    class AreaLightCom extends Light {
        constructor() {
            super();
            this._lightType = exports.LightType.Area;
            this._lightmapBakedType = exports.LightMode.bakeOnly;
            this._spread = 90;
            this._maxBounces = 1024;
            this._size = new Laya.Vector2(1, 1);
            this._areaShape = exports.AreaShape.rectangle;
            this._power = 100;
        }
        get lightmapBakedType() {
            return exports.LightMode.bakeOnly;
        }
        set lightmapBakedType(value) {
            this._lightmapBakedType = exports.LightMode.bakeOnly;
        }
        get shape() {
            return this._areaShape;
        }
        set shape(value) {
            this._areaShape = value;
        }
        set power(value) {
            this._power = value;
        }
        get power() {
            return this._power;
        }
        set size(value) {
            value && value.cloneTo(this._size);
        }
        get size() {
            return this._size;
        }
        set spread(value) {
            this._spread = Math.min((Math.max(0, value)), 180);
        }
        get spread() {
            return this._spread;
        }
        set maxBounces(value) {
            this._maxBounces = value;
        }
        get maxBounces() {
            return this._maxBounces;
        }
        _addToLightQueue() {
        }
        _removeFromLightQueue() {
        }
        _parse(data, spriteMap) {
            super._parse(data, spriteMap);
        }
        _cloneTo(dest) {
            super._cloneTo(dest);
        }
        _create() {
            return new AreaLightCom();
        }
    }

    const tempVec$1 = new Laya.Vector3();
    new Laya.Vector3();
    class LODInfo {
        constructor(mincullRate) {
            this._mincullRate = mincullRate;
            this._renders = [];
            this._cachSprite3D = [];
        }
        set mincullRate(value) {
            this._mincullRate = value;
        }
        get mincullRate() {
            return this._mincullRate;
        }
        set group(value) {
            if (value == this._group)
                return;
            if (this._group) {
                for (let i = 0, n = this._renders.length; i < n; i++) {
                    let element = this._renders[i];
                    element.owner.transform.off(Laya.Event.TRANSFORM_CHANGED, this._group._updateRecaculateFlag);
                    element._LOD = -1;
                }
            }
            this._group = value;
            for (let i = 0, n = this._renders.length; i < n; i++) {
                let element = this._renders[i];
                element.owner.transform.on(Laya.Event.TRANSFORM_CHANGED, this._group, this._group._updateRecaculateFlag);
                element._LOD = this._lodIndex;
            }
        }
        set renders(value) {
            this._cachSprite3D = value;
            for (var i = 0, n = value.length; i < n; i++) {
                this.addNode(value[i]);
            }
        }
        get renders() {
            return this._cachSprite3D;
        }
        addNode(node) {
            if (!node)
                return;
            let ren = node;
            if (ren._isRenderNode > 0) {
                let components = ren.components;
                for (let comp of components) {
                    if ((comp instanceof BaseRender) && this._renders.indexOf(comp) == -1)
                        this._renders.push(comp);
                }
                this._group && node.transform.on(Laya.Event.TRANSFORM_CHANGED, this._group, this._group._updateRecaculateFlag);
            }
            for (var i = 0, n = node.numChildren; i < n; i++) {
                this.addNode(node.getChildAt(i));
            }
        }
        removeNode(node) {
            let ren = node;
            if (ren._isRenderNode > 0) {
                let components = ren.components;
                let index;
                for (let comp of components) {
                    if ((comp instanceof BaseRender) && (index = this._renders.indexOf(comp)) == -1) {
                        this._renders.splice(index, 1);
                        comp.setRenderbitFlag(exports.RenderBitFlag.RenderBitFlag_CullFlag, false);
                        this._group && node.transform.off(Laya.Event.TRANSFORM_CHANGED, this._group._updateRecaculateFlag);
                    }
                }
            }
            for (var i = 0, n = node.numChildren; i < n; i++) {
                this.removeNode(node.getChildAt(i));
            }
        }
        removeAllRender() {
            this._renders.forEach(element => {
                element.setRenderbitFlag(exports.RenderBitFlag.RenderBitFlag_CullFlag, false);
            });
        }
    }
    class LODGroup extends Laya.Component {
        constructor() {
            super();
            this._needcaculateBounds = false;
            this._lods = [];
            this._visialIndex = -1;
            this._bounds = new Bounds();
            this._lodPosition = new Laya.Vector3();
            this.runInEditor = true;
        }
        get lods() {
            return this._lods;
        }
        set lods(data) {
            this._lods = data;
            for (var i = 0, n = this._lods.length; i < n; i++) {
                let element = this._lods[i];
                element._lodIndex = i;
                element.group = this;
                this._setLODinvisible(i);
            }
            this._updateRecaculateFlag();
            this._visialIndex = -1;
            this._lodCount = this._lods.length;
        }
        get nowRate() {
            return this._nowRate;
        }
        get bounds() {
            this.recalculateBounds();
            return this._bounds;
        }
        _onEnable() {
            super._onEnable();
        }
        _onDisable() {
            super._onDisable();
            this._lods.forEach(element => {
                element.removeAllRender();
            });
        }
        _applyVisibleRate(rate) {
            for (var i = 0; i < this._lodCount; i++) {
                let lod = this._lods[i];
                if (rate > lod.mincullRate) {
                    if (i == -1) {
                        this._setLODvisible(i);
                        this._visialIndex = i;
                        return;
                    }
                    if (i == this._visialIndex)
                        return;
                    else {
                        (this._visialIndex != -1) && this._setLODinvisible(this._visialIndex);
                        this._setLODvisible(i);
                        this._visialIndex = i;
                        return;
                    }
                }
            }
            if (this._visialIndex != -1) {
                this._setLODinvisible(this._visialIndex);
                this._visialIndex = -1;
            }
        }
        _setLODvisible(index) {
            let lod = this._lods[index];
            for (var i = 0, n = lod._renders.length; i < n; i++) {
                lod._renders[i].setRenderbitFlag(exports.RenderBitFlag.RenderBitFlag_CullFlag, false);
            }
        }
        _setLODinvisible(index) {
            let lod = this._lods[index];
            for (var i = 0, n = lod._renders.length; i < n; i++) {
                lod._renders[i].setRenderbitFlag(exports.RenderBitFlag.RenderBitFlag_CullFlag, true);
            }
        }
        onDestroy() {
            this._lods.forEach(element => {
                let renderarray = element._renders;
                for (var i = 0; i < renderarray.length; i++) {
                    element.removeNode(renderarray[i].owner);
                }
            });
        }
        _updateRecaculateFlag() {
            this._needcaculateBounds = true;
        }
        _cloneTo(lodGroup) {
            super._cloneTo(lodGroup);
            let getCommomParent = (rootNode, rootCheckNode) => {
                let nodeArray = [];
                let node = rootNode;
                while (!!node) {
                    if (node instanceof Sprite3D)
                        nodeArray.push(node);
                    node = node.parent;
                }
                let checkNode = rootCheckNode;
                while (!!checkNode && nodeArray.indexOf(checkNode) == -1) {
                    checkNode = checkNode.parent;
                }
                return checkNode;
            };
            let cloneHierachFun = (rootNode, rootCheckNode, destNode) => {
                let rootparent = getCommomParent(rootNode, rootCheckNode);
                if (!rootparent)
                    return null;
                let path = [];
                Utils3D._getHierarchyPath(rootparent, rootNode, path);
                let pathcheck = [];
                Utils3D._getHierarchyPath(rootparent, rootCheckNode, pathcheck);
                let destParent = Utils3D._getParentNodeByHierarchyPath(destNode, path);
                if (!destParent)
                    return null;
                return Utils3D._getNodeByHierarchyPath(destParent, pathcheck);
            };
            let lodArray = [];
            for (let i = 0, n = this._lodCount; i < n; i++) {
                let lod = this._lods[i];
                let cloneLOD = new LODInfo(lod.mincullRate);
                lodArray.push(cloneLOD);
                lod._renders.forEach(element => {
                    let node = cloneHierachFun(this.owner, element.owner, lodGroup.owner);
                    if (node)
                        cloneLOD.addNode(node);
                });
            }
            lodGroup.lods = lodArray;
        }
        recalculateBounds() {
            if (!this._needcaculateBounds) {
                return;
            }
            let firstBounds = true;
            for (let i = 0, n = this._lods.length; i < n; i++) {
                let lod = this._lods[i];
                lod._renders.forEach(element => {
                    if (firstBounds) {
                        element.bounds.cloneTo(this._bounds);
                        firstBounds = false;
                    }
                    else
                        Bounds.merge(this._bounds, element.bounds, this._bounds);
                });
            }
            this._lodPosition = this._bounds.getCenter();
            let extend = this._bounds.getExtent();
            this._size = 2 * Math.max(extend.x, extend.y, extend.z);
            this._needcaculateBounds = false;
        }
        onPreRender() {
            this.recalculateBounds();
            let checkCamera = this.owner.scene.cullInfoCamera;
            let maxYDistance = checkCamera.maxlocalYDistance;
            let cameraFrustum = checkCamera.boundFrustum;
            Laya.Vector3.subtract(this._lodPosition, checkCamera.transform.position, tempVec$1);
            let length = tempVec$1.length();
            if (length > checkCamera.farPlane || cameraFrustum.containsPoint(this._lodPosition) == 0) {
                return;
            }
            let rateYDistance = length / checkCamera.farPlane * maxYDistance;
            let rate = (this._size / rateYDistance);
            this._nowRate = rate;
            this._applyVisibleRate(rate);
        }
    }

    class PixelLineData {
        constructor() {
            this.startPosition = new Laya.Vector3();
            this.endPosition = new Laya.Vector3();
            this.startColor = new Laya.Color();
            this.endColor = new Laya.Color();
        }
        cloneTo(destObject) {
            this.startPosition.cloneTo(destObject.startPosition);
            this.endPosition.cloneTo(destObject.endPosition);
            this.startColor.cloneTo(destObject.startColor);
            this.endColor.cloneTo(destObject.endColor);
        }
    }

    class PixelLineVertex {
        constructor() {
        }
        static get vertexDeclaration() {
            return PixelLineVertex._vertexDeclaration;
        }
        static __init__() {
            PixelLineVertex._vertexDeclaration = new Laya.VertexDeclaration(28, [new Laya.VertexElement(0, Laya.VertexElementFormat.Vector3, Laya.VertexMesh.MESH_POSITION0),
                new Laya.VertexElement(12, Laya.VertexElementFormat.Vector4, Laya.VertexMesh.MESH_COLOR0)]);
        }
        get vertexDeclaration() {
            return PixelLineVertex._vertexDeclaration;
        }
    }

    class PixelLineFilter extends GeometryElement {
        constructor(owner, maxLineCount) {
            super(Laya.MeshTopology.Lines, Laya.DrawType.DrawArray);
            this._floatCountPerVertices = 7;
            this._minUpdate = Number.MAX_VALUE;
            this._maxUpdate = Number.MIN_VALUE;
            this._floatBound = new Float32Array(6);
            this._calculateBound = false;
            this._maxLineCount = 0;
            this._lineCount = 0;
            var pointCount = maxLineCount * 2;
            this._ownerRender = owner;
            this._maxLineCount = maxLineCount;
            this._vertices = new Float32Array(pointCount * this._floatCountPerVertices);
            this._vertexBuffer = Laya.LayaGL.renderOBJCreate.createVertexBuffer3D(PixelLineVertex.vertexDeclaration.vertexStride * pointCount, Laya.BufferUsage.Static, false);
            this._vertexBuffer.vertexDeclaration = PixelLineVertex.vertexDeclaration;
            var bufferState = new Laya.BufferState();
            this.bufferState = bufferState;
            this.bufferState.applyState([this._vertexBuffer], null);
            var min = PixelLineFilter._tempVector0;
            var max = PixelLineFilter._tempVector1;
            min.setValue(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
            max.setValue(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
            this._bounds = new Bounds(min, max);
        }
        _getType() {
            return PixelLineFilter._type;
        }
        _resizeLineData(maxCount) {
            var pointCount = maxCount * 2;
            var lastVertices = this._vertices;
            this._vertexBuffer.destroy();
            this._maxLineCount = maxCount;
            var vertexCount = pointCount * this._floatCountPerVertices;
            this._vertices = new Float32Array(vertexCount);
            this._vertexBuffer = Laya.LayaGL.renderOBJCreate.createVertexBuffer3D(PixelLineVertex.vertexDeclaration.vertexStride * pointCount, Laya.BufferUsage.Static, false);
            this._vertexBuffer.vertexDeclaration = PixelLineVertex.vertexDeclaration;
            if (vertexCount < lastVertices.length) {
                this._vertices.set(new Float32Array(lastVertices.buffer, 0, vertexCount));
                this._vertexBuffer.setData(this._vertices.buffer, 0, 0, vertexCount * 4);
            }
            else {
                this._vertices.set(lastVertices);
                this._vertexBuffer.setData(this._vertices.buffer, 0, 0, lastVertices.length * 4);
            }
            this.bufferState.applyState([this._vertexBuffer], null);
            this._minUpdate = Number.MAX_VALUE;
            this._maxUpdate = Number.MIN_VALUE;
        }
        _updateLineVertices(offset, startPosition, endPosition, startColor, endColor) {
            if (startPosition) {
                this._vertices[offset + 0] = startPosition.x;
                this._vertices[offset + 1] = startPosition.y;
                this._vertices[offset + 2] = startPosition.z;
            }
            if (startColor) {
                this._vertices[offset + 3] = startColor.r;
                this._vertices[offset + 4] = startColor.g;
                this._vertices[offset + 5] = startColor.b;
                this._vertices[offset + 6] = startColor.a;
            }
            if (endPosition) {
                this._vertices[offset + 7] = endPosition.x;
                this._vertices[offset + 8] = endPosition.y;
                this._vertices[offset + 9] = endPosition.z;
            }
            if (endColor) {
                this._vertices[offset + 10] = endColor.r;
                this._vertices[offset + 11] = endColor.g;
                this._vertices[offset + 12] = endColor.b;
                this._vertices[offset + 13] = endColor.a;
            }
            this._minUpdate = Math.min(this._minUpdate, offset);
            this._maxUpdate = Math.max(this._maxUpdate, offset + this._floatCountPerVertices * 2);
            var bounds = this._bounds;
            var floatBound = this._floatBound;
            var min = bounds.getMin(), max = bounds.getMax();
            Laya.Vector3.min(min, startPosition, min);
            Laya.Vector3.min(min, endPosition, min);
            Laya.Vector3.max(max, startPosition, max);
            Laya.Vector3.max(max, endPosition, max);
            bounds.setMin(min);
            bounds.setMax(max);
            floatBound[0] = min.x, floatBound[1] = min.y, floatBound[2] = min.z;
            floatBound[3] = max.x, floatBound[4] = max.y, floatBound[5] = max.z;
            this._ownerRender.boundsChange = true;
        }
        _reCalculateBound() {
            if (this._calculateBound) {
                var vertices = this._vertices;
                var min = PixelLineFilter._tempVector0;
                var max = PixelLineFilter._tempVector1;
                min.setValue(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
                max.setValue(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
                for (var i = 0; i < this._lineCount * 2; ++i) {
                    var offset = this._floatCountPerVertices * i;
                    var x = vertices[offset + 0], y = vertices[offset + 1], z = vertices[offset + 2];
                    min.x = Math.min(x, min.x);
                    min.y = Math.min(y, min.y);
                    min.z = Math.min(z, min.z);
                    max.x = Math.max(x, max.x);
                    max.y = Math.max(y, max.y);
                    max.z = Math.max(z, max.z);
                }
                this._bounds.setMin(min);
                this._bounds.setMax(max);
                var floatBound = this._floatBound;
                floatBound[0] = min.x, floatBound[1] = min.y, floatBound[2] = min.z;
                floatBound[3] = max.x, floatBound[4] = max.y, floatBound[5] = max.z;
                this._calculateBound = false;
            }
        }
        _removeLineData(index) {
            var floatCount = this._floatCountPerVertices * 2;
            var nextIndex = index + 1;
            var offset = index * floatCount;
            var vertices = this._vertices;
            var rightPartVertices = new Float32Array(vertices.buffer, nextIndex * floatCount * 4, (this._lineCount - nextIndex) * floatCount);
            vertices.set(rightPartVertices, offset);
            this._minUpdate = Math.min(this._minUpdate, offset);
            this._maxUpdate = Math.max(this._maxUpdate, offset + rightPartVertices.length);
            this._lineCount--;
            var floatBound = this._floatBound;
            var startX = vertices[offset], startY = vertices[offset + 1], startZ = vertices[offset + 2];
            var endX = vertices[offset + 7], endY = vertices[offset + 8], endZ = vertices[offset + 9];
            var minX = floatBound[0], minY = floatBound[1], minZ = floatBound[2];
            var maxX = floatBound[3], maxY = floatBound[4], maxZ = floatBound[5];
            if ((startX === minX) || (startX === maxX) || (startY === minY) || (startY === maxY) || (startZ === minZ) || (startZ === maxZ) ||
                (endX === minX) || (endX === maxX) || (endY === minY) || (endY === maxY) || (endZ === minZ) || (endZ === maxZ))
                this._calculateBound = true;
        }
        _updateLineData(index, startPosition, endPosition, startColor, endColor) {
            var floatCount = this._floatCountPerVertices * 2;
            this._updateLineVertices(index * floatCount, startPosition, endPosition, startColor, endColor);
        }
        _updateLineDatas(index, data) {
            var floatCount = this._floatCountPerVertices * 2;
            var count = data.length;
            for (var i = 0; i < count; i++) {
                var line = data[i];
                this._updateLineVertices((index + i) * floatCount, line.startPosition, line.endPosition, line.startColor, line.endColor);
            }
        }
        _getLineData(index, out) {
            var startPosition = out.startPosition;
            var startColor = out.startColor;
            var endPosition = out.endPosition;
            var endColor = out.endColor;
            var vertices = this._vertices;
            var offset = index * this._floatCountPerVertices * 2;
            startPosition.x = vertices[offset + 0];
            startPosition.y = vertices[offset + 1];
            startPosition.z = vertices[offset + 2];
            startColor.r = vertices[offset + 3];
            startColor.g = vertices[offset + 4];
            startColor.b = vertices[offset + 5];
            startColor.a = vertices[offset + 6];
            endPosition.x = vertices[offset + 7];
            endPosition.y = vertices[offset + 8];
            endPosition.z = vertices[offset + 9];
            endColor.r = vertices[offset + 10];
            endColor.g = vertices[offset + 11];
            endColor.b = vertices[offset + 12];
            endColor.a = vertices[offset + 13];
        }
        _prepareRender(state) {
            return true;
        }
        _updateRenderParams(state) {
            this.clearRenderParams();
            if (this._minUpdate !== Number.MAX_VALUE && this._maxUpdate !== Number.MIN_VALUE) {
                this._vertexBuffer.setData(this._vertices.buffer, this._minUpdate * 4, this._minUpdate * 4, (this._maxUpdate - this._minUpdate) * 4);
                this._minUpdate = Number.MAX_VALUE;
                this._maxUpdate = Number.MIN_VALUE;
            }
            if (this._lineCount > 0) {
                this.setDrawArrayParams(0, this._lineCount * 2);
            }
        }
        destroy() {
            if (this._destroyed)
                return;
            super.destroy();
            this.bufferState.destroy();
            this._vertexBuffer.destroy();
            this.bufferState = null;
            this._vertexBuffer = null;
            this._vertices = null;
        }
    }
    PixelLineFilter._tempVector0 = new Laya.Vector3();
    PixelLineFilter._tempVector1 = new Laya.Vector3();
    PixelLineFilter._type = GeometryElement._typeCounter++;

    class PixelLineMaterial extends Material {
        constructor() {
            super();
            this.setShaderName("LineShader");
            this._shaderValues.setVector(PixelLineMaterial.COLOR, new Laya.Vector4(1.0, 1.0, 1.0, 1.0));
        }
        static __initDefine__() {
            PixelLineMaterial.COLOR = Laya.Shader3D.propertyNameToID("u_Color");
        }
        get color() {
            return this._shaderValues.getVector(PixelLineMaterial.COLOR);
        }
        set color(value) {
            this._shaderValues.setVector(PixelLineMaterial.COLOR, value);
        }
        clone() {
            var dest = new PixelLineMaterial();
            this.cloneTo(dest);
            return dest;
        }
    }

    class PixelLineRenderer extends BaseRender {
        constructor() {
            super();
            this._isRenderActive = false;
            this._isInRenders = false;
            this._needUpdatelines = false;
            this._lines = [];
            this._projectionViewWorldMatrix = new Laya.Matrix4x4();
            this._pixelLineFilter = new PixelLineFilter(this, 20);
            this._shaderValues.addDefine(MeshSprite3DShaderDeclaration.SHADERDEFINE_COLOR);
        }
        get pixelLinesDatas() {
            if (this._needUpdatelines) {
                this._updateLineDatas();
            }
            return this._lines;
        }
        set pixelLinesDatas(value) {
            this.clear();
            this.addLines(value);
        }
        get maxLineCount() {
            return this._pixelLineFilter._maxLineCount;
        }
        set maxLineCount(value) {
            this._pixelLineFilter._resizeLineData(value);
            this._pixelLineFilter._lineCount = Math.min(this._pixelLineFilter._lineCount, value);
        }
        get lineCount() {
            return this._pixelLineFilter._lineCount;
        }
        _onAdded() {
            super._onAdded();
            this._changeRenderObjects(0, PixelLineMaterial.defaultMaterial);
        }
        _onEnable() {
            this._isRenderActive = true;
            if (this._pixelLineFilter._lineCount != 0) {
                (this.owner.scene)._addRenderObject(this);
                this._isInRenders = true;
            }
            this._setBelongScene(this.owner.scene);
        }
        _onDisable() {
            if (this._pixelLineFilter && this._pixelLineFilter._lineCount != 0 && this._isRenderActive) {
                this.owner.scene._removeRenderObject(this);
                this._isInRenders = false;
            }
            this._isRenderActive = false;
            this._setUnBelongScene();
        }
        _calculateBoundingBox() {
            var worldMat = this.owner.transform.worldMatrix;
            var lineFilter = this._pixelLineFilter;
            lineFilter._reCalculateBound();
            lineFilter._bounds._tranform(worldMat, this._bounds);
        }
        _renderUpdateWithCamera(context, transform) {
            context.projectionViewMatrix;
            var sv = this._shaderValues;
            if (transform) {
                var worldMat = transform.worldMatrix;
                sv.setMatrix4x4(Sprite3D.WORLDMATRIX, worldMat);
            }
            else {
                sv.setMatrix4x4(Sprite3D.WORLDMATRIX, Laya.Matrix4x4.DEFAULT);
            }
        }
        _changeRenderObjects(index, material) {
            var renderObjects = this._renderElements;
            (material) || (material = PixelLineMaterial.defaultMaterial);
            var renderElement = renderObjects[index];
            (renderElement) || (renderElement = renderObjects[index] = new RenderElement());
            renderElement.setTransform(this.owner._transform);
            renderElement.setGeometry(this._pixelLineFilter);
            renderElement.render = this;
            renderElement.material = material;
        }
        addLine(startPosition, endPosition, startColor, endColor) {
            if (this._pixelLineFilter._lineCount !== this._pixelLineFilter._maxLineCount)
                this._pixelLineFilter._updateLineData(this._pixelLineFilter._lineCount++, startPosition, endPosition, startColor, endColor);
            else
                throw "PixelLineSprite3D: lineCount has equal with maxLineCount.";
            if (this._isRenderActive && !this._isInRenders && this._pixelLineFilter._lineCount > 0) {
                this.owner.scene && this.owner.scene._addRenderObject(this);
                this._isInRenders = true;
            }
            this._needUpdatelines = true;
        }
        addLines(lines) {
            var lineCount = this._pixelLineFilter._lineCount;
            var addCount = lines.length;
            if (lineCount + addCount > this._pixelLineFilter._maxLineCount) {
                throw "PixelLineSprite3D: lineCount plus lines count must less than maxLineCount.";
            }
            else {
                this._pixelLineFilter._updateLineDatas(lineCount, lines);
                this._pixelLineFilter._lineCount += addCount;
            }
            if (this._isRenderActive && !this._isInRenders && this._pixelLineFilter._lineCount > 0) {
                this.owner.scene && this.owner.scene._addRenderObject(this);
                this._isInRenders = true;
            }
            this._needUpdatelines = true;
        }
        removeLine(index) {
            if (index < this._pixelLineFilter._lineCount)
                this._pixelLineFilter._removeLineData(index);
            else
                throw "PixelLineSprite3D: index must less than lineCount.";
            if (this._isRenderActive && this._isInRenders && this._pixelLineFilter._lineCount == 0) {
                this.owner.scene && this.owner.scene._removeRenderObject(this);
                this._isInRenders = false;
            }
            this._needUpdatelines = true;
        }
        setLine(index, startPosition, endPosition, startColor, endColor) {
            if (index < this._pixelLineFilter._lineCount) {
                this._pixelLineFilter._updateLineData(index, startPosition, endPosition, startColor, endColor);
                let pixeldata = this._lines[index];
                if (pixeldata) {
                    startColor.cloneTo(pixeldata.startColor);
                    endColor.cloneTo(pixeldata.endColor);
                    startPosition.cloneTo(pixeldata.startPosition);
                    endPosition.cloneTo(pixeldata.endPosition);
                }
            }
            else
                throw "PixelLineSprite3D: index must less than lineCount.";
        }
        getLine(index, out) {
            if (index < this.lineCount)
                this._pixelLineFilter._getLineData(index, out);
            else
                throw "PixelLineSprite3D: index must less than lineCount.";
        }
        _updateLineDatas() {
            let n = this.lineCount;
            this._lines = [];
            for (let i = 0; i < n; i++) {
                let pixelLineDatas = new PixelLineData();
                this.getLine(i, pixelLineDatas);
                this._lines.push(pixelLineDatas);
            }
            this._needUpdatelines = false;
        }
        clear() {
            this._pixelLineFilter._lineCount = 0;
            if (this._isRenderActive && this._isInRenders) {
                this.owner.scene && this.owner.scene._removeRenderObject(this);
                this._isInRenders = false;
            }
        }
        _onDestroy() {
            this._pixelLineFilter.destroy();
            this._pixelLineFilter = null;
            super._onDestroy();
        }
        _cloneTo(dest) {
            super._cloneTo(dest);
            let render = dest;
            render.maxLineCount = this.maxLineCount;
            const lineCount = this.lineCount;
            let linedata = new PixelLineData();
            for (let i = 0, n = lineCount; i < n; i++) {
                this.getLine(i, linedata);
                render.addLine(linedata.startPosition, linedata.endPosition, linedata.startColor, linedata.endColor);
            }
        }
    }

    class AnimatorPlayState {
        constructor() {
            this._currentState = null;
        }
        get normalizedTime() {
            return this._normalizedTime;
        }
        get duration() {
            return this._duration;
        }
        get animatorState() {
            return this._currentState;
        }
        _resetPlayState(startTime, clipDuration) {
            this._finish = false;
            this._startPlayTime = startTime;
            this._elapsedTime = startTime;
            this._playEventIndex = 0;
            this._lastIsFront = true;
            this._normalizedTime = this._elapsedTime / clipDuration;
            var playTime = this._normalizedTime % 1.0;
            this._normalizedPlayTime = playTime < 0 ? playTime + 1.0 : playTime;
        }
        _cloneTo(dest) {
            dest._finish = this._finish;
            dest._startPlayTime = this._startPlayTime;
            dest._elapsedTime = this._elapsedTime;
            dest._normalizedTime = this._normalizedTime;
            dest._normalizedPlayTime = this._normalizedPlayTime;
            dest._playEventIndex = this._playEventIndex;
            dest._lastIsFront = this._lastIsFront;
        }
    }

    class AnimatorControllerLayer {
        constructor(name) {
            this._referenceCount = 0;
            this._playType = -1;
            this._crossDuration = -1;
            this._crossMark = 0;
            this._crossNodesOwnersCount = 0;
            this._crossNodesOwners = [];
            this._crossNodesOwnersIndicesMap = {};
            this._srcCrossClipNodeIndices = [];
            this._destCrossClipNodeIndices = [];
            this._states = [];
            this._playStateInfo = new AnimatorPlayState();
            this._crossPlayStateInfo = new AnimatorPlayState();
            this.blendingMode = AnimatorControllerLayer.BLENDINGMODE_OVERRIDE;
            this.defaultWeight = 1.0;
            this.playOnWake = true;
            this.enable = true;
            this.name = name;
        }
        get defaultState() {
            return this._defaultState;
        }
        set defaultState(value) {
            this._defaultState = value;
        }
        get avatarMask() {
            return this._avatarMask;
        }
        set avatarMask(value) {
            this._avatarMask = value;
        }
        get defaultStateName() {
            if (!this._defaultState) {
                return null;
            }
            return this._defaultState.name;
        }
        set defaultStateName(value) {
            this._defaultState = this.getAnimatorState(value);
            if (null == this._defaultState) {
                if (0 == this._states.length) {
                    this._defaultStateNameCatch = value;
                }
                else {
                    for (var i = this._states.length - 1; i >= 0; i--) {
                        if (this._states[i].name == value) {
                            this._defaultState = this._states[i];
                            break;
                        }
                    }
                }
            }
        }
        get states() {
            return this._states;
        }
        set states(states) {
            if (this._states === states)
                return;
            if (this._states.length > 0) {
                let removed = this._states.filter(s => states.indexOf(s) == -1);
                for (let state of removed)
                    this.removeState(state);
            }
            if (states.length > 0) {
                let newAdded = states.filter(s => this._states.indexOf(s) == -1);
                for (let state of newAdded)
                    this.addState(state);
            }
            this._states.length = 0;
            this._states.push(...states);
        }
        _removeClip(clipStateInfos, index, state) {
            var clip = state._clip;
            var clipStateInfo = clipStateInfos[index];
            clipStateInfos.splice(index, 1);
            if (this._animator) {
                var frameNodes = clip._nodes;
                var nodeOwners = clipStateInfo._nodeOwners;
                clip._removeReference();
                for (var i = 0, n = frameNodes.count; i < n; i++)
                    this._animator._removeKeyframeNodeOwner(nodeOwners, frameNodes.getNodeByIndex(i));
            }
        }
        _getReferenceCount() {
            return this._referenceCount;
        }
        _addReference(count = 1) {
            for (var i = 0, n = this._states.length; i < n; i++)
                this._states[i]._addReference(count);
            this._referenceCount += count;
        }
        _removeReference(count = 1) {
            for (var i = 0, n = this._states.length; i < n; i++)
                this._states[i]._removeReference(count);
            this._referenceCount -= count;
        }
        _clearReference() {
            this._removeReference(-this._referenceCount);
        }
        getCurrentPlayState() {
            return this._playStateInfo;
        }
        getAnimatorState(name) {
            var state;
            for (let i = 0; i < this._states.length; i++) {
                if (this._states[i].name == name) {
                    state = this._states[i];
                    break;
                }
            }
            return state ? state : null;
        }
        addState(state) {
            var stateName = state.name;
            if (this.getAnimatorState(stateName)) {
                throw "AnimatorControllerLayer:this stat's name has exist.";
            }
            else {
                this._states.push(state);
                if (stateName == this._defaultStateNameCatch) {
                    this._defaultState = state;
                    this._defaultStateNameCatch = null;
                }
                if (this._animator) {
                    (state._clip) && (state._clip._addReference());
                    this._animator._getOwnersByClip(state);
                }
            }
        }
        removeState(state) {
            var states = this._states;
            var index = -1;
            for (var i = 0, n = states.length; i < n; i++) {
                if (states[i] === state) {
                    index = i;
                    break;
                }
            }
            if (index !== -1)
                this._removeClip(states, index, state);
        }
        destroy() {
            this._clearReference();
            this._states = [];
            this._playStateInfo = null;
            this._crossPlayStateInfo = null;
            this._defaultState = null;
        }
        cloneTo(destObject) {
            var dest = destObject;
            dest.name = this.name;
            dest.blendingMode = this.blendingMode;
            dest.defaultWeight = this.defaultWeight;
            dest.playOnWake = this.playOnWake;
            this.avatarMask && (dest.avatarMask = this._avatarMask.clone());
        }
        clone() {
            var dest = new AnimatorControllerLayer(this.name);
            this.cloneTo(dest);
            return dest;
        }
    }
    AnimatorControllerLayer.BLENDINGMODE_OVERRIDE = 0;
    AnimatorControllerLayer.BLENDINGMODE_ADDTIVE = 1;

    class AnimatorResource {
        static getAnimatorResource(sprite, propertyKey) {
            switch (propertyKey) {
                case "simpleSkinnedMeshRenderer":
                    return sprite.getComponent(SimpleSkinnedMeshRenderer);
                default:
                    return sprite.getComponent(Laya.ClassUtils.getClass(propertyKey));
            }
        }
    }

    class AnimatorState extends Laya.EventDispatcher {
        constructor() {
            super();
            this._referenceCount = 0;
            this._clip = null;
            this._nodeOwners = [];
            this._currentFrameIndices = null;
            this._realtimeDatas = [];
            this._scripts = null;
            this._transitions = [];
            this._soloTransitions = [];
            this.speed = 1.0;
            this.clipStart = 0.0;
            this.clipEnd = 1.0;
        }
        get clip() {
            return this._clip;
        }
        set clip(value) {
            if (this._clip !== value) {
                if (this._clip)
                    (this._referenceCount > 0) && (this._clip._removeReference(this._referenceCount));
                if (value) {
                    var realtimeDatas = this._realtimeDatas;
                    var clipNodes = value._nodes;
                    var count = clipNodes.count;
                    this._currentFrameIndices = new Int16Array(count);
                    this._resetFrameIndices();
                    (this._referenceCount > 0) && (value._addReference(this._referenceCount));
                    this._realtimeDatas.length = count;
                    for (var i = 0; i < count; i++) {
                        switch (clipNodes.getNodeByIndex(i).type) {
                            case exports.KeyFrameValueType.Float:
                                break;
                            case exports.KeyFrameValueType.Position:
                            case exports.KeyFrameValueType.Scale:
                            case exports.KeyFrameValueType.RotationEuler:
                            case exports.KeyFrameValueType.Vector3:
                                realtimeDatas[i] = new Laya.Vector3();
                                break;
                            case exports.KeyFrameValueType.Rotation:
                                realtimeDatas[i] = new Laya.Quaternion();
                                break;
                            case exports.KeyFrameValueType.Vector2:
                                realtimeDatas[i] = new Laya.Vector2();
                                break;
                            case exports.KeyFrameValueType.Vector4:
                            case exports.KeyFrameValueType.Color:
                                realtimeDatas[i] = new Laya.Vector4();
                                break;
                            default:
                                throw "AnimationClipParser04:unknown type.";
                        }
                    }
                }
                this._clip = value;
            }
        }
        get transitions() {
            return this._transitions;
        }
        set transitions(value) {
            this._transitions = value;
        }
        get soloTransitions() {
            return this._soloTransitions;
        }
        set soloTransitions(value) {
            this._soloTransitions = value;
        }
        _eventStart() {
            this.event(AnimatorState.EVENT_OnStateEnter);
            if (this._scripts) {
                for (var i = 0, n = this._scripts.length; i < n; i++)
                    this._scripts[i].onStateEnter();
            }
        }
        _eventExit() {
            this.event(AnimatorState.EVENT_OnStateExit);
            if (this._scripts) {
                for (let i = 0, n = this._scripts.length; i < n; i++) {
                    this._scripts[i].onStateExit();
                }
            }
        }
        _eventStateUpdate(value) {
            this.event(AnimatorState.EVENT_OnStateUpdate, value);
            if (this._scripts) {
                for (var i = 0, n = this._scripts.length; i < n; i++)
                    this._scripts[i].onStateUpdate(value);
            }
        }
        _eventtransition(normalizeTime, paramsMap) {
            let soloNums = this._soloTransitions.length;
            if (soloNums > 0) {
                for (var i = 0; i < soloNums; i++) {
                    if (this._soloTransitions[i].check(normalizeTime, paramsMap))
                        return this._soloTransitions[i];
                }
                return null;
            }
            let transNums = this._transitions.length;
            for (var i = 0; i < transNums; i++) {
                if (this._transitions[i].check(normalizeTime, paramsMap))
                    return this._transitions[i];
            }
            return null;
        }
        _getReferenceCount() {
            return this._referenceCount;
        }
        _addReference(count = 1) {
            (this._clip) && (this._clip._addReference(count));
            this._referenceCount += count;
        }
        _removeReference(count = 1) {
            (this._clip) && (this._clip._removeReference(count));
            this._referenceCount -= count;
        }
        _clearReference() {
            this._removeReference(-this._referenceCount);
        }
        _resetFrameIndices() {
            for (var i = 0, n = this._currentFrameIndices.length; i < n; i++)
                this._currentFrameIndices[i] = -1;
        }
        addScript(type) {
            var script = new type();
            this._scripts = this._scripts || [];
            this._scripts.push(script);
            return script;
        }
        getScript(type) {
            if (this._scripts) {
                for (var i = 0, n = this._scripts.length; i < n; i++) {
                    var script = this._scripts[i];
                    if (script instanceof type)
                        return script;
                }
            }
            return null;
        }
        getScripts(type) {
            var coms = null;
            if (this._scripts) {
                for (var i = 0, n = this._scripts.length; i < n; i++) {
                    var script = this._scripts[i];
                    if (script instanceof type) {
                        coms = coms || [];
                        coms.push(script);
                    }
                }
            }
            return coms;
        }
        cloneTo(destObject) {
            var dest = destObject;
            dest.name = this.name;
            dest.speed = this.speed;
            dest.clipStart = this.clipStart;
            dest.clipEnd = this.clipEnd;
            dest.clip = this._clip;
        }
        clone() {
            var dest = new AnimatorState();
            this.cloneTo(dest);
            return dest;
        }
    }
    AnimatorState.EVENT_OnStateEnter = "OnStartEnter";
    AnimatorState.EVENT_OnStateUpdate = "OnStateUpdate";
    AnimatorState.EVENT_OnStateExit = "OnStateExit";

    class AvatarMask {
        constructor(data) {
            this._avatarPathMap = data || {};
        }
        getTransformActive(path) {
            return this._avatarPathMap[path];
        }
        setTransformActive(path, value) {
            this._avatarPathMap[path] = value;
        }
        getAllTranfromPath() {
            return this._avatarPathMap;
        }
        clone() {
            var dest = new AvatarMask();
            this.cloneTo(dest);
            return dest;
        }
        cloneTo(destObject) {
            var dest = destObject;
            for (var key in this._avatarPathMap) {
                dest.setTransformActive(key, this._avatarPathMap[key]);
            }
        }
    }

    class Animator extends Laya.Component {
        constructor() {
            super();
            this._keyframeNodeOwners = [];
            this._updateMode = Laya.AnimatorUpdateMode.Normal;
            this._lowUpdateDelty = 20;
            this._animatorParams = {};
            this._linkAvatarSpritesData = {};
            this._linkAvatarSprites = [];
            this._renderableSprites = [];
            this.cullingMode = Animator.CULLINGMODE_CULLCOMPLETELY;
            this._controllerLayers = [];
            this._speed = 1.0;
            this._keyframeNodeOwnerMap = {};
            this._updateMark = 0;
        }
        set controller(val) {
            this._controller = val;
            if (this._controller) {
                this._controller.updateTo(this);
            }
        }
        get controller() {
            return this._controller;
        }
        get speed() {
            return this._speed;
        }
        set speed(value) {
            this._speed = value;
        }
        set updateMode(value) {
            this._updateMode = value;
        }
        set lowUpdateDelty(value) {
            this._lowUpdateDelty = value;
        }
        get controllerLayerCount() {
            return this._controllerLayers.length;
        }
        set animatorParams(values) {
            this._animatorParams = values;
        }
        get animatorParams() {
            return this._animatorParams;
        }
        _addKeyframeNodeOwner(clipOwners, node, propertyOwner) {
            var nodeIndex = node._indexInList;
            var fullPath = node.fullPath;
            var keyframeNodeOwner = this._keyframeNodeOwnerMap[fullPath];
            let mat = false;
            if (keyframeNodeOwner) {
                keyframeNodeOwner.referenceCount++;
                clipOwners[nodeIndex] = keyframeNodeOwner;
            }
            else {
                var property = propertyOwner;
                for (var i = 0, n = node.propertyCount; i < n; i++) {
                    property = property[node.getPropertyByIndex(i)];
                    if (property instanceof Material) {
                        mat = true;
                    }
                    if (!property)
                        break;
                }
                keyframeNodeOwner = this._keyframeNodeOwnerMap[fullPath] = new KeyframeNodeOwner();
                keyframeNodeOwner.isMaterial = mat;
                keyframeNodeOwner.fullPath = fullPath;
                keyframeNodeOwner.indexInList = this._keyframeNodeOwners.length;
                keyframeNodeOwner.referenceCount = 1;
                keyframeNodeOwner.propertyOwner = propertyOwner;
                keyframeNodeOwner.nodePath = node.nodePath;
                var propertyCount = node.propertyCount;
                var propertys = [];
                for (i = 0; i < propertyCount; i++)
                    propertys[i] = node.getPropertyByIndex(i);
                keyframeNodeOwner.property = propertys;
                keyframeNodeOwner.type = node.type;
                if (property) {
                    if (node.type === 0) {
                        keyframeNodeOwner.defaultValue = property;
                    }
                    else {
                        var defaultValue = new property.constructor();
                        property.cloneTo(defaultValue);
                        keyframeNodeOwner.defaultValue = defaultValue;
                        keyframeNodeOwner.value = new property.constructor();
                        keyframeNodeOwner.crossFixedValue = new property.constructor();
                    }
                }
                this._keyframeNodeOwners.push(keyframeNodeOwner);
                clipOwners[nodeIndex] = keyframeNodeOwner;
            }
        }
        _removeKeyframeNodeOwner(nodeOwners, node) {
            var fullPath = node.fullPath;
            var keyframeNodeOwner = this._keyframeNodeOwnerMap[fullPath];
            if (keyframeNodeOwner) {
                keyframeNodeOwner.referenceCount--;
                if (keyframeNodeOwner.referenceCount === 0) {
                    delete this._keyframeNodeOwnerMap[fullPath];
                    this._keyframeNodeOwners.splice(this._keyframeNodeOwners.indexOf(keyframeNodeOwner), 1);
                }
                nodeOwners[node._indexInList] = null;
            }
        }
        _getOwnersByClip(clipStateInfo) {
            if (!clipStateInfo._clip)
                return;
            var frameNodes = clipStateInfo._clip._nodes;
            var frameNodesCount = frameNodes.count;
            var nodeOwners = clipStateInfo._nodeOwners;
            nodeOwners.length = frameNodesCount;
            for (var i = 0; i < frameNodesCount; i++) {
                var node = frameNodes.getNodeByIndex(i);
                var property = this.owner;
                for (var j = 0, m = node.ownerPathCount; j < m; j++) {
                    var ownPat = node.getOwnerPathByIndex(j);
                    if (ownPat === "") {
                        break;
                    }
                    else {
                        property = property.getChildByName(ownPat);
                        if (!property)
                            break;
                    }
                }
                if (property) {
                    var propertyOwner = node.propertyOwner;
                    const oriProperty = property;
                    (propertyOwner) && (property = property[propertyOwner]);
                    if (!property) {
                        property = AnimatorResource.getAnimatorResource(oriProperty, propertyOwner);
                    }
                    property && this._addKeyframeNodeOwner(nodeOwners, node, property);
                }
            }
        }
        _updatePlayer(animatorState, playState, elapsedTime, islooping, layerIndex) {
            var clipDuration = animatorState._clip._duration * (animatorState.clipEnd - animatorState.clipStart);
            var lastElapsedTime = playState._elapsedTime;
            var elapsedPlaybackTime = lastElapsedTime + elapsedTime;
            playState._lastElapsedTime = lastElapsedTime;
            playState._elapsedTime = elapsedPlaybackTime;
            var normalizedTime = elapsedPlaybackTime / clipDuration;
            playState._normalizedTime = normalizedTime;
            var playTime = normalizedTime % 1.0;
            playState._normalizedPlayTime = playTime < 0 ? playTime + 1.0 : playTime;
            playState._duration = clipDuration;
            if ((!islooping && elapsedPlaybackTime >= clipDuration)) {
                playState._finish = true;
                playState._elapsedTime = clipDuration;
                playState._normalizedPlayTime = 1.0;
                return;
            }
            animatorState._eventStateUpdate(playState._normalizedPlayTime);
            this._applyTransition(layerIndex, animatorState._eventtransition(playState._normalizedPlayTime, this.animatorParams));
        }
        _applyTransition(layerindex, transition) {
            if (!transition)
                return;
            this.crossFade(transition.destState.name, transition.transduration, layerindex, transition.transstartoffset);
        }
        _updateStateFinish(animatorState, playState) {
            if (playState._finish) {
                animatorState._eventExit();
            }
        }
        _eventScript(events, eventIndex, endTime, front) {
            let scripts = this.owner.components;
            if (front) {
                for (let n = events.length; eventIndex < n; eventIndex++) {
                    let event = events[eventIndex];
                    if (event.time <= endTime) {
                        for (let j = 0, m = scripts.length; j < m; j++) {
                            let script = scripts[j];
                            if (script._isScript()) {
                                let fun = script[event.eventName];
                                (fun) && (fun.apply(script, event.params));
                            }
                        }
                    }
                    else {
                        break;
                    }
                }
            }
            else {
                for (; eventIndex >= 0; eventIndex--) {
                    let event = events[eventIndex];
                    if (event.time >= endTime) {
                        for (let j = 0, m = scripts.length; j < m; j++) {
                            let script = scripts[j];
                            if (script._isScript()) {
                                let fun = script[event.eventName];
                                (fun) && (fun.apply(script, event.params));
                            }
                        }
                    }
                    else {
                        break;
                    }
                }
            }
            return eventIndex;
        }
        _updateEventScript(stateInfo, playStateInfo) {
            if (!this.owner._getBit(Laya.NodeFlags.HAS_SCRIPT))
                return;
            let clip = stateInfo._clip;
            let events = clip._animationEvents;
            let clipDuration = clip._duration;
            let elapsedTime = playStateInfo._elapsedTime;
            let time = elapsedTime % clipDuration;
            let loopCount = Math.abs(Math.floor(elapsedTime / clipDuration) - Math.floor(playStateInfo._lastElapsedTime / clipDuration));
            let frontPlay = playStateInfo._elapsedTime >= playStateInfo._lastElapsedTime;
            if (playStateInfo._lastIsFront !== frontPlay) {
                if (frontPlay)
                    playStateInfo._playEventIndex++;
                else
                    playStateInfo._playEventIndex--;
                playStateInfo._lastIsFront = frontPlay;
            }
            let preEventIndex = playStateInfo._playEventIndex;
            if (frontPlay) {
                let newEventIndex = this._eventScript(events, playStateInfo._playEventIndex, loopCount > 0 ? clipDuration : time, true);
                (preEventIndex === playStateInfo._playEventIndex) && (playStateInfo._playEventIndex = newEventIndex);
                for (let i = 0, n = loopCount - 1; i < n; i++)
                    this._eventScript(events, 0, clipDuration, true);
                (loopCount > 0 && time > 0) && (playStateInfo._playEventIndex = this._eventScript(events, 0, time, true));
            }
            else {
                let newEventIndex = this._eventScript(events, playStateInfo._playEventIndex, loopCount > 0 ? 0 : time, false);
                (preEventIndex === playStateInfo._playEventIndex) && (playStateInfo._playEventIndex = newEventIndex);
                let eventIndex = events.length - 1;
                for (let i = 0, n = loopCount - 1; i < n; i++)
                    this._eventScript(events, eventIndex, 0, false);
                (loopCount > 0 && time > 0) && (playStateInfo._playEventIndex = this._eventScript(events, eventIndex, time, false));
            }
        }
        _updateClipDatas(animatorState, addtive, playStateInfo, animatorMask = null) {
            var clip = animatorState._clip;
            var clipDuration = clip._duration;
            var curPlayTime = animatorState.clipStart * clipDuration + playStateInfo._normalizedPlayTime * playStateInfo._duration;
            var currentFrameIndices = animatorState._currentFrameIndices;
            var frontPlay = playStateInfo._elapsedTime > playStateInfo._lastElapsedTime;
            clip._evaluateClipDatasRealTime(clip._nodes, curPlayTime, currentFrameIndices, addtive, frontPlay, animatorState._realtimeDatas, animatorMask);
        }
        _applyFloat(defaultValue, nodeOwner, additive, weight, isFirstLayer, data) {
            if (nodeOwner.updateMark === this._updateMark) {
                if (additive) {
                    defaultValue += weight * data;
                }
                else {
                    var oriValue = defaultValue;
                    defaultValue = oriValue + weight * (data - oriValue);
                }
            }
            else {
                if (isFirstLayer) {
                    if (additive)
                        defaultValue = nodeOwner.defaultValue + data;
                    else
                        defaultValue = data;
                }
                else {
                    if (additive) {
                        defaultValue = nodeOwner.defaultValue + weight * (data);
                    }
                    else {
                        var defValue = nodeOwner.defaultValue;
                        defaultValue = defValue + weight * (data - defValue);
                    }
                }
            }
            return defaultValue;
        }
        _applyVec2(defaultValue, nodeOwner, additive, weight, isFirstLayer, data) {
            if (!defaultValue)
                return null;
            if (nodeOwner.updateMark === this._updateMark) {
                if (additive) {
                    defaultValue.x += weight * data.x;
                    defaultValue.y += weight * data.y;
                }
                else {
                    var oriValue = defaultValue;
                    defaultValue.x = oriValue.x + weight * (data.x - oriValue.x);
                    defaultValue.y = oriValue.y + weight * (data.y - oriValue.y);
                }
            }
            else {
                if (isFirstLayer) {
                    if (additive) {
                        defaultValue.x = nodeOwner.defaultValue.x + data.x;
                        defaultValue.y = nodeOwner.defaultValue.y + data.y;
                    }
                    else
                        data.cloneTo(defaultValue);
                }
                else {
                    if (additive) {
                        defaultValue.x = nodeOwner.defaultValue.x + weight * (data.x);
                        defaultValue.y = nodeOwner.defaultValue.y + weight * (data.y);
                    }
                    else {
                        var defValue = nodeOwner.defaultValue;
                        defaultValue.x = defValue.x + weight * (data.x - defValue.x);
                        defaultValue.y = defValue.y + weight * (data.y - defValue.y);
                    }
                }
            }
            return defaultValue;
        }
        _applyVec3(defaultValue, nodeOwner, additive, weight, isFirstLayer, data) {
            if (!defaultValue)
                return null;
            if (nodeOwner.updateMark === this._updateMark) {
                if (additive) {
                    defaultValue.x += weight * data.x;
                    defaultValue.y += weight * data.y;
                    defaultValue.z += weight * data.z;
                }
                else {
                    var oriValue = defaultValue;
                    defaultValue.x = oriValue.x + weight * (data.x - oriValue.x);
                    defaultValue.y = oriValue.y + weight * (data.y - oriValue.y);
                    defaultValue.z = oriValue.z + weight * (data.z - oriValue.z);
                }
            }
            else {
                if (isFirstLayer) {
                    if (additive) {
                        defaultValue.x = nodeOwner.defaultValue.x + data.x;
                        defaultValue.y = nodeOwner.defaultValue.y + data.y;
                        defaultValue.z = nodeOwner.defaultValue.z + data.z;
                    }
                    else
                        data.cloneTo(defaultValue);
                }
                else {
                    if (additive) {
                        defaultValue.x = nodeOwner.defaultValue.x + weight * (data.x);
                        defaultValue.y = nodeOwner.defaultValue.y + weight * (data.y);
                        defaultValue.z = nodeOwner.defaultValue.z + weight * (data.z);
                    }
                    else {
                        var defValue = nodeOwner.defaultValue;
                        defaultValue.x = defValue.x + weight * (data.x - defValue.x);
                        defaultValue.y = defValue.y + weight * (data.y - defValue.y);
                        defaultValue.z = defValue.z + weight * (data.z - defValue.z);
                    }
                }
            }
            return defaultValue;
        }
        _applyVec4(defaultValue, nodeOwner, additive, weight, isFirstLayer, data) {
            if (!defaultValue)
                return null;
            if (nodeOwner.updateMark === this._updateMark) {
                if (additive) {
                    defaultValue.x += weight * data.x;
                    defaultValue.y += weight * data.y;
                    defaultValue.z += weight * data.z;
                    defaultValue.w += weight * data.w;
                }
                else {
                    var oriValue = defaultValue;
                    defaultValue.x = oriValue.x + weight * (data.x - oriValue.x);
                    defaultValue.y = oriValue.y + weight * (data.y - oriValue.y);
                    defaultValue.z = oriValue.z + weight * (data.z - oriValue.z);
                    defaultValue.w = oriValue.w + weight * (data.w - oriValue.w);
                }
            }
            else {
                if (isFirstLayer) {
                    if (additive) {
                        defaultValue.x = nodeOwner.defaultValue.x + data.x;
                        defaultValue.y = nodeOwner.defaultValue.y + data.y;
                        defaultValue.z = nodeOwner.defaultValue.z + data.z;
                        defaultValue.w = nodeOwner.defaultValue.w + data.w;
                    }
                    else
                        data.cloneTo(defaultValue);
                }
                else {
                    if (additive) {
                        defaultValue.x = nodeOwner.defaultValue.x + weight * (data.x);
                        defaultValue.y = nodeOwner.defaultValue.y + weight * (data.y);
                        defaultValue.z = nodeOwner.defaultValue.z + weight * (data.z);
                        defaultValue.w = nodeOwner.defaultValue.w + weight * (data.w);
                    }
                    else {
                        var defValue = nodeOwner.defaultValue;
                        defaultValue.x = defValue.x + weight * (data.x - defValue.x);
                        defaultValue.y = defValue.y + weight * (data.y - defValue.y);
                        defaultValue.z = defValue.z + weight * (data.z - defValue.z);
                        defaultValue.w = defValue.w + weight * (data.w - defValue.w);
                    }
                }
            }
            return defaultValue;
        }
        _applyColor(defaultValue, nodeOwner, additive, weight, isFirstLayer, data) {
            if (!defaultValue)
                return null;
            if (nodeOwner.updateMark === this._updateMark) {
                if (additive) {
                    defaultValue.r += weight * data.x;
                    defaultValue.g += weight * data.y;
                    defaultValue.b += weight * data.z;
                    defaultValue.a += weight * data.w;
                }
                else {
                    var oriValue = defaultValue;
                    defaultValue.r = oriValue.r + weight * (data.x - oriValue.r);
                    defaultValue.g = oriValue.g + weight * (data.y - oriValue.g);
                    defaultValue.b = oriValue.b + weight * (data.z - oriValue.b);
                    defaultValue.a = oriValue.a + weight * (data.w - oriValue.a);
                }
            }
            else {
                if (isFirstLayer) {
                    if (additive) {
                        defaultValue.r = nodeOwner.defaultValue.r + data.x;
                        defaultValue.g = nodeOwner.defaultValue.g + data.y;
                        defaultValue.b = nodeOwner.defaultValue.b + data.z;
                        defaultValue.a = nodeOwner.defaultValue.a + data.w;
                    }
                    else {
                        defaultValue.setValue(data.x, data.y, data.z, data.w);
                    }
                }
                else {
                    if (additive) {
                        defaultValue.r = nodeOwner.defaultValue.r + weight * (data.x);
                        defaultValue.g = nodeOwner.defaultValue.g + weight * (data.y);
                        defaultValue.b = nodeOwner.defaultValue.b + weight * (data.z);
                        defaultValue.a = nodeOwner.defaultValue.a + weight * (data.w);
                    }
                    else {
                        var defValue = nodeOwner.defaultValue;
                        defaultValue.r = defValue.r + weight * (data.x - defValue.r);
                        defaultValue.g = defValue.g + weight * (data.y - defValue.g);
                        defaultValue.b = defValue.b + weight * (data.z - defValue.b);
                        defaultValue.a = defValue.a + weight * (data.w - defValue.a);
                    }
                }
            }
            return defaultValue;
        }
        _applyPositionAndRotationEuler(nodeOwner, additive, weight, isFirstLayer, data, out) {
            if (nodeOwner.updateMark === this._updateMark) {
                if (additive) {
                    out.x += weight * data.x;
                    out.y += weight * data.y;
                    out.z += weight * data.z;
                }
                else {
                    var oriX = out.x;
                    var oriY = out.y;
                    var oriZ = out.z;
                    out.x = oriX + weight * (data.x - oriX);
                    out.y = oriY + weight * (data.y - oriY);
                    out.z = oriZ + weight * (data.z - oriZ);
                }
            }
            else {
                if (isFirstLayer) {
                    if (additive) {
                        var defValue = nodeOwner.defaultValue;
                        out.x = defValue.x + data.x;
                        out.y = defValue.y + data.y;
                        out.z = defValue.z + data.z;
                    }
                    else {
                        out.x = data.x;
                        out.y = data.y;
                        out.z = data.z;
                    }
                }
                else {
                    defValue = nodeOwner.defaultValue;
                    if (additive) {
                        out.x = defValue.x + weight * data.x;
                        out.y = defValue.y + weight * data.y;
                        out.z = defValue.z + weight * data.z;
                    }
                    else {
                        var defX = defValue.x;
                        var defY = defValue.y;
                        var defZ = defValue.z;
                        out.x = defX + weight * (data.x - defX);
                        out.y = defY + weight * (data.y - defY);
                        out.z = defZ + weight * (data.z - defZ);
                    }
                }
            }
        }
        _applyRotation(nodeOwner, additive, weight, isFirstLayer, clipRot, localRotation) {
            if (nodeOwner.updateMark === this._updateMark) {
                if (additive) {
                    var tempQuat = Animator._tempQuaternion1;
                    Utils3D.quaternionWeight(clipRot, weight, tempQuat);
                    tempQuat.normalize(tempQuat);
                    Laya.Quaternion.multiply(localRotation, tempQuat, localRotation);
                }
                else {
                    Laya.Quaternion.lerp(localRotation, clipRot, weight, localRotation);
                }
            }
            else {
                if (isFirstLayer) {
                    if (additive) {
                        var defaultRot = nodeOwner.defaultValue;
                        Laya.Quaternion.multiply(defaultRot, clipRot, localRotation);
                    }
                    else {
                        localRotation.x = clipRot.x;
                        localRotation.y = clipRot.y;
                        localRotation.z = clipRot.z;
                        localRotation.w = clipRot.w;
                    }
                }
                else {
                    defaultRot = nodeOwner.defaultValue;
                    if (additive) {
                        tempQuat = Animator._tempQuaternion1;
                        Utils3D.quaternionWeight(clipRot, weight, tempQuat);
                        tempQuat.normalize(tempQuat);
                        Laya.Quaternion.multiply(defaultRot, tempQuat, localRotation);
                    }
                    else {
                        Laya.Quaternion.lerp(defaultRot, clipRot, weight, localRotation);
                    }
                }
            }
        }
        _applyScale(nodeOwner, additive, weight, isFirstLayer, clipSca, localScale) {
            if (nodeOwner.updateMark === this._updateMark) {
                if (additive) {
                    var scale = Animator._tempVector31;
                    Utils3D.scaleWeight(clipSca, weight, scale);
                    localScale.x = localScale.x * scale.x;
                    localScale.y = localScale.y * scale.y;
                    localScale.z = localScale.z * scale.z;
                }
                else {
                    Utils3D.scaleBlend(localScale, clipSca, weight, localScale);
                }
            }
            else {
                if (isFirstLayer) {
                    if (additive) {
                        var defaultSca = nodeOwner.defaultValue;
                        localScale.x = defaultSca.x * clipSca.x;
                        localScale.y = defaultSca.y * clipSca.y;
                        localScale.z = defaultSca.z * clipSca.z;
                    }
                    else {
                        localScale.x = clipSca.x;
                        localScale.y = clipSca.y;
                        localScale.z = clipSca.z;
                    }
                }
                else {
                    defaultSca = nodeOwner.defaultValue;
                    if (additive) {
                        scale = Animator._tempVector31;
                        Utils3D.scaleWeight(clipSca, weight, scale);
                        localScale.x = defaultSca.x * scale.x;
                        localScale.y = defaultSca.y * scale.y;
                        localScale.z = defaultSca.z * scale.z;
                    }
                    else {
                        Utils3D.scaleBlend(defaultSca, clipSca, weight, localScale);
                    }
                }
            }
        }
        _applyCrossData(nodeOwner, additive, weight, isFirstLayer, srcValue, desValue, crossWeight) {
            var pro = nodeOwner.propertyOwner;
            if (pro) {
                switch (nodeOwner.type) {
                    case exports.KeyFrameValueType.Float:
                        var proPat = nodeOwner.property;
                        var m = proPat.length - 1;
                        for (var j = 0; j < m; j++) {
                            pro = pro[proPat[j]];
                            if (!pro)
                                break;
                        }
                        var crossValue = srcValue + crossWeight * (desValue - srcValue);
                        nodeOwner.value = crossValue;
                        const lastpro = proPat[m];
                        if (!nodeOwner.isMaterial) {
                            pro && (pro[lastpro] = this._applyFloat(pro[lastpro], nodeOwner, additive, weight, isFirstLayer, crossValue));
                        }
                        else {
                            pro && pro.setFloat(lastpro, this._applyFloat(pro.getFloat(lastpro), nodeOwner, additive, weight, isFirstLayer, crossValue));
                        }
                        break;
                    case exports.KeyFrameValueType.Position:
                        var localPos = pro.localPosition;
                        var position = nodeOwner.value;
                        var srcX = srcValue.x, srcY = srcValue.y, srcZ = srcValue.z;
                        position.x = srcX + crossWeight * (desValue.x - srcX);
                        position.y = srcY + crossWeight * (desValue.y - srcY);
                        position.z = srcZ + crossWeight * (desValue.z - srcZ);
                        this._applyPositionAndRotationEuler(nodeOwner, additive, weight, isFirstLayer, position, localPos);
                        pro.localPosition = localPos;
                        break;
                    case exports.KeyFrameValueType.Rotation:
                        var localRot = pro.localRotation;
                        var rotation = nodeOwner.value;
                        Laya.Quaternion.lerp(srcValue, desValue, crossWeight, rotation);
                        this._applyRotation(nodeOwner, additive, weight, isFirstLayer, rotation, localRot);
                        pro.localRotation = localRot;
                        break;
                    case exports.KeyFrameValueType.Scale:
                        var localSca = pro.localScale;
                        var scale = nodeOwner.value;
                        Utils3D.scaleBlend(srcValue, desValue, crossWeight, scale);
                        this._applyScale(nodeOwner, additive, weight, isFirstLayer, scale, localSca);
                        pro.localScale = localSca;
                        break;
                    case exports.KeyFrameValueType.RotationEuler:
                        var localEuler = pro.localRotationEuler;
                        var rotationEuler = nodeOwner.value;
                        srcX = srcValue.x, srcY = srcValue.y, srcZ = srcValue.z;
                        rotationEuler.x = srcX + crossWeight * (desValue.x - srcX);
                        rotationEuler.y = srcY + crossWeight * (desValue.y - srcY);
                        rotationEuler.z = srcZ + crossWeight * (desValue.z - srcZ);
                        this._applyPositionAndRotationEuler(nodeOwner, additive, weight, isFirstLayer, rotationEuler, localEuler);
                        pro.localRotationEuler = localEuler;
                        break;
                    case exports.KeyFrameValueType.Color:
                        break;
                    case exports.KeyFrameValueType.Vector2:
                        break;
                    case exports.KeyFrameValueType.Vector4:
                        break;
                    case exports.KeyFrameValueType.Vector3:
                        break;
                }
                nodeOwner.updateMark = this._updateMark;
            }
        }
        _setClipDatasToNode(stateInfo, additive, weight, isFirstLayer, controllerLayer = null) {
            var realtimeDatas = stateInfo._realtimeDatas;
            var nodes = stateInfo._clip._nodes;
            var nodeOwners = stateInfo._nodeOwners;
            for (var i = 0, n = nodes.count; i < n; i++) {
                var nodeOwner = nodeOwners[i];
                if (nodeOwner) {
                    var node = nodes.getNodeByIndex(i);
                    if (controllerLayer.avatarMask && (!controllerLayer.avatarMask.getTransformActive(node.nodePath))) {
                        continue;
                    }
                    var pro = nodeOwner.propertyOwner;
                    let value;
                    if (pro) {
                        switch (nodeOwner.type) {
                            case exports.KeyFrameValueType.Float:
                                var proPat = nodeOwner.property;
                                var m = proPat.length - 1;
                                for (var j = 0; j < m; j++) {
                                    pro = pro[proPat[j]];
                                    if (!pro)
                                        break;
                                }
                                let lastpro = proPat[m];
                                if (!nodeOwner.isMaterial) {
                                    pro && (pro[lastpro] = this._applyFloat(pro[lastpro], nodeOwner, additive, weight, isFirstLayer, realtimeDatas[i]));
                                }
                                else {
                                    pro && pro.setFloat(lastpro, this._applyFloat(0, nodeOwner, additive, weight, isFirstLayer, realtimeDatas[i]));
                                }
                                break;
                            case exports.KeyFrameValueType.Position:
                                var localPos = pro.localPosition;
                                this._applyPositionAndRotationEuler(nodeOwner, additive, weight, isFirstLayer, realtimeDatas[i], localPos);
                                pro.localPosition = localPos;
                                break;
                            case exports.KeyFrameValueType.Rotation:
                                var localRot = pro.localRotation;
                                this._applyRotation(nodeOwner, additive, weight, isFirstLayer, realtimeDatas[i], localRot);
                                pro.localRotation = localRot;
                                break;
                            case exports.KeyFrameValueType.Scale:
                                var localSca = pro.localScale;
                                this._applyScale(nodeOwner, additive, weight, isFirstLayer, realtimeDatas[i], localSca);
                                pro.localScale = localSca;
                                break;
                            case exports.KeyFrameValueType.RotationEuler:
                                var localEuler = pro.localRotationEuler;
                                this._applyPositionAndRotationEuler(nodeOwner, additive, weight, isFirstLayer, realtimeDatas[i], localEuler);
                                pro.localRotationEuler = localEuler;
                                break;
                            case exports.KeyFrameValueType.Vector2:
                                var proPat = nodeOwner.property;
                                var m = proPat.length - 1;
                                for (var j = 0; j < m; j++) {
                                    pro = pro[proPat[j]];
                                    if (!pro)
                                        break;
                                }
                                value = proPat[m];
                                if (!nodeOwner.isMaterial) {
                                    pro && (pro[value] = this._applyVec2(pro[value], nodeOwner, additive, weight, isFirstLayer, realtimeDatas[i]));
                                }
                                else {
                                    pro && pro.getVector2(value) && pro.setVector2(value, this._applyVec2(pro.getVector2(value), nodeOwner, additive, weight, isFirstLayer, realtimeDatas[i]));
                                }
                                break;
                            case exports.KeyFrameValueType.Vector3:
                                var proPat = nodeOwner.property;
                                var m = proPat.length - 1;
                                for (var j = 0; j < m; j++) {
                                    pro = pro[proPat[j]];
                                    if (!pro)
                                        break;
                                }
                                value = proPat[m];
                                if (!nodeOwner.isMaterial) {
                                    pro && (pro[value] = this._applyVec3(pro[value], nodeOwner, additive, weight, isFirstLayer, realtimeDatas[i]));
                                }
                                else {
                                    pro && pro.getVector3(value) && pro.setVector3(value, this._applyVec3(pro.getVector3(value), nodeOwner, additive, weight, isFirstLayer, realtimeDatas[i]));
                                }
                                break;
                            case exports.KeyFrameValueType.Vector4:
                                var proPat = nodeOwner.property;
                                var m = proPat.length - 1;
                                for (var j = 0; j < m; j++) {
                                    pro = pro[proPat[j]];
                                    if (!pro)
                                        break;
                                }
                                value = proPat[m];
                                if (!nodeOwner.isMaterial) {
                                    pro && (pro[value] = this._applyVec4(pro[value], nodeOwner, additive, weight, isFirstLayer, realtimeDatas[i]));
                                }
                                else {
                                    pro && pro.getVector4(value) && pro.setVector4(value, this._applyVec4(pro.getVector4(value), nodeOwner, additive, weight, isFirstLayer, realtimeDatas[i]));
                                }
                                break;
                            case exports.KeyFrameValueType.Color:
                                var proPat = nodeOwner.property;
                                var m = proPat.length - 1;
                                for (var j = 0; j < m; j++) {
                                    pro = pro[proPat[j]];
                                    if (!pro)
                                        break;
                                }
                                value = proPat[m];
                                if (!nodeOwner.isMaterial) {
                                    pro && (pro[value] = this._applyColor(pro[value], nodeOwner, additive, weight, isFirstLayer, realtimeDatas[i]));
                                }
                                else {
                                    pro && pro.getColor(value) && pro.setColor(value, this._applyColor(pro.getColor(value), nodeOwner, additive, weight, isFirstLayer, realtimeDatas[i]));
                                }
                                break;
                        }
                        nodeOwner.updateMark = this._updateMark;
                    }
                }
            }
        }
        _setCrossClipDatasToNode(controllerLayer, srcState, destState, crossWeight, isFirstLayer) {
            var nodeOwners = controllerLayer._crossNodesOwners;
            var ownerCount = controllerLayer._crossNodesOwnersCount;
            var additive = controllerLayer.blendingMode !== AnimatorControllerLayer.BLENDINGMODE_OVERRIDE;
            var weight = controllerLayer.defaultWeight;
            var destRealtimeDatas = destState._realtimeDatas;
            var destDataIndices = controllerLayer._destCrossClipNodeIndices;
            var destNodeOwners = destState._nodeOwners;
            var srcRealtimeDatas = srcState._realtimeDatas;
            var srcDataIndices = controllerLayer._srcCrossClipNodeIndices;
            var srcNodeOwners = srcState._nodeOwners;
            for (var i = 0; i < ownerCount; i++) {
                var nodeOwner = nodeOwners[i];
                if (nodeOwner) {
                    var srcIndex = srcDataIndices[i];
                    var destIndex = destDataIndices[i];
                    var srcValue = srcIndex !== -1 ? srcRealtimeDatas[srcIndex] : destNodeOwners[destIndex].defaultValue;
                    var desValue = destIndex !== -1 ? destRealtimeDatas[destIndex] : srcNodeOwners[srcIndex].defaultValue;
                    if (!desValue) {
                        desValue = srcNodeOwners[srcIndex].defaultValue;
                    }
                    if (!controllerLayer.avatarMask || controllerLayer.avatarMask.getTransformActive(nodeOwner.nodePath)) {
                        this._applyCrossData(nodeOwner, additive, weight, isFirstLayer, srcValue, desValue, crossWeight);
                    }
                }
            }
        }
        _setFixedCrossClipDatasToNode(controllerLayer, destState, crossWeight, isFirstLayer) {
            var nodeOwners = controllerLayer._crossNodesOwners;
            var ownerCount = controllerLayer._crossNodesOwnersCount;
            var additive = controllerLayer.blendingMode !== AnimatorControllerLayer.BLENDINGMODE_OVERRIDE;
            var weight = controllerLayer.defaultWeight;
            var destRealtimeDatas = destState._realtimeDatas;
            var destDataIndices = controllerLayer._destCrossClipNodeIndices;
            for (var i = 0; i < ownerCount; i++) {
                var nodeOwner = nodeOwners[i];
                if (nodeOwner) {
                    var destIndex = destDataIndices[i];
                    var srcValue = nodeOwner.crossFixedValue;
                    var desValue;
                    if (destIndex == -1 || !destRealtimeDatas[destIndex]) {
                        desValue = nodeOwner.defaultValue;
                    }
                    else {
                        desValue = destRealtimeDatas[destIndex];
                    }
                    this._applyCrossData(nodeOwner, additive, weight, isFirstLayer, srcValue, desValue, crossWeight);
                }
            }
        }
        _revertDefaultKeyframeNodes(clipStateInfo) {
            var nodeOwners = clipStateInfo._nodeOwners;
            for (var i = 0, n = nodeOwners.length; i < n; i++) {
                var nodeOwner = nodeOwners[i];
                if (nodeOwner) {
                    var pro = nodeOwner.propertyOwner;
                    let value;
                    if (pro) {
                        switch (nodeOwner.type) {
                            case exports.KeyFrameValueType.Float:
                                var proPat = nodeOwner.property;
                                var m = proPat.length - 1;
                                for (var j = 0; j < m; j++) {
                                    pro = pro[proPat[j]];
                                    if (!pro)
                                        break;
                                }
                                let lastpro = proPat[m];
                                if (!nodeOwner.isMaterial) {
                                    pro && (pro[lastpro] = nodeOwner.defaultValue);
                                }
                                else {
                                    pro && pro.setFloat(lastpro, nodeOwner.defaultValue);
                                }
                                break;
                            case exports.KeyFrameValueType.Position:
                                var locPos = pro.localPosition;
                                var def = nodeOwner.defaultValue;
                                locPos.x = def.x;
                                locPos.y = def.y;
                                locPos.z = def.z;
                                pro.localPosition = locPos;
                                break;
                            case exports.KeyFrameValueType.Rotation:
                                var locRot = pro.localRotation;
                                var defQua = nodeOwner.defaultValue;
                                locRot.x = defQua.x;
                                locRot.y = defQua.y;
                                locRot.z = defQua.z;
                                locRot.w = defQua.w;
                                pro.localRotation = locRot;
                                break;
                            case exports.KeyFrameValueType.Scale:
                                var locSca = pro.localScale;
                                def = nodeOwner.defaultValue;
                                locSca.x = def.x;
                                locSca.y = def.y;
                                locSca.z = def.z;
                                pro.localScale = locSca;
                                break;
                            case exports.KeyFrameValueType.RotationEuler:
                                var locEul = pro.localRotationEuler;
                                def = nodeOwner.defaultValue;
                                locEul.x = def.x;
                                locEul.y = def.y;
                                locEul.z = def.z;
                                pro.localRotationEuler = locEul;
                                break;
                            case exports.KeyFrameValueType.Vector2:
                                var proPat = nodeOwner.property;
                                var m = proPat.length - 1;
                                for (var j = 0; j < m; j++) {
                                    pro = pro[proPat[j]];
                                    if (!pro)
                                        break;
                                }
                                value = proPat[m];
                                if (!nodeOwner.isMaterial) {
                                    pro && (pro[value] = nodeOwner.defaultValue);
                                }
                                else {
                                    pro && pro.getVector2(value) && pro.setVector2(value, nodeOwner.defaultValue);
                                }
                                break;
                            case exports.KeyFrameValueType.Vector3:
                                var proPat = nodeOwner.property;
                                var m = proPat.length - 1;
                                for (var j = 0; j < m; j++) {
                                    pro = pro[proPat[j]];
                                    if (!pro)
                                        break;
                                }
                                value = proPat[m];
                                if (!nodeOwner.isMaterial) {
                                    pro && (pro[value] = nodeOwner.defaultValue);
                                }
                                else {
                                    pro && pro.getVector3(value) && pro.setVector3(value, nodeOwner.defaultValue);
                                }
                                break;
                            case exports.KeyFrameValueType.Vector4:
                                var proPat = nodeOwner.property;
                                var m = proPat.length - 1;
                                for (var j = 0; j < m; j++) {
                                    pro = pro[proPat[j]];
                                    if (!pro)
                                        break;
                                }
                                value = proPat[m];
                                if (!nodeOwner.isMaterial) {
                                    pro && (pro[value] = nodeOwner.defaultValue);
                                }
                                else {
                                    pro && pro.getVector3(value) && pro.setVector3(value, nodeOwner.defaultValue);
                                }
                                break;
                            case exports.KeyFrameValueType.Color:
                                var proPat = nodeOwner.property;
                                var m = proPat.length - 1;
                                for (var j = 0; j < m; j++) {
                                    pro = pro[proPat[j]];
                                    if (!pro)
                                        break;
                                }
                                value = proPat[m];
                                let tempColor = Animator._tempColor;
                                tempColor.r = nodeOwner.defaultValue.x;
                                tempColor.g = nodeOwner.defaultValue.y;
                                tempColor.b = nodeOwner.defaultValue.z;
                                tempColor.a = nodeOwner.defaultValue.w;
                                if (!nodeOwner.isMaterial) {
                                    pro && (pro[value] = tempColor);
                                }
                                else {
                                    pro && pro.getColor(value) && pro.setColor(value, tempColor);
                                }
                                break;
                            default:
                                throw "Animator:unknown type.";
                        }
                    }
                }
            }
        }
        onAfterDeserialize() {
            let arr = this.controllerLayers;
            if (!arr || null != this.controller)
                return;
            delete this.controllerLayers;
            this._controllerLayers.length = 0;
            for (let layer of arr) {
                this.addControllerLayer(layer);
            }
        }
        _onEnable() {
            for (let i = 0, n = this._controllerLayers.length; i < n; i++) {
                if (this._controllerLayers[i].playOnWake) {
                    let defaultClip = this.getDefaultState(i);
                    (defaultClip) && (this.play(null, i, 0));
                }
            }
        }
        _onDestroy() {
            for (let i = 0, n = this._controllerLayers.length; i < n; i++)
                this._controllerLayers[i]._removeReference();
        }
        _applyUpdateMode(delta) {
            let ret;
            switch (this._updateMode) {
                case Laya.AnimatorUpdateMode.Normal:
                    ret = delta;
                    break;
                case Laya.AnimatorUpdateMode.LowFrame:
                    ret = (Laya.Stat.loopCount % this._lowUpdateDelty == 0) ? delta * this._lowUpdateDelty : 0;
                    break;
                case Laya.AnimatorUpdateMode.UnScaleTime:
                    ret = 0;
                    break;
            }
            return ret;
        }
        _handleSpriteOwnersBySprite(isLink, path, sprite) {
            for (var i = 0, n = this._controllerLayers.length; i < n; i++) {
                if (!this._controllerLayers[i].enable)
                    continue;
                var clipStateInfos = this._controllerLayers[i]._states;
                for (var j = 0, m = clipStateInfos.length; j < m; j++) {
                    var clipStateInfo = clipStateInfos[j];
                    var clip = clipStateInfo._clip;
                    var nodePath = path.join("/");
                    var ownersNodes = clip._nodesMap[nodePath];
                    if (ownersNodes) {
                        var nodeOwners = clipStateInfo._nodeOwners;
                        for (var k = 0, p = ownersNodes.length; k < p; k++) {
                            if (isLink)
                                this._addKeyframeNodeOwner(nodeOwners, ownersNodes[k], sprite);
                            else
                                this._removeKeyframeNodeOwner(nodeOwners, ownersNodes[k]);
                        }
                    }
                }
            }
        }
        _parse(data) {
            var play = data.playOnWake;
            var layersData = data.layers;
            for (var i = 0; i < layersData.length; i++) {
                var layerData = layersData[i];
                var animatorLayer = new AnimatorControllerLayer(layerData.name);
                if (i === 0)
                    animatorLayer.defaultWeight = 1.0;
                else
                    animatorLayer.defaultWeight = layerData.weight;
                var blendingModeData = layerData.blendingMode;
                (blendingModeData) && (animatorLayer.blendingMode = blendingModeData);
                this.addControllerLayer(animatorLayer);
                var states = layerData.states;
                for (var j = 0, m = states.length; j < m; j++) {
                    var state = states[j];
                    var clipPath = state.clipPath;
                    if (clipPath) {
                        var name = state.name;
                        var motion;
                        motion = Laya.Loader.getRes(clipPath);
                        if (motion) {
                            var animatorState = new AnimatorState();
                            animatorState.name = name;
                            animatorState.clip = motion;
                            state.speed && (animatorState.speed = state.speed);
                            animatorLayer.addState(animatorState);
                            (j === 0) && (this.getControllerLayer(i).defaultState = animatorState);
                        }
                    }
                }
                (play !== undefined) && (animatorLayer.playOnWake = play);
                let layerMaskData = layerData.avatarMask;
                if (layerMaskData) {
                    let avaMask = new AvatarMask();
                    animatorLayer.avatarMask = avaMask;
                    for (var bips in layerMaskData) {
                        avaMask.setTransformActive(bips, layerMaskData[bips]);
                    }
                }
            }
            var cullingModeData = data.cullingMode;
            (cullingModeData !== undefined) && (this.cullingMode = cullingModeData);
        }
        onUpdate() {
            let timer = this.owner._scene.timer;
            let delta = timer._delta / 1000.0;
            delta = this._applyUpdateMode(delta);
            if (this._speed === 0 || delta === 0)
                return;
            if (!Laya.Stat.enableAnimatorUpdate)
                return;
            var i, n;
            this._updateMark++;
            for (i = 0, n = this._controllerLayers.length; i < n; i++) {
                var controllerLayer = this._controllerLayers[i];
                if (!controllerLayer.enable)
                    continue;
                var playStateInfo = controllerLayer._playStateInfo;
                var crossPlayStateInfo = controllerLayer._crossPlayStateInfo;
                addtive = controllerLayer.blendingMode !== AnimatorControllerLayer.BLENDINGMODE_OVERRIDE;
                switch (controllerLayer._playType) {
                    case 0:
                        var animatorState = playStateInfo._currentState;
                        var clip = animatorState._clip;
                        var speed = this._speed * animatorState.speed;
                        var finish = playStateInfo._finish;
                        finish || this._updatePlayer(animatorState, playStateInfo, delta * speed, clip.islooping, i);
                        {
                            var addtive = controllerLayer.blendingMode !== AnimatorControllerLayer.BLENDINGMODE_OVERRIDE;
                            this._updateClipDatas(animatorState, addtive, playStateInfo, controllerLayer.avatarMask);
                            this._setClipDatasToNode(animatorState, addtive, controllerLayer.defaultWeight, i === 0, controllerLayer);
                            finish || this._updateEventScript(animatorState, playStateInfo);
                        }
                        finish || this._updateStateFinish(animatorState, playStateInfo);
                        break;
                    case 1:
                        animatorState = playStateInfo._currentState;
                        clip = animatorState._clip;
                        var crossState = controllerLayer._crossPlayState;
                        var crossClip = crossState._clip;
                        var crossDuratuion = controllerLayer._crossDuration;
                        var startPlayTime = crossPlayStateInfo._startPlayTime;
                        var crossClipDuration = crossClip._duration - startPlayTime;
                        var crossScale = crossDuratuion > crossClipDuration ? crossClipDuration / crossDuratuion : 1.0;
                        var crossSpeed = this._speed * crossState.speed;
                        this._updatePlayer(crossState, crossPlayStateInfo, delta * crossScale * crossSpeed, crossClip.islooping, i);
                        var crossWeight = ((crossPlayStateInfo._elapsedTime - startPlayTime) / crossScale) / crossDuratuion;
                        var needUpdateFinishcurrentState = false;
                        if (crossWeight >= 1.0) {
                            {
                                this._updateClipDatas(crossState, addtive, crossPlayStateInfo, controllerLayer.avatarMask);
                                this._setClipDatasToNode(crossState, addtive, controllerLayer.defaultWeight, i === 0, controllerLayer);
                                controllerLayer._playType = 0;
                                playStateInfo._currentState = crossState;
                                crossPlayStateInfo._cloneTo(playStateInfo);
                            }
                        }
                        else {
                            if (!playStateInfo._finish) {
                                speed = this._speed * animatorState.speed;
                                needUpdateFinishcurrentState = true;
                                this._updatePlayer(animatorState, playStateInfo, delta * speed, clip.islooping, i);
                                this._updateClipDatas(animatorState, addtive, playStateInfo, controllerLayer.avatarMask);
                            }
                            {
                                this._updateClipDatas(crossState, addtive, crossPlayStateInfo, controllerLayer.avatarMask);
                                this._setCrossClipDatasToNode(controllerLayer, animatorState, crossState, crossWeight, i === 0);
                            }
                        }
                        {
                            this._updateEventScript(animatorState, playStateInfo);
                            this._updateEventScript(crossState, crossPlayStateInfo);
                        }
                        this._updateStateFinish(crossState, crossPlayStateInfo);
                        needUpdateFinishcurrentState && this._updateStateFinish(playStateInfo._currentState, playStateInfo);
                        break;
                    case 2:
                        crossState = controllerLayer._crossPlayState;
                        crossClip = crossState._clip;
                        crossDuratuion = controllerLayer._crossDuration;
                        startPlayTime = crossPlayStateInfo._startPlayTime;
                        crossClipDuration = crossClip._duration - startPlayTime;
                        crossScale = crossDuratuion > crossClipDuration ? crossClipDuration / crossDuratuion : 1.0;
                        crossSpeed = this._speed * crossState.speed;
                        this._updatePlayer(crossState, crossPlayStateInfo, delta * crossScale * crossSpeed, crossClip.islooping, i);
                        {
                            crossWeight = ((crossPlayStateInfo._elapsedTime - startPlayTime) / crossScale) / crossDuratuion;
                            if (crossWeight >= 1.0) {
                                this._updateClipDatas(crossState, addtive, crossPlayStateInfo, controllerLayer.avatarMask);
                                this._setClipDatasToNode(crossState, addtive, 1.0, i === 0, controllerLayer);
                                controllerLayer._playType = 0;
                                playStateInfo._currentState = crossState;
                                crossPlayStateInfo._cloneTo(playStateInfo);
                            }
                            else {
                                this._updateClipDatas(crossState, addtive, crossPlayStateInfo, controllerLayer.avatarMask);
                                this._setFixedCrossClipDatasToNode(controllerLayer, crossState, crossWeight, i === 0);
                            }
                            this._updateEventScript(crossState, crossPlayStateInfo);
                        }
                        this._updateStateFinish(crossState, crossPlayStateInfo);
                        break;
                }
            }
        }
        _cloneTo(dest) {
            var animator = dest;
            animator.cullingMode = this.cullingMode;
            for (var i = 0, n = this._controllerLayers.length; i < n; i++) {
                var controllLayer = this._controllerLayers[i];
                animator.addControllerLayer(controllLayer.clone());
                var animatorStates = controllLayer._states;
                for (var j = 0, m = animatorStates.length; j < m; j++) {
                    var state = animatorStates[j].clone();
                    var cloneLayer = animator.getControllerLayer(i);
                    cloneLayer.addState(state);
                    (j == 0) && (cloneLayer.defaultState = state);
                }
            }
        }
        getDefaultState(layerIndex = 0) {
            var controllerLayer = this._controllerLayers[layerIndex];
            return controllerLayer.defaultState;
        }
        addState(state, layerIndex = 0) {
            var controllerLayer = this._controllerLayers[layerIndex];
            controllerLayer.addState(state);
            console.warn("Animator:this function is discard,please use animatorControllerLayer.addState() instead.");
        }
        removeState(state, layerIndex = 0) {
            var controllerLayer = this._controllerLayers[layerIndex];
            controllerLayer.removeState(state);
            console.warn("Animator:this function is discard,please use animatorControllerLayer.removeState() instead.");
        }
        addControllerLayer(controllderLayer) {
            this._controllerLayers.push(controllderLayer);
            controllderLayer._animator = this;
            controllderLayer._addReference();
            var states = controllderLayer._states;
            for (var i = 0, n = states.length; i < n; i++)
                this._getOwnersByClip(states[i]);
        }
        getControllerLayer(layerInex = 0) {
            return this._controllerLayers[layerInex];
        }
        play(name = null, layerIndex = 0, normalizedTime = Number.NEGATIVE_INFINITY) {
            var controllerLayer = this._controllerLayers[layerIndex];
            if (controllerLayer) {
                var defaultState = controllerLayer.defaultState;
                if (!name && !defaultState)
                    throw new Error("Animator:must have default clip value,please set clip property.");
                var playStateInfo = controllerLayer._playStateInfo;
                var curPlayState = playStateInfo._currentState;
                var animatorState = name ? controllerLayer.getAnimatorState(name) : defaultState;
                if (!animatorState._clip)
                    return;
                var clipDuration = animatorState._clip._duration;
                var calclipduration = animatorState._clip._duration * (animatorState.clipEnd - animatorState.clipStart);
                if (curPlayState !== animatorState) {
                    if (normalizedTime !== Number.NEGATIVE_INFINITY)
                        playStateInfo._resetPlayState(clipDuration * normalizedTime, calclipduration);
                    else
                        playStateInfo._resetPlayState(0.0, calclipduration);
                    (curPlayState !== null && curPlayState !== animatorState) && (this._revertDefaultKeyframeNodes(curPlayState));
                    controllerLayer._playType = 0;
                    playStateInfo._currentState = animatorState;
                }
                else {
                    if (normalizedTime !== Number.NEGATIVE_INFINITY) {
                        playStateInfo._resetPlayState(clipDuration * normalizedTime, calclipduration);
                        controllerLayer._playType = 0;
                    }
                }
                animatorState._scripts;
                animatorState._eventStart();
            }
            else {
                console.warn("Invalid layerIndex " + layerIndex + ".");
            }
            if (this.owner._scene) {
                this.onUpdate();
            }
        }
        crossFade(name, transitionDuration, layerIndex = 0, normalizedTime = Number.NEGATIVE_INFINITY) {
            var controllerLayer = this._controllerLayers[layerIndex];
            if (controllerLayer) {
                var destAnimatorState = controllerLayer.getAnimatorState(name);
                if (destAnimatorState) {
                    var playType = controllerLayer._playType;
                    if (playType === -1) {
                        this.play(name, layerIndex, normalizedTime);
                        return;
                    }
                    var crossPlayStateInfo = controllerLayer._crossPlayStateInfo;
                    var crossNodeOwners = controllerLayer._crossNodesOwners;
                    var crossNodeOwnerIndicesMap = controllerLayer._crossNodesOwnersIndicesMap;
                    var srcAnimatorState = controllerLayer._playStateInfo._currentState;
                    var destNodeOwners = destAnimatorState._nodeOwners;
                    var destCrossClipNodeIndices = controllerLayer._destCrossClipNodeIndices;
                    var destClip = destAnimatorState._clip;
                    var destNodes = destClip._nodes;
                    var destNodesMap = destClip._nodesDic;
                    var crossCount = 0;
                    switch (playType) {
                        case 0:
                            var srcNodeOwners = srcAnimatorState._nodeOwners;
                            var scrCrossClipNodeIndices = controllerLayer._srcCrossClipNodeIndices;
                            var srcClip = srcAnimatorState._clip;
                            var srcNodes = srcClip._nodes;
                            var srcNodesMap = srcClip._nodesDic;
                            controllerLayer._playType = 1;
                            var crossMark = ++controllerLayer._crossMark;
                            crossCount = controllerLayer._crossNodesOwnersCount = 0;
                            for (var i = 0, n = srcNodes.count; i < n; i++) {
                                var srcNode = srcNodes.getNodeByIndex(i);
                                var srcIndex = srcNode._indexInList;
                                var srcNodeOwner = srcNodeOwners[srcIndex];
                                if (srcNodeOwner) {
                                    var srcFullPath = srcNode.fullPath;
                                    scrCrossClipNodeIndices[crossCount] = srcIndex;
                                    var destNode = destNodesMap[srcFullPath];
                                    if (destNode)
                                        destCrossClipNodeIndices[crossCount] = destNode._indexInList;
                                    else
                                        destCrossClipNodeIndices[crossCount] = -1;
                                    crossNodeOwnerIndicesMap[srcFullPath] = crossMark;
                                    crossNodeOwners[crossCount] = srcNodeOwner;
                                    crossCount++;
                                }
                            }
                            for (i = 0, n = destNodes.count; i < n; i++) {
                                destNode = destNodes.getNodeByIndex(i);
                                var destIndex = destNode._indexInList;
                                var destNodeOwner = destNodeOwners[destIndex];
                                if (destNodeOwner) {
                                    var destFullPath = destNode.fullPath;
                                    if (!srcNodesMap[destFullPath]) {
                                        scrCrossClipNodeIndices[crossCount] = -1;
                                        destCrossClipNodeIndices[crossCount] = destIndex;
                                        crossNodeOwnerIndicesMap[destFullPath] = crossMark;
                                        crossNodeOwners[crossCount] = destNodeOwner;
                                        crossCount++;
                                    }
                                }
                            }
                            break;
                        case 1:
                        case 2:
                            controllerLayer._playType = 2;
                            for (i = 0, n = crossNodeOwners.length; i < n; i++) {
                                var nodeOwner = crossNodeOwners[i];
                                nodeOwner.saveCrossFixedValue();
                                destNode = destNodesMap[nodeOwner.fullPath];
                                if (destNode)
                                    destCrossClipNodeIndices[i] = destNode._indexInList;
                                else
                                    destCrossClipNodeIndices[i] = -1;
                            }
                            crossCount = controllerLayer._crossNodesOwnersCount;
                            crossMark = controllerLayer._crossMark;
                            for (i = 0, n = destNodes.count; i < n; i++) {
                                destNode = destNodes.getNodeByIndex(i);
                                destIndex = destNode._indexInList;
                                destNodeOwner = destNodeOwners[destIndex];
                                if (destNodeOwner) {
                                    destFullPath = destNode.fullPath;
                                    if (crossNodeOwnerIndicesMap[destFullPath] !== crossMark) {
                                        destCrossClipNodeIndices[crossCount] = destIndex;
                                        crossNodeOwnerIndicesMap[destFullPath] = crossMark;
                                        nodeOwner = destNodeOwners[destIndex];
                                        crossNodeOwners[crossCount] = nodeOwner;
                                        nodeOwner.saveCrossFixedValue();
                                        crossCount++;
                                    }
                                }
                            }
                            break;
                    }
                    controllerLayer._crossNodesOwnersCount = crossCount;
                    controllerLayer._crossPlayState = destAnimatorState;
                    controllerLayer._crossDuration = srcAnimatorState._clip._duration * transitionDuration;
                    if (normalizedTime !== Number.NEGATIVE_INFINITY)
                        crossPlayStateInfo._resetPlayState(destClip._duration * normalizedTime, controllerLayer._crossDuration);
                    else
                        crossPlayStateInfo._resetPlayState(0.0, controllerLayer._crossDuration);
                    destAnimatorState._eventStart();
                }
                else {
                    console.warn("Invalid name " + layerIndex + ".");
                }
            }
            else {
                console.warn("Invalid layerIndex " + layerIndex + ".");
            }
        }
        setParamsTrigger(name) {
            let id;
            if (typeof name == "number")
                id = name;
            else
                id = Laya.AnimatorStateCondition.conditionNameToID(name);
            this._animatorParams[id] = true;
        }
        setParamsNumber(name, value) {
            let id;
            if (typeof name == "number")
                id = name;
            else
                id = Laya.AnimatorStateCondition.conditionNameToID(name);
            this._animatorParams[id] = value;
        }
        setParamsBool(name, value) {
            let id;
            if (typeof name == "number")
                id = name;
            else
                id = Laya.AnimatorStateCondition.conditionNameToID(name);
            this._animatorParams[id] = value;
        }
        getParamsvalue(name) {
            let id;
            if (typeof name == "number")
                id = name;
            else
                id = Laya.AnimatorStateCondition.conditionNameToID(name);
            return this._animatorParams[id];
        }
        getCurrentAnimatorPlayState(layerInex = 0) {
            return this._controllerLayers[layerInex]._playStateInfo;
        }
    }
    Animator._tempVector31 = new Laya.Vector3();
    Animator._tempColor = new Laya.Color();
    Animator._tempQuaternion1 = new Laya.Quaternion();
    Animator.CULLINGMODE_ALWAYSANIMATE = 0;
    Animator.CULLINGMODE_CULLCOMPLETELY = 2;

    class PostProcessRenderContext {
        constructor() {
            this.source = null;
            this.indirectTarget = null;
            this.destination = null;
            this.camera = null;
            this.compositeShaderData = null;
            this.command = null;
            this.deferredReleaseTextures = [];
        }
        createRTByContextReleaseTexture(width, height, colorFormat, depthFormat, mipmap = false, multiSamples = 1, depthTexture = false, sRGB = false) {
            let n = this.deferredReleaseTextures.length;
            for (let index = 0; index < n; index++) {
                let rt = this.deferredReleaseTextures[index];
                if (rt.width == width && rt.height == height && rt.colorFormat == colorFormat && rt.depthStencilFormat == depthFormat && rt._generateMipmap == mipmap && rt.multiSamples == multiSamples && rt.generateDepthTexture == depthTexture && rt._gammaSpace == sRGB) {
                    rt._inPool = false;
                    let end = this.deferredReleaseTextures[n - 1];
                    this.deferredReleaseTextures[index] = end;
                    this.deferredReleaseTextures.length -= 1;
                    return rt;
                }
            }
            return null;
        }
    }

    class PostProcessEffect {
        constructor() {
            this._active = true;
            this._singleton = true;
        }
        set singleton(value) {
            this._singleton = value;
        }
        get singleton() {
            return this._singleton;
        }
        get active() {
            return this._active;
        }
        set active(value) {
            this._active = value;
        }
        getCameraDepthTextureModeFlag() {
            return 0;
        }
        effectInit(postprocess) {
            return;
        }
        release(postprocess) {
        }
        render(context) {
        }
    }

    var BlitVS = "#define SHADER_NAME BlitVS\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\nvoid main()\r\n{\r\n    gl_Position = vec4(u_OffsetScale.x * 2.0 - 1.0 + (a_PositionTexcoord.x + 1.0) * u_OffsetScale.z, (1.0 - ((u_OffsetScale.y * 2.0 - 1.0 + (-a_PositionTexcoord.y + 1.0) * u_OffsetScale.w) + 1.0) / 2.0) * 2.0 - 1.0, 0.0, 1.0);\r\n\r\n    v_Texcoord0 = a_PositionTexcoord.zw;\r\n}";

    var BlitLUTShader = "#define SHADER_NAME BlitLUTFS\r\n\r\n#include \"Color.glsl\";\r\n\r\n#include \"ColorGrading.glsl\";\r\n#include \"LUT.glsl\";\r\n\r\nuniform sampler2D u_Lut;\r\nuniform vec4 u_LutParams;//w postExposure\r\n\r\n    #ifdef CUSTOMLUT\r\nuniform sampler2D u_CustomLut;\r\nuniform vec4 u_CustomLutParams;\r\n    #endif // CUSTOMLUT\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\nvoid main()\r\n{\r\n    gl_FragColor = texture2D(u_MainTex, v_Texcoord0);\r\n    vec3 color = gl_FragColor.rgb;\r\n    // gl_FragColor.rgb = applyLut(color, 1.0, u_Lut, u_LutParams);\r\n    color *= u_LutParams.w;\r\n    color = applyLut(u_Lut, linearToLogC(color), u_LutParams.xyz);\r\n\r\n    #ifdef CUSTOMLUT\r\n\r\n    float contrib = u_CustomLutParams.w;\r\n    vec3 gamma = linearToGamma(color);\r\n    vec3 userLut = applyLut(u_CustomLut, gamma, u_CustomLutParams);\r\n    gamma = mix(gamma, userLut, contrib);\r\n    color = gammaToLinear(gamma);\r\n\r\n    #endif // CUSTOMLUT\r\n\r\n    gl_FragColor.rgb = color;\r\n\r\n    #ifdef GAMMAOUT\r\n        gl_FragColor = linearToGamma(gl_FragColor);\r\n    #endif\r\n}\r\n";

    exports.ToneMappingType = void 0;
    (function (ToneMappingType) {
        ToneMappingType[ToneMappingType["None"] = 0] = "None";
        ToneMappingType[ToneMappingType["ACES"] = 1] = "ACES";
    })(exports.ToneMappingType || (exports.ToneMappingType = {}));
    class ColorGradEffect extends PostProcessEffect {
        constructor() {
            super();
            this._needBuildLUT = false;
            this._lutBuilderMat = new Material();
            this._lutSize = 32;
            this._enableSplitTone = false;
            this._splitShadow = new Laya.Vector3(0.5, 0.5, 0.5);
            this._splitBalance = 0;
            this._splithighlights = new Laya.Vector3(0.5, 0.5, 0.5);
            this._u_SplitShadow = new Laya.Vector4(0, 0, 0);
            this._enableSMH = false;
            this._shadows = new Laya.Vector3(1, 1, 1);
            this._midtones = new Laya.Vector3(1, 1, 1);
            this._highlights = new Laya.Vector3(1, 1, 1);
            this._limits = new Laya.Vector4(0, 0.33, 0.55, 1);
            this._enableLiftGammaGain = false;
            this._lift = new Laya.Vector3(0, 0, 0);
            this._gamma = new Laya.Vector3(1, 1, 1);
            this._gain = new Laya.Vector3(1, 1, 1);
            this._enableBalance = false;
            this._balance = new Laya.Vector3();
            this._tint = 0;
            this._temperature = 0;
            this._enableColorAdjust = false;
            this._postExposure = 1;
            this._contrast = 1;
            this._colorFilter = new Laya.Color(1, 1, 1);
            this._HueShift = 0;
            this._saturation = 1;
            this._HueSatCon = new Laya.Vector4(0, 1, 1, 0);
            this.default_balance = new Laya.Vector3(1, 1, 1);
            this.default_splitShadow = new Laya.Vector4(0.5, 0.5, 0.5, 0.0);
            this.default_splithighlights = new Laya.Vector3(0.5, 0.5, 0.5);
            this.default_shadow = new Laya.Vector3(1, 1, 1);
            this.default_midtones = new Laya.Vector3(1, 1, 1);
            this.default_highlight = new Laya.Vector3(1, 1, 1);
            this.default_limint = new Laya.Vector4(0.0, 0.3, 0.55, 1.0);
            this.default_lift = new Laya.Vector3(0, 0, 0);
            this.default_gamma = new Laya.Vector3(1, 1, 1);
            this.default_gain = new Laya.Vector3(1, 1, 1);
            this.default_ColorFilter = new Laya.Color(1, 1, 1, 1);
            this.default_HueSatCon = new Laya.Vector4(0, 1, 1, 0);
            this.singleton = true;
            this.active = true;
            this._needBuildLUT = true;
            this._toneMapping = exports.ToneMappingType.None;
            this._blitlutParams = new Laya.Vector4();
            this._lutShaderData = Laya.LayaGL.renderOBJCreate.createShaderData(null);
            this.lutSize = 32;
            this._lutCommond = new CommandBuffer();
            this._lutBuilderMat = new Material();
        }
        static init() {
            ColorGradEffect.__initDefine__();
            let attributeMap = {
                "a_PositionTexcoord": [Laya.VertexMesh.MESH_POSITION0, Laya.ShaderDataType.Vector4]
            };
            let uniformMap = {
                "u_OffsetScale": Laya.ShaderDataType.Vector4,
                "u_MainTex": Laya.ShaderDataType.Texture2D,
                "u_MainTex_TexelSize": Laya.ShaderDataType.Vector4,
            };
            let shader = Laya.Shader3D.add("blitLUTShader");
            let subShader = new Laya.SubShader(attributeMap, uniformMap);
            shader.addSubShader(subShader);
            let pass = subShader.addShaderPass(BlitVS, BlitLUTShader);
            pass.renderState.depthTest = Laya.RenderState.DEPTHTEST_ALWAYS;
            pass.renderState.depthWrite = false;
            pass.renderState.cull = Laya.RenderState.CULL_NONE;
            pass.renderState.blend = Laya.RenderState.BLEND_DISABLE;
        }
        static __initDefine__() {
            ColorGradEffect.SHADERDEFINE_ACES = Laya.Shader3D.getDefineByName("ACES");
            ColorGradEffect.SHADERDEFINE_CUSTOMLUT = Laya.Shader3D.getDefineByName("CUSTOMLUT");
            ColorGradEffect.SHADERVALUE_LUT = Laya.Shader3D.propertyNameToID("u_Lut");
            ColorGradEffect.SHADERVALUE_LUTPARAMS = Laya.Shader3D.propertyNameToID("u_LutParams");
            ColorGradEffect.SHADERVALUE_CUSTOMLUT = Laya.Shader3D.propertyNameToID("u_CustomLut");
            ColorGradEffect.SHADERVALUE_CUSTOMLUTPARAMS = Laya.Shader3D.propertyNameToID("u_CustomLutParams");
        }
        get toneMapping() {
            return this._toneMapping;
        }
        set toneMapping(value) {
            if (value == this._toneMapping)
                return;
            this._needBuildLUT = true;
            this._toneMapping = value;
        }
        get enableSplitTone() {
            return this._enableSplitTone;
        }
        set enableSplitTone(value) {
            this._enableSplitTone = value;
            this._needBuildLUT = true;
        }
        get splitShadow() {
            return this._splitShadow;
        }
        set splitShadow(value) {
            this._needBuildLUT = true;
            value.cloneTo(this._splitShadow);
        }
        get splithighlights() {
            return this._splithighlights;
        }
        set splithighlights(value) {
            if (this._splithighlights.equal(value))
                return;
            this._needBuildLUT = true;
            value.cloneTo(this._splithighlights);
        }
        get splitBalance() {
            return this._splitBalance;
        }
        set splitBalance(value) {
            this._needBuildLUT = true;
            this._splitBalance = value;
        }
        get enableSMH() {
            return this._enableSMH;
        }
        set enableSMH(value) {
            this._needBuildLUT = true;
            this._enableSMH = value;
        }
        get shadows() {
            return this._shadows;
        }
        set shadows(value) {
            if (this._shadows.equal(value))
                return;
            this._needBuildLUT = true;
            value.cloneTo(this._shadows);
        }
        get midtones() {
            return this._midtones;
        }
        set midtones(value) {
            if (this._midtones.equal(value))
                return;
            this._needBuildLUT = true;
            value.cloneTo(this._midtones);
        }
        get highlights() {
            return this._highlights;
        }
        set highlights(value) {
            if (this._highlights.equal(value))
                return;
            this._needBuildLUT = true;
            value.cloneTo(this._highlights);
        }
        get shadowLimitStart() {
            return this._limits.x;
        }
        set shadowLimitStart(value) {
            this._needBuildLUT = true;
            this._limits.x = Math.min(value, this.shadowLimitEnd);
        }
        get shadowLimitEnd() {
            return this._limits.y;
        }
        set shadowLimitEnd(value) {
            this._needBuildLUT = true;
            this._limits.y = Math.max(value, this.shadowLimitStart);
        }
        get highLightLimitStart() {
            return this._limits.z;
        }
        set highLightLimitStart(value) {
            this._needBuildLUT = true;
            this._limits.z = Math.min(value, this.highLightLimitEnd);
        }
        get highLightLimitEnd() {
            return this._limits.w;
        }
        set highLightLimitEnd(value) {
            this._needBuildLUT = true;
            this._limits.w = Math.max(this.highLightLimitStart, value);
        }
        get enableLiftGammaGain() {
            return this._enableLiftGammaGain;
        }
        set enableLiftGammaGain(value) {
            this._needBuildLUT = true;
            this._enableLiftGammaGain = value;
        }
        get lift() {
            return this._lift;
        }
        set lift(value) {
            if (this.lift.equal(value))
                return;
            this._needBuildLUT = true;
            value.cloneTo(this._lift);
        }
        get gamma() {
            return this._gamma;
        }
        set gamma(value) {
            if (this._gamma.equal(value))
                return;
            this._needBuildLUT = true;
            value.cloneTo(this._gamma);
        }
        get gain() {
            return this._gain;
        }
        set gain(value) {
            if (this._gain.equal(value))
                return;
            this._needBuildLUT = true;
            value.cloneTo(this._gain);
        }
        _StandardIlluminantY(x) {
            return 2.87 * x - 3 * x * x - 0.27509507;
        }
        ;
        _CIExyToLMS(x, y) {
            let Y = 1;
            let X = Y * x / y;
            let Z = Y * (1 - x - y) / y;
            let L = 0.7328 * X + 0.4296 * Y - 0.1624 * Z;
            let M = -0.7036 * X + 1.6975 * Y + 0.0061 * Z;
            let S = 0.0030 * X + 0.0136 * Y + 0.9834 * Z;
            return new Laya.Vector3(L, M, S);
        }
        _ColorBalanceToLMSCoeffs(temperature, tint) {
            let t1 = temperature / 65.0;
            let t2 = tint / 65.0;
            let x = 0.31271 - t1 * (t1 < 0 ? 0.1 : 0.05);
            let y = this._StandardIlluminantY(x) + t2 * 0.05;
            let w1 = new Laya.Vector3(0.949237, 1.03542, 1.08728);
            let w2 = this._CIExyToLMS(x, y);
            this._balance.set(w1.x / w2.x, w1.y / w2.y, w1.z / w2.z);
        }
        get enableBalance() {
            return this._enableBalance;
        }
        set enableBalance(value) {
            this._needBuildLUT = true;
            this._enableBalance = value;
        }
        get tint() {
            return this._tint;
        }
        set tint(value) {
            this._needBuildLUT = true;
            this._tint = value;
            this._ColorBalanceToLMSCoeffs(this._temperature, this._tint);
        }
        get temperature() {
            return this._temperature;
        }
        set temperature(value) {
            this._needBuildLUT = true;
            this._temperature = value;
            this._ColorBalanceToLMSCoeffs(this._temperature, this._tint);
        }
        get enableColorAdjust() {
            return this._enableColorAdjust;
        }
        set enableColorAdjust(value) {
            this._needBuildLUT = true;
            this._enableColorAdjust = value;
        }
        get postExposure() {
            return this._postExposure;
        }
        set postExposure(value) {
            this._postExposure = value;
        }
        get contrast() {
            return this._contrast;
        }
        set contrast(value) {
            this._needBuildLUT = true;
            this._contrast = value;
        }
        get colorFilter() {
            return this._colorFilter;
        }
        set colorFilter(value) {
            this._needBuildLUT = true;
            value.cloneTo(this._colorFilter);
        }
        get HueShift() {
            return this._HueShift;
        }
        set HueShift(value) {
            this._needBuildLUT = true;
            this._HueShift = value;
        }
        get saturation() {
            return this._saturation;
        }
        set saturation(value) {
            this._needBuildLUT = true;
            this._saturation = value;
        }
        get lutSize() {
            return this._lutSize;
        }
        set lutSize(value) {
            if (value > 32)
                return;
            this._lutSize = value;
            if (this._lutTex)
                this._lutTex.destroy();
            this._lutTex = new Laya.RenderTexture(this._lutSize * this._lutSize, this._lutSize, Laya.RenderTargetFormat.R16G16B16A16, null, false, 1, false, false);
            this._lutTex.anisoLevel = 1;
            this._lutTex.wrapModeU = Laya.WrapMode.Clamp;
            this._lutTex.wrapModeV = Laya.WrapMode.Clamp;
            this._lutTex.filterMode = Laya.FilterMode.Bilinear;
        }
        _buildLUT() {
            if (!this._needBuildLUT)
                return;
            let lutHeight = this.lutSize;
            let lutWidth = this.lutSize * this.lutSize;
            let lutParams = new Laya.Vector4(lutHeight, 0.5 / lutWidth, 0.5 / lutHeight, lutHeight / (lutHeight - 1));
            this._lutBuilderMat.setVector4("u_LutParams", lutParams);
            if (this.enableBalance) {
                this._ColorBalanceToLMSCoeffs(this.temperature, this.tint);
                this._lutBuilderMat.setVector3("u_ColorBalance", this._balance);
            }
            else {
                this._lutBuilderMat.setVector3("u_ColorBalance", this.default_balance);
            }
            if (this.enableSplitTone) {
                this._u_SplitShadow.setValue(this._splitShadow.x, this._splitShadow.y, this._splitShadow.z, this.splitBalance);
                this._lutBuilderMat.setVector4("u_SplitShadows", this._u_SplitShadow);
                this._lutBuilderMat.setVector3("u_Splithighlights", this._splithighlights);
            }
            else {
                this._lutBuilderMat.setVector4("u_SplitShadows", this.default_splitShadow);
                this._lutBuilderMat.setVector3("u_Splithighlights", this.default_splithighlights);
            }
            if (this.enableSMH) {
                this._lutBuilderMat.setVector3("u_Shadows", this._shadows);
                this._lutBuilderMat.setVector3("u_Midtones", this._midtones);
                this._lutBuilderMat.setVector3("u_Highlights", this._highlights);
                this._lutBuilderMat.setVector4("u_Limits", this._limits);
            }
            else {
                this._lutBuilderMat.setVector3("u_Shadows", this.default_shadow);
                this._lutBuilderMat.setVector3("u_Midtones", this.default_midtones);
                this._lutBuilderMat.setVector3("u_Highlights", this.default_highlight);
                this._lutBuilderMat.setVector4("u_Limits", this.default_limint);
            }
            if (this._enableLiftGammaGain) {
                this._lutBuilderMat.setVector3("u_Lift", this._lift);
                this._lutBuilderMat.setVector3("u_Gamma", this._gamma);
                this._lutBuilderMat.setVector3("u_Gain", this._gain);
            }
            else {
                this._lutBuilderMat.setVector3("u_Lift", this.default_lift);
                this._lutBuilderMat.setVector3("u_Gamma", this.default_gamma);
                this._lutBuilderMat.setVector3("u_Gain", this.default_gain);
            }
            if (this.enableColorAdjust) {
                this._HueSatCon.setValue(this._HueShift, this.saturation, this._contrast, 0.0);
                this._lutBuilderMat.setColor("u_ColorFilter", this._colorFilter);
                this._lutBuilderMat.setVector4("u_HueSatCon", this._HueSatCon);
            }
            else {
                this._lutBuilderMat.setColor("u_ColorFilter", this.default_ColorFilter);
                this._lutBuilderMat.setVector4("u_HueSatCon", this.default_HueSatCon);
            }
            if (this._toneMapping == exports.ToneMappingType.ACES) {
                this._lutBuilderMat.addDefine(ColorGradEffect.SHADERDEFINE_ACES);
            }
            else {
                this._lutBuilderMat.removeDefine(ColorGradEffect.SHADERDEFINE_ACES);
            }
            this._lutCommond.blitScreenQuadByMaterial(Laya.Texture2D.whiteTexture, this._lutTex, null, this._lutBuilderMat);
            this._lutCommond.context = RenderContext3D._instance;
            this._lutCommond._apply();
            this._lutCommond.clear();
        }
        effectInit(postprocess) {
            super.effectInit(postprocess);
            this._lutBuilderMat.setShaderName("LUTBuilder");
            this._LUTShader = Laya.Shader3D.find("blitLUTShader");
            postprocess._enableColorGrad = true;
            postprocess._ColorGradEffect = this;
        }
        release(postprocess) {
            super.release(postprocess);
            postprocess._enableColorGrad = false;
            postprocess._ColorGradEffect = null;
        }
        render(context) {
            let cmd = context.command;
            let source = context.indirectTarget;
            {
                this._blitlutParams.setValue(1 / this._lutTex.width, 1 / this._lutTex.height, this._lutTex.height - 1, this.enableColorAdjust ? this._postExposure : 1);
                this._lutBuilderMat.removeDefine(ColorGradEffect.SHADERDEFINE_CUSTOMLUT);
                this._lutShaderData.setTexture(ColorGradEffect.SHADERVALUE_LUT, this._lutTex);
                this._lutShaderData.setVector(ColorGradEffect.SHADERVALUE_LUTPARAMS, this._blitlutParams);
            }
            cmd.blitScreenTriangle(source, context.destination, null, this._LUTShader, this._lutShaderData);
        }
    }

    class PostProcess {
        constructor() {
            this._compositeShader = Laya.Shader3D.find("PostProcessComposite");
            this._compositeShaderData = Laya.LayaGL.renderOBJCreate.createShaderData(null);
            this._effects = [];
            this._enable = true;
            this._enableColorGrad = false;
            this._context = null;
            this._context = new PostProcessRenderContext();
            this._context.compositeShaderData = this._compositeShaderData;
            this._context.command = new CommandBuffer();
            this._depthtextureFlag = 0;
        }
        static __init__() {
            PostProcess.SHADERDEFINE_BLOOM_LOW = Laya.Shader3D.getDefineByName("BLOOM_LOW");
            PostProcess.SHADERDEFINE_BLOOM = Laya.Shader3D.getDefineByName("BLOOM");
            PostProcess.SHADERDEFINE_FINALPASS = Laya.Shader3D.getDefineByName("FINALPASS");
            PostProcess.SHADERVALUE_MAINTEX = Laya.Shader3D.propertyNameToID("u_MainTex");
            PostProcess.SHADERVALUE_BLOOMTEX = Laya.Shader3D.propertyNameToID("u_BloomTex");
            PostProcess.SHADERVALUE_AUTOEXPOSURETEX = Laya.Shader3D.propertyNameToID("u_AutoExposureTex");
            PostProcess.SHADERVALUE_BLOOM_DIRTTEX = Laya.Shader3D.propertyNameToID("u_Bloom_DirtTex");
            PostProcess.SHADERVALUE_BLOOMTEX_TEXELSIZE = Laya.Shader3D.propertyNameToID("u_BloomTex_TexelSize");
            PostProcess.SHADERVALUE_BLOOM_DIRTTILEOFFSET = Laya.Shader3D.propertyNameToID("u_Bloom_DirtTileOffset");
            PostProcess.SHADERVALUE_BLOOM_SETTINGS = Laya.Shader3D.propertyNameToID("u_Bloom_Settings");
            PostProcess.SHADERVALUE_BLOOM_COLOR = Laya.Shader3D.propertyNameToID("u_Bloom_Color");
        }
        recaculateCameraFlag() {
            this._depthtextureFlag = exports.DepthTextureMode.None;
            let n = this.effects.length;
            for (let i = 0; i < n; i++) {
                this._depthtextureFlag |= this.effects[i].getCameraDepthTextureModeFlag();
            }
        }
        get enable() {
            return this._enable;
        }
        set enable(value) {
            this._enable = value;
        }
        set commandContext(oriContext) {
            this._context.command._context = oriContext;
        }
        set effects(value) {
            this.clearEffect();
            for (var i = 0, n = value.length; i < n; i++) {
                if (value[i])
                    this.addEffect(value[i]);
            }
        }
        get effects() {
            return this._effects;
        }
        get cameraDepthTextureMode() {
            return this._depthtextureFlag;
        }
        _init(camera) {
            this._context.camera = camera;
            this._context.command._camera = camera;
        }
        _render(camera) {
            this._init(camera);
            var camera = this._context.camera;
            var viewport = camera.viewport;
            var cameraTarget = camera._internalRenderTexture;
            var screenTexture = Laya.RenderTexture.createFromPool(cameraTarget.width, cameraTarget.height, camera._getRenderTextureFormat(), Laya.RenderTargetFormat.None, false, 1, false, true);
            var Indirect = [Laya.RenderTexture.createFromPool(cameraTarget.width, cameraTarget.height, camera._getRenderTextureFormat(), Laya.RenderTargetFormat.None, false, 1, false, true), Laya.RenderTexture.createFromPool(cameraTarget.width, cameraTarget.height, camera._getRenderTextureFormat(), Laya.RenderTargetFormat.None, false, 1, false, true)];
            this._context.command.clear();
            this._context.source = screenTexture;
            this._context.indirectTarget = screenTexture;
            this._context.destination = this._effects.length == 2 ? Indirect[0] : cameraTarget;
            this._context.compositeShaderData.clearDefine();
            this._context.command.blitScreenTriangle(cameraTarget, screenTexture);
            this._context.compositeShaderData.setTexture(PostProcess.SHADERVALUE_AUTOEXPOSURETEX, Laya.Texture2D.whiteTexture);
            if (this._enableColorGrad) {
                this._ColorGradEffect._buildLUT();
            }
            for (var i = 0, n = this._effects.length; i < n; i++) {
                if (this._effects[i].active) {
                    this._effects[i].render(this._context);
                    if (i == n - 2) {
                        this._context.indirectTarget = this._context.destination;
                        this._context.destination = cameraTarget;
                    }
                    else {
                        this._context.indirectTarget = this._context.destination;
                        this._context.destination = Indirect[(i + 1) % 2];
                    }
                }
                else if (i == n - 1) {
                    this._context.command.blitScreenTriangle(this._context.indirectTarget, cameraTarget);
                }
            }
            this._compositeShaderData.addDefine(PostProcess.SHADERDEFINE_FINALPASS);
            var offScreenTex = camera._offScreenRenderTexture;
            var dest = offScreenTex ? offScreenTex : null;
            this._context.destination = dest;
            var canvasWidth = camera._getCanvasWidth(), canvasHeight = camera._getCanvasHeight();
            if (dest) {
                camera._screenOffsetScale.setValue(viewport.x / canvasWidth, (canvasHeight - viewport.y - viewport.height) / canvasHeight, viewport.width / canvasWidth, viewport.height / canvasHeight);
                this._context.command.blitScreenTriangle(cameraTarget, dest, camera._screenOffsetScale, null, this._compositeShaderData, 0);
            }
            Laya.RenderTexture.recoverToPool(screenTexture);
            Laya.RenderTexture.recoverToPool(Indirect[0]);
            Laya.RenderTexture.recoverToPool(Indirect[1]);
            var tempRenderTextures = this._context.deferredReleaseTextures;
            for (i = 0, n = tempRenderTextures.length; i < n; i++)
                Laya.RenderTexture.recoverToPool(tempRenderTextures[i]);
            tempRenderTextures.length = 0;
        }
        addEffect(effect) {
            if (effect.singleton && this.getEffect(effect.constructor)) {
                console.error("无法增加已经存在的Effect");
                return;
            }
            if (!this._enableColorGrad || effect instanceof ColorGradEffect) {
                this._effects.push(effect);
            }
            else {
                this._effects.splice(this._effects.length - 1, 0, effect);
            }
            this.recaculateCameraFlag();
            effect.effectInit(this);
        }
        getEffect(classReg) {
            let size = this._effects.length;
            for (let i = 0; i < size; i++) {
                let element = this._effects[i];
                if (element instanceof classReg) {
                    return element;
                }
            }
            return null;
        }
        removeEffect(effect) {
            var index = this._effects.indexOf(effect);
            if (index !== -1) {
                this._effects.splice(index, 1);
                effect.release(this);
                this.recaculateCameraFlag();
            }
        }
        clearEffect() {
            let i = this.effects.length - 1;
            for (; i >= 0; i--) {
                this.removeEffect(this.effects[i]);
            }
        }
        _applyPostProcessCommandBuffers() {
            this._context.command._apply();
        }
    }

    var BloomVS = "#define SHADER_NAME BloomVS\r\nvarying vec2 v_Texcoord0;\r\nvec4 remapPositionZ(vec4 position)\r\n{\r\n    position.z = position.z * 2.0 - position.w;\r\n    return position;\r\n}\r\nvoid main() {\r\n\tgl_Position = vec4(a_PositionTexcoord.xy, 0.0, 1.0);\r\n\tv_Texcoord0 = a_PositionTexcoord.zw;\r\n\tgl_Position = remapPositionZ(gl_Position);\r\n}";

    var BloomDownsample13PS = "#define SHADER_NAME BloomDownSample13FS\r\n#include \"Colors.glsl\";\r\n#include \"Sampling.glsl\";\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\nvoid fragDownsample13() {\r\n\tmediump vec4 color = downsampleBox13Tap(u_MainTex, v_Texcoord0, u_MainTex_TexelSize.xy);\r\n\tgl_FragColor = color;\r\n}\r\n\r\nvoid main() {\r\n\tfragDownsample13();\r\n}";

    var BloomDownsample4PS = "#define SHADER_NAME BloomDownSample4FS\r\n\r\n#include \"Colors.glsl\";\r\n#include \"Sampling.glsl\";\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\nvoid fragDownsample4() {\r\n\tmediump vec4 color = downsampleBox4Tap(u_MainTex, v_Texcoord0, u_MainTex_TexelSize.xy);\r\n\tgl_FragColor = color;\r\n}\r\n\r\nvoid main() {\r\n\tfragDownsample4();\r\n}";

    var BloomPrefilter13PS = "#define SHADER_NAME BloomPreFilter13FS\r\n#include \"Colors.glsl\";\r\n#include \"Sampling.glsl\";\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\nmediump vec4 prefilter(mediump vec4 color, vec2 uv) {\r\n\tmediump float autoExposure = texture2D(u_AutoExposureTex, uv).r;\r\n\tcolor *= autoExposure;\r\n\tcolor = min(vec4(u_Params.x), color); // clamp to max\r\n\tcolor = quadraticThreshold(color, u_Threshold.x, u_Threshold.yzw);\r\n\treturn color;\r\n}\r\n\r\nvoid fragPrefilter13() {\r\n\tmediump vec4 color = downsampleBox13Tap(u_MainTex, v_Texcoord0, u_MainTex_TexelSize.xy);\r\n\tgl_FragColor = prefilter(safeHDR(color), v_Texcoord0);\r\n}\r\n\r\nvoid main() {\r\n\tfragPrefilter13();\r\n}";

    var BloomPrefilter4PS = "#define SHADER_NAME BloomPreFilter4FS\r\n#include \"Colors.glsl\";\r\n#include \"Sampling.glsl\";\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\nmediump vec4 prefilter(mediump vec4 color, vec2 uv) {\r\n\tmediump float autoExposure = texture2D(u_AutoExposureTex, uv).r;\r\n\tcolor *= autoExposure;\r\n\tcolor = min(vec4(u_Params.x), color); // clamp to max\r\n\tcolor = quadraticThreshold(color, u_Threshold.x, u_Threshold.yzw);\r\n\treturn color;\r\n}\r\n\r\nvoid fragPrefilter4() {\r\n\tmediump vec4 color = downsampleBox4Tap(u_MainTex, v_Texcoord0, u_MainTex_TexelSize.xy);\r\n\tgl_FragColor = prefilter(safeHDR(color), v_Texcoord0);\r\n}\r\n\r\nvoid main() {\r\n\tfragPrefilter4();\r\n}";

    var BloomUpsampleBoxPS = "#define SHADER_NAME BloomUpSampleBoxFS\r\n\r\n#include \"Colors.glsl\";\r\n#include \"Sampling.glsl\";\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\nmediump vec4 combine(mediump vec4 bloom, vec2 uv) {\r\n\tmediump vec4 color = texture2D(u_BloomTex, uv);\r\n\treturn bloom + color;\r\n}\r\n\r\nvoid fragUpsampleBox() {\r\n\tmediump vec4 bloom = upsampleBox(u_MainTex, v_Texcoord0, u_MainTex_TexelSize.xy, vec4(u_SampleScale));\r\n\tgl_FragColor = combine(bloom, v_Texcoord0);\r\n}\r\n\r\nvoid main() {\r\n\tfragUpsampleBox();\r\n}";

    var BloomUpsampleTentPS = "#define SHADER_NAME BloomUpSampleTentFS\r\n\r\n#include \"Colors.glsl\";\r\n#include \"Sampling.glsl\";\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\nmediump vec4 combine(mediump vec4 bloom, vec2 uv) {\r\n\tmediump vec4 color = texture2D(u_BloomTex, uv);\r\n\treturn bloom + color;\r\n}\r\n\r\nvoid fragUpsampleTent() {\r\n\tmediump vec4 bloom = upsampleTent(u_MainTex, v_Texcoord0, u_MainTex_TexelSize.xy, vec4(u_SampleScale));\r\n\tgl_FragColor = combine(bloom, v_Texcoord0);\r\n}\r\n\r\nvoid main() {\r\n\tfragUpsampleTent();\r\n}";

    var CompositePS = "#define SHADER_NAME CompositeFS\r\n\r\n#include \"Colors.glsl\";\r\n#include \"Sampling.glsl\";\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\nvoid main() {\r\n\tmediump float autoExposure = texture2D(u_AutoExposureTex, v_Texcoord0).r;\r\n\tmediump vec4 color=vec4(0.0);\r\n\tcolor = texture2D(u_MainTex, v_Texcoord0);\r\n\t\r\n\t//color = sRGBToLinear(color);\r\n\tcolor.rgb *= autoExposure;\r\n\t\r\n\t#if defined(BLOOM)||defined(BLOOM_LOW)\r\n\t\t#ifdef BLOOM\r\n\t\t\tmediump vec4 bloom = upsampleTent(u_BloomTex, v_Texcoord0, u_BloomTex_TexelSize.xy, vec4(u_Bloom_Settings.x));\r\n\t\t#else\r\n\t\t\tmediump vec4 bloom = upsampleBox(u_BloomTex, v_Texcoord0, u_BloomTex_TexelSize.xy, vec4(u_Bloom_Settings.x));\r\n\t\t#endif\r\n\r\n\t\t// UVs should be Distort(uv * u_Bloom_DirtTileOffset.xy + u_Bloom_DirtTileOffset.zw)\r\n\t\t// but considering we use a cover-style scale on the dirt texture the difference\r\n\t\t// isn't massive so we chose to save a few ALUs here instead in case lens distortion\r\n\t\t// is active\r\n\t\tmediump vec4 dirt =vec4(texture2D(u_Bloom_DirtTex, v_Texcoord0 * u_Bloom_DirtTileOffset.xy + u_Bloom_DirtTileOffset.zw).rgb, 0.0);\r\n\r\n\t\t// Additive bloom (artist friendly)\r\n\t\tbloom *= u_Bloom_Settings.y;\r\n\t\tdirt *= u_Bloom_Settings.z;\r\n\t\tmediump vec4 bloomColor=vec4(u_Bloom_Color, 1.0);\r\n\t\tcolor += bloom * bloomColor;\r\n\t\tcolor += dirt * bloom;\r\n\t#endif\r\n\t\r\n\tmediump vec4 finalColor = color;\r\n\t//finalColor = linearToSRGB(finalColor);\r\n\t//finalColor.rgb = Dither(finalColor.rgb, v_Texcoord0);//TODO:抖动\r\n\tgl_FragColor = finalColor;\r\n}";

    var CompositeVS = "#define SHADER_NAME CompositeVS\r\nvarying vec2 v_Texcoord0;\r\nvec4 remapPositionZ(vec4 position)\r\n{\r\n    position.z = position.z * 2.0 - position.w;\r\n    return position;\r\n}\r\nvoid main() {\r\n\tgl_Position = vec4(a_PositionTexcoord.xy, 0.0, 1.0);\r\n\tv_Texcoord0 = a_PositionTexcoord.zw;\r\n\tgl_Position = remapPositionZ(gl_Position);\r\n}";

    var SamplingGLSL = "// Better, temporally stable box filtering\r\n// [Jimenez14] http://goo.gl/eomGso\r\n// . . . . . . .\r\n// . A . B . C .\r\n// . . D . E . .\r\n// . F . G . H .\r\n// . . I . J . .\r\n// . K . L . M .\r\n// . . . . . . .\r\nmediump vec4 downsampleBox13Tap(sampler2D tex, vec2 uv, vec2 texelSize)\r\n{\r\n    mediump vec4 A = texture2D(tex, uv + texelSize * vec2(-1.0, -1.0));\r\n    mediump vec4 B = texture2D(tex, uv + texelSize * vec2( 0.0, -1.0));\r\n    mediump vec4 C = texture2D(tex, uv + texelSize * vec2( 1.0, -1.0));\r\n    mediump vec4 D = texture2D(tex, uv + texelSize * vec2(-0.5, -0.5));\r\n    mediump vec4 E = texture2D(tex, uv + texelSize * vec2( 0.5, -0.5));\r\n    mediump vec4 F = texture2D(tex, uv + texelSize * vec2(-1.0,  0.0));\r\n    mediump vec4 G = texture2D(tex, uv);\r\n    mediump vec4 H = texture2D(tex, uv + texelSize * vec2( 1.0,  0.0));\r\n    mediump vec4 I = texture2D(tex, uv + texelSize * vec2(-0.5,  0.5));\r\n    mediump vec4 J = texture2D(tex, uv + texelSize * vec2( 0.5,  0.5));\r\n    mediump vec4 K = texture2D(tex, uv + texelSize * vec2(-1.0,  1.0));\r\n    mediump vec4 L = texture2D(tex, uv + texelSize * vec2( 0.0,  1.0));\r\n    mediump vec4 M = texture2D(tex, uv + texelSize * vec2( 1.0,  1.0));\r\n\r\n\tmediump vec2 scale= vec2(0.5, 0.125);\r\n    mediump vec2 div = (1.0 / 4.0) * scale;\r\n\r\n    mediump vec4 o = (D + E + I + J) * div.x;\r\n    o += (A + B + G + F) * div.y;\r\n    o += (B + C + H + G) * div.y;\r\n    o += (F + G + L + K) * div.y;\r\n    o += (G + H + M + L) * div.y;\r\n\r\n    return o;\r\n}\r\n\r\n// Standard box filtering\r\nmediump vec4 downsampleBox4Tap(sampler2D tex, vec2 uv, vec2 texelSize)\r\n{\r\n    vec4 d = texelSize.xyxy * vec4(-1.0, -1.0, 1.0, 1.0);\r\n\r\n    mediump vec4 s =  texture2D(tex, uv + d.xy);\r\n    s += texture2D(tex, uv + d.zy);\r\n    s += texture2D(tex, uv + d.xw);\r\n    s += texture2D(tex, uv + d.zw);\r\n\r\n    return s * (1.0 / 4.0);\r\n}\r\n\r\n// 9-tap bilinear upsampler (tent filter)\r\n// . . . . . . .\r\n// . 1 . 2 . 1 .\r\n// . . . . . . .\r\n// . 2 . 4 . 2 .\r\n// . . . . . . .\r\n// . 1 . 2 . 1 .\r\n// . . . . . . .\r\nmediump vec4 upsampleTent(sampler2D tex, vec2 uv, vec2 texelSize, vec4 sampleScale)\r\n{\r\n    vec4 d = texelSize.xyxy * vec4(1.0, 1.0, -1.0, 0.0) * sampleScale;\r\n\r\n    mediump vec4 s =  texture2D(tex, uv - d.xy);\r\n    s += texture2D(tex, uv - d.wy) * 2.0;\r\n    s += texture2D(tex, uv - d.zy);\r\n\r\n    s += texture2D(tex, uv + d.zw) * 2.0;\r\n    s += texture2D(tex, uv) * 4.0;\r\n    s += texture2D(tex,\tuv + d.xw) * 2.0;\r\n\r\n    s += texture2D(tex, uv + d.zy);\r\n    s += texture2D(tex, uv + d.wy) * 2.0;\r\n    s += texture2D(tex, uv + d.xy);\r\n\r\n    return s * (1.0 / 16.0);\r\n}\r\n\r\n// Standard box filtering\r\nmediump vec4 upsampleBox(sampler2D tex, vec2 uv, vec2 texelSize, vec4 sampleScale)\r\n{\r\n    vec4 d = texelSize.xyxy * vec4(-1.0, -1.0, 1.0, 1.0) * 0.5 * sampleScale;\r\n\r\n    mediump vec4 s =  texture2D(tex, uv + d.xy);\r\n    s += texture2D(tex, uv + d.zy);\r\n    s += texture2D(tex, uv + d.xw);\r\n    s += texture2D(tex, uv + d.zw);\r\n\r\n    return s * (1.0 / 4.0);\r\n}";

    var StdLibGLSL = "#define HALF_MAX       65504.0 // (2 - 2^-10) * 2^15\r\n\r\n#define FLT_EPSILON    1.192092896e-07 // Smallest positive number, such that 1.0 + FLT_EPSILON != 1.0\r\n\r\nmediump vec4 safeHDR(mediump vec4 c)\r\n{\r\n    return min(c, HALF_MAX);\r\n}\r\n\r\nfloat max3(float a, float b, float c)\r\n{\r\n    return max(max(a, b), c);\r\n}\r\n\r\nvec3 positivePow(vec3 base, vec3 power)\r\n{\r\n    return pow(max(abs(base), vec3(FLT_EPSILON, FLT_EPSILON, FLT_EPSILON)), power);\r\n}";

    var ColorsGLSL = "#include \"StdLib.glsl\";\r\n\r\n#define EPSILON 1.0e-4\r\n\r\n// Quadratic color thresholding\r\n// curve = (threshold - knee, knee * 2, 0.25 / knee)\r\nmediump vec4 quadraticThreshold(mediump vec4 color, mediump float threshold, mediump vec3 curve) {\r\n\t// Pixel brightness\r\n\tmediump float br = max3(color.r, color.g, color.b);\r\n\r\n\t// Under-threshold part: quadratic curve\r\n\tmediump float rq = clamp(br - curve.x, 0.0, curve.y);\r\n\trq = curve.z * rq * rq;\r\n\r\n\t// Combine and apply the brightness response curve.\r\n\tcolor *= max(rq, br - threshold) / max(br, EPSILON);\r\n\r\n\treturn color;\r\n}\r\n\r\n\r\n\r\n//\r\n// sRGB transfer functions\r\n// Fast path ref: http://chilliant.blogspot.com.au/2012/08/srgb-approximations-for-hlsl.html?m=1\r\n//\r\n// mediump vec3 sRGBToLinear(mediump vec3 c) {\r\n// \t#ifdef USE_VERY_FAST_SRGB\r\n// \t\treturn c * c;\r\n// \t#elif defined(USE_FAST_SRGB)\r\n// \t\treturn c * (c * (c * 0.305306011 + 0.682171111) + 0.012522878);\r\n// \t#else\r\n// \t\tmediump vec3 linearRGBLo = c / 12.92;\r\n// \t\tmediump vec3 power=vec3(2.4, 2.4, 2.4);\r\n// \t\tmediump vec3 linearRGBHi = positivePow((c + 0.055) / 1.055, power);\r\n// \t\tmediump vec3 linearRGB =vec3((c.r<=0.04045) ? linearRGBLo.r : linearRGBHi.r,(c.g<=0.04045) ? linearRGBLo.g : linearRGBHi.g,(c.b<=0.04045) ? linearRGBLo.b : linearRGBHi.b);\r\n// \t\treturn linearRGB;\r\n// \t#endif\r\n// }\r\n\r\n// mediump vec4 sRGBToLinear(mediump vec4 c){\r\n//     return vec4(sRGBToLinear(c.rgb), c.a);\r\n// }\r\n\r\n\r\n\r\n// mediump vec3 linearToSRGB(mediump vec3 c) {\r\n// \t#ifdef USE_VERY_FAST_SRGB\r\n// \t\treturn sqrt(c);\r\n// \t#elif defined(USE_FAST_SRGB)\r\n// \t\treturn max(1.055 * PositivePow(c, 0.416666667) - 0.055, 0.0);\r\n// \t#else\r\n// \t\tmediump vec3 sRGBLo = c * 12.92;\r\n// \t\tmediump vec3 power=vec3(1.0 / 2.4, 1.0 / 2.4, 1.0 / 2.4);\r\n// \t\tmediump vec3 sRGBHi = (positivePow(c, power) * 1.055) - 0.055;\r\n// \t\tmediump vec3 sRGB =vec3((c.r<=0.0031308) ? sRGBLo.r : sRGBHi.r,(c.g<=0.0031308) ? sRGBLo.g : sRGBHi.g,(c.b<=0.0031308) ? sRGBLo.b : sRGBHi.b);\r\n// \t\treturn sRGB;\r\n// \t#endif\r\n// }\r\n\r\n// mediump vec4 linearToSRGB(mediump vec4 c){\r\n//     return vec4(linearToSRGB(c.rgb), c.a);\r\n// }";

    class BloomEffect extends PostProcessEffect {
        constructor() {
            super();
            this._shader = null;
            this._shaderData = Laya.LayaGL.renderOBJCreate.createShaderData(null);
            this._linearColor = new Laya.Color();
            this._bloomTextureTexelSize = new Laya.Vector4();
            this._shaderThreshold = new Laya.Vector4();
            this._shaderParams = new Laya.Vector4();
            this._pyramid = null;
            this._intensity = 0.0;
            this._threshold = 1.0;
            this._softKnee = 0.5;
            this._diffusion = 7.0;
            this._anamorphicRatio = 0.0;
            this._dirtIntensity = 0.0;
            this._shaderSetting = new Laya.Vector4();
            this._dirtTileOffset = new Laya.Vector4();
            this._fastMode = false;
            this._dirtTexture = null;
            this.singleton = true;
            this.active = true;
            this.intensity = 1.0;
            this.threshold = 1.0;
            this.softKnee = 0.5;
            this.clamp = 65472;
            this.diffusion = 7;
            this.anamorphicRatio = 0;
            this.color = new Laya.Color(1.0, 1.0, 1.0, 1.0);
        }
        static init() {
            Laya.Shader3D.addInclude("StdLib.glsl", StdLibGLSL);
            Laya.Shader3D.addInclude("Colors.glsl", ColorsGLSL);
            Laya.Shader3D.addInclude("Sampling.glsl", SamplingGLSL);
            var attributeMap = {
                'a_PositionTexcoord': [Laya.VertexMesh.MESH_POSITION0, Laya.ShaderDataType.Vector4]
            };
            var uniformMap = {
                "u_MainTex": Laya.ShaderDataType.Texture2D,
                "u_MainTex_TexelSize": Laya.ShaderDataType.Vector4,
                "u_AutoExposureTex": Laya.ShaderDataType.Texture2D,
                "u_Threshold": Laya.ShaderDataType.Vector4,
                "u_Params": Laya.ShaderDataType.Vector4,
                "u_BloomTex": Laya.ShaderDataType.Texture2D,
                "u_SampleScale": Laya.ShaderDataType.Float,
            };
            var shader = Laya.Shader3D.add("PostProcessBloom");
            var subShader = new Laya.SubShader(attributeMap, uniformMap);
            shader.addSubShader(subShader);
            var shaderPass = subShader.addShaderPass(BloomVS, BloomPrefilter13PS);
            var renderState = shaderPass.renderState;
            renderState = shaderPass.renderState;
            renderState.depthTest = Laya.RenderState.DEPTHTEST_ALWAYS;
            renderState.depthWrite = false;
            renderState.cull = Laya.RenderState.CULL_NONE;
            renderState.blend = Laya.RenderState.BLEND_DISABLE;
            subShader = new Laya.SubShader(attributeMap, uniformMap);
            shader.addSubShader(subShader);
            shaderPass = subShader.addShaderPass(BloomVS, BloomPrefilter4PS);
            renderState = shaderPass.renderState;
            renderState.depthTest = Laya.RenderState.DEPTHTEST_ALWAYS;
            renderState.depthWrite = false;
            renderState.cull = Laya.RenderState.CULL_NONE;
            renderState.blend = Laya.RenderState.BLEND_DISABLE;
            subShader = new Laya.SubShader(attributeMap, uniformMap);
            shader.addSubShader(subShader);
            shaderPass = subShader.addShaderPass(BloomVS, BloomDownsample13PS);
            renderState = shaderPass.renderState;
            renderState.depthTest = Laya.RenderState.DEPTHTEST_ALWAYS;
            renderState.depthWrite = false;
            renderState.cull = Laya.RenderState.CULL_NONE;
            renderState.blend = Laya.RenderState.BLEND_DISABLE;
            subShader = new Laya.SubShader(attributeMap, uniformMap);
            shader.addSubShader(subShader);
            shaderPass = subShader.addShaderPass(BloomVS, BloomDownsample4PS);
            renderState = shaderPass.renderState;
            renderState.depthTest = Laya.RenderState.DEPTHTEST_ALWAYS;
            renderState.depthWrite = false;
            renderState.cull = Laya.RenderState.CULL_NONE;
            renderState.blend = Laya.RenderState.BLEND_DISABLE;
            subShader = new Laya.SubShader(attributeMap, uniformMap);
            shader.addSubShader(subShader);
            shaderPass = subShader.addShaderPass(BloomVS, BloomUpsampleTentPS);
            renderState = shaderPass.renderState;
            renderState.depthTest = Laya.RenderState.DEPTHTEST_ALWAYS;
            renderState.depthWrite = false;
            renderState.cull = Laya.RenderState.CULL_NONE;
            renderState.blend = Laya.RenderState.BLEND_DISABLE;
            subShader = new Laya.SubShader(attributeMap, uniformMap);
            shader.addSubShader(subShader);
            shaderPass = subShader.addShaderPass(BloomVS, BloomUpsampleBoxPS);
            renderState = shaderPass.renderState;
            renderState.depthTest = Laya.RenderState.DEPTHTEST_ALWAYS;
            renderState.depthWrite = false;
            renderState.cull = Laya.RenderState.CULL_NONE;
            renderState.blend = Laya.RenderState.BLEND_DISABLE;
            BloomEffect.CompositeInit();
            BloomEffect.__initDefine__();
        }
        static CompositeInit() {
            let attributeMap = {
                'a_PositionTexcoord': [Laya.VertexMesh.MESH_POSITION0, Laya.ShaderDataType.Vector4],
            };
            let uniformMap = {
                'u_MainTex': Laya.ShaderDataType.Texture2D,
                'u_BloomTex': Laya.ShaderDataType.Texture2D,
                'u_AutoExposureTex': Laya.ShaderDataType.Texture2D,
                'u_Bloom_DirtTex': Laya.ShaderDataType.Texture2D,
                'u_BloomTex_TexelSize': Laya.ShaderDataType.Vector4,
                'u_Bloom_DirtTileOffset': Laya.ShaderDataType.Vector4,
                'u_Bloom_Settings': Laya.ShaderDataType.Vector3,
                'u_Bloom_Color': Laya.ShaderDataType.Vector3,
            };
            let shader = Laya.Shader3D.add("PostProcessComposite");
            let subShader = new Laya.SubShader(attributeMap, uniformMap);
            shader.addSubShader(subShader);
            let shaderPass = subShader.addShaderPass(CompositeVS, CompositePS);
            let renderState = shaderPass.renderState;
            renderState.depthTest = Laya.RenderState.DEPTHTEST_ALWAYS;
            renderState.depthWrite = false;
            renderState.cull = Laya.RenderState.CULL_NONE;
            renderState.blend = Laya.RenderState.BLEND_DISABLE;
        }
        static __initDefine__() {
            BloomEffect.SHADERVALUE_MAINTEX = Laya.Shader3D.propertyNameToID("u_MainTex");
            BloomEffect.SHADERVALUE_AUTOEXPOSURETEX = Laya.Shader3D.propertyNameToID("u_AutoExposureTex");
            BloomEffect.SHADERVALUE_SAMPLESCALE = Laya.Shader3D.propertyNameToID("u_SampleScale");
            BloomEffect.SHADERVALUE_THRESHOLD = Laya.Shader3D.propertyNameToID("u_Threshold");
            BloomEffect.SHADERVALUE_PARAMS = Laya.Shader3D.propertyNameToID("u_Params");
            BloomEffect.SHADERVALUE_BLOOMTEX = Laya.Shader3D.propertyNameToID("u_BloomTex");
        }
        get clamp() {
            return this._clamp;
        }
        set clamp(value) {
            this._clamp = value;
        }
        get color() {
            return this._color;
        }
        set color(value) {
            this._color = value;
        }
        get fastMode() {
            return this._fastMode;
        }
        set fastMode(value) {
            this._fastMode = value;
        }
        get dirtTexture() {
            return this._dirtTexture;
        }
        set dirtTexture(value) {
            this._dirtTexture && this._dirtTexture._removeReference(1);
            this._dirtTexture = value;
            this._dirtTexture && this._dirtTexture._addReference(1);
        }
        get intensity() {
            return this._intensity;
        }
        set intensity(value) {
            this._intensity = Math.max(value, 0.0);
        }
        get threshold() {
            return this._threshold;
        }
        set threshold(value) {
            this._threshold = Math.max(value, 0.0);
        }
        get softKnee() {
            return this._softKnee;
        }
        set softKnee(value) {
            this._softKnee = Math.min(Math.max(value, 0.0), 1.0);
        }
        get diffusion() {
            return this._diffusion;
        }
        set diffusion(value) {
            this._diffusion = Math.min(Math.max(value, 1), 10);
        }
        get anamorphicRatio() {
            return this._anamorphicRatio;
        }
        set anamorphicRatio(value) {
            this._anamorphicRatio = Math.min(Math.max(value, -1.0), 1.0);
        }
        get dirtIntensity() {
            return this._dirtIntensity;
        }
        set dirtIntensity(value) {
            this._dirtIntensity = Math.max(value, 0.0);
        }
        effectInit(postprocess) {
            super.effectInit(postprocess);
            this._shader = Laya.Shader3D.find("PostProcessBloom");
            this._pyramid = new Array(BloomEffect.MAXPYRAMIDSIZE * 2);
        }
        getCameraDepthTextureModeFlag() {
            return 0;
        }
        release(postprocess) {
            super.release(postprocess);
            this._shader = null;
            this._pyramid = [];
        }
        render(context) {
            var cmd = context.command;
            var viewport = context.camera.viewport;
            this._shaderData.setTexture(BloomEffect.SHADERVALUE_AUTOEXPOSURETEX, Laya.Texture2D.whiteTexture);
            var ratio = this._anamorphicRatio;
            var rw = ratio < 0 ? -ratio : 0;
            var rh = ratio > 0 ? ratio : 0;
            var tw = Math.floor(viewport.width / (2 - rw));
            var th = Math.floor(viewport.height / (2 - rh));
            var s = Math.max(tw, th);
            var logs;
            logs = Math.log2(s) + this._diffusion - 10;
            var logsInt = Math.floor(logs);
            var iterations = Math.min(Math.max(logsInt, 1), BloomEffect.MAXPYRAMIDSIZE);
            var sampleScale = 0.5 + logs - logsInt;
            this._shaderData.setNumber(BloomEffect.SHADERVALUE_SAMPLESCALE, sampleScale);
            var lthresh = Laya.Color.gammaToLinearSpace(this.threshold);
            var knee = lthresh * this._softKnee + 1e-5;
            this._shaderThreshold.setValue(lthresh, lthresh - knee, knee * 2, 0.25 / knee);
            this._shaderData.setVector(BloomEffect.SHADERVALUE_THRESHOLD, this._shaderThreshold);
            var lclamp = Laya.Color.gammaToLinearSpace(this.clamp);
            this._shaderParams.setValue(lclamp, 0, 0, 0);
            this._shaderData.setVector(BloomEffect.SHADERVALUE_PARAMS, this._shaderParams);
            var qualityOffset = this.fastMode ? 1 : 0;
            var lastDownTexture = context.indirectTarget;
            for (var i = 0; i < iterations; i++) {
                var downIndex = i * 2;
                var upIndex = downIndex + 1;
                var subShader = i == 0 ? BloomEffect.SUBSHADER_PREFILTER13 + qualityOffset : BloomEffect.SUBSHADER_DOWNSAMPLE13 + qualityOffset;
                var mipDownTexture = Laya.RenderTexture.createFromPool(tw, th, Laya.RenderTargetFormat.R8G8B8, Laya.RenderTargetFormat.None, false, 1);
                mipDownTexture.filterMode = Laya.FilterMode.Bilinear;
                this._pyramid[downIndex] = mipDownTexture;
                if (i !== iterations - 1) {
                    var mipUpTexture = Laya.RenderTexture.createFromPool(tw, th, Laya.RenderTargetFormat.R8G8B8, Laya.RenderTargetFormat.None, false, 1);
                    mipUpTexture.filterMode = Laya.FilterMode.Bilinear;
                    this._pyramid[upIndex] = mipUpTexture;
                }
                cmd.blitScreenTriangle(lastDownTexture, mipDownTexture, null, this._shader, this._shaderData, subShader);
                lastDownTexture = mipDownTexture;
                tw = Math.max(Math.floor(tw / 2), 1);
                th = Math.max(Math.floor(th / 2), 1);
            }
            var lastUpTexture = this._pyramid[(iterations - 1) * 2];
            for (i = iterations - 2; i >= 0; i--) {
                downIndex = i * 2;
                upIndex = downIndex + 1;
                mipDownTexture = this._pyramid[downIndex];
                mipUpTexture = this._pyramid[upIndex];
                cmd.setShaderDataTexture(this._shaderData, BloomEffect.SHADERVALUE_BLOOMTEX, mipDownTexture);
                cmd.blitScreenTriangle(lastUpTexture, mipUpTexture, null, this._shader, this._shaderData, BloomEffect.SUBSHADER_UPSAMPLETENT + qualityOffset);
                lastUpTexture = mipUpTexture;
            }
            var linearColor = this._linearColor;
            this.color.toLinear(linearColor);
            var intensity = Math.pow(2, this._intensity / 10.0) - 1.0;
            var shaderSettings = this._shaderSetting;
            this._shaderSetting.setValue(sampleScale, intensity, this._dirtIntensity, iterations);
            var usedirtTexture = this._dirtTexture ? this._dirtTexture : Laya.Texture2D.blackTexture;
            var dirtRatio = usedirtTexture.width / usedirtTexture.height;
            var screenRatio = viewport.width / viewport.height;
            var dirtTileOffset = this._dirtTileOffset;
            if (dirtRatio > screenRatio)
                dirtTileOffset.setValue(screenRatio / dirtRatio, 1.0, (1.0 - dirtTileOffset.x) * 0.5, 0.0);
            else if (dirtRatio < screenRatio)
                dirtTileOffset.setValue(1.0, dirtRatio / screenRatio, 0.0, (1.0 - dirtTileOffset.y) * 0.5);
            var compositeShaderData = context.compositeShaderData;
            if (this.fastMode)
                compositeShaderData.addDefine(PostProcess.SHADERDEFINE_BLOOM_LOW);
            else
                compositeShaderData.addDefine(PostProcess.SHADERDEFINE_BLOOM);
            this._bloomTextureTexelSize.setValue(1.0 / lastUpTexture.width, 1.0 / lastUpTexture.height, lastUpTexture.width, lastUpTexture.height);
            compositeShaderData.setVector(PostProcess.SHADERVALUE_BLOOM_DIRTTILEOFFSET, dirtTileOffset);
            compositeShaderData.setVector(PostProcess.SHADERVALUE_BLOOM_SETTINGS, shaderSettings);
            compositeShaderData.setVector(PostProcess.SHADERVALUE_BLOOM_COLOR, new Laya.Vector4(linearColor.r, linearColor.g, linearColor.b, linearColor.a));
            compositeShaderData.setTexture(PostProcess.SHADERVALUE_BLOOM_DIRTTEX, usedirtTexture);
            compositeShaderData.setTexture(PostProcess.SHADERVALUE_BLOOMTEX, lastUpTexture);
            compositeShaderData.setVector(PostProcess.SHADERVALUE_BLOOMTEX_TEXELSIZE, this._bloomTextureTexelSize);
            let _compositeShader = Laya.Shader3D.find("PostProcessComposite");
            cmd.blitScreenTriangle(context.indirectTarget, context.destination, context.camera._screenOffsetScale, _compositeShader, compositeShaderData, 0);
            for (i = 0; i < iterations; i++) {
                downIndex = i * 2;
                upIndex = downIndex + 1;
                Laya.RenderTexture.recoverToPool(this._pyramid[downIndex]);
                (i !== 0 && i !== iterations - 1) && (Laya.RenderTexture.recoverToPool(this._pyramid[upIndex]));
            }
            context.deferredReleaseTextures.push(lastUpTexture);
        }
    }
    BloomEffect.SUBSHADER_PREFILTER13 = 0;
    BloomEffect.SUBSHADER_PREFILTER4 = 1;
    BloomEffect.SUBSHADER_DOWNSAMPLE13 = 2;
    BloomEffect.SUBSHADER_DOWNSAMPLE4 = 3;
    BloomEffect.SUBSHADER_UPSAMPLETENT = 4;
    BloomEffect.SUBSHADER_UPSAMPLEBOX = 5;
    BloomEffect.MAXPYRAMIDSIZE = 16;

    var FullScreenVert = "#define SHADER_NAME SCREENVS\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\nvec4 remapPositionZ(vec4 position)\r\n{\r\n    position.z = position.z * 2.0 - position.w;\r\n    return position;\r\n}\r\n\r\nvoid main() {\t\r\n\tgl_Position = vec4(u_OffsetScale.x*2.0-1.0+(a_PositionTexcoord.x+1.0)*u_OffsetScale.z,(1.0-((u_OffsetScale.y*2.0-1.0+(-a_PositionTexcoord.y+1.0)*u_OffsetScale.w)+1.0)/2.0)*2.0-1.0, 0.0, 1.0);\t\r\n\tv_Texcoord0 = a_PositionTexcoord.zw;\r\n\tgl_Position = remapPositionZ(gl_Position);\r\n}\r\n";

    var CoCFS = "#define SHADER_NAME COCFS\r\n\r\n#ifdef CAMERA_NORMALDEPTH\r\n    uniform sampler2D u_CameraDepthNormalTexture;\r\n#else\r\n    uniform sampler2D u_CameraDepthTexture;\r\n#endif\r\n\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\n// Z buffer to linear 0..1 depth\r\nfloat Linear01Depth(float z,vec4 zbufferParams)\r\n{\r\n    return 1.0 / (zbufferParams.x * z + zbufferParams.y);\r\n}\r\n\r\n// Z buffer to linear depth\r\nfloat LinearEyeDepth(float z,vec4 zbufferParams)\r\n{\r\n    return 1.0 / (zbufferParams.z * z + zbufferParams.w);\r\n}\r\n\r\nfloat DecodeFloatRG(vec2 enc )\r\n{\r\n    vec2 kDecodeDot = vec2(1.0, 1.0/255.0);\r\n    return dot( enc, kDecodeDot );\r\n}\r\n\r\nvoid DecodeDepthNormal(vec4 enc, out float depth)\r\n{\r\n    depth = DecodeFloatRG (enc.zw);\r\n}\r\n\r\nvoid main() {\r\n\r\n    #ifdef CAMERA_NORMALDEPTH\r\n        vec4 depthNormal = texture2D(u_CameraDepthNormalTexture, v_Texcoord0);\r\n        float depth = 0.0;\r\n        DecodeDepthNormal(depthNormal, depth);\r\n        depth = ((1.0 / depth) - u_ZBufferParams.y) * (1.0 / u_ZBufferParams.x);\r\n    #else\r\n        float depth = texture2D(u_CameraDepthTexture, v_Texcoord0).x;\r\n    #endif\r\n\r\n    depth = LinearEyeDepth(depth, u_ZBufferParams);\r\n    float farStart = u_CoCParams.x;\r\n    float farEnd = u_CoCParams.y;\r\n\r\n    float coc = (depth - farStart) / (farEnd - farStart);\r\n    coc = clamp(coc, 0.0, 1.0);\r\n    gl_FragColor = vec4(coc, coc, coc, 1.0);\r\n}\r\n";

    var PrefilterFS = "#define SHADER_NAME PrefilterFS\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\nconst int kCount = 5;\r\nvec2 kTaps[5];\r\n\r\nvoid main () {\r\n\r\n    kTaps[0] = vec2( 0.0,  0.0);\r\n    kTaps[1] = vec2( 0.9, -0.4);\r\n    kTaps[2] = vec2(-0.9,  0.4);\r\n    kTaps[3] = vec2( 0.4,  0.9);\r\n    kTaps[4] = vec2(-0.4, -0.9);\r\n\r\n    vec3 colorAcc = vec3(0.0);\r\n    float farCoCAcc = 0.0;\r\n    for (int i = 0; i < kCount; i++) {\r\n        vec2 uv = u_MainTex_TexelSize.xy * kTaps[i] + v_Texcoord0;\r\n        vec3 tapColor = texture2D(u_MainTex, uv).rgb;\r\n        float coc = texture2D(u_FullCoCTex, uv).r;\r\n\r\n        colorAcc += tapColor * coc;\r\n        farCoCAcc += coc;\r\n    }\r\n    vec3 color = colorAcc * (1.0 / float(kCount));\r\n    float farCoC = farCoCAcc * (1.0 / float(kCount));\r\n\r\n    // float farCoC = texture2D(u_FullCoCTex, v_Texcoord0).x;\r\n    // vec3 color = texture2D(u_MainTex, v_Texcoord0).rgb;\r\n    // color *= farCoC;\r\n\r\n    gl_FragColor = vec4(color, farCoC);\r\n}";

    var BlurVFS = "#define SHADER_NAME BlurVFS\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\n// todo 3 & 5\r\nconst int kTapCount = 3;\r\nfloat kOffsets[3];\r\nfloat kCoeffs[3];\r\n\r\n\r\nvec4 Blur(vec2 dir, float premultiply) {\r\n\r\n    kOffsets[0] = -1.33333333;\r\n    kOffsets[1] = 0.00000000;\r\n    kOffsets[2] = 1.33333333;\r\n\r\n    kCoeffs[0] = 0.35294118;\r\n    kCoeffs[1] = 0.29411765;\r\n    kCoeffs[2] = 0.3529411;\r\n\r\n    vec2 uv = v_Texcoord0;\r\n    // ivec2 positionSS = ivec2(u_SourceSize.xy * uv);\r\n\r\n    vec4 halfColor = texture2D(u_MainTex, uv);\r\n    float samp0CoC = halfColor.a;\r\n\r\n    float maxRadius = u_CoCParams.z;\r\n    vec2 offset = u_SourceSize.zw * dir * samp0CoC * maxRadius;\r\n\r\n    vec4 acc = vec4(0.0);\r\n\r\n    for (int i = 0; i < kTapCount; i++) {\r\n        vec2 sampCoord = uv + kOffsets[i] * offset;\r\n        vec4 samp = texture2D(u_MainTex, sampCoord);\r\n        float sampCoC = samp.w;\r\n        vec3 sampColor = samp.xyz;\r\n\r\n        float weight = clamp(1.0 - (samp0CoC - sampCoC), 0.0, 1.0);\r\n        acc += vec4(sampColor, 1.0) * kCoeffs[i] * weight;\r\n    }\r\n\r\n    acc.xyz /= acc.w + 1e-4;\r\n    return vec4(acc.xyz, 1.0);\r\n}\r\n\r\nvoid main() {\r\n    gl_FragColor = Blur(vec2(0.0, 1.0), 0.0);\r\n    // gl_FragColor = texture2D(u_MainTex, v_Texcoord0);\r\n}\r\n";

    var BlurHFS = "#define SHADER_NAME BlurHFS\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\nconst int kTapCount = 3;\r\nfloat kOffsets[3];\r\nfloat kCoeffs[3];\r\n\r\nvec4 Blur(vec2 dir, float premultiply) {\r\n\r\n    kOffsets[0] = -1.33333333;\r\n    kOffsets[1] = 0.00000000;\r\n    kOffsets[2] = 1.33333333;\r\n\r\n    kCoeffs[0] = 0.35294118;\r\n    kCoeffs[1] = 0.29411765;\r\n    kCoeffs[2] = 0.3529411;\r\n\r\n    vec2 uv = v_Texcoord0;\r\n    // ivec2 positionSS = ivec2(u_SourceSize.xy * uv);\r\n\r\n    vec4 halfColor = texture2D(u_MainTex, uv);\r\n    float samp0CoC = halfColor.a;\r\n\r\n    float maxRadius = u_CoCParams.z;\r\n    vec2 offset = u_SourceSize.zw  * dir * samp0CoC * maxRadius;\r\n\r\n    vec4 acc = vec4(0.0);\r\n\r\n    for (int i = 0; i < kTapCount; i++) {\r\n        vec2 sampCoord = uv + kOffsets[i] * offset;\r\n        vec4 samp = texture2D(u_MainTex, sampCoord);\r\n        float sampCoC = samp.a;\r\n        vec3 sampColor = samp.rgb;\r\n\r\n        float weight = clamp(1.0 - (samp0CoC - sampCoC), 0.0, 1.0);\r\n        acc += vec4(sampColor, sampCoC) * kCoeffs[i] * weight;\r\n    }\r\n\r\n    acc.xyz /= acc.w + 1e-4;\r\n    return vec4(acc.xyz, samp0CoC);\r\n}\r\n\r\nvoid main() {\r\n    gl_FragColor = Blur(vec2(1.0, 0.0), 1.0);\r\n}";

    var CompositeFS = "#define SHADER_NAME CompositeFS\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\nvoid main() {\r\n\r\n    vec3 baseColor = texture2D(u_MainTex, v_Texcoord0).rgb;\r\n    vec4 samplevalue = texture2D(u_BlurCoCTex, v_Texcoord0);\r\n    vec3 farColor = samplevalue.rgb;\r\n    float coc = texture2D(u_FullCoCTex, v_Texcoord0).r;\r\n\r\n    vec3 dstColor = vec3(0.0);\r\n    float dstAlpha = 1.0;\r\n\r\n    float blend = sqrt(coc * 3.14 * 2.0);\r\n    dstColor = farColor * clamp(blend, 0.0, 1.0);\r\n    dstAlpha = clamp(1.0 - blend, 0.0, 1.0);\r\n\r\n\r\n    gl_FragColor = vec4(baseColor * dstAlpha + dstColor, 1.0);\r\n\r\n}";

    class GaussianDoF extends PostProcessEffect {
        constructor() {
            super();
            this._shader = Laya.Shader3D.find("GaussianDoF");
            this._shaderData = Laya.LayaGL.renderOBJCreate.createShaderData(null);
            this._shaderData.setVector3(GaussianDoF.COCPARAMS, new Laya.Vector3(10, 30, 1));
            this._zBufferParams = new Laya.Vector4();
            this._sourceSize = new Laya.Vector4();
            this._dowmSampleScale = new Laya.Vector4();
        }
        static init() {
            GaussianDoF.SOURCESIZE = Laya.Shader3D.propertyNameToID("u_SourceSize");
            GaussianDoF.ZBUFFERPARAMS = Laya.Shader3D.propertyNameToID("u_ZBufferParams");
            GaussianDoF.COCPARAMS = Laya.Shader3D.propertyNameToID("u_CoCParams");
            GaussianDoF.DEPTHTEXTURE = Laya.Shader3D.propertyNameToID("u_CameraDepthTexture");
            GaussianDoF.NORMALDEPTHTEXTURE = Laya.Shader3D.propertyNameToID("u_CameraDepthNormalTexture");
            GaussianDoF.FULLCOCTEXTURE = Laya.Shader3D.propertyNameToID("u_FullCoCTex");
            GaussianDoF.DOWNSAMPLESCALE = Laya.Shader3D.propertyNameToID("u_DownSampleScale");
            GaussianDoF.BLURCOCTEXTURE = Laya.Shader3D.propertyNameToID("u_BlurCoCTex");
            GaussianDoF.SHADERDEFINE_DEPTHNORMALTEXTURE = Laya.Shader3D.getDefineByName("CAMERA_NORMALDEPTH");
            let attributeMap = {
                'a_PositionTexcoord': [Laya.VertexMesh.MESH_POSITION0, Laya.ShaderDataType.Vector4],
            };
            let uniformMap = {
                "u_MainTex": Laya.ShaderDataType.Texture2D,
                "u_MainTex_TexelSize": Laya.ShaderDataType.Vector4,
                "u_OffsetScale": Laya.ShaderDataType.Vector4,
                "u_ZBufferParams": Laya.ShaderDataType.Vector4,
                "u_CoCParams": Laya.ShaderDataType.Vector3,
                "u_FullCoCTex": Laya.ShaderDataType.Texture2D,
                "u_SourceSize": Laya.ShaderDataType.Vector4,
                "u_DownSampleScale": Laya.ShaderDataType.Vector4,
                "u_BlurCoCTex": Laya.ShaderDataType.Texture2D,
            };
            let shader = Laya.Shader3D.add("GaussianDoF");
            let cocSubShader = new Laya.SubShader(attributeMap, uniformMap);
            shader.addSubShader(cocSubShader);
            cocSubShader.addShaderPass(FullScreenVert, CoCFS);
            let prefilterSubShader = new Laya.SubShader(attributeMap, uniformMap);
            shader.addSubShader(prefilterSubShader);
            prefilterSubShader.addShaderPass(FullScreenVert, PrefilterFS);
            let blurHSubShader = new Laya.SubShader(attributeMap, uniformMap);
            shader.addSubShader(blurHSubShader);
            blurHSubShader.addShaderPass(FullScreenVert, BlurHFS);
            let blurVSubShader = new Laya.SubShader(attributeMap, uniformMap);
            shader.addSubShader(blurVSubShader);
            blurVSubShader.addShaderPass(FullScreenVert, BlurVFS);
            let compositeSubShader = new Laya.SubShader(attributeMap, uniformMap);
            shader.addSubShader(compositeSubShader);
            compositeSubShader.addShaderPass(FullScreenVert, CompositeFS);
        }
        set farStart(value) {
            let cocParams = this._shaderData.getVector3(GaussianDoF.COCPARAMS);
            cocParams.x = value;
            this._shaderData.setVector3(GaussianDoF.COCPARAMS, cocParams);
        }
        get farStart() {
            return this._shaderData.getVector3(GaussianDoF.COCPARAMS).x;
        }
        set farEnd(value) {
            let cocParams = this._shaderData.getVector3(GaussianDoF.COCPARAMS);
            cocParams.y = Math.max(cocParams.x, value);
            this._shaderData.setVector3(GaussianDoF.COCPARAMS, cocParams);
        }
        get farEnd() {
            return this._shaderData.getVector3(GaussianDoF.COCPARAMS).y;
        }
        set maxRadius(value) {
            let cocParams = this._shaderData.getVector3(GaussianDoF.COCPARAMS);
            cocParams.z = Math.min(value, 2);
            this._shaderData.setVector3(GaussianDoF.COCPARAMS, cocParams);
        }
        get maxRadius() {
            return this._shaderData.getVector3(GaussianDoF.COCPARAMS).z;
        }
        _setupShaderValue(context) {
            let camera = context.camera;
            this._dowmSampleScale.setValue(0.5, 0.5, 2.0, 2.0);
            this._shaderData.setVector(GaussianDoF.DOWNSAMPLESCALE, this._dowmSampleScale);
            let far = camera.farPlane;
            let near = camera.nearPlane;
            this._zBufferParams.setValue(1.0 - far / near, far / near, (near - far) / (near * far), 1 / near);
            this._shaderData.setVector(GaussianDoF.ZBUFFERPARAMS, this._zBufferParams);
        }
        getCameraDepthTextureModeFlag() {
            return exports.DepthTextureMode.Depth;
        }
        render(context) {
            let cmd = context.command;
            this._setupShaderValue(context);
            let source = context.source;
            let shader = this._shader;
            let shaderData = this._shaderData;
            let dataTexFormat = Laya.RenderTargetFormat.R16G16B16A16;
            let fullCoC = Laya.RenderTexture.createFromPool(source.width, source.height, dataTexFormat, Laya.RenderTargetFormat.None, false, 1);
            cmd.blitScreenTriangle(source, fullCoC, null, shader, shaderData, 0);
            fullCoC.filterMode = Laya.FilterMode.Bilinear;
            this._shaderData.setTexture(GaussianDoF.FULLCOCTEXTURE, fullCoC);
            let prefilterTex = Laya.RenderTexture.createFromPool(source.width / 2, source.height / 2, dataTexFormat, Laya.RenderTargetFormat.None, false, 1);
            cmd.blitScreenTriangle(source, prefilterTex, null, shader, shaderData, 1);
            prefilterTex.filterMode = Laya.FilterMode.Bilinear;
            this._sourceSize.setValue(prefilterTex.width, prefilterTex.height, 1.0 / prefilterTex.width, 1.0 / prefilterTex.height);
            this._shaderData.setShaderData(GaussianDoF.SOURCESIZE, Laya.ShaderDataType.Vector4, this._sourceSize);
            let blurHTex = Laya.RenderTexture.createFromPool(prefilterTex.width, prefilterTex.height, dataTexFormat, Laya.RenderTargetFormat.None, false, 1);
            cmd.blitScreenTriangle(prefilterTex, blurHTex, null, this._shader, this._shaderData, 2);
            let blurVTex = Laya.RenderTexture.createFromPool(prefilterTex.width, prefilterTex.height, dataTexFormat, Laya.RenderTargetFormat.None, false, 1);
            cmd.blitScreenTriangle(blurHTex, blurVTex, null, this._shader, this._shaderData, 3);
            blurVTex.filterMode = Laya.FilterMode.Bilinear;
            blurVTex.anisoLevel = 1;
            fullCoC.filterMode = Laya.FilterMode.Point;
            this._shaderData.setTexture(GaussianDoF.BLURCOCTEXTURE, blurVTex);
            let finalTex = Laya.RenderTexture.createFromPool(source.width, source.height, source.colorFormat, source.depthStencilFormat, false, 1);
            cmd.blitScreenTriangle(source, context.destination, null, this._shader, this._shaderData, 4);
            Laya.RenderTexture.recoverToPool(fullCoC);
            Laya.RenderTexture.recoverToPool(prefilterTex);
            Laya.RenderTexture.recoverToPool(blurHTex);
            Laya.RenderTexture.recoverToPool(blurVTex);
            context.deferredReleaseTextures.push(finalTex);
        }
    }

    var FragAO = "#if defined(GL_FRAGMENT_PRECISION_HIGH)\r\nprecision highp float;\r\n#else\r\nprecision mediump float;\r\n#endif\r\n\r\n#define SHADER_NAME OcclusionEstimation:FS\r\n\r\n#include \"DepthNormalUtil.glsl\";\r\n\r\n#include \"AmbientOcclusion.glsl\";\r\n\r\n#define FIX_SAMPLING_PATTERN\r\n\r\n// Check if the camera is perspective.\r\n// (returns 1.0 when orthographic)\r\nfloat CheckPerspective(float x)\r\n{   \r\n    // todo ortho\r\n    return mix(x, 1.0, 0.0);\r\n}\r\n\r\nvec3 ReconstructViewPos(vec2 uv, float depth, vec2 p11_22, vec2 p13_31)\r\n{\r\n    return vec3((uv * 2.0 - 1.0 - p13_31) / p11_22 * CheckPerspective(depth), depth);\r\n}\r\n\r\n// Pseudo random number generator with 2D coordinates\r\n// https://stackoverflow.com/questions/12964279/whats-the-origin-of-this-glsl-rand-one-liner\r\nfloat UVRandom(float u, float v) {\r\n    float f = dot(vec2(12.9898, 78.233), vec2(u, v));\r\n    return fract(43758.5453 * sin(f));\r\n}\r\n\r\nvec2 CosSin(float theta)\r\n{\r\n    // float sn, cs;\r\n    // sincos(theta, sn, cs);\r\n    float sn = sin(theta);\r\n    float cs = cos(theta);\r\n    return vec2(cs, sn);\r\n}\r\n\r\nfloat GradientNoise(vec2 uv)\r\n{\r\n    uv = floor(uv * u_MainTex_TexelSize.zw);\r\n    float f = dot(vec2(0.06711056, 0.00583715), uv);\r\n    return fract(52.9829189 * fract(f));\r\n}\r\n\r\n// Sample point picker\r\nvec3 PickSamplePoint(vec2 uv, float index) \r\n{\r\n    #if defined(FIX_SAMPLING_PATTERN)\r\n        float gn = GradientNoise(uv * DOWNSAMPLE);\r\n        float u = fract(UVRandom(0.0, index + uv.x * 1e-10) + gn) * 2.0 - 1.0;\r\n        float theta = (UVRandom(1.0, index + uv.x * 1e-10) + gn) * TWO_PI;\r\n    #else\r\n        float u = UVRandom(uv.x + u_PlugTime.x, uv.y + index) * 2.0 - 1.0;\r\n        float theta = UVRandom(-uv.x - u_PlugTime.x, uv.y + index) * TWO_PI;\r\n    #endif\r\n\r\n    vec3 v = vec3(CosSin(theta) * sqrt(1.0 - u * u), u);\r\n    float l = sqrt((index + 1.0) / float(SAMPLE_COUNT)) * RADIUS;\r\n    return v * l;\r\n}\r\n\r\nvoid main()\r\n{\r\n    vec2 uv = v_Texcoord0;\r\n\r\n    mat3 proj = mat3(u_Projection);\r\n    vec2 p11_22 = vec2(u_Projection[0][0], u_Projection[1][1]);\r\n    vec2 p13_31 = vec2(u_Projection[2][0], u_Projection[2][1]);\r\n\r\n    vec3 norm_o;\r\n    float depth_o = SampleDepthNormal(uv, norm_o);\r\n\r\n    // Reconstruct the view-space position.\r\n    vec3 vpos_o = ReconstructViewPos(uv, depth_o, p11_22, p13_31);\r\n\r\n    float ao = 0.0;\r\n\r\n    for (int s = 0; s < int(SAMPLE_COUNT); s++) {\r\n        float s_float = float(s);\r\n        vec3 v_s1 = PickSamplePoint(uv, s_float);\r\n\r\n        v_s1 = faceforward(v_s1, -norm_o, v_s1);\r\n        vec3 vpos_s1 = vpos_o + v_s1;\r\n\r\n        // Reproject the sample point\r\n        vec3 spos_s1 = proj * vpos_s1;\r\n        vec2 uv_s1_01 = (spos_s1.xy / CheckPerspective(vpos_s1.z) + 1.0) * 0.5;\r\n\r\n        float depth_s1 = SampleDepth(uv_s1_01);\r\n\r\n        vec3 vpos_s2 = ReconstructViewPos(uv_s1_01, depth_s1, p11_22, p13_31);\r\n        vec3 v_s2 = vpos_s2 - vpos_o;\r\n\r\n        float a1 = max(dot(v_s2, norm_o) - kBeta * depth_o, 0.0);\r\n        float a2 = dot(v_s2, v_s2) + EPSILON;\r\n\r\n        ao += a1 / a2;\r\n    }\r\n\r\n    ao *= RADIUS;\r\n\r\n    ao = PositivePow(ao * INTENSITY / float(SAMPLE_COUNT), kContrast);\r\n\r\n    gl_FragColor = PackAONormal(ao, norm_o);\r\n}\r\n\r\n/**\r\n    0.8741,     0,          0,          0, \r\n    0,          1.7320,     0,          0, \r\n    0,          0,          -1.0152,    -1, \r\n    0,          0,          -0.3046,    0\r\n**/";

    var AoBlurHorizontal = "#if defined(GL_FRAGMENT_PRECISION_HIGH)\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n\r\n#define SHADER_NAME AOBlurHorizontal\r\n//质量\r\n#define BLUR_HIGH_QUALITY 0\r\n\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\n// uniform vec2 u_Delty;\r\n\r\nvec3 GetPackedNormal(vec4 p)\r\n{\r\n    return p.gba * 2.0 - 1.0;\r\n}\r\n\r\nfloat CompareNormal(vec3 d1, vec3 d2)\r\n{\r\n    return smoothstep(0.8, 1.0, dot(d1, d2));\r\n}\r\n\r\nfloat GetPackedAO(vec4 p)\r\n{\r\n    return p.r;\r\n}\r\n\r\nvec4 PackAONormal(float ao, vec3 normal) {\r\n    return vec4(ao, normal * 0.5 + 0.5);\r\n}\r\n\r\nvoid main() {\r\n\t vec2 delta = vec2(u_MainTex_TexelSize.x * 2.0*u_Delty.x,u_Delty.y*u_MainTex_TexelSize.y*2.0);\r\n\t vec2 uv = v_Texcoord0;\r\n\r\n\r\n#if defined(BLUR_HIGH_QUALITY)\r\n\r\n    // High quality 7-tap Gaussian with adaptive sampling\r\n\tvec2 uvtran = uv;\r\n    vec4 p0  = texture2D(u_MainTex,uv);\r\n\tuvtran = uv-delta;\r\n    vec4 p1a = texture2D(u_MainTex,uvtran);\r\n\tuvtran = uv+delta;\r\n    vec4 p1b = texture2D(u_MainTex,uvtran);\r\n\tuvtran = uv-delta*2.0;\r\n    vec4 p2a =  texture2D(u_MainTex,uvtran);\r\n\tuvtran = uv+delta*2.0;\r\n    vec4 p2b =  texture2D(u_MainTex,uvtran);\r\n\tuvtran = uv-delta * 3.2307692308;\r\n    vec4 p3a =  texture2D(u_MainTex,uvtran);;\r\n\tuvtran = uv+delta * 3.2307692308;\r\n    vec4 p3b =  texture2D(u_MainTex,uvtran);;\r\n\r\n    vec3 n0 = GetPackedNormal(p0);\r\n    \r\n\r\n    float w0  = 0.37004405286;\r\n    float w1a = CompareNormal(n0, GetPackedNormal(p1a)) * 0.31718061674;\r\n    float w1b = CompareNormal(n0, GetPackedNormal(p1b)) * 0.31718061674;\r\n    float w2a = CompareNormal(n0, GetPackedNormal(p2a)) * 0.19823788546;\r\n    float w2b = CompareNormal(n0, GetPackedNormal(p2b)) * 0.19823788546;\r\n    float w3a = CompareNormal(n0, GetPackedNormal(p3a)) * 0.11453744493;\r\n    float w3b = CompareNormal(n0, GetPackedNormal(p3b)) * 0.11453744493;\r\n\r\n    float s;\r\n    s  = GetPackedAO(p0)  * w0;\r\n    s += GetPackedAO(p1a) * w1a;\r\n    s += GetPackedAO(p1b) * w1b;\r\n    s += GetPackedAO(p2a) * w2a;\r\n    s += GetPackedAO(p2b) * w2b;\r\n    s += GetPackedAO(p3a) * w3a;\r\n    s += GetPackedAO(p3b) * w3b;\r\n\r\n    s /= w0 + w1a + w1b + w2a + w2b + w3a + w3b;\r\n\r\n#else\r\n\r\n    // Fater 5-tap Gaussian with linear sampling\r\n    vec4 p0  = texture2D(u_MainTex, sampler_MainTex, i.texcoordStereo);\r\n    vec4 p1a = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, UnityStereoTransformScreenSpaceTex(i.texcoord - delta * 1.3846153846));\r\n    vec4 p1b = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, UnityStereoTransformScreenSpaceTex(i.texcoord + delta * 1.3846153846));\r\n    vec4 p2a = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, UnityStereoTransformScreenSpaceTex(i.texcoord - delta * 3.2307692308));\r\n    vec4 p2b = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, UnityStereoTransformScreenSpaceTex(i.texcoord + delta * 3.2307692308));\r\n\r\n\tvec2 uvtran = uv;\r\n    vec4 p0  = texture2D(u_MainTex,uv);\r\n\tuvtran = uv-delta * 1.3846153846;\r\n    vec4 p1a = texture2D(u_MainTex,uvtran);\r\n\tuvtran = uv+delta * 1.3846153846;\r\n    vec4 p1b = texture2D(u_MainTex,uvtran);\r\n\tuvtran = uv-delta*3.2307692308;\r\n    vec4 p2a =  texture2D(u_MainTex,uvtran);\r\n\tuvtran = uv+delta*3.2307692308;\r\n    vec4 p2b =  texture2D(u_MainTex,uvtran);\r\n\r\n \tvec3 n0 = GetPackedNormal(p0);\r\n\r\n    float w0  = 0.2270270270;\r\n    float w1a = CompareNormal(n0, GetPackedNormal(p1a)) * 0.3162162162;\r\n    float w1b = CompareNormal(n0, GetPackedNormal(p1b)) * 0.3162162162;\r\n    float w2a = CompareNormal(n0, GetPackedNormal(p2a)) * 0.0702702703;\r\n    float w2b = CompareNormal(n0, GetPackedNormal(p2b)) * 0.0702702703;\r\n\r\n    float s;\r\n    s  = GetPackedAO(p0)  * w0;\r\n    s += GetPackedAO(p1a) * w1a;\r\n    s += GetPackedAO(p1b) * w1b;\r\n    s += GetPackedAO(p2a) * w2a;\r\n    s += GetPackedAO(p2b) * w2b;\r\n\r\n    s /= w0 + w1a + w1b + w2a + w2b;\r\n\r\n#endif\r\n\r\n    gl_FragColor = PackAONormal(s, n0);;\r\n}";

    var AOComposition = "#if defined(GL_FRAGMENT_PRECISION_HIGH)\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#define SHADER_NAME AOComposition\r\n#define BLUR_HIGH_QUALITY 0\r\n\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\nvec3 GetPackedNormal(vec4 p)\r\n{\r\n    return p.gba * 2.0 - 1.0;\r\n}\r\nfloat CompareNormal(vec3 d1, vec3 d2)\r\n{\r\n    return smoothstep(0.8, 1.0, dot(d1, d2));\r\n}\r\nfloat GetPackedAO(vec4 p)\r\n{\r\n    return p.r;\r\n}\r\n\r\n// Geometry-aware bilateral filter (single pass/small kernel)\r\nfloat BlurSmall(sampler2D tex, vec2 uv, vec2 delta)\r\n{\r\n    vec4 p0 = texture2D(tex,uv);\r\n    vec2 uvtran =uv+vec2(-delta.x,-delta.y) ;\r\n    vec4 p1 = texture2D(tex,uvtran);\r\n    uvtran =uv+vec2(delta.x,-delta.y);\r\n    vec4 p2 = texture2D(tex, uvtran);\r\n    uvtran =uv+vec2(-delta.x,delta.y) ;\r\n    vec4 p3 = texture2D(tex, uvtran);\r\n    uvtran =uv+delta;\r\n    vec4 p4 = texture2D(tex, uvtran);\r\n\r\n    vec3 n0 = GetPackedNormal(p0);\r\n\r\n    float w0 = 1.0;\r\n    float w1 = CompareNormal(n0, GetPackedNormal(p1));\r\n    float w2 = CompareNormal(n0, GetPackedNormal(p2));\r\n    float w3 = CompareNormal(n0, GetPackedNormal(p3));\r\n    float w4 = CompareNormal(n0, GetPackedNormal(p4));\r\n\r\n    float s;\r\n    s  = GetPackedAO(p0) * w0;\r\n    s += GetPackedAO(p1) * w1;\r\n    s += GetPackedAO(p2) * w2;\r\n    s += GetPackedAO(p3) * w3;\r\n    s += GetPackedAO(p4) * w4;\r\n\r\n    return s / (w0 + w1 + w2 + w3 + w4);\r\n}\r\n\r\nvoid main() {\r\n    vec2 uv = v_Texcoord0;\r\n    vec2 delty = u_MainTex_TexelSize.xy;\r\n    float ao = BlurSmall(u_compositionAoTexture,uv,delty);\r\n    vec4 albedo = texture2D(u_MainTex,uv);\r\n    vec4 aocolor = vec4(ao*u_AOColor.rgb,ao);\r\n    albedo.rgb = albedo.rgb*(1.0-ao)+ao*u_AOColor.rgb*ao;\r\n    gl_FragColor = albedo;\r\n\r\n\r\n}";

    var AmbientOcclusion = "#include \"Camera.glsl\";\r\n// const \r\n#define TWO_PI 6.2831852\r\n\r\n#define EPSILON         1.0e-4\r\n#define FLT_EPSILON     1.192092896e-07 // Smallest positive number, such that 1.0 + FLT_EPSILON != 1.0\r\n\r\nconst float kContrast = 0.6;\r\nconst float kGeometryCoeff = 0.8;\r\nconst float kBeta = 0.002;\r\n\r\n\r\n// varying\r\nvarying vec2 v_Texcoord0;\r\n\r\n#if defined(AO_High)\r\n\t#define SAMPLE_COUNT 12\r\n#elif defined(AO_MEDIUM)\r\n\t#define SAMPLE_COUNT 8\r\n#else\r\n\t#define SAMPLE_COUNT 4\r\n#endif\r\n\r\n#ifdef AOLOWEST\r\n#define SAMPLE_COUNT 8\r\n#endif\r\n\r\n#ifdef AOLOWEST\r\n#define SAMPLE_COUNT 8\r\n#endif\r\n\r\n\r\n#define INTENSITY u_AOParams.x\r\n#define RADIUS u_AOParams.y\r\n#define DOWNSAMPLE u_AOParams.z\r\n\r\nfloat PositivePow(float base, float power)\r\n{\r\n    return pow(max(abs(base), float(FLT_EPSILON)), power);\r\n}\r\n\r\n\r\n// Boundary check for depth sampler\r\n// (returns a very large value if it lies out of bounds)\r\nfloat CheckBounds(vec2 uv, float d) \r\n{\r\n    float ob = 0.0;\r\n    // todo\r\n    if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) \r\n    {\r\n        ob = 1.0;\r\n    }\r\n    if (d <= 0.00001) {\r\n        ob += 1.0;\r\n    }\r\n\r\n    return ob * 1e8;\r\n}\r\n\r\nfloat SampleDepth(vec2 uv) \r\n{\r\n    float depthTex_Depth = SAMPLE_DEPTH_TEXTURE(u_CameraDepthTexture, uv);\r\n    float depthTex_Linear01Depth = Linear01Depth(depthTex_Depth, u_ZBufferParams);\r\n    return  depthTex_Linear01Depth * u_ProjectionParams.y + CheckBounds(uv, depthTex_Linear01Depth);\r\n}\r\n\r\nvec3 SampleNormal(vec2 uv) \r\n{\r\n    vec4 col = texture2D(u_CameraDepthNormalsTexture, uv);\r\n    vec3 depthNormal_Normal = DecodeViewNormalStereo(col);\r\n    return depthNormal_Normal * vec3(1.0, 1.0, -1.0);\r\n}\r\n\r\nfloat SampleDepthNormal(vec2 uv, out vec3 normal) \r\n{\r\n    normal = SampleNormal(uv);\r\n    return SampleDepth(uv);\r\n}\r\n\r\n// Normal vector comparer (for geometry-aware weighting)\r\nfloat CompareNormal(vec3 d1, vec3 d2)\r\n{\r\n    return smoothstep(kGeometryCoeff, 1.0, dot(d1, d2));\r\n}\r\n\r\n// Accessors for packed AO/normal buffer\r\nvec4 PackAONormal(float ao, vec3 n) \r\n{\r\n    return vec4(ao, n * 0.5 + 0.5);\r\n}\r\n\r\nvec3 GetPackedNormal(vec4 p)\r\n{\r\n    return p.gba * 2.0 - 1.0;\r\n}\r\n\r\nfloat GetPackAO(vec4 p)\r\n{\r\n    return p.r;\r\n}\r\n\r\n\r\n";

    exports.AOQUALITY = void 0;
    (function (AOQUALITY) {
        AOQUALITY[AOQUALITY["High"] = 0] = "High";
        AOQUALITY[AOQUALITY["MEDIUM"] = 1] = "MEDIUM";
        AOQUALITY[AOQUALITY["LOWEST"] = 2] = "LOWEST";
    })(exports.AOQUALITY || (exports.AOQUALITY = {}));
    class ScalableAO extends PostProcessEffect {
        constructor() {
            super();
            this._aoParams = new Laya.Vector3();
            this._aoQuality = exports.AOQUALITY.MEDIUM;
            this._shader = Laya.Shader3D.find("ScalableAO");
            this._shaderData = Laya.LayaGL.renderOBJCreate.createShaderData(null);
            this._aoParams = new Laya.Vector3(0.12, 0.15, 1);
            this._shaderData.setVector3(ScalableAO.AOParams, this._aoParams);
            this._shaderData.setVector(BaseCamera.DEPTHZBUFFERPARAMS, new Laya.Vector4());
            this._aoBlurHorizontalShader = Laya.Shader3D.find("AOBlurHorizontal");
            this._aoComposition = Laya.Shader3D.find("AOComposition");
            this.aoQuality = exports.AOQUALITY.MEDIUM;
        }
        static init() {
            ScalableAO.BlurDelty = Laya.Shader3D.propertyNameToID("u_Delty");
            ScalableAO.AOColor = Laya.Shader3D.propertyNameToID("u_AOColor");
            ScalableAO.aoTexture = Laya.Shader3D.propertyNameToID("u_compositionAoTexture");
            ScalableAO.AOParams = Laya.Shader3D.propertyNameToID('u_AOParams');
            ScalableAO.SourceTex = Laya.Shader3D.propertyNameToID('u_SourceTex');
            ScalableAO.SHADERDEFINE_AOHigh = Laya.Shader3D.getDefineByName("AO_High");
            ScalableAO.SHADERDEFINE_AOMEDIUM = Laya.Shader3D.getDefineByName("AO_MEDIUM");
            ScalableAO.SHADERDEFINE_LOWEST = Laya.Shader3D.getDefineByName("AO_LOWEST");
            Laya.Shader3D.addInclude("AmbientOcclusion.glsl", AmbientOcclusion);
            let attributeMap = {
                'a_PositionTexcoord': [Laya.VertexMesh.MESH_POSITION0, Laya.ShaderDataType.Vector4]
            };
            let uniformMap = {
                'u_OffsetScale': Laya.ShaderDataType.Vector4,
                'u_MainTex': Laya.ShaderDataType.Texture2D,
                'u_MainTex_TexelSize': Laya.ShaderDataType.Vector4,
                'u_Delty': Laya.ShaderDataType.Vector2,
                'u_PlugTime': Laya.ShaderDataType.Vector4,
                'u_AOParams': Laya.ShaderDataType.Vector4,
                'u_BlurVector': Laya.ShaderDataType.Vector2,
                'u_AOColor': Laya.ShaderDataType.Color,
                'u_compositionAoTexture': Laya.ShaderDataType.Texture2D
            };
            let shader = Laya.Shader3D.add("ScalableAO");
            let subShader = new Laya.SubShader(attributeMap, uniformMap);
            shader.addSubShader(subShader);
            subShader.addShaderPass(BlitVS, FragAO);
            shader = Laya.Shader3D.add("AOBlurHorizontal");
            subShader = new Laya.SubShader(attributeMap, uniformMap);
            shader.addSubShader(subShader);
            subShader.addShaderPass(BlitVS, AoBlurHorizontal);
            shader = Laya.Shader3D.add("AOComposition");
            subShader = new Laya.SubShader(attributeMap, uniformMap);
            shader.addSubShader(subShader);
            subShader.addShaderPass(BlitVS, AOComposition);
        }
        set aoColor(value) {
            this._shaderData.setColor(ScalableAO.AOColor, value);
        }
        get aoColor() {
            return this._shaderData.getColor(ScalableAO.AOColor);
        }
        set intensity(value) {
            this._aoParams.x = value;
            this._shaderData.setVector3(ScalableAO.AOParams, this._aoParams);
        }
        get intensity() {
            return this._aoParams.x;
        }
        set radius(value) {
            this._aoParams.y = value;
            this._shaderData.setVector3(ScalableAO.AOParams, this._aoParams);
        }
        get radius() {
            return this._aoParams.y;
        }
        get aoQuality() {
            return this._aoQuality;
        }
        set aoQuality(value) {
            this._aoQuality = value;
            switch (value) {
                case exports.AOQUALITY.High:
                    this._shaderData.addDefine(ScalableAO.SHADERDEFINE_AOHigh);
                    this._shaderData.removeDefine(ScalableAO.SHADERDEFINE_AOMEDIUM);
                    this._shaderData.removeDefine(ScalableAO.SHADERDEFINE_LOWEST);
                    break;
                case exports.AOQUALITY.MEDIUM:
                    this._shaderData.addDefine(ScalableAO.SHADERDEFINE_AOMEDIUM);
                    this._shaderData.removeDefine(ScalableAO.SHADERDEFINE_AOHigh);
                    this._shaderData.removeDefine(ScalableAO.SHADERDEFINE_LOWEST);
                    break;
                case exports.AOQUALITY.LOWEST:
                    this._shaderData.addDefine(ScalableAO.SHADERDEFINE_LOWEST);
                    this._shaderData.removeDefine(ScalableAO.SHADERDEFINE_AOHigh);
                    this._shaderData.removeDefine(ScalableAO.SHADERDEFINE_AOMEDIUM);
                    break;
            }
        }
        getCameraDepthTextureModeFlag() {
            return exports.DepthTextureMode.DepthAndDepthNormals;
        }
        render(context) {
            let cmd = context.command;
            context.camera.viewport;
            let camera = context.camera;
            camera.depthTextureMode |= exports.DepthTextureMode.DepthNormals;
            camera.depthTextureMode |= exports.DepthTextureMode.Depth;
            let depthNormalTexture = camera.depthNormalTexture;
            let depthTexture = camera.depthTexture;
            if (!depthNormalTexture || !depthTexture) {
                return;
            }
            depthNormalTexture.wrapModeU = Laya.WrapMode.Clamp;
            depthNormalTexture.wrapModeV = Laya.WrapMode.Clamp;
            let source = context.source;
            let width = source.width;
            let height = source.height;
            let textureFormat = source.colorFormat;
            let depthFormat = Laya.RenderTargetFormat.None;
            let finalTex = Laya.RenderTexture.createFromPool(width, height, textureFormat, depthFormat, false, 1);
            let shader = this._shader;
            let shaderData = this._shaderData;
            cmd.blitScreenTriangle(null, finalTex, null, shader, shaderData, 0);
            let blurTex = Laya.RenderTexture.createFromPool(width, height, textureFormat, depthFormat, false, 1);
            cmd.blitScreenTriangle(finalTex, blurTex, null, this._aoBlurHorizontalShader, shaderData, 0);
            cmd.setShaderDataVector2(shaderData, ScalableAO.BlurDelty, ScalableAO.deltyVector);
            cmd.blitScreenTriangle(blurTex, finalTex, null, this._aoBlurHorizontalShader, this._shaderData, 0);
            cmd.setShaderDataTexture(shaderData, ScalableAO.aoTexture, finalTex);
            cmd.blitScreenTriangle(context.source, context.destination, null, this._aoComposition, this._shaderData, 0);
            context.deferredReleaseTextures.push(finalTex);
            context.deferredReleaseTextures.push(blurTex);
        }
    }
    ScalableAO.deltyHorizontal = new Laya.Vector2(1.0, 0.0);
    ScalableAO.deltyVector = new Laya.Vector2(0.0, 1.0);

    class AnimatorTransition {
        constructor() {
            this._conditions = [];
            this._exitByTime = true;
            this._exitTime = 0.85;
            this._transduration = 0.15;
            this._transstartoffset = 0;
            this._mute = false;
        }
        get name() {
            return this._name;
        }
        set name(value) {
            this._name = value;
        }
        get mute() {
            return this._mute;
        }
        set mute(value) {
            this._mute = value;
        }
        get destState() {
            return this._destState;
        }
        set destState(value) {
            this._destState = value;
        }
        get conditions() {
            return this._conditions;
        }
        set conditions(value) {
            for (var i = this._conditions.length - 1; i >= 0; i--) {
                this.removeCondition(this._conditions[i]);
            }
            for (var i = 0; i < value.length; i++) {
                this.addCondition(value[i]);
            }
        }
        get exitByTime() {
            return this._exitByTime;
        }
        set exitByTime(value) {
            this._exitByTime = value;
        }
        set transduration(value) {
            this._transduration = Math.max(0, Math.min(value, 1.0));
        }
        get transduration() {
            return this._transduration;
        }
        set transstartoffset(value) {
            this._transstartoffset = Math.max(0, Math.min(value, 1.0));
        }
        get transstartoffset() {
            return this._transstartoffset;
        }
        set exitTime(value) {
            this._exitTime = Math.max(0, Math.min(value, 1.0));
        }
        get exitTime() {
            return this._exitTime;
        }
        addCondition(condition) {
            if (this._conditions.indexOf(condition) == -1) {
                this._conditions.push(condition);
            }
        }
        removeCondition(condition) {
            let index = this._conditions.indexOf(condition);
            if (index != -1) {
                this._conditions.splice(index, 0);
            }
        }
        check(normalizeTime, paramsMap) {
            if (this._mute) {
                return false;
            }
            if (this._conditions.length == 0) {
                if (normalizeTime > this._exitTime)
                    return true;
            }
            else {
                if (this._exitByTime && normalizeTime < this._exitTime) {
                    return false;
                }
                for (var i = 0; i < this._conditions.length; i++) {
                    let con = this._conditions[i];
                    let out = con.checkState(paramsMap[con.id]);
                    if (out) {
                        if (con.type == Laya.AniStateConditionType.Trigger)
                            paramsMap[con.id] = false;
                        return true;
                    }
                }
            }
            return false;
        }
    }

    class AnimatorController extends Laya.Resource {
        constructor(data) {
            super();
            let obj = Laya.AnimatorControllerParse.parse(data);
            this.data = obj.ret;
            this.clipsID = obj.clipsID;
        }
        getLayers() {
            let layers = this.data.controllerLayers;
            let lArr = [];
            for (let i = layers.length - 1; i >= 0; i--) {
                let l = layers[i];
                let acl = new AnimatorControllerLayer(l.name);
                lArr.unshift(acl);
                for (let k in l) {
                    if ("name" == k || "states" == k || null == l[k]) {
                        continue;
                    }
                    try {
                        acl[k] = l[k];
                    }
                    catch (err) { }
                }
                this.getState(l.states, acl, this.data);
            }
            return lArr;
        }
        updateTo(a) {
            let currLayer = a._controllerLayers;
            for (let i = 0, len = currLayer.length; i < len; i++) {
                currLayer[i]._removeReference();
            }
            currLayer.length = 0;
            let layers = this.getLayers();
            for (let i = 0, len = layers.length; i < len; i++) {
                a.addControllerLayer(layers[i]);
            }
            let parms = this.data.animatorParams;
            if (parms) {
                for (let i = parms.length - 1; i >= 0; i--) {
                    let p = parms[i];
                    if (Laya.AniParmType.Bool == p.type) {
                        a.setParamsBool(p.name, Boolean(p.val));
                    }
                    else if (Laya.AniParmType.Float == p.type) {
                        let val = Number(p.val);
                        if (isNaN(val)) {
                            val = 0;
                        }
                        a.setParamsNumber(p.name, val);
                    }
                    else if (Laya.AniParmType.Trigger == p.type) {
                        if (p.val) {
                            a.setParamsTrigger(p.name);
                        }
                    }
                }
            }
        }
        createState(states, idCatch, acl) {
            if (!states)
                return null;
            let ret = {};
            let defID = null;
            for (let i = states.length - 1; i >= 0; i--) {
                let obj = states[i];
                let childStates = obj.states;
                if (childStates) {
                    let groupRet = this.createState(childStates, idCatch, acl);
                    if (groupRet) {
                        idCatch[obj.id] = groupRet.states[groupRet.id];
                    }
                    continue;
                }
                if (0 > Number(obj.id)) {
                    if ("-1" == obj.id) {
                        let transitions = obj.soloTransitions;
                        if (transitions && 0 < transitions.length) {
                            defID = transitions[0].id;
                        }
                    }
                    continue;
                }
                let state = new AnimatorState();
                idCatch[obj.id] = state;
                ret[obj.id] = state;
                for (let k in obj) {
                    try {
                        if ("scripts" == k) {
                            let scripts = obj[k];
                            if (scripts && Array.isArray(scripts)) {
                                for (let k = scripts.length - 1; k >= 0; k--) {
                                    let uuid = scripts[k];
                                    let c = Laya.ClassUtils.getClass(uuid);
                                    if (c) {
                                        state.addScript(c);
                                    }
                                }
                            }
                            continue;
                        }
                        else if ("soloTransitions" == k) {
                            continue;
                        }
                        else if (null != obj[k]) {
                            state[k] = obj[k];
                        }
                    }
                    catch (err) { }
                }
                acl.addState(state);
            }
            return { id: defID, states: ret };
        }
        setExitTransition(exitRet, transitions, idCatch, data, pExitRet) {
            for (let id in exitRet) {
                let state = idCatch[id];
                if (state) {
                    let ats = state.transitions;
                    let sts = state.soloTransitions;
                    let linArr = exitRet[id];
                    for (let i = transitions.length - 1; i >= 0; i--) {
                        let t = transitions[i];
                        if ("-3" == t.id) {
                            if (null == pExitRet[id]) {
                                pExitRet[id] = [];
                            }
                            pExitRet[id].push(t);
                            continue;
                        }
                        for (let j = linArr.length - 1; j >= 0; j--) {
                            let t2 = linArr[j];
                            let ato = new AnimatorTransition();
                            ato.destState = idCatch[t.id];
                            if (t.conditions) {
                                this.addConditions(t.conditions, ato, data);
                            }
                            if (t2.conditions) {
                                this.addConditions(t2.conditions, ato, data);
                            }
                            for (let k in t) {
                                if ("solo" == k || "id" == k || "conditions" == k) {
                                    continue;
                                }
                                else {
                                    ato[k] = t[k];
                                }
                            }
                            if (t.solo) {
                                sts.unshift(ato);
                            }
                            else {
                                ats.unshift(ato);
                            }
                        }
                    }
                }
            }
        }
        setTransitions(states, idCatch, acl, data, pState) {
            if (!states)
                return null;
            let exitRet = {};
            for (let i = states.length - 1; i >= 0; i--) {
                let obj = states[i];
                if (obj.states) {
                    let exitTransition = this.setTransitions(obj.states, idCatch, acl, data, obj);
                    if (exitTransition) {
                        let transitions = obj.soloTransitions;
                        if (transitions) {
                            this.setExitTransition(exitTransition, transitions, idCatch, data, exitRet);
                        }
                    }
                }
            }
            for (let i = states.length - 1; i >= 0; i--) {
                let obj = states[i];
                if (obj.states) {
                    continue;
                }
                if ("-1" == obj.id) {
                    if (obj.soloTransitions && 0 < obj.soloTransitions.length) {
                        if (null == pState) {
                            acl.defaultState = idCatch[obj.soloTransitions[0].id];
                        }
                        else {
                            idCatch[pState.id] = idCatch[obj.soloTransitions[0].id];
                        }
                        continue;
                    }
                }
                else if ("-2" == obj.id) {
                    let transitions = obj.soloTransitions;
                    if (transitions) {
                        for (let j = transitions.length - 1; j >= 0; j--) {
                            let o = transitions[j];
                            let destState = idCatch[o.id];
                            if (destState) {
                                for (let idk in idCatch) {
                                    let state = idCatch[idk];
                                    let ato = new AnimatorTransition();
                                    ato.destState = destState;
                                    if (o.conditions) {
                                        this.addConditions(o.conditions, ato, data);
                                    }
                                    for (let k in o) {
                                        if ("solo" == k || "id" == k || "conditions" == k) {
                                            continue;
                                        }
                                        else {
                                            ato[k] = o[k];
                                        }
                                    }
                                    if (o.solo) {
                                        state.soloTransitions.unshift(ato);
                                    }
                                    else {
                                        state.transitions.unshift(ato);
                                    }
                                }
                            }
                        }
                    }
                    continue;
                }
                else if ("-3" == obj.id) {
                    continue;
                }
                let soloTransitions = obj.soloTransitions;
                if (soloTransitions && idCatch[obj.id]) {
                    let ats = idCatch[obj.id].transitions;
                    let sts = idCatch[obj.id].soloTransitions;
                    for (let j = soloTransitions.length - 1; j >= 0; j--) {
                        let o = soloTransitions[j];
                        if ("-3" == o.id) {
                            if (null == exitRet[obj.id]) {
                                exitRet[obj.id] = [];
                            }
                            exitRet[obj.id].push(o);
                            continue;
                        }
                        let ato = new AnimatorTransition();
                        if (idCatch[o.id]) {
                            ato.destState = idCatch[o.id];
                        }
                        if (o.conditions) {
                            this.addConditions(o.conditions, ato, data);
                        }
                        for (let k in o) {
                            if ("solo" == k || "id" == k || "conditions" == k) {
                                continue;
                            }
                            else {
                                ato[k] = o[k];
                            }
                        }
                        if (o.solo) {
                            sts.unshift(ato);
                        }
                        else {
                            ats.unshift(ato);
                        }
                    }
                }
            }
            return exitRet;
        }
        getState(states, acl, data) {
            if (states) {
                let idCatch = {};
                this.createState(states, idCatch, acl);
                this.setTransitions(states, idCatch, acl, data);
            }
        }
        addConditions(arr, ato, data) {
            let parms = data.animatorParams;
            if (null == parms || 0 == parms.length)
                return;
            for (let i = 0, len = arr.length; i < len; i++) {
                let o = arr[i];
                let parm = null;
                for (let j = parms.length - 1; j >= 0; j--) {
                    if (parms[j].id == o.id) {
                        parm = parms[j];
                        break;
                    }
                }
                if (null == parm) {
                    return;
                }
                let c;
                if (parm.type == Laya.AniParmType.Bool) {
                    let b = new Laya.AnimatorStateBoolCondition(o.name);
                    b.compareFlag = Boolean(o.checkValue);
                    c = b;
                }
                else if (parm.type == Laya.AniParmType.Float) {
                    let n = new Laya.AnimatorStateNumberCondition(o.name);
                    n.numberValue = Number(o.checkValue);
                    n.compareFlag = o.type;
                    c = n;
                }
                else if (parm.type == Laya.AniParmType.Trigger) {
                    let t = new Laya.AnimatorStateTriggerCondition(o.name);
                    c = t;
                }
                ato.addCondition(c);
            }
        }
    }

    class BatchMark {
        constructor() {
            this.updateMark = -1;
            this.indexInList = -1;
            this.batched = false;
        }
    }

    class InstanceBatchManager {
        constructor() {
            this._instanceBatchOpaqueMarks = [];
            this.updateCountMark = 0;
        }
        _getData(key, data, cls) {
            if (null == cls) {
                cls = Array;
            }
            if ("boolean" == typeof key) {
                return (data[key ? 0 : 1]) || (data[key ? 0 : 1] = new cls());
            }
            else {
                return data[key] || (data[key] = new cls());
            }
        }
        getInstanceBatchOpaquaMark(receiveShadow, materialID, subMeshID, invertFace, reflectionprob) {
            var data = this._getData(receiveShadow, this._instanceBatchOpaqueMarks);
            data = this._getData(materialID, data);
            data = this._getData(subMeshID, data);
            data = this._getData(invertFace, data);
            return this._getData(reflectionprob, data, BatchMark);
        }
    }
    InstanceBatchManager.instance = new InstanceBatchManager();

    const tempVec = new Laya.Vector3();
    new Laya.Vector3();
    class BatchRender extends BaseRender {
        constructor() {
            super();
            this._lodInstanceRenderElement = {};
            this._RenderBitFlag = exports.RenderBitFlag.RenderBitFlag_Batch;
            this._renderElements = [];
            this._lodInstanceRenderElement[-1] = [];
            this._batchList = new Laya.SingletonList();
        }
        get checkLOD() {
            return this._checkLOD;
        }
        set checkLOD(value) {
            this._checkLOD = value;
        }
        set lodCullRateArray(value) {
            if (!this._checkLOD) {
                return;
            }
            value.sort((a, b) => b - a);
            this._lodRateArray = value;
        }
        get lodCullRateArray() {
            return this._lodRateArray;
        }
        _canBatch(render) {
            if (render._batchRender) {
                return false;
            }
            return false;
        }
        _onEnable() {
            super._onEnable();
            if (this._batchList) {
                for (let i = 0, n = this._batchList.length; i < n; i++) {
                    this._batchList.elements[i].setRenderbitFlag(this._RenderBitFlag, true);
                }
            }
        }
        _onDisable() {
            super._onDisable();
            if (this._batchList) {
                for (let i = 0, n = this._batchList.length; i < n; i++) {
                    this._batchList.elements[i].setRenderbitFlag(this._RenderBitFlag, false);
                }
            }
        }
        _changeLOD(lod) {
            if (this._cacheLod == lod) {
                return;
            }
            if (this._cacheLod == this.lodCullRateArray.length - 1) {
                lod = -1;
            }
            this._renderElements = this._lodInstanceRenderElement[lod];
            if (this._lodInstanceRenderElement[lod] && lod != -1) {
                this._renderElements || (this._renderElements = []);
                this._renderElements = this._renderElements.concat(this._lodInstanceRenderElement[-1]);
            }
            else {
                this._renderElements = this._lodInstanceRenderElement[-1];
            }
        }
        onPreRender() {
            if (!this.checkLOD || !this._lodRateArray || this._lodRateArray.length < 1) {
                this._changeLOD(0);
            }
            else {
                let checkCamera = this.owner.scene.cullInfoCamera;
                let maxYDistance = checkCamera.maxlocalYDistance;
                Laya.Vector3.subtract(this._bounds.getCenter(), checkCamera.transform.position, tempVec);
                let length = tempVec.length();
                let rateYDistance = length / checkCamera.farPlane * maxYDistance;
                let rate = (this._lodsize / rateYDistance);
                for (let i = 0; i < this._lodRateArray.length; i++) {
                    if (rate < this._lodRateArray[i])
                        continue;
                    this._changeLOD(i);
                    break;
                }
            }
        }
        _batchOneRender(render) {
            return false;
        }
        _removeOneRender(render) {
        }
        _updateOneRender(render) {
        }
        addList(renderNode) {
            for (var i = 0, n = renderNode.length; i < n; i++) {
                let baseRender = renderNode[i];
                if (this._canBatch(baseRender)) {
                    this._batchList.add(baseRender);
                }
            }
        }
        reBatch() {
            let renderNums = this._batchList.length;
            let renders = this._batchList.elements;
            for (var i = 0; i < renderNums; i++) {
                let render = renders[i];
                this._batchOneRender(render);
            }
        }
        _restorRenderNode() {
            for (let i = 0, n = this._batchList.length; i < n; i++) {
                this._removeOneRender(this._batchList.elements[i]);
            }
        }
        _clear() {
            this._restorRenderNode();
            this._renderElements = [];
            this._batchList.destroy();
            this._batchList = new Laya.SingletonList();
            this._lodInstanceRenderElement = {};
            this._lodInstanceRenderElement[-1] = [];
        }
    }

    class StaticInstanceBatchRender extends BatchRender {
        constructor() {
            super();
            this._insBatchMarksNums = [];
            this._insElementMarksArray = [];
            this._instanceBatchminNums = 10;
            this._updateChangeElement = [];
            this.checkLOD = true;
            this._batchManager = new InstanceBatchManager();
            this._RenderBitFlag = exports.RenderBitFlag.RenderBitFlag_InstanceBatch;
        }
        _isRenderNodeAllCanInstanceBatch(render) {
            let elements = render._renderElements;
            for (var i = 0, n = elements.length; i < n; i++) {
                let element = elements[i];
                if (!element.material._shader._enableInstancing || element.render.lightmapIndex > 0) {
                    return false;
                }
            }
            return true;
        }
        _sumInstanceBatch(render) {
            let elements = render._renderElements;
            for (var i = 0, n = elements.length; i < n; i++) {
                let element = elements[i];
                var insBatchMarks = this._batchManager.getInstanceBatchOpaquaMark(element.render.receiveShadow, element.material.id, element._geometry._id, element.transform ? element.transform._isFrontFaceInvert : false, element.render._probReflection ? element.render._probReflection.id : -1);
                if (insBatchMarks.indexInList == -1) {
                    insBatchMarks.indexInList = this._insBatchMarksNums.length;
                    this._insBatchMarksNums.push(0);
                }
                this._insBatchMarksNums[insBatchMarks.indexInList] += 1;
            }
        }
        _batchOneElement(element, render) {
            var insBatchMarks = this._batchManager.getInstanceBatchOpaquaMark(element.render.receiveShadow, element.material.id, element._geometry._id, element.transform ? element.transform._isFrontFaceInvert : false, element.render._probReflection ? element.render._probReflection.id : -1);
            if (insBatchMarks.indexInList == -1)
                return;
            let instanceelement = this._insElementMarksArray[insBatchMarks.indexInList];
            if (!instanceelement) {
                instanceelement = this._createInstanceElement(element, render, insBatchMarks);
            }
            let list = instanceelement._instanceBatchElementList;
            if (list.length == InstanceRenderElement.maxInstanceCount) {
                this._insBatchMarksNums.push(this._insBatchMarksNums[insBatchMarks.indexInList]);
                insBatchMarks.indexInList = this._insBatchMarksNums.length - 1;
                instanceelement = this._createInstanceElement(element, render, insBatchMarks);
                list = instanceelement._instanceBatchElementList;
            }
            if (list.indexof(element) == -1) {
                list.add(element);
                instanceelement._isUpdataData = true;
                (this._updateChangeElement.indexOf(instanceelement) == -1) && this._updateChangeElement.push(instanceelement);
                element._batchElement = instanceelement;
            }
        }
        _removeOneElement(element, render) {
            var insBatchMarks = this._batchManager.getInstanceBatchOpaquaMark(element.render.receiveShadow, element.material.id, element._geometry._id, element.transform ? element.transform._isFrontFaceInvert : false, element.render._probReflection ? element.render._probReflection.id : -1);
            if (insBatchMarks.indexInList == -1)
                return;
            let instanceelement = element._batchElement;
            if (!instanceelement || this._renderElements.indexOf(instanceelement) == -1) {
                return;
            }
            let list = instanceelement._instanceBatchElementList;
            if (list.indexof(element) != -1) {
                list.remove(element);
                instanceelement._isUpdataData = true;
                (this._updateChangeElement.indexOf(instanceelement) == -1) && this._updateChangeElement.push(instanceelement);
                element._batchElement = null;
            }
        }
        _updateOneElement(element, render) {
            let instanceelement = element._batchElement;
            if (!instanceelement || this._renderElements.indexOf(instanceelement) == -1) {
                return;
            }
            let list = instanceelement._instanceBatchElementList;
            if (list.indexof(element) != -1) {
                instanceelement._isUpdataData = true;
                (this._updateChangeElement.indexOf(instanceelement) == -1) && this._updateChangeElement.push(instanceelement);
            }
        }
        _createInstanceElement(element, render, batchMark) {
            let instanceRenderElement = new InstanceRenderElement();
            instanceRenderElement.render = render;
            instanceRenderElement.renderType = RenderElement.RENDERTYPE_INSTANCEBATCH;
            instanceRenderElement._geometry.subMesh = element._geometry;
            instanceRenderElement.material = element.material;
            instanceRenderElement.setTransform(null);
            instanceRenderElement.renderSubShader = element.renderSubShader;
            let list = instanceRenderElement._instanceBatchElementList;
            list.length = 0;
            list.add(element);
            this._insElementMarksArray[batchMark.indexInList] = instanceRenderElement;
            batchMark.batched = true;
            if (!this._lodInstanceRenderElement[render._LOD]) {
                this._lodInstanceRenderElement[render._LOD] = [];
            }
            this._lodInstanceRenderElement[render._LOD].push(instanceRenderElement);
            return instanceRenderElement;
        }
        _canBatch(render) {
            let elements = render._renderElements;
            for (var i = 0, n = elements.length; i < n; i++) {
                let element = elements[i];
                var insBatchMarks = this._batchManager.getInstanceBatchOpaquaMark(element.render.receiveShadow, element.material.id, element._geometry._id, element.transform ? element.transform._isFrontFaceInvert : false, element.render._probReflection ? element.render._probReflection.id : -1);
                if (this._insBatchMarksNums[insBatchMarks.indexInList] < this._instanceBatchminNums || element.material.renderQueue >= 3000) {
                    return false;
                }
            }
            return true;
        }
        _calculateBoundingBox() {
            let bound = this._bounds;
            for (let i = 0, n = this._batchList.length; i < n; i++) {
                if (i == 0) {
                    this._batchList.elements[i].bounds.cloneTo(bound);
                }
                else {
                    Bounds.merge(bound, this._batchList.elements[i].bounds, bound);
                }
            }
            let extend = this._bounds.getExtent();
            this._lodsize = 2 * Math.max(extend.x, extend.y, extend.z);
            return this._bounds;
        }
        _onDestroy() {
            super._onDestroy();
        }
        _batchOneRender(render) {
            if (!this._canBatch(render))
                return false;
            this.boundsChange = true;
            let elements = render._renderElements;
            for (let i = 0, n = elements.length; i < n; i++) {
                let renderelement = elements[i];
                this._batchOneElement(renderelement, render);
            }
            render._batchRender = this;
            render.setRenderbitFlag(exports.RenderBitFlag.RenderBitFlag_InstanceBatch, true);
            return true;
        }
        _removeOneRender(render) {
            if (!this._canBatch(render))
                return;
            if (this._batchList.indexof(render) != -1) {
                this.boundsChange = true;
                let elements = render._renderElements;
                for (let i = 0, n = elements.length; i < n; i++) {
                    let renderelement = elements[i];
                    this._removeOneElement(renderelement, render);
                }
                render._batchRender = null;
                render.setRenderbitFlag(exports.RenderBitFlag.RenderBitFlag_InstanceBatch, false);
            }
        }
        _updateOneRender(render) {
            if (!this._canBatch(render))
                return;
            if (this._batchList.indexof(render) != -1) {
                this.boundsChange = true;
                let elements = render._renderElements;
                for (let i = 0, n = elements.length; i < n; i++) {
                    let renderelement = elements[i];
                    this._updateOneElement(renderelement, render);
                }
            }
        }
        _clear() {
            super._clear();
            this._insElementMarksArray.forEach(element => {
                element && element.destroy();
            });
            this._insElementMarksArray = [];
            this._updateChangeElement = [];
            this._insBatchMarksNums = [];
        }
        addList(renderNodes) {
            if (!this._batchList) {
                this._batchList = new Laya.SingletonList();
            }
            let renders = [];
            for (var i = 0; i < renderNodes.length; i++) {
                let baseRender = renderNodes[i];
                if (baseRender._batchRender) {
                    continue;
                }
                if (this._isRenderNodeAllCanInstanceBatch(baseRender)) {
                    renders.push(baseRender);
                    this._sumInstanceBatch(baseRender);
                }
            }
            for (var i = 0, n = renders.length; i < n; i++) {
                let baseRender = renders[i];
                if (this._canBatch(baseRender)) {
                    this._batchList.add(baseRender);
                }
            }
        }
        reBatch() {
            let renderNums = this._batchList.length;
            let renders = this._batchList.elements;
            for (var i = 0; i < renderNums; i++) {
                let render = renders[i];
                this._batchOneRender(render);
            }
        }
    }

    class StatiVertexMergeBatchRender extends BatchRender {
        _addList(renderNodes) {
        }
    }

    class StaticBatchVolume extends Volume {
        constructor() {
            super();
            this._customBatchs = [];
            this.checkLOD = true;
            this._enableStaticInstanceBatch = false;
            this._enableStaticVertexMergeBatch = false;
            this._cacheRender = new Laya.SingletonList();
            this._batchRender = new Laya.SingletonList();
            this._enableCustomBatch = false;
        }
        _getStaticInstanceBatchRender() {
            let render = this.owner.getComponent(StaticInstanceBatchRender);
            if (!render) {
                render = this.owner.addComponent(StaticInstanceBatchRender);
            }
            return render;
        }
        _getStatiVertexMergeBatchRender() {
            let render = this.owner.getComponent(StatiVertexMergeBatchRender);
            if (!render) {
                render = this.owner.addComponent(StatiVertexMergeBatchRender);
            }
            return render;
        }
        get checkLOD() {
            return this._checkLOD;
        }
        set checkLOD(value) {
            this._checkLOD = value;
            if (this._enableStaticInstanceBatch) {
                this._instanceBatchRender.checkLOD = value;
            }
            if (this._enableStaticVertexMergeBatch) {
                this._vertexMergeBatchRender.checkLOD = value;
            }
            if (this._enableCustomBatch) {
                this._customBatchs.forEach(element => {
                    element.checkLOD = value;
                });
            }
        }
        get enableStaticInstanceBatchRender() {
            return this._enableStaticInstanceBatch;
        }
        set enableStaticInstanceBatchRender(value) {
            if (!this._instanceBatchRender && value) {
                this._instanceBatchRender = this._getStaticInstanceBatchRender();
            }
            if (value == this._enableStaticInstanceBatch)
                return;
            if (value) {
                this._instanceBatchRender.enabled = true;
            }
            else {
                this._instanceBatchRender.enabled = false;
            }
            this._enableStaticInstanceBatch = value;
        }
        get enableMergeBatchRender() {
            return this._enableStaticVertexMergeBatch;
        }
        set enableMergeBatchRender(value) {
            if (!this._vertexMergeBatchRender && value) {
                this._vertexMergeBatchRender = this._getStatiVertexMergeBatchRender();
            }
            if (value == this._enableStaticVertexMergeBatch)
                return;
            if (value) {
                this._vertexMergeBatchRender.enabled = true;
            }
            else {
                this._vertexMergeBatchRender.enabled = false;
            }
            this._enableStaticVertexMergeBatch = value;
        }
        get enableCustomBatchRender() {
            return this._enableCustomBatch;
        }
        set enableCustomBatchRender(value) {
            this._enableCustomBatch = value;
            this._customBatchs.forEach(element => {
                element.enabled = value;
            });
        }
        set customBatchRenders(value) {
            if (this._customBatchs) {
                this._customBatchs.forEach(element => {
                    this.owner._destroyComponent(element);
                });
            }
            this._customBatchs = value;
            this._customBatchs.forEach(element => {
                this.owner.addComponentInstance(element);
            });
            this.enableCustomBatchRender = this._enableCustomBatch;
        }
        get customBatchRenders() {
            return this._customBatchs;
        }
        _restorRenderNode() {
            if (this.enableCustomBatchRender) {
                this._customBatchs.forEach(element => {
                    element._clear();
                });
            }
            if (this._enableStaticInstanceBatch) {
                this._instanceBatchRender._clear();
            }
            if (this.enableCustomBatchRender) {
                this._vertexMergeBatchRender._clear();
            }
        }
        __addRenderNodeToBatch(renderNode) {
            if (this.enableCustomBatchRender) {
                this._customBatchs.forEach(element => {
                    if (element._batchOneRender(renderNode))
                        return;
                });
            }
            if (this._enableStaticInstanceBatch) {
                if (this._instanceBatchRender._batchOneRender(renderNode))
                    return;
            }
            if (this.enableCustomBatchRender) {
                if (this._vertexMergeBatchRender._batchOneRender(renderNode))
                    return;
            }
        }
        __removeRenderNodeFromBatch(renderNode) {
            renderNode._batchRender._removeOneRender(renderNode);
        }
        _onEnable() {
            super._onEnable();
            if (this._enableStaticInstanceBatch)
                this._instanceBatchRender && (this._instanceBatchRender.enabled = true);
            if (this._enableStaticVertexMergeBatch)
                this._vertexMergeBatchRender && (this._vertexMergeBatchRender.enabled = true);
            if (this.enableCustomBatchRender) {
                this._customBatchs.forEach(element => {
                    element.enabled = true;
                });
            }
        }
        _onDisable() {
            super._onDisable();
            if (this._enableStaticInstanceBatch)
                this._instanceBatchRender && (this._instanceBatchRender.enabled = false);
            if (this._enableStaticVertexMergeBatch)
                this._vertexMergeBatchRender && (this._vertexMergeBatchRender.enabled = false);
            if (this.enableCustomBatchRender) {
                this._customBatchs.forEach(element => {
                    element.enabled = false;
                });
            }
        }
        _addRenderNode(renderNode) {
            if (renderNode.renderNode.staticMask == exports.StaticFlag.StaticBatch) {
                if (this._cacheRender.indexof(renderNode) != -1) {
                    return;
                }
                this._cacheRender.add(renderNode);
                if (this._batchRender.length > 0) {
                    this.__addRenderNodeToBatch(renderNode);
                }
            }
        }
        _removeRenderNode(renderNode) {
            if (renderNode.renderNode.staticMask == exports.StaticFlag.StaticBatch) {
                if (this._batchRender.indexof(renderNode) != -1) {
                    this.__removeRenderNodeFromBatch(renderNode);
                    this._batchRender.remove(renderNode);
                }
            }
        }
        _VolumeChange() {
            super._VolumeChange();
            this._cacheRender.clear();
        }
        onStart() {
            this.reBatch();
        }
        reBatch() {
            this._cacheRender.elements.length = this._cacheRender.length;
            this._batchRender.clear();
            this._restorRenderNode();
            if (this.enableCustomBatchRender) {
                this._customBatchs.forEach(element => {
                    element.addList(this._cacheRender.elements);
                    element.reBatch();
                });
            }
            if (this._enableStaticInstanceBatch) {
                this._instanceBatchRender.addList(this._cacheRender.elements);
                this._instanceBatchRender.reBatch();
            }
            if (this.enableCustomBatchRender) {
                this._vertexMergeBatchRender.addList(this._cacheRender.elements);
                this._vertexMergeBatchRender.reBatch();
            }
            for (var i = 0, n = this._cacheRender.length; i < n; i++) {
                (this._cacheRender.elements[i]._batchRender) && this._batchRender.add(this._cacheRender.elements[i]);
            }
        }
    }

    class AnimationClipLoader {
        load(task) {
            return task.loader.fetch(task.url, "arraybuffer", task.progress.createCallback(), task.options).then(data => {
                if (!data)
                    return null;
                return AnimationClip._parse(data);
            });
        }
    }
    Laya.Loader.registerLoader(["lani"], AnimationClipLoader, Laya.Loader.ANIMATIONCLIP);

    var internalResources;
    class CubemapLoader {
        constructor() {
            if (!internalResources) {
                internalResources = {
                    "WhiteTextureCube.ltc": TextureCube.whiteTexture,
                    "BlackTextureCube.ltc": TextureCube.blackTexture,
                    "GrayTextureCube.ltc": TextureCube.grayTexture,
                };
            }
        }
        load(task) {
            if (task.url.indexOf("internal/") != -1) {
                let tex = internalResources[Laya.Utils.getBaseName(task.url)];
                if (tex)
                    return Promise.resolve(tex);
            }
            if (task.ext == "ktx" || task.ext == "cubemap") {
                let url = task.url;
                if (task.ext == "cubemap")
                    url = Laya.AssetDb.inst.getSubAssetURL(url, task.uuid, "0", "ktx");
                return task.loader.fetch(url, "arraybuffer", task.progress.createCallback(), task.options).then(data => {
                    if (!data)
                        return null;
                    let ktxInfo = Laya.KTXTextureInfo.getKTXTextureInfo(data);
                    if (ktxInfo.dimension != Laya.TextureDimension.Cube) {
                        console.warn("ktxInfo.dimension != TextureDimension.Cube! " + task.url);
                        return null;
                    }
                    let tex = new TextureCube(ktxInfo.width, ktxInfo.format, ktxInfo.mipmapCount > 1, ktxInfo.sRGB);
                    tex.setKTXData(ktxInfo);
                    let obsoluteInst = task.obsoluteInst;
                    if (obsoluteInst && (obsoluteInst instanceof TextureCube))
                        tex = this.move(obsoluteInst, tex);
                    return tex;
                });
            }
            else if (task.ext == "ltcb" || task.ext == "ltcb.ls") {
                return task.loader.fetch(task.url, "arraybuffer", task.progress.createCallback(), task.options).then(data => {
                    if (!data)
                        return null;
                    let byte = new Laya.Byte(data);
                    let version = byte.readUTFString();
                    if (version !== "LAYATEXTURECUBE:0000") {
                        console.warn(`CubemapBinLoader: unknow version. ${version}`);
                        return null;
                    }
                    let format = byte.readUint8();
                    let mipCount = byte.getUint8();
                    let size = byte.readUint16();
                    let filterMode = byte.getUint8();
                    let wrapModeU = byte.getUint8();
                    let wrapModev = byte.getUint8();
                    let anisoLevel = byte.getUint8();
                    let tex = new TextureCube(size, format, mipCount > 1 ? true : false);
                    tex.setPixelsData(null, false, false);
                    tex.filterMode = filterMode;
                    tex.wrapModeU = wrapModeU;
                    tex.wrapModeV = wrapModev;
                    tex.anisoLevel = anisoLevel;
                    let pos = byte.pos;
                    let mipSize = size;
                    for (let i = 0; i < mipCount; i++) {
                        let uint8Arrays = new Array(6);
                        let mipPixelLength = mipSize * mipSize * tex._getFormatByteCount();
                        for (let j = 0; j < 6; j++) {
                            uint8Arrays[j] = new Uint8Array(data, pos, mipPixelLength);
                            pos += mipPixelLength;
                        }
                        tex.updateSubPixelsData(uint8Arrays, 0, 0, mipSize, mipSize, i, false, false, false);
                        mipSize /= 2;
                    }
                    let obsoluteInst = task.obsoluteInst;
                    if (obsoluteInst && (obsoluteInst instanceof TextureCube))
                        tex = this.move(obsoluteInst, tex);
                    return tex;
                });
            }
            else {
                return task.loader.fetch(task.url, "json", task.progress.createCallback(0.2), task.options).then(data => {
                    if (!data)
                        return null;
                    let ltcBasePath = Laya.URL.getPath(task.url);
                    let urls = [
                        Laya.URL.join(ltcBasePath, data.front),
                        Laya.URL.join(ltcBasePath, data.back),
                        Laya.URL.join(ltcBasePath, data.left),
                        Laya.URL.join(ltcBasePath, data.right),
                        Laya.URL.join(ltcBasePath, data.up),
                        Laya.URL.join(ltcBasePath, data.down)
                    ];
                    return Promise.all(urls.map(url => {
                        if (url)
                            return task.loader.fetch(url, "image", task.progress.createCallback(), task.options);
                        else
                            return Promise.resolve(null);
                    })).then(images => {
                        var _a, _b;
                        let constructParams = task.options.constructParams;
                        let size = constructParams ? constructParams[0] : ((_b = ((_a = images[0]) === null || _a === void 0 ? void 0 : _a.width)) !== null && _b !== void 0 ? _b : 1);
                        let format = constructParams ? constructParams[1] : Laya.TextureFormat.R8G8B8A8;
                        let mipmap = constructParams ? constructParams[3] : false;
                        let srgb = constructParams ? constructParams[5] : true;
                        let tex = new TextureCube(size, format, mipmap, srgb);
                        tex.setImageData(images, false, false);
                        let obsoluteInst = task.obsoluteInst;
                        if (obsoluteInst && (obsoluteInst instanceof TextureCube))
                            tex = this.move(obsoluteInst, tex);
                        return tex;
                    });
                });
            }
        }
        move(obsoluteInst, tex) {
            obsoluteInst._texture = tex._texture;
            obsoluteInst.width = tex.width;
            obsoluteInst.height = tex.height;
            obsoluteInst.obsolute = false;
            delete Laya.Resource._idResourcesMap[tex.id];
            return obsoluteInst;
        }
    }
    Laya.Loader.registerLoader(["ltc", "ltcb", "ltcb.ls", "cubemap"], CubemapLoader, Laya.Loader.TEXTURECUBE);

    class MaterialParser {
        static parse(data) {
            let props = data.props;
            switch (data.version) {
                case "LAYAMATERIAL:01":
                case "LAYAMATERIAL:02":
                case "LAYAMATERIAL:03":
                    let mat = MaterialParser.parseLegacy(data);
                    mat.oldparseEndEvent();
                    return mat;
                case "LAYAMATERIAL:04":
                    break;
                default:
                    console.error("Material:unkonwn version.");
                    return null;
            }
            let mat = new Material();
            mat.setShaderName(props.type);
            for (let key in props) {
                switch (key) {
                    case "type":
                    case "name":
                        break;
                    case "defines":
                        let defineNames = props[key];
                        for (let i = 0, n = defineNames.length; i < n; i++) {
                            let define = Laya.Shader3D.getDefineByName(defineNames[i]);
                            mat._shaderValues.addDefine(define);
                        }
                        break;
                    case "textures":
                        let textures = props[key];
                        for (let i = 0, n = textures.length; i < n; i++) {
                            let texture = textures[i];
                            let path = texture.path;
                            (path) && (mat._shaderValues.setTexture(Laya.Shader3D.propertyNameToID(texture.name), Laya.Loader.getBaseTexture(path)));
                        }
                        break;
                    case "renderQueue":
                        mat.renderQueue = props[key];
                        break;
                    case "alphaTest":
                        mat.alphaTest = props[key];
                        break;
                    case "materialRenderMode":
                        mat.materialRenderMode = props[key];
                        break;
                    default:
                        let property = props[key];
                        let uniName = Laya.Shader3D.propertyNameToID(key);
                        switch (uniName) {
                            case Material.CULL:
                                mat.cull = property;
                                break;
                            case Material.BLEND:
                                mat.blend = property;
                                break;
                            case Material.BLEND_SRC:
                                mat.blendSrc = property;
                                break;
                            case Material.BLEND_DST:
                                mat.blendDst = property;
                                break;
                            case Material.DEPTH_TEST:
                                mat.depthTest = property;
                                break;
                            case Material.DEPTH_WRITE:
                                mat.depthWrite = !!props[key];
                                break;
                            default:
                                if (!property.length) {
                                    mat._shaderValues.setNumber(uniName, props[key]);
                                }
                                else {
                                    var vectorValue = property;
                                    switch (vectorValue.length) {
                                        case 2:
                                            mat._shaderValues.setVector2(uniName, new Laya.Vector2(vectorValue[0], vectorValue[1]));
                                            break;
                                        case 3:
                                            mat._shaderValues.setVector3(uniName, new Laya.Vector3(vectorValue[0], vectorValue[1], vectorValue[2]));
                                            break;
                                        case 4:
                                            if (mat._shaderValues.getColor(uniName)) {
                                                mat._shaderValues.setColor(uniName, new Laya.Color(vectorValue[0], vectorValue[1], vectorValue[2], vectorValue[3]));
                                            }
                                            else
                                                mat._shaderValues.setVector(uniName, new Laya.Vector4(vectorValue[0], vectorValue[1], vectorValue[2], vectorValue[3]));
                                            break;
                                        default:
                                            mat._shaderValues.setBuffer(uniName, vectorValue);
                                    }
                                }
                                break;
                        }
                }
            }
            return mat;
        }
        static collectLinks(data, basePath) {
            let urls = [];
            let textures = data.props.textures;
            if (textures) {
                for (let i = 0, n = textures.length; i < n; i++) {
                    let tex2D = textures[i];
                    let tex2DPath = tex2D.path;
                    if (tex2DPath) {
                        tex2D.path = Laya.URL.join(basePath, tex2DPath);
                        urls.push({ url: tex2D.path, type: Laya.Loader.TEXTURE2D, constructParams: tex2D.constructParams, propertyParams: tex2D.propertyParams });
                    }
                }
            }
            return urls;
        }
        static parseLegacy(data) {
            let jsonData = data;
            let props = jsonData.props;
            let mat;
            let classType = props.type;
            let clas = Laya.ClassUtils.getClass(classType);
            if (!clas && classType && classType.startsWith("Laya."))
                clas = Laya.ClassUtils.getClass(classType.substring(5));
            if (clas)
                mat = new clas();
            else {
                mat = new Material();
                mat.setShaderName(classType);
            }
            switch (jsonData.version) {
                case "LAYAMATERIAL:01":
                case "LAYAMATERIAL:02":
                    for (let key in props) {
                        switch (key) {
                            case "type":
                                break;
                            case "vectors":
                                let vectors = props[key];
                                for (let i = 0, n = vectors.length; i < n; i++) {
                                    let vector = vectors[i];
                                    let vectorValue = vector.value;
                                    switch (vectorValue.length) {
                                        case 2:
                                            mat[vector.name] = new Laya.Vector2(vectorValue[0], vectorValue[1]);
                                            break;
                                        case 3:
                                            if (mat[vector.name] instanceof Laya.Color) {
                                                mat[vector.name] = new Laya.Color(vectorValue[0], vectorValue[1], vectorValue[2], 1.0);
                                            }
                                            else
                                                mat[vector.name] = new Laya.Vector3(vectorValue[0], vectorValue[1], vectorValue[2]);
                                            break;
                                        case 4:
                                            if (mat[vector.name] instanceof Laya.Color) {
                                                mat[vector.name] = new Laya.Color(vectorValue[0], vectorValue[1], vectorValue[2], vectorValue[3]);
                                            }
                                            else
                                                mat[vector.name] = new Laya.Vector4(vectorValue[0], vectorValue[1], vectorValue[2], vectorValue[3]);
                                            break;
                                        default:
                                            throw new Error("Material:unkonwn color length.");
                                    }
                                }
                                break;
                            case "colors":
                                let colors = props[key];
                                for (let i = 0, n = colors.length; i < n; i++) {
                                    let color = colors[i];
                                    let vectorValue = color.value;
                                    mat[color.name] = new Laya.Color(vectorValue[0], vectorValue[1], vectorValue[2], vectorValue[3]);
                                }
                                break;
                            case "textures":
                                let textures = props[key];
                                for (let i = 0, n = textures.length; i < n; i++) {
                                    let texture = textures[i];
                                    let path = texture.path;
                                    (path) && (mat[texture.name] = Laya.Loader.getBaseTexture(path));
                                }
                                break;
                            case "defines":
                                let defineNames = props[key];
                                for (let i = 0, n = defineNames.length; i < n; i++) {
                                    let define = Laya.Shader3D.getDefineByName(defineNames[i]);
                                    mat._shaderValues.addDefine(define);
                                }
                                break;
                            case "renderStates":
                                let renderStatesData = props[key];
                                let renderStateData = renderStatesData[0];
                                mat.blend = renderStateData.blend;
                                mat.cull = this._getRenderStateParams(renderStateData.cull);
                                mat.depthTest = this._getRenderStateParams(renderStateData.depthTest);
                                mat.depthWrite = renderStateData.depthWrite;
                                mat.blendSrc = this._getRenderStateParams(renderStateData.srcBlend);
                                mat.blendDst = this._getRenderStateParams(renderStateData.dstBlend);
                                break;
                            case "cull":
                                mat.cull = this._getRenderStateParams(props[key]);
                                break;
                            case "blend":
                                mat.blend = this._getRenderStateParams(props[key]);
                                break;
                            case "depthWrite":
                                mat.depthWrite = !!props[key];
                                break;
                            case "srcBlend":
                                mat.blendSrc = this._getRenderStateParams(props[key]);
                                break;
                            case "dstBlend":
                                mat.blendDst = this._getRenderStateParams(props[key]);
                                break;
                            case "depthTest":
                                mat.depthTest = this._getRenderStateParams(props[key]);
                                break;
                            case "blendDst":
                                mat.blendDst = this._getRenderStateParams(props[key]);
                                break;
                            case "blendSrc":
                                mat.blendSrc = this._getRenderStateParams(props[key]);
                                break;
                            default:
                                mat[key] = props[key];
                        }
                    }
                    break;
                case "LAYAMATERIAL:03":
                    for (let key in props) {
                        switch (key) {
                            case "type":
                            case "name":
                                break;
                            case "defines":
                                let defineNames = props[key];
                                for (let i = 0, n = defineNames.length; i < n; i++) {
                                    let define = Laya.Shader3D.getDefineByName(defineNames[i]);
                                    mat._shaderValues.addDefine(define);
                                }
                                break;
                            case "textures":
                                let textures = props[key];
                                for (let i = 0, n = textures.length; i < n; i++) {
                                    let texture = textures[i];
                                    let path = texture.path;
                                    (path) && (mat._shaderValues.setTexture(Laya.Shader3D.propertyNameToID(texture.name), Laya.Loader.getBaseTexture(path)));
                                }
                                break;
                            case "renderQueue":
                                mat.renderQueue = props[key];
                                break;
                            default:
                                let property = props[key];
                                let uniName = Laya.Shader3D.propertyNameToID(key);
                                switch (uniName) {
                                    case Material.CULL:
                                        mat.cull = this._getRenderStateParams(property);
                                        break;
                                    case Material.BLEND:
                                        mat.blend = this._getRenderStateParams(property);
                                        break;
                                    case Material.BLEND_SRC:
                                        mat.blendSrc = this._getRenderStateParams(property);
                                        break;
                                    case Material.BLEND_DST:
                                        mat.blendDst = this._getRenderStateParams(property);
                                        break;
                                    case Material.DEPTH_TEST:
                                        mat.depthTest = this._getRenderStateParams(property);
                                        break;
                                    case Material.DEPTH_WRITE:
                                        mat.depthWrite = !!props[key];
                                        break;
                                    default:
                                        if (!property.length) {
                                            mat._shaderValues.setNumber(uniName, props[key]);
                                        }
                                        else {
                                            var vectorValue = property;
                                            switch (vectorValue.length) {
                                                case 2:
                                                    mat._shaderValues.setVector2(uniName, new Laya.Vector2(vectorValue[0], vectorValue[1]));
                                                    break;
                                                case 3:
                                                    mat._shaderValues.setVector3(uniName, new Laya.Vector3(vectorValue[0], vectorValue[1], vectorValue[2]));
                                                    break;
                                                case 4:
                                                    if (mat._shaderValues.getColor(uniName)) {
                                                        mat._shaderValues.setColor(uniName, new Laya.Color(vectorValue[0], vectorValue[1], vectorValue[2], vectorValue[3]));
                                                    }
                                                    else
                                                        mat._shaderValues.setVector(uniName, new Laya.Vector4(vectorValue[0], vectorValue[1], vectorValue[2], vectorValue[3]));
                                                    break;
                                                default:
                                                    throw new Error("Material:unkonwn color length.");
                                            }
                                        }
                                        break;
                                }
                        }
                    }
                    break;
                default:
                    throw new Error("Material:unkonwn version.");
            }
            return mat;
        }
        static _getRenderStateParams(type) {
            switch (type) {
                case 0x0300:
                    return Laya.BlendFactor.SourceColor;
                case 0x0301:
                    return Laya.BlendFactor.OneMinusSourceColor;
                case 0x0306:
                    return Laya.BlendFactor.DestinationColor;
                case 0x0307:
                    return Laya.BlendFactor.OneMinusDestinationColor;
                case 0x0302:
                    return Laya.BlendFactor.SourceAlpha;
                case 0x0303:
                    return Laya.BlendFactor.OneMinusSourceAlpha;
                case 0x0304:
                    return Laya.BlendFactor.DestinationAlpha;
                case 0x0305:
                    return Laya.BlendFactor.OneMinusDestinationAlpha;
                case 0x0308:
                    return Laya.BlendFactor.SourceAlphaSaturate;
                case 0x8006:
                    return Laya.BlendEquationSeparate.ADD;
                case 0x800A:
                    return Laya.BlendEquationSeparate.SUBTRACT;
                case 0x800B:
                    return Laya.BlendEquationSeparate.REVERSE_SUBTRACT;
                case 0x0200:
                    return Laya.CompareFunction.Never;
                case 0x0201:
                    return Laya.CompareFunction.Less;
                case 0x0202:
                    return Laya.CompareFunction.Equal;
                case 0x0203:
                    return Laya.CompareFunction.LessEqual;
                case 0x0204:
                    return Laya.CompareFunction.Greater;
                case 0x0205:
                    return Laya.CompareFunction.NotEqual;
                case 0x0206:
                    return Laya.CompareFunction.GreaterEqual;
                case 0x0207:
                    return Laya.CompareFunction.Always;
                default:
                    return type;
            }
        }
    }

    class MaterialLoader {
        load(task) {
            return task.loader.fetch(task.url, "json", task.progress.createCallback(0.3), task.options).then(data => {
                if (!data)
                    return null;
                let basePath = Laya.URL.getPath(task.url);
                let urls = MaterialParser.collectLinks(data, basePath);
                if (data.version === "LAYAMATERIAL:04") {
                    let shaderName = data.props.type;
                    if (!Laya.Shader3D.find(shaderName)) {
                        let url = Laya.AssetDb.inst.shaderName_to_URL(shaderName);
                        if (url)
                            urls.push(url);
                        else {
                            let promise = Laya.AssetDb.inst.shaderName_to_URL_async(shaderName);
                            if (promise) {
                                return promise.then(url => {
                                    if (url)
                                        urls.push(url);
                                    return this.load2(task, data, urls);
                                });
                            }
                            else if (data.props.shaderPath) {
                                urls.push(Laya.URL.join(basePath, data.props.shaderPath));
                            }
                        }
                    }
                }
                return this.load2(task, data, urls);
            });
        }
        load2(task, data, urls) {
            if (urls.length == 0) {
                let mat = MaterialParser.parse(data);
                let obsoluteInst = task.obsoluteInst;
                if (obsoluteInst)
                    mat = this.move(obsoluteInst, mat);
                return Promise.resolve(mat);
            }
            return task.loader.load(urls, task.options, task.progress.createCallback()).then(() => {
                let mat = MaterialParser.parse(data);
                let obsoluteInst = task.obsoluteInst;
                if (task.obsoluteInst)
                    mat = this.move(obsoluteInst, mat);
                return mat;
            });
        }
        move(obsoluteInst, mat) {
            obsoluteInst._shaderValues.reset();
            obsoluteInst.setShaderName(mat._shader.name);
            mat._shaderValues.cloneTo(obsoluteInst._shaderValues);
            obsoluteInst.renderQueue = mat.renderQueue;
            obsoluteInst.obsolute = false;
            mat.destroy();
            return obsoluteInst;
        }
    }
    Laya.Loader.registerLoader(["lmat"], MaterialLoader, Laya.Loader.MATERIAL);

    class LoadModelV04 {
        static parse(readData, version, mesh, subMeshes) {
            LoadModelV04._mesh = mesh;
            LoadModelV04._subMeshes = subMeshes;
            LoadModelV04._version = version;
            LoadModelV04._readData = readData;
            LoadModelV04.READ_DATA();
            LoadModelV04.READ_BLOCK();
            LoadModelV04.READ_STRINGS();
            for (var i = 0, n = LoadModelV04._BLOCK.count; i < n; i++) {
                LoadModelV04._readData.pos = LoadModelV04._BLOCK.blockStarts[i];
                var index = LoadModelV04._readData.getUint16();
                var blockName = LoadModelV04._strings[index];
                var fn = LoadModelV04["READ_" + blockName];
                if (fn == null)
                    throw new Error("model file err,no this function:" + index + " " + blockName);
                else
                    fn.call(null);
            }
            LoadModelV04._strings.length = 0;
            LoadModelV04._readData = null;
            LoadModelV04._version = null;
            LoadModelV04._mesh = null;
            LoadModelV04._subMeshes = null;
        }
        static _readString() {
            return LoadModelV04._strings[LoadModelV04._readData.getUint16()];
        }
        static READ_DATA() {
            LoadModelV04._DATA.offset = LoadModelV04._readData.getUint32();
            LoadModelV04._DATA.size = LoadModelV04._readData.getUint32();
        }
        static READ_BLOCK() {
            var count = LoadModelV04._BLOCK.count = LoadModelV04._readData.getUint16();
            var blockStarts = LoadModelV04._BLOCK.blockStarts = [];
            var blockLengths = LoadModelV04._BLOCK.blockLengths = [];
            for (var i = 0; i < count; i++) {
                blockStarts.push(LoadModelV04._readData.getUint32());
                blockLengths.push(LoadModelV04._readData.getUint32());
            }
        }
        static READ_STRINGS() {
            var offset = LoadModelV04._readData.getUint32();
            var count = LoadModelV04._readData.getUint16();
            var prePos = LoadModelV04._readData.pos;
            LoadModelV04._readData.pos = offset + LoadModelV04._DATA.offset;
            for (var i = 0; i < count; i++)
                LoadModelV04._strings[i] = LoadModelV04._readData.readUTFString();
            LoadModelV04._readData.pos = prePos;
        }
        static READ_MESH() {
            LoadModelV04._readString();
            var arrayBuffer = LoadModelV04._readData.__getBuffer();
            var i;
            var memorySize = 0;
            var vertexBufferCount = LoadModelV04._readData.getInt16();
            var offset = LoadModelV04._DATA.offset;
            for (i = 0; i < vertexBufferCount; i++) {
                var vbStart = offset + LoadModelV04._readData.getUint32();
                var vbLength = LoadModelV04._readData.getUint32();
                var vbArrayBuffer = arrayBuffer.slice(vbStart, vbStart + vbLength);
                var vbDatas = new Float32Array(vbArrayBuffer);
                var bufferAttribute = LoadModelV04._readString();
                var vertexDeclaration;
                switch (LoadModelV04._version) {
                    case "LAYAMODEL:0301":
                    case "LAYAMODEL:0400":
                        vertexDeclaration = Laya.VertexMesh.getVertexDeclaration(bufferAttribute);
                        break;
                    case "LAYAMODEL:0401":
                        vertexDeclaration = Laya.VertexMesh.getVertexDeclaration(bufferAttribute, false);
                        break;
                    default:
                        throw new Error("LoadModelV03: unknown version.");
                }
                if (!vertexDeclaration)
                    throw new Error("LoadModelV03: unknown vertexDeclaration.");
                var vertexBuffer = Laya.LayaGL.renderOBJCreate.createVertexBuffer3D(vbDatas.length * 4, Laya.BufferUsage.Static, true);
                vertexBuffer.vertexDeclaration = vertexDeclaration;
                vertexBuffer.setData(vbDatas.buffer);
                LoadModelV04._mesh._vertexBuffer = vertexBuffer;
                LoadModelV04._mesh._vertexCount += vertexBuffer._byteLength / vertexDeclaration.vertexStride;
                memorySize += vbDatas.length * 4;
            }
            var ibStart = offset + LoadModelV04._readData.getUint32();
            var ibLength = LoadModelV04._readData.getUint32();
            var ibDatas = new Uint16Array(arrayBuffer.slice(ibStart, ibStart + ibLength));
            var indexBuffer = Laya.LayaGL.renderOBJCreate.createIndexBuffer3D(Laya.IndexFormat.UInt16, ibLength / 2, Laya.BufferUsage.Static, true);
            indexBuffer.setData(ibDatas);
            LoadModelV04._mesh._indexBuffer = indexBuffer;
            memorySize += indexBuffer.indexCount * 2;
            LoadModelV04._mesh._setBuffer(LoadModelV04._mesh._vertexBuffer, indexBuffer);
            LoadModelV04._mesh._setCPUMemory(memorySize);
            LoadModelV04._mesh._setGPUMemory(memorySize);
            var boneNames = LoadModelV04._mesh._boneNames = [];
            var boneCount = LoadModelV04._readData.getUint16();
            boneNames.length = boneCount;
            for (i = 0; i < boneCount; i++)
                boneNames[i] = LoadModelV04._strings[LoadModelV04._readData.getUint16()];
            LoadModelV04._readData.pos += 8;
            var bindPoseDataStart = LoadModelV04._readData.getUint32();
            var bindPoseDataLength = LoadModelV04._readData.getUint32();
            var bindPoseDatas = new Float32Array(arrayBuffer.slice(offset + bindPoseDataStart, offset + bindPoseDataStart + bindPoseDataLength));
            var bindPoseFloatCount = bindPoseDatas.length;
            var bindPoseBuffer = LoadModelV04._mesh._inverseBindPosesBuffer = new ArrayBuffer(bindPoseFloatCount * 4);
            LoadModelV04._mesh._inverseBindPoses = [];
            if (bindPoseFloatCount != 0)
                LoadModelV04._mesh._instanceBufferStateType = Mesh.MESH_INSTANCEBUFFER_TYPE_SIMPLEANIMATOR;
            else
                LoadModelV04._mesh._instanceBufferStateType = Mesh.MESH_INSTANCEBUFFER_TYPE_NORMAL;
            for (i = 0; i < bindPoseFloatCount; i += 16) {
                var inverseGlobalBindPose = new Laya.Matrix4x4(bindPoseDatas[i + 0], bindPoseDatas[i + 1], bindPoseDatas[i + 2], bindPoseDatas[i + 3], bindPoseDatas[i + 4], bindPoseDatas[i + 5], bindPoseDatas[i + 6], bindPoseDatas[i + 7], bindPoseDatas[i + 8], bindPoseDatas[i + 9], bindPoseDatas[i + 10], bindPoseDatas[i + 11], bindPoseDatas[i + 12], bindPoseDatas[i + 13], bindPoseDatas[i + 14], bindPoseDatas[i + 15], new Float32Array(bindPoseBuffer, i * 4, 16));
                LoadModelV04._mesh._inverseBindPoses[i / 16] = inverseGlobalBindPose;
            }
            return true;
        }
        static READ_SUBMESH() {
            var arrayBuffer = LoadModelV04._readData.__getBuffer();
            var subMesh = new SubMesh(LoadModelV04._mesh);
            LoadModelV04._readData.getInt16();
            LoadModelV04._readData.getUint32();
            LoadModelV04._readData.getUint32();
            var ibStart = LoadModelV04._readData.getUint32();
            var ibCount = LoadModelV04._readData.getUint32();
            var indexBuffer = LoadModelV04._mesh._indexBuffer;
            subMesh._indexBuffer = indexBuffer;
            subMesh._setIndexRange(ibStart, ibCount);
            var vertexBuffer = LoadModelV04._mesh._vertexBuffer;
            subMesh._vertexBuffer = vertexBuffer;
            var offset = LoadModelV04._DATA.offset;
            var subIndexBufferStart = subMesh._subIndexBufferStart;
            var subIndexBufferCount = subMesh._subIndexBufferCount;
            var boneIndicesList = subMesh._boneIndicesList;
            var drawCount = LoadModelV04._readData.getUint16();
            subIndexBufferStart.length = drawCount;
            subIndexBufferCount.length = drawCount;
            boneIndicesList.length = drawCount;
            var skinnedCache = LoadModelV04._mesh._skinnedMatrixCaches;
            var subMeshIndex = LoadModelV04._subMeshes.length;
            skinnedCache.length = LoadModelV04._mesh._inverseBindPoses.length;
            for (var i = 0; i < drawCount; i++) {
                subIndexBufferStart[i] = LoadModelV04._readData.getUint32();
                subIndexBufferCount[i] = LoadModelV04._readData.getUint32();
                var boneDicofs = LoadModelV04._readData.getUint32();
                var boneDicCount = LoadModelV04._readData.getUint32();
                var boneIndices = boneIndicesList[i] = new Uint16Array(arrayBuffer.slice(offset + boneDicofs, offset + boneDicofs + boneDicCount));
                var boneIndexCount = boneIndices.length;
                for (var j = 0; j < boneIndexCount; j++) {
                    var index = boneIndices[j];
                    skinnedCache[index] || (skinnedCache[index] = new skinnedMatrixCache(subMeshIndex, i, j));
                }
            }
            LoadModelV04._subMeshes.push(subMesh);
            return true;
        }
    }
    LoadModelV04._BLOCK = { count: 0 };
    LoadModelV04._DATA = { offset: 0, size: 0 };
    LoadModelV04._strings = [];

    class LoadModelV05 {
        static parse(readData, version, mesh, subMeshes) {
            LoadModelV05._mesh = mesh;
            LoadModelV05._subMeshes = subMeshes;
            LoadModelV05._version = version;
            LoadModelV05._readData = readData;
            LoadModelV05.READ_DATA();
            LoadModelV05.READ_BLOCK();
            LoadModelV05.READ_STRINGS();
            for (var i = 0, n = LoadModelV05._BLOCK.count; i < n; i++) {
                LoadModelV05._readData.pos = LoadModelV05._BLOCK.blockStarts[i];
                var index = LoadModelV05._readData.getUint16();
                var blockName = LoadModelV05._strings[index];
                var fn = LoadModelV05["READ_" + blockName];
                if (fn == null)
                    throw new Error("model file err,no this function:" + index + " " + blockName);
                else
                    fn.call(null);
            }
            LoadModelV05._strings.length = 0;
            LoadModelV05._readData = null;
            LoadModelV05._version = null;
            LoadModelV05._mesh = null;
            LoadModelV05._subMeshes = null;
        }
        static _readString() {
            return LoadModelV05._strings[LoadModelV05._readData.getUint16()];
        }
        static READ_DATA() {
            LoadModelV05._DATA.offset = LoadModelV05._readData.getUint32();
            LoadModelV05._DATA.size = LoadModelV05._readData.getUint32();
        }
        static READ_BLOCK() {
            var count = LoadModelV05._BLOCK.count = LoadModelV05._readData.getUint16();
            var blockStarts = LoadModelV05._BLOCK.blockStarts = [];
            var blockLengths = LoadModelV05._BLOCK.blockLengths = [];
            for (var i = 0; i < count; i++) {
                blockStarts.push(LoadModelV05._readData.getUint32());
                blockLengths.push(LoadModelV05._readData.getUint32());
            }
        }
        static READ_STRINGS() {
            var offset = LoadModelV05._readData.getUint32();
            var count = LoadModelV05._readData.getUint16();
            var prePos = LoadModelV05._readData.pos;
            LoadModelV05._readData.pos = offset + LoadModelV05._DATA.offset;
            for (var i = 0; i < count; i++)
                LoadModelV05._strings[i] = LoadModelV05._readData.readUTFString();
            LoadModelV05._readData.pos = prePos;
        }
        static READ_MESH() {
            var i;
            var memorySize = 0;
            LoadModelV05._readString();
            var reader = LoadModelV05._readData;
            var arrayBuffer = reader.__getBuffer();
            var vertexBufferCount = reader.getInt16();
            var offset = LoadModelV05._DATA.offset;
            for (i = 0; i < vertexBufferCount; i++) {
                var vbStart = offset + reader.getUint32();
                var vertexCount = reader.getUint32();
                var vertexFlag = LoadModelV05._readString();
                var vertexDeclaration = Laya.VertexMesh.getVertexDeclaration(vertexFlag, false);
                var vertexStride = vertexDeclaration.vertexStride;
                var vertexData;
                var floatData;
                var uint8Data;
                var subVertexFlags = vertexFlag.split(",");
                var subVertexCount = subVertexFlags.length;
                var mesh = LoadModelV05._mesh;
                switch (LoadModelV05._version) {
                    case "LAYAMODEL:05":
                    case "LAYAMODEL:0501":
                        vertexData = arrayBuffer.slice(vbStart, vbStart + vertexCount * vertexStride);
                        floatData = new Float32Array(vertexData);
                        uint8Data = new Uint8Array(vertexData);
                        break;
                    case "LAYAMODEL:COMPRESSION_05":
                    case "LAYAMODEL:COMPRESSION_0501":
                        vertexData = new ArrayBuffer(vertexStride * vertexCount);
                        floatData = new Float32Array(vertexData);
                        uint8Data = new Uint8Array(vertexData);
                        var lastPosition = reader.pos;
                        reader.pos = vbStart;
                        for (var j = 0; j < vertexCount; j++) {
                            var subOffset;
                            var verOffset = j * vertexStride;
                            for (var k = 0; k < subVertexCount; k++) {
                                switch (subVertexFlags[k]) {
                                    case "POSITION":
                                        subOffset = verOffset / 4;
                                        floatData[subOffset] = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                        floatData[subOffset + 1] = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                        floatData[subOffset + 2] = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                        verOffset += 12;
                                        break;
                                    case "NORMAL":
                                        subOffset = verOffset / 4;
                                        floatData[subOffset] = reader.getUint8() / 127.5 - 1;
                                        floatData[subOffset + 1] = reader.getUint8() / 127.5 - 1;
                                        floatData[subOffset + 2] = reader.getUint8() / 127.5 - 1;
                                        verOffset += 12;
                                        break;
                                    case "COLOR":
                                        subOffset = verOffset / 4;
                                        floatData[subOffset] = reader.getUint8() / 255;
                                        floatData[subOffset + 1] = reader.getUint8() / 255;
                                        floatData[subOffset + 2] = reader.getUint8() / 255;
                                        floatData[subOffset + 3] = reader.getUint8() / 255;
                                        verOffset += 16;
                                        break;
                                    case "UV":
                                        subOffset = verOffset / 4;
                                        floatData[subOffset] = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                        floatData[subOffset + 1] = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                        verOffset += 8;
                                        break;
                                    case "UV1":
                                        subOffset = verOffset / 4;
                                        floatData[subOffset] = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                        floatData[subOffset + 1] = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                        verOffset += 8;
                                        break;
                                    case "BLENDWEIGHT":
                                        subOffset = verOffset / 4;
                                        floatData[subOffset] = reader.getUint8() / 255;
                                        floatData[subOffset + 1] = reader.getUint8() / 255;
                                        floatData[subOffset + 2] = reader.getUint8() / 255;
                                        floatData[subOffset + 3] = reader.getUint8() / 255;
                                        verOffset += 16;
                                        break;
                                    case "BLENDINDICES":
                                        uint8Data[verOffset] = reader.getUint8();
                                        uint8Data[verOffset + 1] = reader.getUint8();
                                        uint8Data[verOffset + 2] = reader.getUint8();
                                        uint8Data[verOffset + 3] = reader.getUint8();
                                        verOffset += 4;
                                        break;
                                    case "TANGENT":
                                        subOffset = verOffset / 4;
                                        floatData[subOffset] = reader.getUint8() / 127.5 - 1;
                                        floatData[subOffset + 1] = reader.getUint8() / 127.5 - 1;
                                        floatData[subOffset + 2] = reader.getUint8() / 127.5 - 1;
                                        floatData[subOffset + 3] = reader.getUint8() / 127.5 - 1;
                                        verOffset += 16;
                                        break;
                                }
                            }
                        }
                        reader.pos = lastPosition;
                        break;
                }
                var vertexBuffer = Laya.LayaGL.renderOBJCreate.createVertexBuffer3D(vertexData.byteLength, Laya.BufferUsage.Static, true);
                vertexBuffer.vertexDeclaration = vertexDeclaration;
                vertexBuffer.setData(vertexData);
                var vertexCount = vertexBuffer._byteLength / vertexDeclaration.vertexStride;
                if (vertexCount > 65535)
                    mesh._indexFormat = Laya.IndexFormat.UInt32;
                else
                    mesh._indexFormat = Laya.IndexFormat.UInt16;
                mesh._vertexBuffer = vertexBuffer;
                mesh._vertexCount += vertexCount;
                memorySize += floatData.length * 4;
            }
            var ibStart = offset + reader.getUint32();
            var ibLength = reader.getUint32();
            var ibDatas;
            if (mesh.indexFormat == Laya.IndexFormat.UInt32)
                ibDatas = new Uint32Array(arrayBuffer.slice(ibStart, ibStart + ibLength));
            else
                ibDatas = new Uint16Array(arrayBuffer.slice(ibStart, ibStart + ibLength));
            var indexBuffer = Laya.LayaGL.renderOBJCreate.createIndexBuffer3D(mesh.indexFormat, ibDatas.length, Laya.BufferUsage.Static, true);
            indexBuffer.setData(ibDatas);
            mesh._indexBuffer = indexBuffer;
            mesh._setBuffer(mesh._vertexBuffer, indexBuffer);
            memorySize += indexBuffer.indexCount * 2;
            mesh._setCPUMemory(memorySize);
            mesh._setGPUMemory(memorySize);
            if (LoadModelV05._version == "LAYAMODEL:0501" || LoadModelV05._version == "LAYAMODEL:COMPRESSION_0501") {
                var bounds = mesh.bounds;
                var min = bounds.getMin();
                var max = bounds.getMax();
                min.setValue(reader.getFloat32(), reader.getFloat32(), reader.getFloat32());
                max.setValue(reader.getFloat32(), reader.getFloat32(), reader.getFloat32());
                bounds.setMin(min);
                bounds.setMax(max);
                mesh.bounds = bounds;
            }
            var boneNames = mesh._boneNames = [];
            var boneCount = reader.getUint16();
            boneNames.length = boneCount;
            for (i = 0; i < boneCount; i++)
                boneNames[i] = LoadModelV05._strings[reader.getUint16()];
            var bindPoseDataStart = reader.getUint32();
            var bindPoseDataLength = reader.getUint32();
            var bindPoseDatas = new Float32Array(arrayBuffer.slice(offset + bindPoseDataStart, offset + bindPoseDataStart + bindPoseDataLength));
            var bindPoseFloatCount = bindPoseDatas.length;
            var bindPoseBuffer = mesh._inverseBindPosesBuffer = new ArrayBuffer(bindPoseFloatCount * 4);
            mesh._inverseBindPoses = [];
            if (bindPoseFloatCount != 0)
                mesh._instanceBufferStateType = Mesh.MESH_INSTANCEBUFFER_TYPE_SIMPLEANIMATOR;
            else
                mesh._instanceBufferStateType = Mesh.MESH_INSTANCEBUFFER_TYPE_NORMAL;
            for (i = 0; i < bindPoseFloatCount; i += 16) {
                var inverseGlobalBindPose = new Laya.Matrix4x4(bindPoseDatas[i + 0], bindPoseDatas[i + 1], bindPoseDatas[i + 2], bindPoseDatas[i + 3], bindPoseDatas[i + 4], bindPoseDatas[i + 5], bindPoseDatas[i + 6], bindPoseDatas[i + 7], bindPoseDatas[i + 8], bindPoseDatas[i + 9], bindPoseDatas[i + 10], bindPoseDatas[i + 11], bindPoseDatas[i + 12], bindPoseDatas[i + 13], bindPoseDatas[i + 14], bindPoseDatas[i + 15], new Float32Array(bindPoseBuffer, i * 4, 16));
                mesh._inverseBindPoses[i / 16] = inverseGlobalBindPose;
            }
            return true;
        }
        static READ_SUBMESH() {
            var reader = LoadModelV05._readData;
            var arrayBuffer = reader.__getBuffer();
            var subMesh = new SubMesh(LoadModelV05._mesh);
            reader.getInt16();
            var ibStart = reader.getUint32();
            var ibCount = reader.getUint32();
            var indexBuffer = LoadModelV05._mesh._indexBuffer;
            subMesh._indexBuffer = indexBuffer;
            subMesh._setIndexRange(ibStart, ibCount);
            var vertexBuffer = LoadModelV05._mesh._vertexBuffer;
            subMesh._vertexBuffer = vertexBuffer;
            var offset = LoadModelV05._DATA.offset;
            var subIndexBufferStart = subMesh._subIndexBufferStart;
            var subIndexBufferCount = subMesh._subIndexBufferCount;
            var boneIndicesList = subMesh._boneIndicesList;
            var drawCount = reader.getUint16();
            subIndexBufferStart.length = drawCount;
            subIndexBufferCount.length = drawCount;
            boneIndicesList.length = drawCount;
            var skinnedCache = LoadModelV05._mesh._skinnedMatrixCaches;
            var subMeshIndex = LoadModelV05._subMeshes.length;
            skinnedCache.length = LoadModelV05._mesh._inverseBindPoses.length;
            for (var i = 0; i < drawCount; i++) {
                subIndexBufferStart[i] = reader.getUint32();
                subIndexBufferCount[i] = reader.getUint32();
                var boneDicofs = reader.getUint32();
                var boneDicCount = reader.getUint32();
                var boneIndices = boneIndicesList[i] = new Uint16Array(arrayBuffer.slice(offset + boneDicofs, offset + boneDicofs + boneDicCount));
                for (var j = 0, m = boneIndices.length; j < m; j++) {
                    var index = boneIndices[j];
                    skinnedCache[index] || (skinnedCache[index] = new skinnedMatrixCache(subMeshIndex, i, j));
                }
            }
            LoadModelV05._subMeshes.push(subMesh);
            return true;
        }
        static READ_UVSIZE() {
            LoadModelV05._mesh._width = LoadModelV05._readData.readUint16();
            LoadModelV05._mesh._height = LoadModelV05._readData.readUint16();
        }
    }
    LoadModelV05._BLOCK = { count: 0 };
    LoadModelV05._DATA = { offset: 0, size: 0 };
    LoadModelV05._strings = [];

    class MeshReader {
        static _parse(data) {
            var mesh = new Mesh();
            MeshReader.read(data, mesh, mesh._subMeshes);
            return mesh;
        }
        static read(data, mesh, subMeshes) {
            var readData = new Laya.Byte(data);
            readData.pos = 0;
            var version = readData.readUTFString();
            switch (version) {
                case "LAYAMODEL:0301":
                case "LAYAMODEL:0400":
                case "LAYAMODEL:0401":
                    LoadModelV04.parse(readData, version, mesh, subMeshes);
                    break;
                case "LAYAMODEL:05":
                case "LAYAMODEL:COMPRESSION_05":
                case "LAYAMODEL:0501":
                case "LAYAMODEL:COMPRESSION_0501":
                    LoadModelV05.parse(readData, version, mesh, subMeshes);
                    break;
                default:
                    throw new Error("MeshReader: unknown mesh version.");
            }
            mesh._setSubMeshes(subMeshes);
            if (version != "LAYAMODEL:0501" && version != "LAYAMODEL:COMPRESSION_0501")
                mesh.calculateBounds();
        }
    }

    class MeshLoader {
        load(task) {
            let url = Laya.AssetDb.inst.getSubAssetURL(task.url, task.uuid, null, "lm");
            return task.loader.fetch(url, "arraybuffer", task.progress.createCallback(), task.options).then(data => {
                if (!data)
                    return null;
                return MeshReader._parse(data);
            });
        }
    }
    Laya.Loader.registerLoader(["lm"], MeshLoader, Laya.Loader.MESH);

    class HierarchyParserV2 {
        static _createSprite3DInstance(nodeData, spriteMap, outBatchSprites) {
            let node;
            switch (nodeData.type) {
                case "Scene3D":
                    node = new Scene3D();
                    break;
                case "Sprite3D":
                    node = new Sprite3D();
                    break;
                case "MeshSprite3D":
                    node = new MeshSprite3D();
                    (outBatchSprites && nodeData.props.isStatic) && (outBatchSprites.push(node));
                    break;
                case "SkinnedMeshSprite3D":
                    node = new SkinnedMeshSprite3D();
                    break;
                case "SimpleSkinnedMeshSprite3D":
                    node = new SimpleSkinnedMeshSprite3D();
                    break;
                case "ShuriKenParticle3D":
                    node = new ShuriKenParticle3D();
                    break;
                case "Camera":
                    node = new Camera();
                    break;
                case "DirectionLight":
                    node = new DirectionLight();
                    break;
                case "PointLight":
                    node = new PointLight();
                    break;
                case "SpotLight":
                    node = new SpotLight();
                    break;
                case "TrailSprite3D":
                    node = new TrailSprite3D();
                    break;
                case "ReflectionProbe":
                    node = new Sprite3D();
                    node.addComponent(ReflectionProbe);
                    break;
                default:
                    throw new Error("Utils3D:unidentified class type in (.lh) file.");
            }
            let childData = nodeData.child;
            if (childData) {
                for (let i = 0, n = childData.length; i < n; i++) {
                    let child = HierarchyParserV2._createSprite3DInstance(childData[i], spriteMap, outBatchSprites);
                    node.addChild(child);
                }
            }
            spriteMap[nodeData.instanceID] = node;
            return node;
        }
        static _createComponentInstance(nodeData, spriteMap, interactMap) {
            let node = spriteMap[nodeData.instanceID];
            node._parse(nodeData.props, spriteMap);
            let childData = nodeData.child;
            if (childData) {
                for (let i = 0, n = childData.length; i < n; i++)
                    HierarchyParserV2._createComponentInstance(childData[i], spriteMap, interactMap);
            }
            let componentsData = nodeData.components;
            if (componentsData) {
                for (let j = 0, m = componentsData.length; j < m; j++) {
                    let data = componentsData[j];
                    let cls = Laya.ClassUtils.getClass(data.type);
                    if (cls) {
                        let component = node.addComponent(cls);
                        component._parse(data, interactMap);
                    }
                    else {
                        console.warn(`Unidentified component type: ${data.type}.`);
                    }
                }
            }
        }
        static _createNodeByJson02(nodeData, outBatchSprites) {
            let spriteMap = {};
            let interactMap = { component: [], data: [] };
            let node = HierarchyParserV2._createSprite3DInstance(nodeData, spriteMap, outBatchSprites);
            HierarchyParserV2._createComponentInstance(nodeData, spriteMap, interactMap);
            HierarchyParserV2._createInteractInstance(interactMap, spriteMap);
            return node;
        }
        static _createInteractInstance(interatMap, spriteMap) {
            let components = interatMap.component;
            let data = interatMap.data;
            for (let i = 0, n = components.length; i < n; i++) {
                components[i]._parseInteractive(data[i], spriteMap);
            }
        }
        static parse(data) {
            let json = data.data;
            let outBatchSprits = [];
            let sprite;
            switch (data.version) {
                case "LAYAHIERARCHY:02":
                case "LAYASCENE3D:02":
                    sprite = HierarchyParserV2._createNodeByJson02(json, outBatchSprits);
                    break;
                default:
                    sprite = HierarchyParserV2._createNodeByJson(json, outBatchSprits);
            }
            return sprite;
        }
        static _createNodeByJson(nodeData, outBatchSprites) {
            let node;
            switch (nodeData.type) {
                case "Scene3D":
                    node = new Scene3D();
                    break;
                case "Sprite3D":
                    node = new Sprite3D();
                    break;
                case "MeshSprite3D":
                    node = new MeshSprite3D();
                    (outBatchSprites && nodeData.props.isStatic) && (outBatchSprites.push(node));
                    break;
                case "SkinnedMeshSprite3D":
                    node = new SkinnedMeshSprite3D();
                    break;
                case "ShuriKenParticle3D":
                    node = new ShuriKenParticle3D();
                    break;
                case "Camera":
                    node = new Camera();
                    break;
                case "DirectionLight":
                    node = new DirectionLight();
                    break;
                case "PointLight":
                    node = new PointLight();
                    break;
                case "SpotLight":
                    node = new SpotLight();
                    break;
                case "TrailSprite3D":
                    node = new TrailSprite3D();
                    break;
                default:
                    throw new Error(`Unidentified node type ${nodeData.type}`);
            }
            let childData = nodeData.child;
            if (childData) {
                for (let i = 0, n = childData.length; i < n; i++) {
                    let child = HierarchyParserV2._createNodeByJson(childData[i], outBatchSprites);
                    node.addChild(child);
                }
            }
            let componentsData = nodeData.components;
            if (componentsData) {
                for (let j = 0, m = componentsData.length; j < m; j++) {
                    let data = componentsData[j];
                    let clas = Laya.ClassUtils.getClass(data.type);
                    if (clas) {
                        let component = node.addComponent(clas);
                        component._parse(data);
                    }
                    else {
                        console.warn(`Unidentified component type: ${data.type}.`);
                    }
                }
            }
            node._parse(nodeData.props, null);
            return node;
        }
        static collectResourceLinks(data, basePath) {
            let test = {};
            let innerUrls = [];
            function addInnerUrl(url, type, constructParams, propertyParams) {
                let url2 = test[url];
                if (url2 === undefined) {
                    url2 = Laya.URL.join(basePath, url);
                    innerUrls.push({ url: url2, type: type, constructParams: constructParams, propertyParams: propertyParams });
                    test[url] = url2;
                }
                return url2;
            }
            function check(nodeData) {
                let props = nodeData.props;
                switch (nodeData.type) {
                    case "Scene3D":
                        let lightmaps = props.lightmaps;
                        if (lightmaps) {
                            for (let i = 0, n = lightmaps.length; i < n; i++) {
                                let lightMap = lightmaps[i];
                                if (lightMap.path) {
                                    lightMap.path = addInnerUrl(lightMap.path, Laya.Loader.TEXTURE2D, lightMap.constructParams, lightMap.propertyParams);
                                }
                                else {
                                    let lightmapColorData = lightMap.color;
                                    lightmapColorData.path = addInnerUrl(lightmapColorData.path, Laya.Loader.TEXTURE2D, lightmapColorData.constructParams, lightmapColorData.propertyParams);
                                    let lightmapDirectionData = lightMap.direction;
                                    if (lightmapDirectionData)
                                        lightmapDirectionData.path = addInnerUrl(lightmapDirectionData.path, Laya.Loader.TEXTURE2D, lightmapDirectionData.constructParams, lightmapDirectionData.propertyParams);
                                }
                            }
                        }
                        let reflectionTextureData = props.reflectionTexture;
                        (reflectionTextureData) && (props.reflection = addInnerUrl(reflectionTextureData, Laya.Loader.TEXTURECUBE));
                        let reflectionData = props.reflection;
                        (reflectionData) && (props.reflection = addInnerUrl(reflectionData, Laya.Loader.TEXTURECUBE));
                        if (props.sky) {
                            let skyboxMaterial = props.sky.material;
                            (skyboxMaterial) && (skyboxMaterial.path = addInnerUrl(skyboxMaterial.path, Laya.Loader.MATERIAL));
                        }
                        break;
                    case "Camera":
                        let skyboxMatData = props.skyboxMaterial;
                        (skyboxMatData) && (skyboxMatData.path = addInnerUrl(skyboxMatData.path, Laya.Loader.MATERIAL));
                        break;
                    case "TrailSprite3D":
                    case "MeshSprite3D":
                    case "SkinnedMeshSprite3D":
                    case "SimpleSkinnedMeshSprite3D":
                        let meshPath = props.meshPath;
                        (meshPath) && (props.meshPath = addInnerUrl(meshPath, Laya.Loader.MESH));
                        let materials = props.materials;
                        if (materials)
                            for (let i = 0, n = materials.length; i < n; i++)
                                materials[i].path = addInnerUrl(materials[i].path, Laya.Loader.MATERIAL);
                        if (nodeData.type == "SimpleSkinnedMeshSprite3D")
                            if (props.animatorTexture)
                                props.animatorTexture = addInnerUrl(props.animatorTexture, Laya.Loader.TEXTURE2D);
                        break;
                    case "ShuriKenParticle3D":
                        if (props.main) {
                            let resources = props.renderer.resources;
                            let mesh = resources.mesh;
                            let material = resources.material;
                            (mesh) && (resources.mesh = addInnerUrl(mesh, Laya.Loader.MESH));
                            (material) && (resources.material = addInnerUrl(material, Laya.Loader.MATERIAL));
                        }
                        else {
                            let parMeshPath = props.meshPath;
                            (parMeshPath) && (props.meshPath = addInnerUrl(parMeshPath, Laya.Loader.MESH));
                            props.material.path = addInnerUrl(props.material.path, Laya.Loader.MATERIAL);
                        }
                        break;
                    case "Terrain":
                        addInnerUrl(props.dataPath, Laya.Loader.TERRAINRES);
                        break;
                    case "ReflectionProbe":
                        let reflection = props.reflection;
                        (reflection) && (props.reflection = addInnerUrl(reflection, Laya.Loader.TEXTURECUBE));
                        break;
                }
                let components = nodeData.components;
                if (components) {
                    for (let k = 0, p = components.length; k < p; k++) {
                        let component = components[k];
                        switch (component.type) {
                            case "Animator":
                                let clipPaths = component.clipPaths;
                                if (!clipPaths) {
                                    let layersData = component.layers;
                                    for (let i = 0; i < layersData.length; i++) {
                                        let states = layersData[i].states;
                                        for (let j = 0, m = states.length; j < m; j++) {
                                            let clipPath = states[j].clipPath;
                                            (clipPath) && (states[j].clipPath = addInnerUrl(clipPath, Laya.Loader.ANIMATIONCLIP));
                                        }
                                    }
                                }
                                else {
                                    for (let i = 0, n = clipPaths.length; i < n; i++)
                                        clipPaths[i] = addInnerUrl(clipPaths[i], Laya.Loader.ANIMATIONCLIP);
                                }
                                break;
                            case "PhysicsCollider":
                            case "Rigidbody3D":
                            case "CharacterController":
                                let shapes = component.shapes;
                                for (let i = 0; i < shapes.length; i++) {
                                    let shape = shapes[i];
                                    if (shape.type === "MeshColliderShape") {
                                        let mesh = shape.mesh;
                                        (mesh) && (shape.mesh = addInnerUrl(mesh, Laya.Loader.MESH));
                                    }
                                }
                                break;
                        }
                    }
                }
                let children = nodeData.child;
                if (!children)
                    return;
                for (let i = 0, n = children.length; i < n; i++)
                    check(children[i]);
            }
            check(data.data);
            return innerUrls;
        }
    }
    Laya.HierarchyLoader.v2 = HierarchyParserV2;

    class AvatarMaskLoader {
        load(task) {
            return task.loader.fetch(task.url, "json", task.progress.createCallback(), task.options).then(data => {
                if (!data)
                    return null;
                return new AvatarMask(data);
            });
        }
    }
    Laya.Loader.registerLoader(["lavm"], AvatarMaskLoader);

    class ParseJSON {
        static parse(str) {
            return this.parseStart(str);
        }
        static findIndex(str, i, fstr, len) {
            var fi = str.indexOf(fstr, i + 1);
            if (0 > fi) {
                fi = len;
            }
            return { str: str.substring(i + 1, fi), i: fi };
        }
        static finCurrObj() {
            this.type = 1;
            if (null == this.cobj) {
                return null;
            }
            if (0 == this.currArr.length) {
                if (this.cobj.k) {
                    this.ret[this.cobj.k] = this.cobj.val;
                }
                return null;
            }
            else {
                var pobj = this.currArr.pop();
                if (this.cobj.k) {
                    if (Array.isArray(pobj.val)) {
                        if (null != this.cobj.k) {
                            var obj = {};
                            obj[this.cobj.k] = this.cobj.val;
                            pobj.val.push(obj);
                        }
                    }
                    else {
                        pobj.val[this.cobj.k] = this.cobj.val;
                    }
                }
                else if (Array.isArray(this.cobj.val)) {
                    if (Array.isArray(pobj.val)) {
                        pobj.val.push(this.cobj.val);
                    }
                    else {
                        pobj.val = this.cobj.val;
                    }
                }
                else ;
                return pobj;
            }
        }
        static formatVal(str) {
            if (null == str) {
                return null;
            }
            var numVal = Number(str);
            if (!isNaN(numVal)) {
                return numVal;
            }
            if ("false" == str.toLowerCase()) {
                return false;
            }
            else if ("true" == str.toLowerCase()) {
                return true;
            }
            else if ("null" == str) {
                return null;
            }
            return str;
        }
        static finCurrStr() {
            if (null != this.currStr) {
                this.currStr = this.currStr.trim();
                if ("" != this.currStr) {
                    if (null != this.cobj) {
                        if (Array.isArray(this.cobj.val)) {
                            this.cobj.val.push(this.formatVal(this.currStr));
                        }
                        else {
                            this.cobj.val = this.formatVal(this.currStr);
                            this.cobj = this.finCurrObj();
                        }
                    }
                    this.currStr = "";
                }
            }
        }
        static parseStart(str) {
            this.len = str.length;
            var i = 0;
            this.ret = {};
            this.currStr = null;
            this.currArr = [];
            this.cobj = null;
            this.type = 0;
            while (i < this.len) {
                var c = str.charAt(i);
                if ("/" == c) {
                    if (i + 1 < this.len) {
                        i += 1;
                        var cNext = str.charAt(i);
                        var cstr = null;
                        if ("/" == cNext) {
                            cstr = "\n";
                        }
                        else if ("*" == cNext) {
                            cstr = "*/";
                        }
                        if (null != cstr) {
                            this.finCurrStr();
                            var fi = str.indexOf(cstr, i);
                            if (0 > fi) {
                                console.log("没有找到注释结尾，应该是一直注释到最后了");
                                i = this.len;
                            }
                            else {
                                i = fi + cstr.length - 1;
                            }
                        }
                    }
                }
                else if ("}" == c) {
                    if (null != this.cobj) {
                        this.finCurrStr();
                        if (null != this.cobj) {
                            this.cobj = this.finCurrObj();
                        }
                    }
                    this.currStr = "";
                    this.type = 1;
                }
                else if ("{" == c) {
                    this.currStr = "";
                    this.type = 1;
                }
                else if ("'" == c || "\"" == c || "‘" == c || "“" == c) {
                    if ("‘" == c) {
                        c = "’";
                    }
                    else if ("“" == c) {
                        c = "”";
                    }
                    var obj = this.findIndex(str, i, c, this.len);
                    if (2 == this.type && null != this.cobj && Array.isArray(this.cobj.val)) {
                        if (null != this.currStr) {
                            this.currStr = this.currStr.trim();
                            if ("" != this.currStr) {
                                this.cobj.val.push(this.formatVal(this.currStr));
                            }
                        }
                        this.cobj.val.push(obj.str);
                        this.currStr = "";
                    }
                    else if (null != this.currStr) {
                        this.currStr += obj.str;
                    }
                    i = obj.i;
                }
                else if (";" == c || "," == c || "\n" == c) {
                    this.finCurrStr();
                }
                else if ("]" == c) {
                    if (null != this.currStr && null != this.cobj && Array.isArray(this.cobj.val)) {
                        this.currStr = this.currStr.trim();
                        if ("" != this.currStr) {
                            this.cobj.val.push(this.formatVal(this.currStr));
                        }
                    }
                    if (null != this.cobj) {
                        this.cobj = this.finCurrObj();
                        this.cobj = this.finCurrObj();
                    }
                    this.currStr = "";
                }
                else if ("[" == c) {
                    if (2 != this.type) {
                        console.warn("没有key值，忽略掉一个数组");
                    }
                    else {
                        if (null != this.cobj) {
                            this.currArr.push(this.cobj);
                        }
                        this.cobj = { val: [] };
                    }
                }
                else if (":" == c) {
                    if (null != this.currStr && 1 == this.type) {
                        this.type = 2;
                        if (null != this.cobj) {
                            this.currArr.push(this.cobj);
                        }
                        if (null != this.cobj && Array.isArray(this.cobj.val)) {
                            var pcobj = this.cobj;
                            this.cobj = { val: {} };
                            pcobj.val.push(this.cobj.val);
                            this.currArr.push(this.cobj);
                        }
                        this.cobj = { k: this.currStr.trim(), val: {} };
                        this.currStr = "";
                    }
                }
                else if (null != this.currStr) {
                    this.currStr += c;
                }
                i++;
            }
            return this.ret;
        }
    }

    const CGBlock = ["GLSL Start", "GLSL End"];
    const split = ["#defineGLSL", "#endGLSL"];
    const shaderBlock = ["Shader3D Start", "Shader3D End"];
    const shaderDataOBJ = {
        "Color": Laya.ShaderDataType.Color,
        "Int": Laya.ShaderDataType.Int,
        "Bool": Laya.ShaderDataType.Bool,
        "Float": Laya.ShaderDataType.Float,
        "Vector2": Laya.ShaderDataType.Vector2,
        "Vector3": Laya.ShaderDataType.Vector3,
        "Vector4": Laya.ShaderDataType.Vector4,
        "Matrix4x4": Laya.ShaderDataType.Matrix4x4,
        "Texture2D": Laya.ShaderDataType.Texture2D,
        "TextureCube": Laya.ShaderDataType.TextureCube,
    };
    class ShaderParser {
        static parse(data, basePath) {
            let obj = ShaderParser.getShaderBlock(data);
            let cgmap = ShaderParser.getCGBlock(data);
            ShaderParser.bindCG(obj, cgmap);
            let shader = Laya.Shader3D.parse(obj, basePath);
            return shader;
        }
        static compileToTree(sliceFlag, data, sliceIndex) {
            if (sliceIndex == sliceFlag.length)
                return [data];
            let slicedata = sliceFlag[sliceIndex];
            let splitmap = data.split(slicedata);
            if (splitmap.length == 1)
                return splitmap;
            let map = [];
            for (let i = 0, n = splitmap.length; i < n; i++) {
                map = map.concat(ShaderParser.compileToTree(sliceFlag, splitmap[i], sliceIndex + 1));
                (i != n - 1) && map.push(slicedata);
            }
            return map;
        }
        static getMapKey(value) {
            let index = value.indexOf("\n");
            value = value.slice(0, index).replace("\r", "");
            value = value.slice(0, index).replace(" ", "");
            value = value.trim();
            return value;
        }
        static getShaderBlock(source) {
            let shaderData = source.substring(source.indexOf(shaderBlock[0]) + shaderBlock[0].length, source.indexOf(shaderBlock[1]));
            let shaderObj;
            try {
                shaderObj = ParseJSON.parse(shaderData);
            }
            catch (_a) {
                console.error("Shader describe Data error");
            }
            return shaderObj;
        }
        static getCGBlock(source) {
            let cgdata = source.substring(source.indexOf(CGBlock[0]), source.indexOf(CGBlock[1]));
            let map = ShaderParser.compileToTree(split, cgdata, 0);
            let cgmap = {};
            for (let i = 0, n = map.length; i < n; i++) {
                let value = map[i];
                if (value == split[0]) {
                    i += 1;
                    let datavalue = map[i];
                    let key = ShaderParser.getMapKey(datavalue);
                    cgmap[key] = datavalue.slice(datavalue.indexOf("\n"), datavalue.length - 1);
                }
            }
            return cgmap;
        }
        static bindCG(shaderObj, cgmap) {
            let passArray = shaderObj.shaderPass;
            if (passArray) {
                passArray.forEach(element => {
                    if (element.VS) {
                        element.VS = cgmap[element.VS];
                    }
                    if (element.FS) {
                        element.FS = cgmap[element.FS];
                    }
                });
            }
            let attributemap = shaderObj.attributeMap;
            if (attributemap) {
                let indexofAttribute = 0;
                for (let i in attributemap) {
                    if (attributemap[i] instanceof Array) {
                        let dataArray = attributemap[i];
                        attributemap[i] = [dataArray[1], ShaderParser.getShaderDataType(dataArray[0])];
                    }
                    else {
                        attributemap[i] = [indexofAttribute, ShaderParser.getShaderDataType(attributemap[i])];
                        indexofAttribute++;
                    }
                }
            }
            let uniformMap = shaderObj.uniformMap;
            if (uniformMap) {
                let defaultmap = {};
                shaderObj.defaultValue = defaultmap;
                let newUniformMap = {};
                shaderObj.uniformMap = newUniformMap;
                for (let k in uniformMap) {
                    let entry = uniformMap[k];
                    if (entry.serializable === false)
                        continue;
                    let dataType = ShaderParser.getShaderDataType(entry.type);
                    if (entry.default != null)
                        defaultmap[k] = ShaderParser.getDefaultData(dataType, entry.default);
                    if (entry.block) {
                        let block = newUniformMap[entry.block];
                        if (!block)
                            newUniformMap[entry.block] = block = {};
                        block[k] = dataType;
                    }
                    else
                        newUniformMap[k] = dataType;
                }
            }
        }
        static getShaderDataType(value) {
            return shaderDataOBJ[value];
        }
        static getDefaultData(type, data) {
            switch (type) {
                case Laya.ShaderDataType.Int:
                case Laya.ShaderDataType.Float:
                case Laya.ShaderDataType.Bool:
                    return data;
                case Laya.ShaderDataType.Vector2:
                    return new Laya.Vector2(data[0], data[1]);
                case Laya.ShaderDataType.Vector3:
                    return new Laya.Vector3(data[0], data[1], data[2]);
                case Laya.ShaderDataType.Vector4:
                    return new Laya.Vector4(data[0], data[1], data[2], data[3]);
                case Laya.ShaderDataType.Color:
                    return new Laya.Color(data[0], data[1], data[2], data[3]);
                case Laya.ShaderDataType.Matrix4x4:
                    let mat = new Laya.Matrix4x4();
                    mat.cloneByArray(data);
                    return mat;
                case Laya.ShaderDataType.Texture2D:
                    let tex = Laya.Texture2D.whiteTexture;
                    if (data == "write")
                        tex = Laya.Texture2D.whiteTexture;
                    else if (data == "black")
                        tex = Laya.Texture2D.blackTexture;
                    else if (data == "gray")
                        tex = Laya.Texture2D.grayTexture;
                    else if (data == "normal")
                        tex = Laya.Texture2D.normalTexture;
                    return tex;
                case Laya.ShaderDataType.TextureCube:
                    let texcube = TextureCube.grayTexture;
                    if (data == "write")
                        texcube = TextureCube.whiteTexture;
                    else if (data == "black")
                        texcube = TextureCube.blackTexture;
                    else if (data == "gray")
                        texcube = TextureCube.grayTexture;
                    return texcube;
            }
        }
    }

    class ShaderLoader {
        load(task) {
            let url = task.url;
            if (task.ext === "bps")
                url = Laya.AssetDb.inst.getSubAssetURL(url, task.uuid, "0", "shader");
            return task.loader.fetch(url, "text", task.progress.createCallback(), task.options).then(data => {
                if (!data)
                    return null;
                let obj = ShaderParser.getShaderBlock(data);
                let cgmap = ShaderParser.getCGBlock(data);
                ShaderParser.bindCG(obj, cgmap);
                if (!obj.name || !obj.uniformMap)
                    return null;
                let basePath = Laya.URL.getPath(task.url);
                let passArray = obj.shaderPass;
                return Promise.all(passArray.map(pass => Laya.ShaderCompile.compileAsync(pass.VS, pass.FS, basePath))).then(compiledObjs => {
                    if (compiledObjs.findIndex(obj => obj == null) != -1) {
                        console.warn("some pass null");
                        return null;
                    }
                    let shader = Laya.Shader3D.add(obj.name, obj.enableInstancing, obj.supportReflectionProbe);
                    let subshader = new Laya.SubShader(obj.attributeMap ? obj.attributeMap : Laya.SubShader.DefaultAttributeMap, obj.uniformMap, obj.defaultValue);
                    shader.addSubShader(subshader);
                    for (let i in passArray) {
                        subshader._addShaderPass(compiledObjs[i], passArray[i].pipeline);
                    }
                    return shader;
                });
            });
        }
    }
    Laya.Loader.registerLoader(["shader", "bps"], ShaderLoader);

    class GLSLLoader {
        load(task) {
            let url = task.url;
            return task.loader.fetch(url, "text", task.progress.createCallback(), task.options).then(data => {
                if (!data)
                    return null;
                return Laya.ShaderCompile.addInclude(task.url, data, true);
            });
        }
    }
    Laya.Loader.registerLoader(["glsl", "vs", "fs"], GLSLLoader);

    class AnimationControllerLoader {
        load(task) {
            return task.loader.fetch(task.url, "json", task.progress.createCallback(0.2), task.options).then(data => {
                let ret = task.ext == "controller" ? new AnimatorController(data) : new Laya.AnimatorController2D(data);
                if (ret && ret.data && ret.data.controllerLayers) {
                    let layers = ret.data.controllerLayers;
                    let promises = [];
                    for (let i = layers.length - 1; i >= 0; i--) {
                        let states = layers[i].states;
                        this.loadStates(states, promises, task);
                    }
                    return Promise.all(promises).then(() => ret);
                }
                else
                    return ret;
            });
        }
        loadStates(states, promises, task) {
            let basePath = Laya.URL.getPath(task.url);
            for (let j = states.length - 1; j >= 0; j--) {
                if (states[j].clip && states[j].clip._$uuid) {
                    let url = Laya.URL.getResURLByUUID(states[j].clip._$uuid);
                    if (!url.startsWith("res://"))
                        url = Laya.URL.join(basePath, url);
                    promises.push(task.loader.load(url).then(res => {
                        states[j].clip = res;
                    }));
                }
                if (states[j].states) {
                    this.loadStates(states[j].states, promises, task);
                }
            }
        }
    }
    Laya.Loader.registerLoader(["controller"], AnimationControllerLoader, "AnimationController");
    Laya.Loader.registerLoader(["mcc"], AnimationControllerLoader, "AnimationController2D");

    let c$1 = Laya.ClassUtils.regClass;
    c$1("Sprite3D", Sprite3D);
    c$1("Scene3D", Scene3D);
    c$1("Camera", Camera);
    c$1("LightSprite", LightSprite);
    c$1("DirectionLight", DirectionLight);
    c$1("PointLight", PointLight);
    c$1("SpotLight", SpotLight);
    c$1("AreaLightCom", AreaLightCom);
    c$1("DirectionLightCom", DirectionLightCom);
    c$1("PointLightCom", PointLightCom);
    c$1("SpotLightCom", SpotLightCom);
    c$1("RenderableSprite3D", RenderableSprite3D);
    c$1("MeshSprite3D", MeshSprite3D);
    c$1("MeshFilter", MeshFilter);
    c$1("BaseRender", BaseRender);
    c$1("MeshRenderer", MeshRenderer);
    c$1("SimpleSkinnedMeshSprite3D", SimpleSkinnedMeshSprite3D);
    c$1("SkinnedMeshSprite3D", SkinnedMeshSprite3D);
    c$1("SkinnedMeshRenderer", SkinnedMeshRenderer);
    c$1("SimpleSkinnedMeshRenderer", SimpleSkinnedMeshRenderer);
    c$1("SkyRenderer", SkyRenderer);
    c$1("TrailSprite3D", TrailSprite3D);
    c$1("TrailFilter", TrailFilter);
    c$1("TrailRenderer", TrailRenderer);
    c$1("PixelLineRenderer", PixelLineRenderer);
    c$1("PixelLineData", PixelLineData);
    c$1("Gradient", Gradient);
    c$1("Transform3D", Transform3D);
    c$1("Lightmap", Lightmap);
    c$1("ReflectionProbe", ReflectionProbe);
    c$1("StaticBatchVolume", StaticBatchVolume);
    c$1("StaticInstanceBatchRender", StaticInstanceBatchRender);
    c$1("SphericalHarmonicsL2", SphericalHarmonicsL2);
    c$1("Viewport", Viewport);
    c$1("Bounds", Bounds);
    c$1("BoundBox", BoundBox);
    c$1("TextureCube", TextureCube);
    c$1("Mesh", Mesh);
    c$1("FloatKeyframe", FloatKeyframe);
    c$1("RenderTexture", Laya.RenderTexture);
    c$1("Animator", Animator);
    c$1("AnimatorController", AnimatorController);
    c$1("AnimatorControllerLayer", AnimatorControllerLayer);
    c$1("AnimatorState", AnimatorState);
    c$1("AnimationClip", AnimationClip);
    c$1("AvatarMask", AvatarMask);
    c$1("Material", Material);
    c$1("BlinnPhongMaterial", BlinnPhongMaterial);
    c$1("EffectMaterial", EffectMaterial);
    c$1("ExtendTerrainMaterial", ExtendTerrainMaterial);
    c$1("PBRStandardMaterial", PBRStandardMaterial);
    c$1("SkyBoxMaterial", SkyBoxMaterial);
    c$1("SkyPanoramicMaterial", SkyPanoramicMaterial);
    c$1("SkyProceduralMaterial", SkyProceduralMaterial);
    c$1("UnlitMaterial", UnlitMaterial);
    c$1("WaterPrimaryMaterial", WaterPrimaryMaterial);
    c$1("ShurikenParticleMaterial", ShurikenParticleMaterial);
    c$1("TrailMaterial", TrailMaterial);
    c$1("ShuriKenParticle3D", ShuriKenParticle3D);
    c$1("ShurikenParticleRenderer", ShurikenParticleRenderer);
    c$1("ShurikenParticleSystem", ShurikenParticleSystem);
    c$1("Burst", Burst);
    c$1("Emission", Emission);
    c$1("BaseShape", BaseShape);
    c$1("BoxShape", BoxShape);
    c$1("CircleShape", CircleShape);
    c$1("ConeShape", ConeShape);
    c$1("HemisphereShape", HemisphereShape);
    c$1("SphereShape", SphereShape);
    c$1("FrameOverTime", FrameOverTime);
    c$1("GradientAngularVelocity", GradientAngularVelocity);
    c$1("GradientColor", GradientColor);
    c$1("GradientDataInt", GradientDataInt);
    c$1("GradientDataNumber", GradientDataNumber);
    c$1("GradientSize", GradientSize);
    c$1("GradientVelocity", GradientVelocity);
    c$1("StartFrame", StartFrame);
    c$1("TextureSheetAnimation", TextureSheetAnimation);
    c$1("ColorOverLifetime", ColorOverLifetime);
    c$1("RotationOverLifetime", RotationOverLifetime);
    c$1("SizeOverLifetime", SizeOverLifetime);
    c$1("VelocityOverLifetime", VelocityOverLifetime);
    c$1("LODInfo", LODInfo);
    c$1("LODGroup", LODGroup);
    c$1("DirectionLight", DirectionLight);
    c$1("DirectionLightCom", DirectionLightCom);
    c$1("MeshRenderer", MeshRenderer);
    c$1("MeshFilter", MeshFilter);
    c$1("MeshRenderer", MeshRenderer);
    c$1("SkinnedMeshRenderer", SkinnedMeshRenderer);
    c$1("SimpleSkinnedMeshRenderer", SimpleSkinnedMeshRenderer);
    c$1("SkyRenderer", SkyRenderer);
    c$1("BoxColliderShape", BoxColliderShape);
    c$1("CapsuleColliderShape", CapsuleColliderShape);
    c$1("ConeColliderShape", ConeColliderShape);
    c$1("CylinderColliderShape", CylinderColliderShape);
    c$1("SphereColliderShape", SphereColliderShape);
    c$1("MeshColliderShape", MeshColliderShape);
    c$1("CompoundColliderShape", CompoundColliderShape);
    c$1("PostProcess", PostProcess);
    c$1("PostProcessEffect", PostProcessEffect);
    c$1("BloomEffect", BloomEffect);
    c$1("GaussianDoF", GaussianDoF);
    c$1("ScalableAO", ScalableAO);
    c$1("ColorGradEffect", ColorGradEffect);

    class SubMeshInstanceBatch extends GeometryElement {
        constructor() {
            super(Laya.MeshTopology.Triangles, Laya.DrawType.DrawElementInstance);
            this.instanceWorldMatrixData = new Float32Array(SubMeshInstanceBatch.maxInstanceCount * 16);
            this.instanceSimpleAnimatorData = new Float32Array(SubMeshInstanceBatch.maxInstanceCount * 4);
            this.indexFormat = Laya.IndexFormat.UInt16;
            this.instanceWorldMatrixBuffer = Laya.LayaGL.renderOBJCreate.createVertexBuffer3D(this.instanceWorldMatrixData.length * 4, Laya.BufferUsage.Dynamic, false);
            this.instanceWorldMatrixBuffer.vertexDeclaration = Laya.VertexMesh.instanceWorldMatrixDeclaration;
            this.instanceWorldMatrixBuffer.instanceBuffer = true;
            this.instanceSimpleAnimatorBuffer = Laya.LayaGL.renderOBJCreate.createVertexBuffer3D(this.instanceSimpleAnimatorData.length * 4, Laya.BufferUsage.Dynamic, false);
            this.instanceSimpleAnimatorBuffer.vertexDeclaration = Laya.VertexMesh.instanceSimpleAnimatorDeclaration;
            this.instanceSimpleAnimatorBuffer.instanceBuffer = true;
        }
        static __init__() {
            SubMeshInstanceBatch.instance = new SubMeshInstanceBatch();
        }
        _updateRenderParams(state) {
            var element = state.renderElement;
            var subMesh = element.instanceSubMesh;
            var count = element.instanceBatchElementList.length;
            var indexCount = subMesh._indexCount;
            this.clearRenderParams();
            this.bufferState = subMesh._mesh._instanceBufferState;
            this.instanceCount = count;
            this.setDrawElemenParams(indexCount, subMesh._indexStart * 2);
        }
    }
    SubMeshInstanceBatch.maxInstanceCount = 1024;

    class VertexPositionTerrain {
        constructor(position, normal, textureCoord0, textureCoord1) {
            this._position = position;
            this._normal = normal;
            this._textureCoord0 = textureCoord0;
            this._textureCoord1 = textureCoord1;
        }
        static __init__() {
            VertexPositionTerrain._vertexDeclaration = new Laya.VertexDeclaration(40, [new Laya.VertexElement(0, Laya.VertexElementFormat.Vector3, VertexPositionTerrain.TERRAIN_POSITION0),
                new Laya.VertexElement(12, Laya.VertexElementFormat.Vector3, VertexPositionTerrain.TERRAIN_NORMAL0),
                new Laya.VertexElement(24, Laya.VertexElementFormat.Vector2, VertexPositionTerrain.TERRAIN_TEXTURECOORDINATE0),
                new Laya.VertexElement(32, Laya.VertexElementFormat.Vector2, VertexPositionTerrain.TERRAIN_TEXTURECOORDINATE1)]);
        }
        static get vertexDeclaration() {
            return VertexPositionTerrain._vertexDeclaration;
        }
        get position() {
            return this._position;
        }
        get normal() {
            return this._normal;
        }
        get textureCoord0() {
            return this._textureCoord0;
        }
        get textureCoord1() {
            return this._textureCoord1;
        }
        get vertexDeclaration() {
            return VertexPositionTerrain._vertexDeclaration;
        }
    }
    VertexPositionTerrain.TERRAIN_POSITION0 = 0;
    VertexPositionTerrain.TERRAIN_NORMAL0 = 1;
    VertexPositionTerrain.TERRAIN_TEXTURECOORDINATE0 = 2;
    VertexPositionTerrain.TERRAIN_TEXTURECOORDINATE1 = 3;

    class BulletInteractive {
        constructor(mem, dbgline) {
            this.drawLine = (sx, sy, sz, ex, ey, ez, color) => {
                if (!this.dbgLine)
                    return;
                this.dbgLine.color(color);
                this.dbgLine.line(sx, sy, sz, ex, ey, ez);
            };
            this.clearLine = () => {
                if (!this.dbgLine)
                    return;
                this.dbgLine.clear();
            };
            this.jslog = (ptr, len) => {
                if (!this.mem)
                    return;
                let td = new TextDecoder();
                let str = new Uint8Array(this.mem.buffer, ptr, len);
                let jsstr = td.decode(str);
                console.log(jsstr);
            };
            this.mem = mem;
            this.dbgLine = dbgline;
        }
        getWorldTransform(rigidBodyID, worldTransPointer) {
        }
        setWorldTransform(rigidBodyID, worldTransPointer) {
            var rigidBody = PhysicsComponent._physicObjectsMap[rigidBodyID];
            rigidBody._simulation._updatedRigidbodies++;
            rigidBody._updateTransformComponent(worldTransPointer);
        }
    }

    class PrimitiveMesh {
        static __init__() {
        }
        static _createMesh(vertexDeclaration, vertices, indices) {
            var mesh = new Mesh();
            var subMesh = new SubMesh(mesh);
            var vertexBuffer = Laya.LayaGL.renderOBJCreate.createVertexBuffer3D(vertices.length * 4, Laya.BufferUsage.Static, true);
            vertexBuffer.vertexDeclaration = vertexDeclaration;
            vertexBuffer.setData(vertices.buffer);
            mesh._vertexBuffer = vertexBuffer;
            mesh._vertexCount = vertexBuffer._byteLength / vertexDeclaration.vertexStride;
            var indexBuffer = Laya.LayaGL.renderOBJCreate.createIndexBuffer3D(Laya.IndexFormat.UInt16, indices.length, Laya.BufferUsage.Static, true);
            indexBuffer.setData(indices);
            mesh._indexBuffer = indexBuffer;
            mesh._setBuffer(vertexBuffer, indexBuffer);
            subMesh._vertexBuffer = vertexBuffer;
            subMesh._indexBuffer = indexBuffer;
            subMesh._setIndexRange(0, indexBuffer.indexCount);
            var subIndexBufferStart = subMesh._subIndexBufferStart;
            var subIndexBufferCount = subMesh._subIndexBufferCount;
            var boneIndicesList = subMesh._boneIndicesList;
            subIndexBufferStart.length = 1;
            subIndexBufferCount.length = 1;
            boneIndicesList.length = 1;
            subIndexBufferStart[0] = 0;
            subIndexBufferCount[0] = indexBuffer.indexCount;
            var subMeshes = [];
            subMeshes.push(subMesh);
            mesh._setSubMeshes(subMeshes);
            mesh.calculateBounds();
            var memorySize = vertexBuffer._byteLength + indexBuffer._byteLength;
            mesh._setCPUMemory(memorySize);
            mesh._setGPUMemory(memorySize);
            return mesh;
        }
        static createBox(long = 1, height = 1, width = 1) {
            var vertexDeclaration = Laya.VertexMesh.getVertexDeclaration("POSITION,NORMAL,UV");
            var halfLong = long / 2;
            var halfHeight = height / 2;
            var halfWidth = width / 2;
            var vertices = new Float32Array([
                -halfLong, halfHeight, -halfWidth, 0, 1, 0, 0, 0, halfLong, halfHeight, -halfWidth, 0, 1, 0, 1, 0, halfLong, halfHeight, halfWidth, 0, 1, 0, 1, 1, -halfLong, halfHeight, halfWidth, 0, 1, 0, 0, 1,
                -halfLong, -halfHeight, -halfWidth, 0, -1, 0, 0, 1, halfLong, -halfHeight, -halfWidth, 0, -1, 0, 1, 1, halfLong, -halfHeight, halfWidth, 0, -1, 0, 1, 0, -halfLong, -halfHeight, halfWidth, 0, -1, 0, 0, 0,
                -halfLong, halfHeight, -halfWidth, -1, 0, 0, 0, 0, -halfLong, halfHeight, halfWidth, -1, 0, 0, 1, 0, -halfLong, -halfHeight, halfWidth, -1, 0, 0, 1, 1, -halfLong, -halfHeight, -halfWidth, -1, 0, 0, 0, 1,
                halfLong, halfHeight, -halfWidth, 1, 0, 0, 1, 0, halfLong, halfHeight, halfWidth, 1, 0, 0, 0, 0, halfLong, -halfHeight, halfWidth, 1, 0, 0, 0, 1, halfLong, -halfHeight, -halfWidth, 1, 0, 0, 1, 1,
                -halfLong, halfHeight, halfWidth, 0, 0, 1, 0, 0, halfLong, halfHeight, halfWidth, 0, 0, 1, 1, 0, halfLong, -halfHeight, halfWidth, 0, 0, 1, 1, 1, -halfLong, -halfHeight, halfWidth, 0, 0, 1, 0, 1,
                -halfLong, halfHeight, -halfWidth, 0, 0, -1, 1, 0, halfLong, halfHeight, -halfWidth, 0, 0, -1, 0, 0, halfLong, -halfHeight, -halfWidth, 0, 0, -1, 0, 1, -halfLong, -halfHeight, -halfWidth, 0, 0, -1, 1, 1
            ]);
            var indices = new Uint16Array([
                0, 1, 2, 2, 3, 0,
                4, 7, 6, 6, 5, 4,
                8, 9, 10, 10, 11, 8,
                12, 15, 14, 14, 13, 12,
                16, 17, 18, 18, 19, 16,
                20, 23, 22, 22, 21, 20
            ]);
            return PrimitiveMesh._createMesh(vertexDeclaration, vertices, indices);
        }
        static createCapsule(radius = 0.5, height = 2, stacks = 16, slices = 32) {
            var vertexCount = (stacks + 1) * (slices + 1) * 2 + (slices + 1) * 2;
            var indexCount = (3 * stacks * (slices + 1)) * 2 * 2 + 2 * slices * 3;
            var vertexDeclaration = Laya.VertexMesh.getVertexDeclaration("POSITION,NORMAL,UV");
            var vertexFloatStride = vertexDeclaration.vertexStride / 4;
            var vertices = new Float32Array(vertexCount * vertexFloatStride);
            var indices = new Uint16Array(indexCount);
            var stackAngle = (Math.PI / 2.0) / stacks;
            var sliceAngle = (Math.PI * 2.0) / slices;
            var hcHeight = height / 2 - radius;
            var posX = 0;
            var posY = 0;
            var posZ = 0;
            var vc = 0;
            var ic = 0;
            var verticeCount = 0;
            var stack, slice;
            for (stack = 0; stack <= stacks; stack++) {
                for (slice = 0; slice <= slices; slice++) {
                    posX = radius * Math.cos(stack * stackAngle) * Math.cos(slice * sliceAngle + Math.PI);
                    posY = radius * Math.sin(stack * stackAngle);
                    posZ = radius * Math.cos(stack * stackAngle) * Math.sin(slice * sliceAngle + Math.PI);
                    vertices[vc++] = posX;
                    vertices[vc++] = posY + hcHeight;
                    vertices[vc++] = posZ;
                    vertices[vc++] = posX;
                    vertices[vc++] = posY;
                    vertices[vc++] = posZ;
                    vertices[vc++] = 1 - slice / slices;
                    vertices[vc++] = (1 - stack / stacks) * ((Math.PI * radius / 2) / (height + Math.PI * radius));
                    if (stack < stacks) {
                        indices[ic++] = (stack * (slices + 1)) + slice + (slices + 1);
                        indices[ic++] = (stack * (slices + 1)) + slice;
                        indices[ic++] = (stack * (slices + 1)) + slice + 1;
                        indices[ic++] = (stack * (slices + 1)) + slice + (slices);
                        indices[ic++] = (stack * (slices + 1)) + slice;
                        indices[ic++] = (stack * (slices + 1)) + slice + (slices + 1);
                    }
                }
            }
            verticeCount += (stacks + 1) * (slices + 1);
            for (stack = 0; stack <= stacks; stack++) {
                for (slice = 0; slice <= slices; slice++) {
                    posX = radius * Math.cos(stack * stackAngle) * Math.cos(slice * sliceAngle + Math.PI);
                    posY = radius * Math.sin(-stack * stackAngle);
                    posZ = radius * Math.cos(stack * stackAngle) * Math.sin(slice * sliceAngle + Math.PI);
                    vertices[vc++] = posX;
                    vertices[vc++] = posY - hcHeight;
                    vertices[vc++] = posZ;
                    vertices[vc++] = posX;
                    vertices[vc++] = posY;
                    vertices[vc++] = posZ;
                    vertices[vc++] = 1 - slice / slices;
                    vertices[vc++] = ((stack / stacks) * (Math.PI * radius / 2) + (height + Math.PI * radius / 2)) / (height + Math.PI * radius);
                    if (stack < stacks) {
                        indices[ic++] = verticeCount + (stack * (slices + 1)) + slice;
                        indices[ic++] = verticeCount + (stack * (slices + 1)) + slice + (slices + 1);
                        indices[ic++] = verticeCount + (stack * (slices + 1)) + slice + 1;
                        indices[ic++] = verticeCount + (stack * (slices + 1)) + slice;
                        indices[ic++] = verticeCount + (stack * (slices + 1)) + slice + (slices);
                        indices[ic++] = verticeCount + (stack * (slices + 1)) + slice + (slices + 1);
                    }
                }
            }
            verticeCount += (stacks + 1) * (slices + 1);
            for (slice = 0; slice <= slices; slice++) {
                posX = radius * Math.cos(slice * sliceAngle + Math.PI);
                posY = hcHeight;
                posZ = radius * Math.sin(slice * sliceAngle + Math.PI);
                vertices[vc++] = posX;
                vertices[vc + (slices + 1) * 8 - 1] = posX;
                vertices[vc++] = posY;
                vertices[vc + (slices + 1) * 8 - 1] = -posY;
                vertices[vc++] = posZ;
                vertices[vc + (slices + 1) * 8 - 1] = posZ;
                vertices[vc++] = posX;
                vertices[vc + (slices + 1) * 8 - 1] = posX;
                vertices[vc++] = 0;
                vertices[vc + (slices + 1) * 8 - 1] = 0;
                vertices[vc++] = posZ;
                vertices[vc + (slices + 1) * 8 - 1] = posZ;
                vertices[vc++] = 1 - slice * 1 / slices;
                vertices[vc + (slices + 1) * 8 - 1] = 1 - slice * 1 / slices;
                vertices[vc++] = (Math.PI * radius / 2) / (height + Math.PI * radius);
                vertices[vc + (slices + 1) * 8 - 1] = (Math.PI * radius / 2 + height) / (height + Math.PI * radius);
            }
            for (slice = 0; slice < slices; slice++) {
                indices[ic++] = slice + verticeCount + (slices + 1);
                indices[ic++] = slice + verticeCount + 1;
                indices[ic++] = slice + verticeCount;
                indices[ic++] = slice + verticeCount + (slices + 1);
                indices[ic++] = slice + verticeCount + (slices + 1) + 1;
                indices[ic++] = slice + verticeCount + 1;
            }
            verticeCount += 2 * (slices + 1);
            return PrimitiveMesh._createMesh(vertexDeclaration, vertices, indices);
        }
        static createCone(radius = 0.5, height = 1, slices = 32) {
            var vertexCount = (slices + 1 + 1) + (slices + 1) * 2;
            var indexCount = 6 * slices + 3 * slices;
            var vertexDeclaration = Laya.VertexMesh.getVertexDeclaration("POSITION,NORMAL,UV");
            var vertexFloatStride = vertexDeclaration.vertexStride / 4;
            var vertices = new Float32Array(vertexCount * vertexFloatStride);
            var indices = new Uint16Array(indexCount);
            var sliceAngle = (Math.PI * 2.0) / slices;
            var halfHeight = height / 2;
            var curAngle = 0;
            var verticeCount = 0;
            var posX = 0;
            var posY = 0;
            var posZ = 0;
            var normal = new Laya.Vector3();
            var downV3 = new Laya.Vector3(0, -1, 0);
            var upPoint = new Laya.Vector3(0, halfHeight, 0);
            var downPoint = new Laya.Vector3();
            var v3 = new Laya.Vector3();
            var q4 = new Laya.Quaternion();
            var rotateAxis = new Laya.Vector3();
            var rotateRadius;
            var vc = 0;
            var ic = 0;
            for (var rv = 0; rv <= slices; rv++) {
                curAngle = rv * sliceAngle;
                posX = Math.cos(curAngle + Math.PI) * radius;
                posY = halfHeight;
                posZ = Math.sin(curAngle + Math.PI) * radius;
                vertices[vc++] = 0;
                vertices[vc + (slices + 1) * 8 - 1] = posX;
                vertices[vc++] = posY;
                vertices[vc + (slices + 1) * 8 - 1] = -posY;
                vertices[vc++] = 0;
                vertices[vc + (slices + 1) * 8 - 1] = posZ;
                normal.x = posX;
                normal.y = 0;
                normal.z = posZ;
                downPoint.x = posX;
                downPoint.y = -posY;
                downPoint.z = posZ;
                Laya.Vector3.subtract(downPoint, upPoint, v3);
                Laya.Vector3.normalize(v3, v3);
                rotateRadius = Math.acos(Laya.Vector3.dot(downV3, v3));
                Laya.Vector3.cross(downV3, v3, rotateAxis);
                Laya.Vector3.normalize(rotateAxis, rotateAxis);
                Laya.Quaternion.createFromAxisAngle(rotateAxis, rotateRadius, q4);
                Laya.Vector3.normalize(normal, normal);
                Laya.Vector3.transformQuat(normal, q4, normal);
                Laya.Vector3.normalize(normal, normal);
                vertices[vc++] = normal.x;
                vertices[vc + (slices + 1) * 8 - 1] = normal.x;
                vertices[vc++] = normal.y;
                vertices[vc + (slices + 1) * 8 - 1] = normal.y;
                vertices[vc++] = normal.z;
                vertices[vc + (slices + 1) * 8 - 1] = normal.z;
                vertices[vc++] = 1 - rv * 1 / slices;
                vertices[vc + (slices + 1) * 8 - 1] = 1 - rv * 1 / slices;
                vertices[vc++] = 0;
                vertices[vc + (slices + 1) * 8 - 1] = 1;
            }
            vc += (slices + 1) * 8;
            for (var ri = 0; ri < slices; ri++) {
                indices[ic++] = ri + verticeCount + (slices + 1);
                indices[ic++] = ri + verticeCount + 1;
                indices[ic++] = ri + verticeCount;
                indices[ic++] = ri + verticeCount + (slices + 1);
                indices[ic++] = ri + verticeCount + (slices + 1) + 1;
                indices[ic++] = ri + verticeCount + 1;
            }
            verticeCount += 2 * (slices + 1);
            for (var bv = 0; bv <= slices; bv++) {
                if (bv === 0) {
                    vertices[vc++] = 0;
                    vertices[vc++] = -halfHeight;
                    vertices[vc++] = 0;
                    vertices[vc++] = 0;
                    vertices[vc++] = -1;
                    vertices[vc++] = 0;
                    vertices[vc++] = 0.5;
                    vertices[vc++] = 0.5;
                }
                curAngle = bv * sliceAngle;
                posX = Math.cos(curAngle + Math.PI) * radius;
                posY = -halfHeight;
                posZ = Math.sin(curAngle + Math.PI) * radius;
                vertices[vc++] = posX;
                vertices[vc++] = posY;
                vertices[vc++] = posZ;
                vertices[vc++] = 0;
                vertices[vc++] = -1;
                vertices[vc++] = 0;
                vertices[vc++] = 0.5 + Math.cos(curAngle) * 0.5;
                vertices[vc++] = 0.5 + Math.sin(curAngle) * 0.5;
            }
            for (var bi = 0; bi < slices; bi++) {
                indices[ic++] = 0 + verticeCount;
                indices[ic++] = bi + 2 + verticeCount;
                indices[ic++] = bi + 1 + verticeCount;
            }
            verticeCount += slices + 1 + 1;
            return PrimitiveMesh._createMesh(vertexDeclaration, vertices, indices);
        }
        static createCylinder(radius = 0.5, height = 2, slices = 32) {
            var vertexCount = (slices + 1 + 1) + (slices + 1) * 2 + (slices + 1 + 1);
            var indexCount = 3 * slices + 6 * slices + 3 * slices;
            var vertexDeclaration = Laya.VertexMesh.getVertexDeclaration("POSITION,NORMAL,UV");
            var vertexFloatStride = vertexDeclaration.vertexStride / 4;
            var vertices = new Float32Array(vertexCount * vertexFloatStride);
            var indices = new Uint16Array(indexCount);
            var sliceAngle = (Math.PI * 2.0) / slices;
            var halfHeight = height / 2;
            var curAngle = 0;
            var verticeCount = 0;
            var posX = 0;
            var posY = 0;
            var posZ = 0;
            var vc = 0;
            var ic = 0;
            for (var tv = 0; tv <= slices; tv++) {
                if (tv === 0) {
                    vertices[vc++] = 0;
                    vertices[vc++] = halfHeight;
                    vertices[vc++] = 0;
                    vertices[vc++] = 0;
                    vertices[vc++] = 1;
                    vertices[vc++] = 0;
                    vertices[vc++] = 0.5;
                    vertices[vc++] = 0.5;
                }
                curAngle = tv * sliceAngle;
                posX = Math.cos(curAngle) * radius;
                posY = halfHeight;
                posZ = Math.sin(curAngle) * radius;
                vertices[vc++] = posX;
                vertices[vc++] = posY;
                vertices[vc++] = posZ;
                vertices[vc++] = 0;
                vertices[vc++] = 1;
                vertices[vc++] = 0;
                vertices[vc++] = 0.5 + Math.cos(curAngle) * 0.5;
                vertices[vc++] = 0.5 + Math.sin(curAngle) * 0.5;
            }
            for (var ti = 0; ti < slices; ti++) {
                indices[ic++] = 0;
                indices[ic++] = ti + 1;
                indices[ic++] = ti + 2;
            }
            verticeCount += slices + 1 + 1;
            for (var rv = 0; rv <= slices; rv++) {
                curAngle = rv * sliceAngle;
                posX = Math.cos(curAngle + Math.PI) * radius;
                posY = halfHeight;
                posZ = Math.sin(curAngle + Math.PI) * radius;
                vertices[vc++] = posX;
                vertices[vc + (slices + 1) * 8 - 1] = posX;
                vertices[vc++] = posY;
                vertices[vc + (slices + 1) * 8 - 1] = -posY;
                vertices[vc++] = posZ;
                vertices[vc + (slices + 1) * 8 - 1] = posZ;
                vertices[vc++] = posX;
                vertices[vc + (slices + 1) * 8 - 1] = posX;
                vertices[vc++] = 0;
                vertices[vc + (slices + 1) * 8 - 1] = 0;
                vertices[vc++] = posZ;
                vertices[vc + (slices + 1) * 8 - 1] = posZ;
                vertices[vc++] = 1 - rv * 1 / slices;
                vertices[vc + (slices + 1) * 8 - 1] = 1 - rv * 1 / slices;
                vertices[vc++] = 0;
                vertices[vc + (slices + 1) * 8 - 1] = 1;
            }
            vc += (slices + 1) * 8;
            for (var ri = 0; ri < slices; ri++) {
                indices[ic++] = ri + verticeCount + (slices + 1);
                indices[ic++] = ri + verticeCount + 1;
                indices[ic++] = ri + verticeCount;
                indices[ic++] = ri + verticeCount + (slices + 1);
                indices[ic++] = ri + verticeCount + (slices + 1) + 1;
                indices[ic++] = ri + verticeCount + 1;
            }
            verticeCount += 2 * (slices + 1);
            for (var bv = 0; bv <= slices; bv++) {
                if (bv === 0) {
                    vertices[vc++] = 0;
                    vertices[vc++] = -halfHeight;
                    vertices[vc++] = 0;
                    vertices[vc++] = 0;
                    vertices[vc++] = -1;
                    vertices[vc++] = 0;
                    vertices[vc++] = 0.5;
                    vertices[vc++] = 0.5;
                }
                curAngle = bv * sliceAngle;
                posX = Math.cos(curAngle + Math.PI) * radius;
                posY = -halfHeight;
                posZ = Math.sin(curAngle + Math.PI) * radius;
                vertices[vc++] = posX;
                vertices[vc++] = posY;
                vertices[vc++] = posZ;
                vertices[vc++] = 0;
                vertices[vc++] = -1;
                vertices[vc++] = 0;
                vertices[vc++] = 0.5 + Math.cos(curAngle) * 0.5;
                vertices[vc++] = 0.5 + Math.sin(curAngle) * 0.5;
            }
            for (var bi = 0; bi < slices; bi++) {
                indices[ic++] = 0 + verticeCount;
                indices[ic++] = bi + 2 + verticeCount;
                indices[ic++] = bi + 1 + verticeCount;
            }
            verticeCount += slices + 1 + 1;
            return PrimitiveMesh._createMesh(vertexDeclaration, vertices, indices);
        }
        static createPlane(long = 10, width = 10, stacks = 10, slices = 10) {
            var vertexCount = (stacks + 1) * (slices + 1);
            var indexCount = stacks * slices * 2 * 3;
            var indices = new Uint16Array(indexCount);
            var vertexDeclaration = Laya.VertexMesh.getVertexDeclaration("POSITION,NORMAL,UV");
            var vertexFloatStride = vertexDeclaration.vertexStride / 4;
            var vertices = new Float32Array(vertexCount * vertexFloatStride);
            var halfLong = long / 2;
            var halfWidth = width / 2;
            var stacksLong = long / stacks;
            var slicesWidth = width / slices;
            var verticeCount = 0;
            for (var i = 0; i <= slices; i++) {
                for (var j = 0; j <= stacks; j++) {
                    vertices[verticeCount++] = j * stacksLong - halfLong;
                    vertices[verticeCount++] = 0;
                    vertices[verticeCount++] = i * slicesWidth - halfWidth;
                    vertices[verticeCount++] = 0;
                    vertices[verticeCount++] = 1;
                    vertices[verticeCount++] = 0;
                    vertices[verticeCount++] = j * 1 / stacks;
                    vertices[verticeCount++] = i * 1 / slices;
                }
            }
            var indiceIndex = 0;
            for (i = 0; i < slices; i++) {
                for (j = 0; j < stacks; j++) {
                    indices[indiceIndex++] = (i + 1) * (stacks + 1) + j;
                    indices[indiceIndex++] = i * (stacks + 1) + j;
                    indices[indiceIndex++] = (i + 1) * (stacks + 1) + j + 1;
                    indices[indiceIndex++] = i * (stacks + 1) + j;
                    indices[indiceIndex++] = i * (stacks + 1) + j + 1;
                    indices[indiceIndex++] = (i + 1) * (stacks + 1) + j + 1;
                }
            }
            return PrimitiveMesh._createMesh(vertexDeclaration, vertices, indices);
        }
        static createQuad(long = 1, width = 1) {
            var vertexDeclaration = Laya.VertexMesh.getVertexDeclaration("POSITION,NORMAL,UV");
            var halfLong = long / 2;
            var halfWidth = width / 2;
            var vertices = new Float32Array([-halfLong, halfWidth, 0, 0, 0, 1, 0, 0, halfLong, halfWidth, 0, 0, 0, 1, 1, 0, -halfLong, -halfWidth, 0, 0, 0, 1, 0, 1, halfLong, -halfWidth, 0, 0, 0, 1, 1, 1]);
            var indices = new Uint16Array([0, 1, 2, 3, 2, 1]);
            return PrimitiveMesh._createMesh(vertexDeclaration, vertices, indices);
        }
        static createSphere(radius = 0.5, stacks = 32, slices = 32) {
            var vertexCount = (stacks + 1) * (slices + 1);
            var indexCount = (3 * stacks * (slices + 1)) * 2;
            var indices = new Uint16Array(indexCount);
            var vertexDeclaration = Laya.VertexMesh.getVertexDeclaration("POSITION,NORMAL,UV");
            var vertexFloatStride = vertexDeclaration.vertexStride / 4;
            var vertices = new Float32Array(vertexCount * vertexFloatStride);
            var stackAngle = Math.PI / stacks;
            var sliceAngle = (Math.PI * 2.0) / slices;
            var vertexIndex = 0;
            vertexCount = 0;
            indexCount = 0;
            for (var stack = 0; stack < (stacks + 1); stack++) {
                var r = Math.sin(stack * stackAngle);
                var y = Math.cos(stack * stackAngle);
                for (var slice = 0; slice < (slices + 1); slice++) {
                    var x = r * Math.sin(slice * sliceAngle + Math.PI * 1 / 2);
                    var z = r * Math.cos(slice * sliceAngle + Math.PI * 1 / 2);
                    vertices[vertexCount + 0] = x * radius;
                    vertices[vertexCount + 1] = y * radius;
                    vertices[vertexCount + 2] = z * radius;
                    vertices[vertexCount + 3] = x;
                    vertices[vertexCount + 4] = y;
                    vertices[vertexCount + 5] = z;
                    vertices[vertexCount + 6] = slice / slices;
                    vertices[vertexCount + 7] = stack / stacks;
                    vertexCount += vertexFloatStride;
                    if (stack != (stacks - 1)) {
                        indices[indexCount++] = vertexIndex + (slices + 1);
                        indices[indexCount++] = vertexIndex;
                        indices[indexCount++] = vertexIndex + 1;
                        indices[indexCount++] = vertexIndex + (slices);
                        indices[indexCount++] = vertexIndex;
                        indices[indexCount++] = vertexIndex + (slices + 1);
                        vertexIndex++;
                    }
                }
            }
            return PrimitiveMesh._createMesh(vertexDeclaration, vertices, indices);
        }
    }

    var UtilsGLSL = "#if !defined(Utils_lib)\r\n    #define Utils_lib\r\n\r\n#endif // Utils_lib";

    var ColorGLSL = "#if !defined(Color_lib)\r\n    #define Color_lib\r\n\r\n    #include \"Math.glsl\";\r\n\r\nvec3 linearToGamma(in vec3 value)\r\n{\r\n    return vec3(mix(pow(value.rgb, vec3(0.41666)) * 1.055 - vec3(0.055), value.rgb * 12.92, vec3(lessThanEqual(value.rgb, vec3(0.0031308)))));\r\n}\r\n\r\nvec4 linearToGamma(in vec4 value)\r\n{\r\n    return vec4(linearToGamma(value.rgb), value.a);\r\n}\r\n\r\nvec3 gammaToLinear(in vec3 value)\r\n{\r\n    return pow((value + 0.055) / 1.055, vec3(2.4));\r\n}\r\n\r\nvec4 gammaToLinear(in vec4 value)\r\n{\r\n    return vec4(gammaToLinear(value.rgb), value.a);\r\n}\r\n\r\nconst float c_RGBDMaxRange = 255.0;\r\n\r\n// float color to rgbd\r\nvec4 encodeRGBD(in vec3 color)\r\n{\r\n    float maxRGB = max(vecmax(color), FLT_EPS);\r\n    float d = max(1.0, c_RGBDMaxRange / maxRGB);\r\n    d = saturate(d / 255.0);\r\n\r\n    vec3 rgb = color.rgb * d;\r\n    rgb = saturate(rgb);\r\n    return vec4(rgb, d);\r\n}\r\n\r\n// rgbd to float color\r\nvec3 decodeRGBD(in vec4 rgbd)\r\n{\r\n    vec3 color = rgbd.rgb * (1.0 / rgbd.a);\r\n    return color;\r\n}\r\n\r\n// float color to rgbm\r\nvec4 encodeRGBM(in vec3 color, float range)\r\n{\r\n    color *= 1.0 / range;\r\n    float maxRGB = max(vecmax(color), FLT_EPS);\r\n    float m = ceil(maxRGB * 255.0) / 255.0;\r\n    vec3 rgb = color.rgb * 1.0 / m;\r\n\r\n    vec4 rgbm = vec4(rgb, m);\r\n    return rgbm;\r\n}\r\n\r\n// rgbm to float color\r\nvec3 decodeRGBM(in vec4 rgbm, float range)\r\n{\r\n    return range * rgbm.rgb * rgbm.a;\r\n}\r\n\r\n#endif // Color_lib";

    var MathGLSL = "#if !defined(Math_lib)\r\n    #define Math_lib\r\n\r\n    #ifndef GRAPHICS_API_GLES3\r\nmat2 inverse(mat2 m)\r\n{\r\n    return mat2(m[1][1], -m[0][1], -m[1][0], m[0][0]) / (m[0][0] * m[1][1] - m[0][1] * m[1][0]);\r\n}\r\nmat3 inverse(mat3 m)\r\n{\r\n    float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];\r\n    float a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];\r\n    float a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];\r\n\r\n    float b01 = a22 * a11 - a12 * a21;\r\n    float b11 = -a22 * a10 + a12 * a20;\r\n    float b21 = a21 * a10 - a11 * a20;\r\n\r\n    float det = a00 * b01 + a01 * b11 + a02 * b21;\r\n\r\n    return mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11), b11, (a22 * a00 - a02 * a20),\r\n\t       (-a12 * a00 + a02 * a10), b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10))\r\n\t/ det;\r\n}\r\n\r\nmat4 inverse(mat4 m)\r\n{\r\n    float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3], a10 = m[1][0], a11 = m[1][1], a12 = m[1][2],\r\n\t  a13 = m[1][3], a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3], a30 = m[3][0], a31 = m[3][1],\r\n\t  a32 = m[3][2], a33 = m[3][3],\r\n\r\n\t  b00 = a00 * a11 - a01 * a10, b01 = a00 * a12 - a02 * a10, b02 = a00 * a13 - a03 * a10,\r\n\t  b03 = a01 * a12 - a02 * a11, b04 = a01 * a13 - a03 * a11, b05 = a02 * a13 - a03 * a12,\r\n\t  b06 = a20 * a31 - a21 * a30, b07 = a20 * a32 - a22 * a30, b08 = a20 * a33 - a23 * a30,\r\n\t  b09 = a21 * a32 - a22 * a31, b10 = a21 * a33 - a23 * a31, b11 = a22 * a33 - a23 * a32,\r\n\r\n\t  det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\r\n\r\n    return mat4(a11 * b11 - a12 * b10 + a13 * b09, a02 * b10 - a01 * b11 - a03 * b09, a31 * b05 - a32 * b04 + a33 * b03,\r\n\t       a22 * b04 - a21 * b05 - a23 * b03, a12 * b08 - a10 * b11 - a13 * b07, a00 * b11 - a02 * b08 + a03 * b07,\r\n\t       a32 * b02 - a30 * b05 - a33 * b01, a20 * b05 - a22 * b02 + a23 * b01, a10 * b10 - a11 * b08 + a13 * b06,\r\n\t       a01 * b08 - a00 * b10 - a03 * b06, a30 * b04 - a31 * b02 + a33 * b00, a21 * b02 - a20 * b04 - a23 * b00,\r\n\t       a11 * b07 - a10 * b09 - a12 * b06, a00 * b09 - a01 * b07 + a02 * b06, a31 * b01 - a30 * b03 - a32 * b00,\r\n\t       a20 * b03 - a21 * b01 + a22 * b00)\r\n\t/ det;\r\n}\r\n\r\nmat4 transpose(mat4 m){\r\n    return mat4(m[0][0],m[1][0],m[2][0],m[3][0],\r\n                m[0][1],m[1][1],m[2][1],m[3][1],\r\n                m[0][2],m[1][2],m[2][2],m[3][2],\r\n                m[0][3],m[1][3],m[2][3],m[3][3]);\r\n}\r\nmat3 transpose(mat3 m){\r\n    return mat3(m[0][0],m[1][0],m[2][0],\r\n                m[0][1],m[1][1],m[2][1],\r\n                m[0][2],m[1][2],m[2][2]);\r\n}\r\n    #endif // GRAPHICS_API_GLES3\r\n\r\n    #define PI 3.14159265359\r\n\r\n    #define INVERT_PI 0.31830988618\r\n\r\n    #define HALF_PI 1.570796327\r\n\r\n    #define MEDIUMP_FLT_MAX 65504.0\r\n    #define MEDIUMP_FLT_MIN 0.00006103515625\r\n\r\n    #if defined(GL_FRAGMENT_PRECISION_HIGH)\r\n\t#define FLT_EPS\t\t   1e-5\r\n\t#define saturateMediump(x) x\r\n    #else\r\n\t#define FLT_EPS\t\t   MEDIUMP_FLT_MIN\r\n\t#define saturateMediump(x) min(x, MEDIUMP_FLT_MAX)\r\n    #endif // GL_FRAGMENT_PRECISION_HIGH\r\n\r\n    #define saturate(x) clamp(x, 0.0, 1.0)\r\n\r\nfloat pow2(float x)\r\n{\r\n    return x * x;\r\n}\r\n\r\nfloat pow5(float x)\r\n{\r\n    float x2 = x * x;\r\n    return x2 * x2 * x;\r\n}\r\n\r\nconst float INVERT_LOG10 = 0.43429448190325176;\r\n\r\nfloat log10(float x)\r\n{\r\n    return log(x) * INVERT_LOG10;\r\n}\r\n\r\nfloat vecmax(const vec2 v)\r\n{\r\n    return max(v.x, v.y);\r\n}\r\n\r\nfloat vecmax(const vec3 v)\r\n{\r\n    return max(v.x, max(v.y, v.z));\r\n}\r\n\r\nfloat vecmax(const vec4 v)\r\n{\r\n    return max(max(v.x, v.y), max(v.z, v.w));\r\n}\r\n\r\nfloat vecmin(const vec2 v)\r\n{\r\n    return min(v.x, v.y);\r\n}\r\n\r\nfloat vecmin(const vec3 v)\r\n{\r\n    return min(v.x, min(v.y, v.z));\r\n}\r\n\r\nfloat vecmin(const vec4 v)\r\n{\r\n    return min(min(v.x, v.y), min(v.z, v.w));\r\n}\r\n\r\nvec3 SafeNormalize(in vec3 inVec)\r\n{\r\n    float dp3 = max(0.001, dot(inVec, inVec));\r\n    return inVec * inversesqrt(dp3);\r\n}\r\n\r\n/**\r\n * Approximates acos(x) with a max absolute error of 9.0x10^-3.\r\n * Valid in the range -1..1.\r\n */\r\nfloat acosFast(float x)\r\n{\r\n    // Lagarde 2014, \"Inverse trigonometric functions GPU optimization for AMD GCN architecture\"\r\n    // This is the approximation of degree 1, with a max absolute error of 9.0x10^-3\r\n    float y = abs(x);\r\n    float p = -0.1565827 * y + 1.570796;\r\n    p *= sqrt(1.0 - y);\r\n    return x >= 0.0 ? p : PI - p;\r\n}\r\n\r\n/**\r\n * Approximates acos(x) with a max absolute error of 9.0x10^-3.\r\n * Valid only in the range 0..1.\r\n */\r\nfloat acosFastPositive(float x)\r\n{\r\n    float p = -0.1565827 * x + 1.570796;\r\n    return p * sqrt(1.0 - x);\r\n}\r\n\r\n/*\r\n * Random number between 0 and 1, using interleaved gradient noise.\r\n * w must not be normalized (e.g. window coordinates)\r\n */\r\nfloat interleavedGradientNoise(const highp vec2 w)\r\n{\r\n    const vec3 m = vec3(0.06711056, 0.00583715, 52.9829189);\r\n    return fract(m.z * fract(dot(w, m.xy)));\r\n}\r\n\r\n/*\r\n * vertex rotate by Euler\r\n */\r\nvec3 rotationByEuler(in vec3 vector, in vec3 rot)\r\n{\r\n    float halfRoll = rot.z * 0.5;\r\n    float halfPitch = rot.x * 0.5;\r\n    float halfYaw = rot.y * 0.5;\r\n\r\n    float sinRoll = sin(halfRoll);\r\n    float cosRoll = cos(halfRoll);\r\n    float sinPitch = sin(halfPitch);\r\n    float cosPitch = cos(halfPitch);\r\n    float sinYaw = sin(halfYaw);\r\n    float cosYaw = cos(halfYaw);\r\n\r\n    float quaX = (cosYaw * sinPitch * cosRoll) + (sinYaw * cosPitch * sinRoll);\r\n    float quaY = (sinYaw * cosPitch * cosRoll) - (cosYaw * sinPitch * sinRoll);\r\n    float quaZ = (cosYaw * cosPitch * sinRoll) - (sinYaw * sinPitch * cosRoll);\r\n    float quaW = (cosYaw * cosPitch * cosRoll) + (sinYaw * sinPitch * sinRoll);\r\n\r\n    // vec4 q=vec4(quaX,quaY,quaZ,quaW);\r\n    // vec3 temp = cross(q.xyz, vector) + q.w * vector;\r\n    // return (cross(temp, -q.xyz) + dot(q.xyz,vector) * q.xyz + q.w * temp);\r\n\r\n    float x = quaX + quaX;\r\n    float y = quaY + quaY;\r\n    float z = quaZ + quaZ;\r\n    float wx = quaW * x;\r\n    float wy = quaW * y;\r\n    float wz = quaW * z;\r\n    float xx = quaX * x;\r\n    float xy = quaX * y;\r\n    float xz = quaX * z;\r\n    float yy = quaY * y;\r\n    float yz = quaY * z;\r\n    float zz = quaZ * z;\r\n\r\n    return vec3(((vector.x * ((1.0 - yy) - zz)) + (vector.y * (xy - wz))) + (vector.z * (xz + wy)),\r\n\t((vector.x * (xy + wz)) + (vector.y * ((1.0 - xx) - zz))) + (vector.z * (yz - wx)),\r\n\t((vector.x * (xz - wy)) + (vector.y * (yz + wx))) + (vector.z * ((1.0 - xx) - yy)));\r\n}\r\n\r\n/*\r\n * Assume that axis has been normalized\r\n * point rotate by one axis\r\n */\r\nvec3 rotationByAxis(in vec3 vector, in vec3 axis, in float angle)\r\n{\r\n    float halfAngle = angle * 0.5;\r\n    float sin = sin(halfAngle);\r\n\r\n    float quaX = axis.x * sin;\r\n    float quaY = axis.y * sin;\r\n    float quaZ = axis.z * sin;\r\n    float quaW = cos(halfAngle);\r\n\r\n    // vec4 q=vec4(quaX,quaY,quaZ,quaW);\r\n    // vec3 temp = cross(q.xyz, vector) + q.w * vector;\r\n    // return (cross(temp, -q.xyz) + dot(q.xyz,vector) * q.xyz + q.w * temp);\r\n\r\n    float x = quaX + quaX;\r\n    float y = quaY + quaY;\r\n    float z = quaZ + quaZ;\r\n    float wx = quaW * x;\r\n    float wy = quaW * y;\r\n    float wz = quaW * z;\r\n    float xx = quaX * x;\r\n    float xy = quaX * y;\r\n    float xz = quaX * z;\r\n    float yy = quaY * y;\r\n    float yz = quaY * z;\r\n    float zz = quaZ * z;\r\n\r\n    return vec3(((vector.x * ((1.0 - yy) - zz)) + (vector.y * (xy - wz))) + (vector.z * (xz + wy)),\r\n\t((vector.x * (xy + wz)) + (vector.y * ((1.0 - xx) - zz))) + (vector.z * (yz - wx)),\r\n\t((vector.x * (xz - wy)) + (vector.y * (yz + wx))) + (vector.z * ((1.0 - xx) - yy)));\r\n}\r\n\r\n/*\r\n *rotate by quaternions\r\n */\r\nvec3 rotationByQuaternions(in vec3 v, in vec4 q)\r\n{\r\n    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);\r\n}\r\n\r\n#endif // Math_lib";

    var TBNNormalGLSL = "#if !defined(TBNNormal_lib)\r\n    #define TBNNormal_lib\r\n\r\n    #ifdef NEEDTBN\r\n\r\nmat3 generateTBNMat(in VertexParams params)\r\n{\r\n    vec3 normalWS = params.normalWS;\r\n    vec3 tangentWS = params.tangentWS.xyz;\r\n    vec3 biNormalWS = params.biNormalWS;\r\n\r\n    mat3 TBNMat = mat3(tangentWS, biNormalWS, normalWS);\r\n    return TBNMat;\r\n}\r\n\r\nvec3 sampleTBNNormalMap(in VertexParams params, in mat3 TBN, sampler2D normalMap, in vec2 uv)\r\n{\r\n    // vec2 uv = params.texCoord0;\r\n    vec3 samplerNormal = texture2D(normalMap, uv).rgb;\r\n    samplerNormal = normalize(samplerNormal * 2.0 - 1.0);;\r\n    vec3 normalWS = normalize(TBN * samplerNormal);\r\n    return normalWS;\r\n}\r\n\r\n    #endif // NEEDTBN\r\n\r\n#endif // TBNNormal_lib";

    var BakedBoneMatrixSamplerGLSL = "#if !defined(BakeBoneAnimSampler_lib)\r\n    #define BakeBoneAnimSampler_lib\r\n\r\nmat4 loadBakedMatMatrix(float FramePos, float boneIndices, float offset)\r\n{\r\n    vec2 uv;\r\n    float PixelPos = FramePos + boneIndices * 4.0;\r\n    float halfOffset = offset * 0.5;\r\n    float uvoffset = PixelPos / u_SimpleAnimatorTextureSize;\r\n    uv.y = floor(uvoffset) * offset + halfOffset;\r\n    uv.x = mod(float(PixelPos), u_SimpleAnimatorTextureSize) * offset + halfOffset;\r\n    vec4 mat0row = texture2D(u_SimpleAnimatorTexture, uv);\r\n    uv.x += offset;\r\n    vec4 mat1row = texture2D(u_SimpleAnimatorTexture, uv);\r\n    uv.x += offset;\r\n    vec4 mat2row = texture2D(u_SimpleAnimatorTexture, uv);\r\n    uv.x += offset;\r\n    vec4 mat3row = texture2D(u_SimpleAnimatorTexture, uv);\r\n    mat4 m = mat4(mat0row.x, mat0row.y, mat0row.z, mat0row.w,\r\n\tmat1row.x, mat1row.y, mat1row.z, mat1row.w,\r\n\tmat2row.x, mat2row.y, mat2row.z, mat2row.w,\r\n\tmat3row.x, mat3row.y, mat3row.z, mat3row.w);\r\n    return m;\r\n}\r\n\r\n#endif // BakeBoneAnimSampler_lib";

    var VertexGLSL = "#if !defined(VertexCommon_lib)\r\n    #define VertexCommon_lib\r\n\r\nstruct Vertex {\r\n\r\n    vec3 positionOS;\r\n\r\n    vec3 normalOS;\r\n\r\n    #ifdef TANGENT\r\n    vec4 tangentOS;\r\n    #endif // TANGENT\r\n\r\n    // todo  uv define ?\r\n    #ifdef UV\r\n    vec2 texCoord0;\r\n    #endif // UV\r\n\r\n    #ifdef UV1\r\n    vec2 texCoord1;\r\n    #endif // UV1\r\n\r\n    #ifdef COLOR\r\n    vec4 vertexColor;\r\n    #endif // COLOR\r\n};\r\n\r\n\r\n/**\r\n * vertex position\r\n */\r\nvec4 getVertexPosition()\r\n{\r\n    vec4 position = a_Position;\r\n    return position;\r\n}\r\n\r\nvec2 transformUV(in vec2 texcoord, in vec4 tilingOffset)\r\n{\r\n    vec2 uv = texcoord * tilingOffset.xy + tilingOffset.zw * vec2(1.0, -1.0) + vec2(0.0, 1.0 - tilingOffset.y);\r\n    return uv;\r\n}\r\n\r\nvoid getVertexParams(inout Vertex vertex)\r\n{\r\n    vertex.positionOS = getVertexPosition().xyz;\r\n\r\n    vertex.normalOS = a_Normal.xyz;\r\n\r\n    #ifdef TANGENT\r\n    vertex.tangentOS = a_Tangent0;\r\n    #endif // TANGENT\r\n\r\n    #ifdef UV\r\n    vertex.texCoord0 = a_Texcoord0;\r\n    #endif // UV\r\n\r\n    #ifdef UV1\r\n    vertex.texCoord1 = a_Texcoord1;\r\n    #endif // UV1\r\n\r\n    #ifdef COLOR\r\n    vertex.vertexColor = a_Color;\r\n    #endif // COLOR\r\n}\r\n\r\n#endif // VertexCommon_lib";

    var SceneGLSL = "#if !defined(SceneCommon_lib)\r\n    #define SceneCommon_lib\r\n\r\n    #ifdef ENUNIFORMBLOCK\r\nuniform SceneUniformBlock\r\n{\r\n    // time\r\n    float u_Time;\r\n    vec4 u_FogParams;// x start,y range,z Density\r\n    vec4 u_FogColor;\r\n};\r\n    #else // ENUNIFORMBLOCK\r\n// time\r\nuniform float u_Time;\r\nuniform vec4 u_FogParams;//x start,y range,z Density\r\nuniform vec4 u_FogColor;\r\n    #endif // ENUNIFORMBLOCK\r\n    //rotate SH IBL\r\nuniform float u_GIRotate;\r\n\r\n#endif // SceneCommon_lib";

    var CameraGLSL = "#if !defined(CameraCommon_lib)\r\n    #define CameraCommon_lib\r\n\r\n    #ifdef ENUNIFORMBLOCK\r\n\r\nuniform CameraUniformBlock\r\n{\r\n    mat4 u_View;\r\n    mat4 u_Projection;\r\n    mat4 u_ViewProjection;\r\n    vec4 u_ProjectionParams; // x: near, y: far, z: invert, w: 1/far\r\n    vec4 u_Viewport; // x,y,width,height\r\n    vec3 u_CameraDirection;\r\n    vec3 u_CameraUp;\r\n    vec3 u_CameraPos;\r\n};\r\n    #else\r\nuniform mat4 u_View;\r\nuniform mat4 u_Projection;\r\nuniform mat4 u_ViewProjection;\r\nuniform vec4 u_ProjectionParams; // x: near, y: far, z: invert, w: 1/far\r\nuniform vec4 u_Viewport; // x, y, width, height\r\nuniform vec3 u_CameraDirection;\r\nuniform vec3 u_CameraUp;\r\nuniform vec3 u_CameraPos;\r\n    #endif // ENUNIFORMBLOCK\r\n\r\n/*Depth or DepthNormal Uniform*/\r\nuniform highp sampler2D u_CameraDepthTexture;\r\nuniform vec4 u_ZBufferParams; //(1.0 - far / near, far / near, (near - far) / (near * far), 1 / near)\r\nuniform mediump sampler2D u_CameraDepthNormalsTexture;\r\nuniform mediump sampler2D u_CameraOpaqueTexture;\r\n\r\nvec4 getPositionCS(in vec3 positionWS)\r\n{\r\n    return u_ViewProjection * vec4(positionWS, 1.0);\r\n}\r\n\r\nvec3 getViewDirection(in vec3 positionWS)\r\n{\r\n    return normalize(u_CameraPos - positionWS);\r\n}\r\n\r\n// 根据投影剧专重映射深度\r\nvec4 remapPositionZ(vec4 position)\r\n{\r\n    position.z = position.z * 2.0 - position.w;\r\n    return position;\r\n}\r\n\r\n#endif // CameraCommon_lib";

    var Sprite3DCommonGLSL = "#if !defined(Sprite3DCommon_lib)\r\n    #define Sprite3DCommon_lib\r\n\r\nuniform mat4 u_WorldMat;\r\n\r\n    #ifdef LIGHTMAP\r\nuniform vec4 u_LightmapScaleOffset;\r\n    #endif // LIGHTMAP\r\n\r\nvec2 tranformLightMapUV(in vec2 texcoord, in vec4 tilingOffset)\r\n{\r\n    vec2 lightMapUV = vec2(texcoord.x, 1.0 - texcoord.y) * tilingOffset.xy + tilingOffset.zw;\r\n    lightMapUV.y = 1.0 - lightMapUV.y;\r\n    return lightMapUV;\r\n}\r\n\r\n#endif // Sprite3DCommon_lib";

    var Sprite3DVertexGLSL = "#if !defined(Sprite3DVertex_lib)\r\n    #define Sprite3DVertex_lib\r\n\r\n    #include \"Sprite3DCommon.glsl\";\r\n\r\n    #ifdef BONE\r\n// todo const int c_MaxBoneCount = 24\r\nuniform mat4 u_Bones[24];\r\n\r\n\t#ifdef SIMPLEBONE\r\nuniform vec4 u_SimpleAnimatorParams;\r\nuniform sampler2D u_SimpleAnimatorTexture;\r\nuniform float u_SimpleAnimatorTextureSize;\r\n\t    #include \"BakedBoneMatrixSampler.glsl\";\r\n\r\n\t#endif // SIMPLEBONE\r\n\r\n    #endif // BONE\r\n\r\n/**\r\n * world matrix\r\n */\r\nmat4 getWorldMatrix()\r\n{\r\n    #ifdef GPU_INSTANCE\r\n    mat4 worldMat = a_WorldMat;\r\n    #else\r\n    mat4 worldMat = u_WorldMat;\r\n    #endif // GPU_INSTANCE\r\n\r\n    #ifdef BONE\r\n\r\n\t#ifdef SIMPLEBONE\r\n\r\n\t    #ifdef GPU_INSTANCE\r\n    float currentPixelPos = a_SimpleTextureParams.x + a_SimpleTextureParams.y;\r\n\t    #else // GPU_INSTANCE\r\n    float currentPixelPos = u_SimpleAnimatorParams.x + u_SimpleAnimatorParams.y;\r\n\t    #endif // GPU_INSTANCE\r\n\r\n    float offset = 1.0 / u_SimpleAnimatorTextureSize;\r\n    mat4 skinTrans = loadBakedMatMatrix(currentPixelPos, a_BoneIndices.x, offset) * a_BoneWeights.x;\r\n    skinTrans += loadBakedMatMatrix(currentPixelPos, a_BoneIndices.y, offset) * a_BoneWeights.y;\r\n    skinTrans += loadBakedMatMatrix(currentPixelPos, a_BoneIndices.z, offset) * a_BoneWeights.z;\r\n    skinTrans += loadBakedMatMatrix(currentPixelPos, a_BoneIndices.w, offset) * a_BoneWeights.w;\r\n    worldMat = worldMat * skinTrans;\r\n\r\n\t#else // SIMPLEBONE\r\n\r\n    ivec4 boneIndex = ivec4(a_BoneIndices);\r\n    mat4 skinTrans = u_Bones[boneIndex.x] * a_BoneWeights.x;\r\n    skinTrans += u_Bones[boneIndex.y] * a_BoneWeights.y;\r\n    skinTrans += u_Bones[boneIndex.z] * a_BoneWeights.z;\r\n    skinTrans += u_Bones[boneIndex.w] * a_BoneWeights.w;\r\n    worldMat = worldMat * skinTrans;\r\n\r\n\t#endif // SIMPLEBONE\r\n\r\n    #endif // BONE\r\n\r\n    return worldMat;\r\n}\r\n\r\n#endif // Sprite3DVertex_lib";

    var Sprite3DFragGLSL = "#if !defined(Sprite3DFrag_lib)\r\n    #define Sprite3DFrag_lib\r\n\r\n    #include \"Sprite3DCommon.glsl\";\r\n\r\n#endif // Sprite3DFrag_lib";

    var DepthVertexGLSL = "#if !defined(DepthVertex_lib)\r\n    #define DepthVertex_lib\r\n\r\n    #include \"Scene.glsl\";\r\n    #include \"Camera.glsl\";\r\n    #include \"Sprite3DVertex.glsl\";\r\n\r\n    #include \"VertexCommon.glsl\";\r\n\r\n    #if defined(SHADOW) || defined(SHADOW_SPOT)\r\n\r\n\t#ifndef DEPTHPASS\r\n\t    #ifdef ENUNIFORMBLOCK\r\nuniform ShadowUniformBlock\r\n{\r\n    vec4 u_ShadowBias; // x: depth bias, y: normal bias\r\n    vec3 u_ShadowLightDirection;\r\n};\r\n\t    #else // ENUNIFORMBLOCK\r\nuniform vec4 u_ShadowBias; // x: depth bias, y: normal bias\r\n\t\t#ifdef SHADOW\r\nuniform vec3 u_ShadowLightDirection;\r\n\t\t#endif // SHADOW\r\n\t    #endif // ENUNIFORMBLOCK\r\n\r\n// 根据投影剧专重映射深度\r\n//vec4 remapPositionZ(vec4 position)\r\n//{\r\n//    position.z = position.z * 2.0 - position.w;\r\n//    return position;\r\n//}\r\n\r\nvec3 applyShadowBias(vec3 positionWS, vec3 normalWS, vec3 lightDirection)\r\n{\r\n    float invNdotL = 1.0 - clamp(dot(-lightDirection, normalWS), 0.0, 1.0);\r\n    float scale = invNdotL * u_ShadowBias.y;\r\n\r\n    // normal bias is negative since we want to apply an inset normal offset\r\n    positionWS += -lightDirection * u_ShadowBias.xxx;\r\n    positionWS += normalWS * vec3(scale);\r\n    return positionWS;\r\n}\r\n\t#endif // DEPTHPASS\r\n    #endif // SHADOW || SHADOW_SPOT\r\n\r\n    #ifdef DEPTHPASS\r\n\t#include \"Camera.glsl\";\r\n    #endif // DEPTHPASS\r\n\r\nvec4 DepthPositionCS(in vec3 positionWS, in vec3 normalWS)\r\n{\r\n    #ifdef DEPTHPASS\r\n    vec4 positionCS = u_ViewProjection * vec4(positionWS, 1.0);\r\n    #endif // DEPTHPASS\r\n\r\n    #ifdef SHADOW\r\n\t#ifndef DEPTHPASS\r\n    positionWS = applyShadowBias(positionWS, normalWS, u_ShadowLightDirection);\r\n    vec4 positionCS = u_ViewProjection * vec4(positionWS, 1.0);\r\n    positionCS.z = max(positionCS.z, 0.0); // min ndc z is 0.0\r\n\t#endif // DEPTHPASS\r\n    #endif // SHADOW\r\n\r\n    #ifdef SHADOW_SPOT\r\n\t#ifndef DEPTHPASS\r\n    vec4 positionCS = u_ViewProjection * vec4(positionWS, 1.0);\r\n    positionCS.z = positionCS.z - u_ShadowBias.x / positionCS.w;\r\n    positionCS.z = max(positionCS.z, 0.0); // min ndc z is 0.0\r\n\t#endif // DEPTHPASS\r\n    #endif // SHADOW_SPOT\r\n\r\n    return positionCS;\r\n}\r\n\r\n\r\n#endif // DepthVertex_lib";

    var DepthFragGLSL = "#if !defined(DepthFrag_lib)\r\n    #define DepthFrag_lib\r\n\r\nvec4 getDepthColor()\r\n{\r\n    return vec4(0.0);\r\n}\r\n\r\n#endif // DepthFrag_lib";

    var DepthNormalUtilGLSL = "#define SAMPLE_DEPTH_TEXTURE(textureName,coord2) (texture2D(textureName,coord2).r)\r\n//此方法库用来压缩解析深度贴图，法线深度贴图\r\n\r\n// Encoding/decoding view space normals into 2D 0..1 vector\r\nvec2 EncodeViewNormalStereo( vec3 n )\r\n{\r\n    n.z = abs(n.z);\r\n    float kScale = 1.7777;\r\n    vec2 enc;\r\n    enc = n.xy / (n.z+1.0);\r\n    enc /= kScale;\r\n    enc = enc*0.5+0.5;\r\n    return enc;\r\n}\r\n\r\nvec3 DecodeViewNormalStereo( vec4 enc4 )\r\n{\r\n    float kScale = 1.7777;\r\n    vec3 nn = enc4.xyz*vec3(2.0*kScale,2.0*kScale,0.0) + vec3(-kScale,-kScale,1.0);\r\n    float g = 2.0 / dot(nn.xyz,nn.xyz);\r\n    vec3 n;\r\n    n.xy = g*nn.xy;\r\n    n.z = g-1.0;\r\n    return n;\r\n}\r\n\r\n\r\n// Encoding/decoding [0..1) floats into 8 bit/channel RG. Note that 1.0 will not be encoded properly.\r\nvec2 EncodeFloatRG( float v )\r\n{\r\n    vec2 kEncodeMul = vec2(1.0, 255.0);\r\n    float kEncodeBit = 1.0/255.0;\r\n    vec2 enc = kEncodeMul * v;\r\n    enc = fract(enc);\r\n    enc.x -= enc.y * kEncodeBit;\r\n    return enc;\r\n}\r\n\r\n\r\n\r\nfloat DecodeFloatRG( vec2 enc )\r\n{\r\n    vec2 kDecodeDot = vec2(1.0, 1.0/255.0);\r\n    return dot( enc, kDecodeDot );\r\n}\r\n\r\nvec4 EncodeDepthNormal(float depth,vec3 normals){\r\n\tvec4 encode;\r\n\tencode.xy = EncodeViewNormalStereo(normals);\r\n\tencode.zw = EncodeFloatRG(depth);\r\n    return encode;\r\n}\r\n\r\nvoid DecodeDepthNormal( vec4 enc, out float depth, out vec3 normal )\r\n{\r\n    depth = DecodeFloatRG (enc.zw);\r\n    normal = DecodeViewNormalStereo (enc);\r\n}\r\n\r\n\r\n\r\nvec4 depthNormalsFragment(vec4 depthNormal)\r\n{\r\n    return EncodeDepthNormal(depthNormal.w,depthNormal.xyz);\r\n}\r\n\r\n\r\n// Z buffer to linear 0..1 depth\r\nfloat Linear01Depth(float z,vec4 zbufferParams)\r\n{\r\n    return 1.0 / (zbufferParams.x * z + zbufferParams.y);\r\n}\r\n// Z buffer to linear depth\r\nfloat LinearEyeDepth(float z,vec4 zbufferParams)\r\n{\r\n    return 1.0 / (zbufferParams.z * z + zbufferParams.w);\r\n}\r\n";

    var ShadowSampleTentGLSL = "// ------------------------------------------------------------------\r\n//  PCF Filtering Tent Functions\r\n// ------------------------------------------------------------------\r\n\r\n// Assuming a isoceles right angled triangle of height \"triangleHeight\" (as drawn below).\r\n// This function return the area of the triangle above the first texel(in Y the first texel).\r\n//\r\n// |\\      <-- 45 degree slop isosceles right angled triangle\r\n// | \\\r\n// ----    <-- length of this side is \"triangleHeight\"\r\n// _ _ _ _ <-- texels\r\nfloat sampleShadowGetIRTriangleTexelArea(float triangleHeight)\r\n{\r\n    return triangleHeight - 0.5;\r\n}\r\n\r\n// Assuming a isoceles triangle of 1.5 texels height and 3 texels wide lying on 4 texels.\r\n// This function return the area of the triangle above each of those texels.\r\n//    |    <-- offset from -0.5 to 0.5, 0 meaning triangle is exactly in the center\r\n//   / \\   <-- 45 degree slop isosceles triangle (ie tent projected in 2D)\r\n//  /   \\\r\n// _ _ _ _ <-- texels\r\n// X Y Z W <-- result indices (in computedArea.xyzw and computedAreaUncut.xyzw)\r\n// Top point at (right,top) in a texel,left bottom point at (middle,middle) in a texel,right bottom point at (middle,middle) in a texel.\r\nvoid sampleShadowGetTexelAreasTent3x3(float offset, out vec4 computedArea, out vec4 computedAreaUncut)\r\n{\r\n    // Compute the exterior areas,a and h is same.\r\n    float a = offset + 0.5;\r\n    float offsetSquaredHalved = a * a * 0.5;\r\n    computedAreaUncut.x = computedArea.x = offsetSquaredHalved - offset;\r\n    computedAreaUncut.w = computedArea.w = offsetSquaredHalved;\r\n\r\n    // Compute the middle areas\r\n    // For Y : We find the area in Y of as if the left section of the isoceles triangle would\r\n    // intersect the axis between Y and Z (ie where offset = 0).\r\n    computedAreaUncut.y = sampleShadowGetIRTriangleTexelArea(1.5 - offset);\r\n    // This area is superior to the one we are looking for if (offset < 0) thus we need to\r\n    // subtract the area of the triangle defined by (0,1.5-offset), (0,1.5+offset), (-offset,1.5).\r\n    float clampedOffsetLeft = min(offset,0.0);\r\n    float areaOfSmallLeftTriangle = clampedOffsetLeft * clampedOffsetLeft;\r\n    computedArea.y = computedAreaUncut.y - areaOfSmallLeftTriangle;\r\n\r\n    // We do the same for the Z but with the right part of the isoceles triangle\r\n    computedAreaUncut.z = sampleShadowGetIRTriangleTexelArea(1.5 + offset);\r\n    float clampedOffsetRight = max(offset,0.0);\r\n    float areaOfSmallRightTriangle = clampedOffsetRight * clampedOffsetRight;\r\n    computedArea.z = computedAreaUncut.z - areaOfSmallRightTriangle;\r\n}\r\n\r\n// Assuming a isoceles triangle of 2.5 texel height and 5 texels wide lying on 6 texels.\r\n// This function return the weight of each texels area relative to the full triangle area.\r\n//  /       \\\r\n// _ _ _ _ _ _ <-- texels\r\n// 0 1 2 3 4 5 <-- computed area indices (in texelsWeights[])\r\n// Top point at (right,top) in a texel,left bottom point at (middle,middle) in a texel,right bottom point at (middle,middle) in a texel.\r\nvoid sampleShadowGetTexelWeightsTent5x5(float offset, out vec3 texelsWeightsA, out vec3 texelsWeightsB)\r\n{\r\n    vec4 areaFrom3texelTriangle;\r\n    vec4 areaUncutFrom3texelTriangle;\r\n    sampleShadowGetTexelAreasTent3x3(offset, areaFrom3texelTriangle, areaUncutFrom3texelTriangle);\r\n\r\n    // Triangle slope is 45 degree thus we can almost reuse the result of the 3 texel wide computation.\r\n    // the 5 texel wide triangle can be seen as the 3 texel wide one but shifted up by one unit/texel.\r\n    // 0.16 is 1/(the triangle area)\r\n    texelsWeightsA.x = 0.16 * (areaFrom3texelTriangle.x);\r\n    texelsWeightsA.y = 0.16 * (areaUncutFrom3texelTriangle.y);\r\n    texelsWeightsA.z = 0.16 * (areaFrom3texelTriangle.y + 1.0);\r\n    texelsWeightsB.x = 0.16 * (areaFrom3texelTriangle.z + 1.0);\r\n    texelsWeightsB.y = 0.16 * (areaUncutFrom3texelTriangle.z);\r\n    texelsWeightsB.z = 0.16 * (areaFrom3texelTriangle.w);\r\n}\r\n\r\n// 5x5 Tent filter (45 degree sloped triangles in U and V)\r\nvoid sampleShadowComputeSamplesTent5x5(vec4 shadowMapTextureTexelSize, vec2 coord, out float fetchesWeights[9], out vec2 fetchesUV[9])\r\n{\r\n    // tent base is 5x5 base thus covering from 25 to 36 texels, thus we need 9 bilinear PCF fetches\r\n    vec2 tentCenterInTexelSpace = coord.xy * shadowMapTextureTexelSize.zw;\r\n    vec2 centerOfFetchesInTexelSpace = floor(tentCenterInTexelSpace + 0.5);\r\n    vec2 offsetFromTentCenterToCenterOfFetches = tentCenterInTexelSpace - centerOfFetchesInTexelSpace;\r\n\r\n    // find the weight of each texel based on the area of a 45 degree slop tent above each of them.\r\n    vec3 texelsWeightsUA, texelsWeightsUB;\r\n    vec3 texelsWeightsVA, texelsWeightsVB;\r\n    sampleShadowGetTexelWeightsTent5x5(offsetFromTentCenterToCenterOfFetches.x, texelsWeightsUA, texelsWeightsUB);\r\n    sampleShadowGetTexelWeightsTent5x5(offsetFromTentCenterToCenterOfFetches.y, texelsWeightsVA, texelsWeightsVB);\r\n\r\n    // each fetch will cover a group of 2x2 texels, the weight of each group is the sum of the weights of the texels\r\n    vec3 fetchesWeightsU = vec3(texelsWeightsUA.xz, texelsWeightsUB.y) + vec3(texelsWeightsUA.y, texelsWeightsUB.xz);\r\n    vec3 fetchesWeightsV = vec3(texelsWeightsVA.xz, texelsWeightsVB.y) + vec3(texelsWeightsVA.y, texelsWeightsVB.xz);\r\n\r\n    // move the PCF bilinear fetches to respect texels weights\r\n    vec3 fetchesOffsetsU = vec3(texelsWeightsUA.y, texelsWeightsUB.xz) / fetchesWeightsU.xyz + vec3(-2.5,-0.5,1.5);\r\n    vec3 fetchesOffsetsV = vec3(texelsWeightsVA.y, texelsWeightsVB.xz) / fetchesWeightsV.xyz + vec3(-2.5,-0.5,1.5);\r\n    fetchesOffsetsU *= shadowMapTextureTexelSize.xxx;\r\n    fetchesOffsetsV *= shadowMapTextureTexelSize.yyy;\r\n\r\n    vec2 bilinearFetchOrigin = centerOfFetchesInTexelSpace * shadowMapTextureTexelSize.xy;\r\n    fetchesUV[0] = bilinearFetchOrigin + vec2(fetchesOffsetsU.x, fetchesOffsetsV.x);\r\n    fetchesUV[1] = bilinearFetchOrigin + vec2(fetchesOffsetsU.y, fetchesOffsetsV.x);\r\n    fetchesUV[2] = bilinearFetchOrigin + vec2(fetchesOffsetsU.z, fetchesOffsetsV.x);\r\n    fetchesUV[3] = bilinearFetchOrigin + vec2(fetchesOffsetsU.x, fetchesOffsetsV.y);\r\n    fetchesUV[4] = bilinearFetchOrigin + vec2(fetchesOffsetsU.y, fetchesOffsetsV.y);\r\n    fetchesUV[5] = bilinearFetchOrigin + vec2(fetchesOffsetsU.z, fetchesOffsetsV.y);\r\n    fetchesUV[6] = bilinearFetchOrigin + vec2(fetchesOffsetsU.x, fetchesOffsetsV.z);\r\n    fetchesUV[7] = bilinearFetchOrigin + vec2(fetchesOffsetsU.y, fetchesOffsetsV.z);\r\n    fetchesUV[8] = bilinearFetchOrigin + vec2(fetchesOffsetsU.z, fetchesOffsetsV.z);\r\n\r\n    fetchesWeights[0] = fetchesWeightsU.x * fetchesWeightsV.x;\r\n    fetchesWeights[1] = fetchesWeightsU.y * fetchesWeightsV.x;\r\n    fetchesWeights[2] = fetchesWeightsU.z * fetchesWeightsV.x;\r\n    fetchesWeights[3] = fetchesWeightsU.x * fetchesWeightsV.y;\r\n    fetchesWeights[4] = fetchesWeightsU.y * fetchesWeightsV.y;\r\n    fetchesWeights[5] = fetchesWeightsU.z * fetchesWeightsV.y;\r\n    fetchesWeights[6] = fetchesWeightsU.x * fetchesWeightsV.z;\r\n    fetchesWeights[7] = fetchesWeightsU.y * fetchesWeightsV.z;\r\n    fetchesWeights[8] = fetchesWeightsU.z * fetchesWeightsV.z;\r\n}";

    var ShadowSamplerGLSL = "#if !defined(ShadowSampler_lib)\r\n    #define ShadowSampler_lib\r\n\r\n    #ifndef GRAPHICS_API_GLES3\r\n\t#define NO_NATIVE_SHADOWMAP\r\n    #endif // GRAPHICS_API_GLES3\r\n\r\n    #if defined(NO_NATIVE_SHADOWMAP)\r\n\t#define TEXTURE2D_SHADOW(textureName)\t\t     uniform mediump sampler2D textureName\r\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, coord3) (texture2D(textureName, coord3.xy).r < coord3.z ? 0.0 : 1.0)\r\n\t#define TEXTURE2D_SHADOW_PARAM(shadowMap)\t     mediump sampler2D shadowMap\r\n    #else // NO_NATIVE_SHADOWMAP\r\n\t#define TEXTURE2D_SHADOW(textureName)\t\t     uniform mediump sampler2DShadow textureName\r\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, coord3) textureLod(textureName, coord3, 0.0)\r\n\t#define TEXTURE2D_SHADOW_PARAM(shadowMap)\t     mediump sampler2DShadow shadowMap\r\n    #endif // NO_NATIVE_SHADOWMAP\r\n\r\n    // 计算阴影\r\n    #ifdef RECEIVESHADOW\r\n\r\n\t#include \"ShadowSampleTent.glsl\";\r\n\r\nuniform vec4 u_ShadowParams;\r\n\r\n\t#define ShadowStrength\t   u_ShadowParams.x\r\n\t#define SpotShadowStrength u_ShadowParams.y\r\n\r\n    // 平行光阴影\r\n\t#ifdef SHADOW\r\n\t    #define CALCULATE_SHADOWS\r\nvarying vec4 v_ShadowCoord;\r\nTEXTURE2D_SHADOW(u_ShadowMap);\r\nuniform vec4 u_ShadowMapSize;\r\n\r\n#ifdef SHADOW_CASCADE\r\nconst int c_MaxCascadeCount = 4;\r\n#else //SHADOW_CASCADE\r\nconst int c_MaxCascadeCount = 1;\r\n#endif//SHADOW_CASCADE\r\n\r\nuniform mat4 u_ShadowMatrices[c_MaxCascadeCount];\r\nuniform vec4 u_ShadowSplitSpheres[c_MaxCascadeCount];\r\n\t#endif // SHADOW\r\n\r\n\t// 聚光灯阴影\r\n\t#ifdef SHADOW_SPOT\r\n\t    #define CALCULATE_SPOTSHADOWS\r\nvarying vec4 v_SpotShadowCoord;\r\nTEXTURE2D_SHADOW(u_SpotShadowMap);\r\nuniform vec4 u_SpotShadowMapSize;\r\nuniform mat4 u_SpotViewProjectMatrix;\r\n\t#endif // SHADOW_SPOT\r\n\r\nfloat sampleShdowMapFiltered4(TEXTURE2D_SHADOW_PARAM(shadowMap), vec3 shadowCoord, vec4 shadowMapSize)\r\n{\r\n    float attenuation;\r\n    vec4 attenuation4;\r\n    vec2 offset = shadowMapSize.xy / 2.0;\r\n    vec3 shadowCoord0 = shadowCoord + vec3(-offset, 0.0);\r\n    vec3 shadowCoord1 = shadowCoord + vec3(offset.x, -offset.y, 0.0);\r\n    vec3 shadowCoord2 = shadowCoord + vec3(-offset.x, offset.y, 0.0);\r\n    vec3 shadowCoord3 = shadowCoord + vec3(offset, 0.0);\r\n    attenuation4.x = SAMPLE_TEXTURE2D_SHADOW(shadowMap, shadowCoord0);\r\n    attenuation4.y = SAMPLE_TEXTURE2D_SHADOW(shadowMap, shadowCoord1);\r\n    attenuation4.z = SAMPLE_TEXTURE2D_SHADOW(shadowMap, shadowCoord2);\r\n    attenuation4.w = SAMPLE_TEXTURE2D_SHADOW(shadowMap, shadowCoord3);\r\n    attenuation = dot(attenuation4, vec4(0.25));\r\n    return attenuation;\r\n}\r\n\r\nfloat sampleShdowMapFiltered9(TEXTURE2D_SHADOW_PARAM(shadowMap), vec3 shadowCoord, vec4 shadowmapSize)\r\n{\r\n    float attenuation;\r\n    float fetchesWeights[9];\r\n    vec2 fetchesUV[9];\r\n    sampleShadowComputeSamplesTent5x5(shadowmapSize, shadowCoord.xy, fetchesWeights, fetchesUV);\r\n    attenuation = fetchesWeights[0] * SAMPLE_TEXTURE2D_SHADOW(shadowMap, vec3(fetchesUV[0].xy, shadowCoord.z));\r\n    attenuation += fetchesWeights[1] * SAMPLE_TEXTURE2D_SHADOW(shadowMap, vec3(fetchesUV[1].xy, shadowCoord.z));\r\n    attenuation += fetchesWeights[2] * SAMPLE_TEXTURE2D_SHADOW(shadowMap, vec3(fetchesUV[2].xy, shadowCoord.z));\r\n    attenuation += fetchesWeights[3] * SAMPLE_TEXTURE2D_SHADOW(shadowMap, vec3(fetchesUV[3].xy, shadowCoord.z));\r\n    attenuation += fetchesWeights[4] * SAMPLE_TEXTURE2D_SHADOW(shadowMap, vec3(fetchesUV[4].xy, shadowCoord.z));\r\n    attenuation += fetchesWeights[5] * SAMPLE_TEXTURE2D_SHADOW(shadowMap, vec3(fetchesUV[5].xy, shadowCoord.z));\r\n    attenuation += fetchesWeights[6] * SAMPLE_TEXTURE2D_SHADOW(shadowMap, vec3(fetchesUV[6].xy, shadowCoord.z));\r\n    attenuation += fetchesWeights[7] * SAMPLE_TEXTURE2D_SHADOW(shadowMap, vec3(fetchesUV[7].xy, shadowCoord.z));\r\n    attenuation += fetchesWeights[8] * SAMPLE_TEXTURE2D_SHADOW(shadowMap, vec3(fetchesUV[8].xy, shadowCoord.z));\r\n    return attenuation;\r\n}\r\n    #endif // RECEIVESHADOW\r\n\r\n    // 计算平行光阴影\r\n    #if defined(CALCULATE_SHADOWS)\r\n\r\n#ifdef SHADOW_CASCADE\r\n// 平行光阴影级联索引\r\nmediump int computeCascadeIndex(in vec3 positionWS)\r\n{\r\n    vec3 fromCenter0 = positionWS - u_ShadowSplitSpheres[0].xyz;\r\n    vec3 fromCenter1 = positionWS - u_ShadowSplitSpheres[1].xyz;\r\n    vec3 fromCenter2 = positionWS - u_ShadowSplitSpheres[2].xyz;\r\n    vec3 fromCenter3 = positionWS - u_ShadowSplitSpheres[3].xyz;\r\n\r\n    mediump vec4 comparison = vec4(dot(fromCenter0, fromCenter0) < u_ShadowSplitSpheres[0].w,\r\n\tdot(fromCenter1, fromCenter1) < u_ShadowSplitSpheres[1].w,\r\n\tdot(fromCenter2, fromCenter2) < u_ShadowSplitSpheres[2].w,\r\n\tdot(fromCenter3, fromCenter3) < u_ShadowSplitSpheres[3].w);\r\n\r\n    comparison.yzw = clamp(comparison.yzw - comparison.xyz, 0.0, 1.0); // keep the nearest\r\n    mediump vec4 indexCoefficient = vec4(4.0, 3.0, 2.0, 1.0);\r\n    mediump int index = 4 - int(dot(comparison, indexCoefficient));\r\n    return index;\r\n}\r\n#endif\r\n\r\n// 平行光阴影坐标\r\nvec4 getShadowCoord(in vec3 positionWS)\r\n{\r\n\t#ifdef SHADOW_CASCADE\r\n    mediump int cascadeIndex = computeCascadeIndex(positionWS);\r\n\t    #ifdef GRAPHICS_API_GLES3\r\n    mat4 shadowMat = u_ShadowMatrices[cascadeIndex];\r\n\t    #else // GRAPHICS_API_GLES3\r\n    mat4 shadowMat;\r\n    if (cascadeIndex == 0)\r\n\t{\r\n\t    shadowMat = u_ShadowMatrices[0];\r\n\t}\r\n    else if (cascadeIndex == 1)\r\n\t{\r\n\t    shadowMat = u_ShadowMatrices[1];\r\n\t}\r\n    else if (cascadeIndex == 2)\r\n\t{\r\n\t    shadowMat = u_ShadowMatrices[2];\r\n\t}\r\n    else\r\n\t{\r\n\t    shadowMat = u_ShadowMatrices[3];\r\n\t}\r\n\t    #endif // GRAPHICS_API_GLES3\r\n\r\n    return shadowMat * vec4(positionWS, 1.0);\r\n\r\n\t#else // SHADOW_CASCADE\r\n\r\n    return u_ShadowMatrices[0] * vec4(positionWS, 1.0);\r\n\r\n\t#endif // SHADOW_CASCADE\r\n}\r\n\r\n// 采样平行光阴影\r\nfloat sampleShadowmap(in vec4 shadowCoord)\r\n{\r\n    float attenuation = 1.0;\r\n\r\n    vec3 coord = shadowCoord.xyz / shadowCoord.w;\r\n\r\n    vec4 shadowmapSize = u_ShadowMapSize;\r\n\r\n    if (coord.z > 0.0 && coord.z < 1.0)\r\n\t{\r\n\t#if defined(SHADOW_SOFT_SHADOW_HIGH)\r\n\t    attenuation = sampleShdowMapFiltered9(u_ShadowMap, coord, shadowmapSize);\r\n\t#elif defined(SHADOW_SOFT_SHADOW_LOW)\r\n\t    attenuation = sampleShdowMapFiltered4(u_ShadowMap, coord, shadowmapSize);\r\n\t#else // hard\r\n\t    attenuation = SAMPLE_TEXTURE2D_SHADOW(u_ShadowMap, coord);\r\n\t#endif // SHADOW_SOFT_SHADOW_HIGH\r\n\t    attenuation = mix(1.0, attenuation, ShadowStrength);\r\n\t}\r\n\r\n    return attenuation;\r\n}\r\n\r\n    #endif // CALCULATE_SHADOWS\r\n\r\n    // 计算 聚光灯 阴影\r\n    #if defined(CALCULATE_SPOTSHADOWS)\r\n\r\n// 聚光灯阴影坐标\r\nvec4 getSpotShadowCoord(in vec3 positionWS)\r\n{\r\n    vec4 coordinate = u_SpotViewProjectMatrix * vec4(positionWS, 1.0);\r\n\r\n    return coordinate;\r\n}\r\n\r\n// 采样聚光灯阴影\r\nfloat sampleSpotShadowmap(vec4 shadowCoord)\r\n{\r\n    float attenuation = 1.0;\r\n\r\n    vec3 coord = shadowCoord.xyz / shadowCoord.w;\r\n    coord.xy = coord.xy * 0.5 + 0.5;\r\n\r\n    vec4 shadowmapSize = u_SpotShadowMapSize;\r\n    // todo\r\n    if (coord.z > 0.0 && coord.z < 1.0)\r\n\t{\r\n\t#if defined(SHADOW_SPOT_SOFT_SHADOW_HIGH)\r\n\t    attenuation = sampleShdowMapFiltered9(u_SpotShadowMap, coord, shadowmapSize);\r\n\t#elif defined(SHADOW_SPOT_SOFT_SHADOW_LOW)\r\n\t    attenuation = sampleShdowMapFiltered4(u_SpotShadowMap, coord, shadowmapSize);\r\n\t#else // hard\r\n\t    attenuation = SAMPLE_TEXTURE2D_SHADOW(u_SpotShadowMap, coord);\r\n\t#endif\r\n\t    attenuation = mix(1.0, attenuation, SpotShadowStrength);\r\n\t}\r\n\r\n    return attenuation;\r\n}\r\n\r\n    #endif // CALCULATE_SPOTSHADOWS\r\n\r\n#endif // ShadowSampler_lib";

    var SceneFogGLSL = "#if !defined(SceneFog_lib)\r\n    #define SceneFog_lib\r\n\r\n#include \"Camera.glsl\";\r\n\r\n    \r\n#ifdef FOG\r\n    varying float v_fogFactor;\r\n    float getFogFactor()\r\n    {\r\n        return v_fogFactor;\r\n    }\r\n\r\n    vec3 scenUnlitFog(in vec3 color)\r\n    {\r\n        float lerpFact = getFogFactor();\r\n        #ifdef ADDTIVEFOG\r\n            clamp(lerpFact, 0.0, 1.0);\r\n            return mix(vec3(0.0), color, lerpFact);\r\n        #else\r\n            clamp(lerpFact, 0.0, 1.0);\r\n            return mix(u_FogColor.rgb, color, lerpFact);\r\n        #endif // ADDTIVEFOG\r\n    }\r\n\r\n    vec3 sceneLitFog(in vec3 color)\r\n    {\r\n        float lerpFact = getFogFactor();\r\n        clamp(lerpFact, 0.0, 1.0);\r\n        return mix(u_FogColor.rgb, color, lerpFact);\r\n    }\r\n\r\n#endif\r\n#endif // SceneFog_lib";

    var SceneFogInputGLSL = "#if !defined(SceneFog_lib)\r\n    #define SceneFog_lib\r\n\r\n#include \"Camera.glsl\";\r\n\r\n    \r\n#ifdef FOG\r\n    varying float v_fogFactor;\r\n    void FogHandle(in float fact)\r\n    {\r\n        float lerpFact = 0.0;\r\n        #ifdef FOG_EXP\r\n            lerpFact = fact * (u_FogParams.z / log(2.0));\r\n            lerpFact = exp2(-lerpFact);\r\n        #elif defined(FOG_EXP2)\r\n            lerpFact = fact * (u_FogParams.z / sqrt(log(2.0)));\r\n            lerpFact = exp2(-lerpFact);\r\n        #else // default FOG_LINEAR\r\n            lerpFact = (-1.0 * fact / (u_FogParams.y - u_FogParams.x) + u_FogParams.y / (u_FogParams.y - u_FogParams.x));\r\n        #endif\r\n        v_fogFactor = lerpFact;\r\n    }\r\n#endif\r\n#endif // SceneFog_lib";

    var LightingGLSL = "#if !defined(Lighting_lib)\r\n    #define Lighting_lib\r\n\r\n    #include \"ShadowSampler.glsl\";\r\n\r\nstruct Light {\r\n    vec3 color;\r\n    vec3 dir;\r\n    float attenuation;\r\n};\r\n\r\nstruct DirectionLight {\r\n    vec3 color;\r\n    vec3 direction;\r\n    float attenuation;\r\n    int lightMode;\r\n};\r\n\r\nstruct PointLight {\r\n    vec3 color;\r\n    vec3 position;\r\n    float range;\r\n    float attenuation;\r\n    int lightMode;\r\n};\r\n\r\nstruct SpotLight {\r\n    vec3 color;\r\n    vec3 position;\r\n    float range;\r\n    vec3 direction;\r\n    float spot;\r\n    float attenuation;\r\n    int lightMode;\r\n};\r\n\r\n    #define LightMode_Mix      0\r\n    #define LightMode_RealTime 1\r\n\r\nint getAttenuationByMode(float lightMapMode)\r\n{\r\n    #ifdef LIGHTMAP // mix 0 realtime 1\r\n    return int(lightMapMode);\r\n    #endif\r\n    return LightMode_RealTime;\r\n}\r\n\r\n    #if defined(DIRECTIONLIGHT) || defined(POINTLIGHT) || defined(SPOTLIGHT)\r\n\r\n\t#define LIGHTING\r\n\r\n// 灯光衰减函数\r\nfloat attenuation(in vec3 L, in float invLightRadius)\r\n{\r\n    float fRatio = clamp(length(L) * invLightRadius, 0.0, 1.0);\r\n    fRatio *= fRatio;\r\n    return 1.0 / (1.0 + 25.0 * fRatio) * clamp(4.0 * (1.0 - fRatio), 0.0, 1.0);\r\n}\r\n\r\n// 平行光\r\nLight getLight(in DirectionLight directionLight)\r\n{\r\n    Light light;\r\n    light.color = directionLight.color;\r\n    light.dir = directionLight.direction;\r\n    light.attenuation = directionLight.attenuation;\r\n    return light;\r\n}\r\n\r\n// 点光\r\nLight getLight(in PointLight pointLight, in vec3 normalWS, in vec3 positionWS)\r\n{\r\n    vec3 lightDirection = positionWS - pointLight.position;\r\n    float rangeAttenuate = attenuation(lightDirection, 1.0 / pointLight.range);\r\n\r\n    Light light;\r\n    light.color = pointLight.color * rangeAttenuate;\r\n    light.dir = normalize(lightDirection);\r\n    light.attenuation = pointLight.attenuation;\r\n    return light;\r\n}\r\n\r\n// 聚光灯\r\nLight getLight(in SpotLight spotLight, in vec3 normalWS, in vec3 positionWS)\r\n{\r\n    vec3 lightDirection = positionWS - spotLight.position;\r\n    vec3 normalizeLightDir = normalize(lightDirection);\r\n\r\n    vec2 cosAngles = cos(vec2(spotLight.spot, spotLight.spot * 0.5) * 0.5);\r\n    float dirAttenuate = dot(spotLight.direction, normalizeLightDir);\r\n    dirAttenuate *= smoothstep(cosAngles.x, cosAngles.y, dirAttenuate);\r\n\r\n    float rangeAttenuate = attenuation(lightDirection, 1.0 / spotLight.range);\r\n\r\n    Light light;\r\n    light.color = spotLight.color * rangeAttenuate * dirAttenuate;\r\n    light.dir = normalizeLightDir;\r\n    light.attenuation = spotLight.attenuation;\r\n    return light;\r\n}\r\n\r\n\t#ifdef LEGACYSINGLELIGHTING\r\n\t    #define CalculateLightCount 1\r\n\t    #define DirectionCount\t1\r\n\r\n\t    #ifdef DIRECTIONLIGHT\r\nuniform DirectionLight u_DirectionLight;\r\n\t    #endif // DIRECTIONLIGHT\r\n\r\n\t    #ifdef POINTLIGHT\r\nuniform PointLight u_PointLight;\r\n\t    #endif // POINTLIGHT\r\n\r\n\t    #ifdef SPOTLIGHT\r\nuniform SpotLight u_SpotLight;\r\n\t    #endif // SPOTLIGHT\r\n\r\n\t#else // LEGACYSINGLELIGHTING\r\n\t    #define CalculateLightCount MAX_LIGHT_COUNT\r\n\t    #define DirectionCount\tu_DirationLightCount\r\n\r\nuniform sampler2D u_LightBuffer;\r\n\r\n\t    #ifdef DIRECTIONLIGHT\r\nuniform mediump int u_DirationLightCount;\r\n\t    #endif\r\n\r\n\t    #if defined(POINTLIGHT) || defined(SPOTLIGHT)\r\nconst int c_ClusterBufferWidth = CLUSTER_X_COUNT * CLUSTER_Y_COUNT;\r\nconst int c_ClusterBufferHeight = CLUSTER_Z_COUNT * (1 + int(ceil(float(MAX_LIGHT_COUNT_PER_CLUSTER) / 4.0)));\r\nconst int c_ClusterBufferFloatWidth = c_ClusterBufferWidth * 4;\r\nuniform sampler2D u_LightClusterBuffer;\r\n\r\nint getLightIndex(in int offset, in int index)\r\n{\r\n    int totalOffset = offset + index;\r\n    int row = totalOffset / c_ClusterBufferFloatWidth;\r\n    int lastRowFloat = totalOffset - row * c_ClusterBufferFloatWidth;\r\n    int col = lastRowFloat / 4;\r\n    vec2 uv = vec2((float(col) + 0.5) / float(c_ClusterBufferWidth), (float(row) + 0.5) / float(c_ClusterBufferHeight));\r\n    vec4 texPixel = texture2D(u_LightClusterBuffer, uv);\r\n    int pixelComponent = lastRowFloat - col * 4;\r\n\r\n\t\t#ifdef GRAPHICS_API_GLES3\r\n    return int(texPixel[pixelComponent]);\r\n\t\t#else\r\n    if (pixelComponent == 0)\r\n\treturn int(texPixel.x);\r\n    else if (pixelComponent == 1)\r\n\treturn int(texPixel.y);\r\n    else if (pixelComponent == 2)\r\n\treturn int(texPixel.z);\r\n    else\r\n\treturn int(texPixel.w);\r\n\t\t#endif\r\n}\r\n\t    #endif // POINTLIGHT || SPOTLIGHT\r\n\r\n\t#endif // LEGACYSINGLELIGHTING\r\n\r\n\t#ifdef DIRECTIONLIGHT\r\nDirectionLight getDirectionLight(in int index, in vec3 positionWS)\r\n{\r\n    DirectionLight light;\r\n\t    #ifdef LEGACYSINGLELIGHTING\r\n    light.color = u_DirectionLight.color;\r\n    light.direction = u_DirectionLight.direction;\r\n    light.attenuation = 1.0;\r\n    light.lightMode = LightMode_RealTime;\r\n\t    #else // LEGACYSINGLELIGHTING\r\n    float v = (float(index) + 0.5) / float(CalculateLightCount);\r\n    vec4 p1 = texture2D(u_LightBuffer, vec2(0.125, v));\r\n    vec4 p2 = texture2D(u_LightBuffer, vec2(0.375, v));\r\n    light.color = p1.rgb;\r\n    light.direction = p2.rgb;\r\n    light.attenuation = 1.0;\r\n    light.lightMode = getAttenuationByMode(p1.a);\r\n\t    #endif // LEGACYSINGLELIGHTING\r\n\r\n\t    #if defined(CALCULATE_SHADOWS)\r\n    if (index == 0)\r\n\t{\r\n\t    vec4 shadowCoord = getShadowCoord(positionWS);\r\n\t    float shadowAttenuation = sampleShadowmap(shadowCoord);\r\n\t    light.attenuation = shadowAttenuation;\r\n\t}\r\n\t    #endif // CALCULATE_SHADOWS\r\n\r\n    return light;\r\n}\r\n\t#endif // DIRECTIONLIGHT\r\n\r\n\t#if defined(POINTLIGHT) || defined(SPOTLIGHT)\r\nivec4 getClusterInfo(mat4 viewMatrix, vec4 viewport, vec3 positionWS, vec4 fragCoord, vec4 projectParams)\r\n{\r\n\t    #ifdef LEGACYSINGLELIGHTING\r\n    return ivec4(1, 1, 0, 0);\r\n\t    #else // LEGACYSINGLELIGHTING\r\n    // todo  这个地方 用 positionVS 替换?\r\n    vec3 viewPos = vec3(viewMatrix * vec4(positionWS, 1.0));\r\n    int clusterXIndex = int(floor(fragCoord.x / (float(viewport.z) / float(CLUSTER_X_COUNT))));\r\n    int clusterYIndex = int(floor((viewport.w * (projectParams.z < 0.0 ? 0.0 : 1.0) - fragCoord.y * projectParams.z) / (float(viewport.w) / float(CLUSTER_Y_COUNT))));\r\n    float zSliceParam = float(CLUSTER_Z_COUNT) / log2(projectParams.y / projectParams.x);\r\n    int clusterZIndex = int(floor(log2(-viewPos.z) * zSliceParam - log2(projectParams.x) * zSliceParam));\r\n    // todo 化简\r\n    vec2 uv = vec2((float(clusterXIndex + clusterYIndex * CLUSTER_X_COUNT) + 0.5) / float(c_ClusterBufferWidth), (float(clusterZIndex) + 0.5) / float(c_ClusterBufferHeight));\r\n    vec4 clusterPixel = texture2D(u_LightClusterBuffer, uv);\r\n    return ivec4(clusterPixel); // X:Point Count Y:Spot Count Z、W:Light Offset\r\n\t    #endif // LEGACYSINGLELIGHTING\r\n}\r\n\t#endif // POINTLIGHT || SPOTLIGHT\r\n\r\n\t#ifdef POINTLIGHT\r\nPointLight getPointLight(in int index, in ivec4 clusterInfo, in vec3 positionWS)\r\n{\r\n\r\n    PointLight light;\r\n\t    #ifdef LEGACYSINGLELIGHTING\r\n    light.color = u_PointLight.color;\r\n    light.position = u_PointLight.position;\r\n    light.range = u_PointLight.range;\r\n    light.attenuation = 1.0;\r\n\t    #else // LEGACYSINGLELIGHTING\r\n    // todo  重复计算\r\n    int indexOffset = clusterInfo.z * c_ClusterBufferFloatWidth + clusterInfo.w;\r\n    int pointIndex = getLightIndex(indexOffset, index);\r\n    float v = (float(pointIndex) + 0.5) / float(CalculateLightCount);\r\n    vec4 p1 = texture2D(u_LightBuffer, vec2(0.125, v));\r\n    vec4 p2 = texture2D(u_LightBuffer, vec2(0.375, v));\r\n    light.color = p1.rgb;\r\n    light.range = p1.a;\r\n    light.position = p2.rgb;\r\n    light.attenuation = 1.0;\r\n    light.lightMode = getAttenuationByMode(p2.a);\r\n\t    #endif // LEGACYSINGLELIGHTING\r\n    return light;\r\n}\r\n\t#endif // POINTLIGHT\r\n\r\n\t#ifdef SPOTLIGHT\r\nSpotLight getSpotLight(in int index, in ivec4 clusterInfo, in vec3 positionWS)\r\n{\r\n    SpotLight light;\r\n\r\n\t    #ifdef LEGACYSINGLELIGHTING\r\n    light.color = u_SpotLight.color;\r\n    light.position = u_SpotLight.position;\r\n    light.range = u_SpotLight.range;\r\n    light.direction = u_SpotLight.direction;\r\n    light.spot = u_SpotLight.spot;\r\n    light.attenuation = 1.0;\r\n\t    #else // LEGACYSINGLELIGHTING\r\n    // todo  重复计算\r\n    int indexOffset = clusterInfo.z * c_ClusterBufferFloatWidth + clusterInfo.w;\r\n    int spotIndex = getLightIndex(indexOffset, index + clusterInfo.x);\r\n    float v = (float(spotIndex) + 0.5) / float(CalculateLightCount);\r\n    vec4 p1 = texture2D(u_LightBuffer, vec2(0.125, v));\r\n    vec4 p2 = texture2D(u_LightBuffer, vec2(0.375, v));\r\n    vec4 p3 = texture2D(u_LightBuffer, vec2(0.625, v));\r\n    light.color = p1.rgb;\r\n    light.range = p1.a;\r\n    light.position = p2.rgb;\r\n    light.spot = p2.a;\r\n    light.direction = p3.rgb;\r\n    light.attenuation = 1.0;\r\n    light.lightMode = getAttenuationByMode(p3.a);\r\n\t    #endif // LEGACYSINGLELIGHTING\r\n\r\n\t    #if defined(CALCULATE_SPOTSHADOWS)\r\n    if (index == 0)\r\n\t{\r\n\t    vec4 shadowCoord = getSpotShadowCoord(positionWS);\r\n\t    float shadowAttenuation = sampleSpotShadowmap(shadowCoord);\r\n\t    light.attenuation = shadowAttenuation;\r\n\t}\r\n\t    #endif // CALCULATE_SPOTSHADOWS\r\n\r\n    return light;\r\n}\r\n\t#endif // SPOTLIGHT\r\n\r\n    #endif // DIRECTIONLIGHT || POINTLIGHT || SPOTLIGHT\r\n\r\n#endif // Lighting_lib";

    var GlobalIlluminationGLSL = "#if !defined(globalIllumination_lib)\r\n    #define globalIllumination_lib\r\n\r\nvec3 rotateByYAixs(in vec3 normal)\r\n{\r\n    float co = cos(u_GIRotate);\r\n    float si = sin(u_GIRotate);\r\n    float x = normal.x * co - normal.z * si;\r\n    float z = normal.x * si + normal.z * co;\r\n    return vec3(x, normal.y, z);\r\n}\r\n\r\nvec4 rotateByYAixs(in vec4 normal)\r\n{\r\n    float co = cos(u_GIRotate);\r\n    float si = sin(u_GIRotate);\r\n    float x = normal.x * co - normal.z * si;\r\n    float z = normal.x * si + normal.z * co;\r\n    return vec4(x, normal.y, z, normal.w);\r\n}\r\nuniform float u_AmbientIntensity;\r\nuniform float u_ReflectionIntensity;\r\n\r\n    #ifdef GI_IBL\r\n\r\nuniform vec3 u_IblSH[9];\r\n\r\n\t#define IBL_ROUGHNESS_LEVEL 4.0\r\nuniform samplerCube u_IBLTex;\r\n\r\n// todo 格式\r\nvec3 diffuseIrradiance(in vec3 normal)\r\n{\r\n    // todo cmeng 生成的数据问题， 临时转换下\r\n    vec3 n = normal * vec3(-1.0, 1.0, 1.0);\r\n    n = rotateByYAixs(n);\r\n    return max(\r\n\tu_IblSH[0]\r\n\t    + u_IblSH[1] * n.y\r\n\t    + u_IblSH[2] * n.z\r\n\t    + u_IblSH[3] * n.x\r\n\t    + u_IblSH[4] * (n.y * n.x)\r\n\t    + u_IblSH[5] * (n.y * n.z)\r\n\t    + u_IblSH[6] * (3.0 * n.z * n.z - 1.0)\r\n\t    + u_IblSH[7] * (n.z * n.x)\r\n\t    + u_IblSH[8] * (n.x * n.x - n.y * n.y),\r\n\t0.0);\r\n}\r\n\r\nvec3 specularIrradiance(in vec3 r, in float perceptualRoughness)\r\n{\r\n    float lod = IBL_ROUGHNESS_LEVEL * perceptualRoughness;\r\n\r\n    // todo 临时转换\r\n    vec3 reflectDir = r * vec3(-1.0, 1.0, 1.0);\r\n\r\n    // todo rotateY SceneConfig\r\n    reflectDir = rotateByYAixs(reflectDir);\r\n\r\n    // todo float 编码 ?\r\n    vec4 reflectSampler = textureCubeLodEXT(u_IBLTex, reflectDir, lod);\r\n\r\n\t#ifdef IBL_RGBD\r\n    return decodeRGBD(reflectSampler);\r\n\t#else // IBL_RGBD\r\n    return reflectSampler.rgb;\r\n\t#endif // IBL_RGBD\r\n}\r\n\r\n    #endif // GI_IBL\r\n\r\n    #ifdef GI_LEGACYIBL\r\n\r\nuniform vec4 u_AmbientSHAr;\r\nuniform vec4 u_AmbientSHAg;\r\nuniform vec4 u_AmbientSHAb;\r\nuniform vec4 u_AmbientSHBr;\r\nuniform vec4 u_AmbientSHBg;\r\nuniform vec4 u_AmbientSHBb;\r\nuniform vec4 u_AmbientSHC;\r\n\r\n\t#define LAYA_SPECCUBE_LOD_STEPS 6.0\r\nuniform samplerCube u_ReflectTexture;\r\nuniform vec4 u_ReflectCubeHDRParams;\r\n\r\nvec3 shEvalLinearL0L1(in vec4 normal)\r\n{\r\n    vec3 x;\r\n    x.r = dot(u_AmbientSHAr, normal);\r\n    x.g = dot(u_AmbientSHAg, normal);\r\n    x.b = dot(u_AmbientSHAb, normal);\r\n    return x;\r\n}\r\n\r\nvec3 shEvalLinearL2(in vec4 normal)\r\n{\r\n    vec3 x1, x2;\r\n    // 4 of the quadratic (L2) polynomials\r\n    vec4 vB = normal.xyzz * normal.yzzx;\r\n    x1.r = dot(u_AmbientSHBr, vB);\r\n    x1.g = dot(u_AmbientSHBg, vB);\r\n    x1.b = dot(u_AmbientSHBb, vB);\r\n\r\n    // Final (5th) quadratic (L2) polynomial\r\n    float vC = normal.x * normal.x - normal.y * normal.y;\r\n    x2 = u_AmbientSHC.rgb * vC;\r\n\r\n    return x1 + x2;\r\n}\r\n\r\nvec3 diffuseIrradiance(in vec3 normalWS)\r\n{\r\n    // todo -x 坐标转换\r\n    vec4 normal = vec4(-normalWS.x, normalWS.yz, 1.0);\r\n\r\n    // TODO rotate y SceneConfig\r\n\r\n    normal = rotateByYAixs(normal);\r\n\r\n    vec3 ambientContrib = shEvalLinearL0L1(normal);\r\n    ambientContrib += shEvalLinearL2(normal);\r\n    vec3 ambient = max(vec3(0.0), ambientContrib);\r\n\r\n    return ambient;\r\n}\r\n\r\nvec3 specularIrradiance(in vec3 r, in float perceptualRoughness)\r\n{\r\n    float roughness = perceptualRoughness * (1.7 - 0.7 * perceptualRoughness);\r\n    // todo 临时转换\r\n    r *= vec3(-1.0, 1.0, 1.0);\r\n    r = rotateByYAixs(r);\r\n\r\n    float lod = roughness * LAYA_SPECCUBE_LOD_STEPS;\r\n    vec4 rgbm = textureCubeLodEXT(u_ReflectTexture, r, lod);\r\n    float range = u_ReflectCubeHDRParams.x;\r\n    vec3 color = decodeRGBM(rgbm, range);\r\n    color = gammaToLinear(color);\r\n    return color;\r\n}\r\n\r\n    #endif // GI_LEGACYIBL\r\n\r\n    #ifndef GI_IBL\r\n\t#ifndef GI_LEGACYIBL\r\n\r\nuniform vec4 u_AmbientColor;\r\n\r\nvec3 diffuseIrradiance(in vec3 normalWS)\r\n{\r\n    return u_AmbientColor.rgb;\r\n}\r\n\r\nvec3 specularIrradiance(in vec3 r, in float perceptualRoughness)\r\n{\r\n    // todo\r\n    return u_AmbientColor.rgb;\r\n}\r\n\r\n\t#endif // GI_LEGACYIBL\r\n    #endif // GI_IBL\r\n\r\n    #ifdef LIGHTMAP\r\nuniform sampler2D u_LightMap;\r\nvec3 getBakedLightmapColor(in vec2 lightmapUV)\r\n{\r\n    vec4 lightmapSampler = texture2D(u_LightMap, lightmapUV);\r\n\t// todo lightmap rgbm encode color space\r\n\t#ifdef Gamma_u_LightMap\r\n    lightmapSampler = gammaToLinear(lightmapSampler);\r\n\t#endif // Gamma_u_LightMap\r\n    return lightmapSampler.rgb;\r\n}\r\n    #endif // LIGHTMAP\r\n\r\n#ifdef SPECCUBE_BOX_PROJECTION\r\n\r\nuniform vec3 u_SpecCubeProbePosition;\r\nuniform vec3 u_SpecCubeBoxMax;\r\nuniform vec3 u_SpecCubeBoxMin;\r\n\r\nvec3 getBoxProjectionReflectedVector(vec3 r, vec3 positionWS, vec3 boxCenter, vec3 boxMin, vec3 boxMax)\r\n{\r\n    vec3 nr = normalize(r);\r\n    vec3 rbmax = boxMax - positionWS;\r\n    vec3 rbmin = boxMin - positionWS;\r\n    vec3 select = step(vec3(0.0), r);\r\n    vec3 rbminmax = mix(rbmin, rbmax, select) / nr;\r\n    float scalar = vecmin(rbminmax);\r\n    vec3 boxr = nr * scalar + positionWS - boxCenter;\r\n    return boxr;\r\n}\r\n\r\n#endif // SPECCUBE_BOX_PROJECTION\r\n\r\n#endif // globalIllumination_lib";

    var BlinnPhongLightingGLSL = "#if !defined(BlinnPhongLighting_lib)\r\n    #define BlinnPhongLighting_lib\r\n\r\n    #include \"Lighting.glsl\";\r\n    #include \"globalIllumination.glsl\";\r\n\r\nstruct PixelInfo {\r\n    vec3 positionWS;\r\n    vec3 normalWS;\r\n    vec3 viewDir;\r\n\r\n    #ifdef LIGHTMAP\r\n\t#ifdef UV1\r\n    vec2 lightmapUV;\r\n\t#endif // UV1\r\n    #endif // LIGHTMAP\r\n};\r\n\r\nstruct Surface {\r\n    vec3 diffuseColor;\r\n    vec3 specularColor;\r\n    float shininess;\r\n    vec3 gloss;\r\n    float alpha;\r\n    float alphaClip;\r\n};\r\n\r\nvec3 BlinnPhongLighting(in Surface surface, in Light light, in PixelInfo pixel)\r\n{\r\n    vec3 l = normalize(-light.dir);\r\n    vec3 v = pixel.viewDir;\r\n\r\n    vec3 normalWS = pixel.normalWS;\r\n\r\n    vec3 diffuseColor = surface.diffuseColor;\r\n    float shininess = surface.shininess;\r\n    vec3 specularColor = surface.specularColor;\r\n    vec3 gloss = surface.gloss;\r\n\r\n    // difffuse\r\n    float ndl = max(0.0, dot(normalWS, l));\r\n    vec3 lightDiffuse = light.color * diffuseColor * ndl;\r\n\r\n    // specular\r\n    mediump vec3 h = normalize(v + l);\r\n    lowp float ndh = max(0.0, dot(h, normalWS));\r\n    float specularIntensity = pow(ndh, shininess * 128.0);\r\n    vec3 lightSpecular = light.color * specularColor * specularIntensity * gloss;\r\n\r\n    return lightDiffuse + lightSpecular;\r\n}\r\n\r\nvec3 BlinnPhongGI(const in Surface surface, const in PixelInfo info)\r\n{\r\n    vec3 indirect = vec3(0.0);\r\n\r\n    #ifdef LIGHTMAP\r\n\t#ifdef UV1\r\n\r\n    vec2 lightmapUV = info.lightmapUV;\r\n    vec3 bakedColor = getBakedLightmapColor(lightmapUV);\r\n    // todo  surface.diffuseColor ？\r\n    indirect = bakedColor;\r\n\r\n\t#endif // UV1\r\n\r\n    #else // LIGHTMAP\r\n\r\n    vec3 n = info.normalWS;\r\n    indirect = diffuseIrradiance(n) * surface.diffuseColor * u_AmbientIntensity;\r\n\r\n    #endif // LIGHTMAP\r\n\r\n    return indirect;\r\n}\r\n\r\n#endif // BlinnPhongLighting_lib";

    var PBRLightingGLSL = "#if !defined(PBRLighting_lib)\r\n    #define PBRLighting_lib\r\n\r\n    #include \"Lighting.glsl\";\r\n\r\n    // 精度\r\n    #if !defined(GL_FRAGMENT_PRECISION_HIGH)\r\n\t#define MIN_PERCEPTUAL_ROUGHNESS 0.089\r\n\t#define MIN_ROUGHNESS\t\t 0.007921\r\n    #else\r\n\t#define MIN_PERCEPTUAL_ROUGHNESS 0.045\r\n\t#define MIN_ROUGHNESS\t\t 0.002025\r\n    #endif\r\n\r\n    #define MIN_N_DOT_V 1e-4\r\n\r\n    #include \"BRDF.glsl\";\r\n\r\nstruct PixelInfo {\r\n    vec3 positionWS;\r\n    vec3 normalWS;\r\n\r\n    #ifdef NEEDTBN\r\n    vec3 tangentWS;\r\n    vec3 biNormalWS;\r\n\r\n\t#ifdef ANISOTROPIC\r\n    float ToV;\r\n    float BoV;\r\n\t#endif // ANISOTROPIC\r\n\r\n    #endif // NEEDTBN\r\n\r\n    vec3 viewDir;\r\n    float NoV;\r\n\r\n    #ifdef LIGHTMAP\r\n\t#ifdef UV1\r\n    vec2 lightmapUV;\r\n\t#endif // UV1\r\n    #endif // LIGHTMAP\r\n};\r\n\r\nstruct Surface {\r\n    vec3 diffuseColor;\r\n    float alpha;\r\n    vec3 f0;\r\n    float roughness;\r\n    float perceptualRoughness;\r\n    float occlusion;\r\n\r\n    #ifdef ANISOTROPIC\r\n    float anisotropy;\r\n    #endif // ANISOTROPIC\r\n};\r\n\r\nstruct LightParams {\r\n    vec3 h;\r\n    float NoL;\r\n    float NoH;\r\n    float LoH;\r\n\r\n    #ifdef ANISOTROPIC\r\n    float ToL;\r\n    float BoL;\r\n    #endif // ANISOTROPIC\r\n};\r\n\r\n// 获取反射向量\r\nvec3 getReflectedVector(const in Surface surface, const in PixelInfo info)\r\n{\r\n    vec3 v = info.viewDir;\r\n    vec3 n = info.normalWS;\r\n\r\n    #ifdef ANISOTROPIC\r\n\r\n    vec3 direction = surface.anisotropy >= 0.0 ? info.biNormalWS : info.tangentWS;\r\n    vec3 at = cross(direction, v);\r\n    vec3 an = cross(at, direction);\r\n    float bendFactor = abs(surface.anisotropy) * saturate(5.0 * surface.perceptualRoughness);\r\n    vec3 bentNormal = normalize(mix(n, an, bendFactor));\r\n    return reflect(-v, bentNormal);\r\n\r\n    #else // ANISOTROPIC\r\n    return reflect(-v, n);\r\n    #endif // ANISOTROPIC\r\n}\r\n\r\nvoid initLightParams(inout LightParams params, const in PixelInfo pixel, const in Light light)\r\n{\r\n    vec3 l = normalize(-light.dir);\r\n    vec3 v = pixel.viewDir;\r\n    vec3 n = pixel.normalWS;\r\n\r\n    vec3 h = SafeNormalize(v + l);\r\n    params.h = h;\r\n    params.NoL = saturate(dot(n, l));\r\n    params.NoH = saturate(dot(n, h));\r\n    params.LoH = saturate(dot(l, h));\r\n\r\n    #ifdef ANISOTROPIC\r\n    params.ToL = dot(pixel.tangentWS, l);\r\n    params.BoL = dot(pixel.biNormalWS, l);\r\n    #endif // ANISOTROPIC\r\n}\r\n\r\nvec3 diffuseLobe(in Surface surface, const in PixelInfo pixel, const in LightParams lightParams)\r\n{\r\n    return surface.diffuseColor * diffuse();\r\n    // return surface.diffuseColor * Fd_Burley(surface.roughness, pixel.NoV, lightParams.NoL, lightParams.LoH);\r\n}\r\n\r\nvec3 specularLobe(const in Surface surface, const in PixelInfo pixel, const in LightParams lightParams)\r\n{\r\n    float roughness = surface.roughness;\r\n    #ifdef ANISOTROPIC\r\n\r\n\t#ifdef NEEDTBN\r\n\r\n    float at = max(roughness * (1.0 + surface.anisotropy), 0.001);\r\n    float ab = max(roughness * (1.0 - surface.anisotropy), 0.001);\r\n\r\n    float D = D_GGX_Anisotropic(lightParams.NoH, lightParams.h, pixel.tangentWS, pixel.biNormalWS, at, ab);\r\n    float V = V_SmithGGXCorrelated_Anisotropic(at, ab, pixel.ToV, pixel.BoV, lightParams.ToL, lightParams.BoL, pixel.NoV, lightParams.NoL);\r\n\r\n\t#endif // NEEDTBN\r\n\r\n    #else // ANISOTROPIC\r\n\r\n    float D = distribution(roughness, lightParams.NoH, lightParams.h, pixel.normalWS);\r\n    float V = visibility(roughness, pixel.NoV, lightParams.NoL);\r\n\r\n    #endif // ANISOTROPIC\r\n\r\n    vec3 F = fresnel(surface.f0, lightParams.LoH);\r\n\r\n    return (D * V) * F;\r\n}\r\n\r\nvec3 PBRLighting(const in Surface surface, const in PixelInfo pixel, const in Light light)\r\n{\r\n    LightParams lightParams;\r\n    initLightParams(lightParams, pixel, light);\r\n\r\n    vec3 Fd = diffuseLobe(surface, pixel, lightParams);\r\n\r\n    vec3 Fr = specularLobe(surface, pixel, lightParams);\r\n\r\n    return (Fd + Fr) * light.color * lightParams.NoL;\r\n}\r\n\r\n    // gi\r\n    #include \"PBRGI.glsl\";\r\n\r\n#endif // PBRLighting_lib";

    var BlitFS = "#define SHADER_NAME BlitFS\r\n\r\n#include \"Color.glsl\";\r\n#include \"FastApproximateAntiAliasing.glsl\";\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\nvoid main()\r\n{\r\n#ifdef FXAA\r\n    gl_FragColor = FXAAMain(u_MainTex, v_Texcoord0, u_MainTex_TexelSize.zw);\r\n#else\r\n    gl_FragColor = texture2D(u_MainTex, v_Texcoord0);\r\n#endif\r\n\r\n#ifdef GAMMAOUT\r\n    gl_FragColor = linearToGamma(gl_FragColor);\r\n#endif\r\n    // gl_FragColor.rgb = FXAAMain(u_MainTex,v_Texcoord0,u_MainTex_TexelSize.zw);\r\n}\r\n";

    var FXAA = "#if !defined(FXAA_lib)\r\n    #define FXAA_lib\r\n#ifdef FXAA\r\n    #define EDGE_THRESHOLD_MIN 0.0312\r\n    #define EDGE_THRESHOLD_MAX 0.125\r\n    #define QUALITY(q)\t       ((q) < 5 ? 1.0 : ((q) > 5 ? ((q) < 10 ? 2.0 : ((q) < 11 ? 4.0 : 8.0)) : 1.5))\r\n    #define ITERATIONS\t       12\r\n    #define SUBPIXEL_QUALITY   0.75\r\n\r\nfloat rgb2luma(in vec3 rgb)\r\n{\r\n    return dot(rgb, vec3(0.299, 0.587, 0.114));\r\n}\r\n\r\nvec3 textureOffsetbyScreenSize(in sampler2D mainTex, in vec2 uv, in vec2 offset, in vec2 inverseScreenSize)\r\n{\r\n    vec2 sampleruv = uv + inverseScreenSize * offset; // u_texturesize表示每个像素的偏移量\r\n    return texture2D(mainTex, sampleruv).rgb;\r\n}\r\n\r\nvec4 FXAAMain(in sampler2D mainTex, in vec2 texuv, in vec2 inverseScreenSize)\r\n{\r\n\r\n    vec4 mainColor = texture2D(mainTex, texuv);\r\n    vec3 colorCenter = mainColor.rgb;\r\n    // Luma at the current fragment\r\n    float lumaCenter = rgb2luma(colorCenter);\r\n\r\n    // Luma at the four direct neighbours of the current fragment.\r\n    float lumaDown = rgb2luma(textureOffsetbyScreenSize(mainTex, texuv, vec2(0, -1), inverseScreenSize));\r\n    float lumaUp = rgb2luma(textureOffsetbyScreenSize(mainTex, texuv, vec2(0, 1), inverseScreenSize));\r\n    float lumaLeft = rgb2luma(textureOffsetbyScreenSize(mainTex, texuv, vec2(-1, 0), inverseScreenSize));\r\n    float lumaRight = rgb2luma(textureOffsetbyScreenSize(mainTex, texuv, vec2(1, 0), inverseScreenSize));\r\n\r\n    // Find the maximum and minimum luma around the current fragment.\r\n    float lumaMin = min(lumaCenter, min(min(lumaDown, lumaUp), min(lumaLeft, lumaRight)));\r\n    float lumaMax = max(lumaCenter, max(max(lumaDown, lumaUp), max(lumaLeft, lumaRight)));\r\n\r\n    // Compute the delta.\r\n    float lumaRange = lumaMax - lumaMin;\r\n\r\n    // If the luma variation is lower that a threshold (or if we are in a really dark area), we are not on an edge, don't perform any AA.\r\n    if (lumaRange < max(EDGE_THRESHOLD_MIN, lumaMax * EDGE_THRESHOLD_MAX))\r\n\t{\r\n\t    return mainColor;\r\n\t}\r\n\r\n    // Query the 4 remaining corners lumas.\r\n    float lumaDownLeft = rgb2luma(textureOffsetbyScreenSize(mainTex, texuv, vec2(-1, -1), inverseScreenSize));\r\n    float lumaUpRight = rgb2luma(textureOffsetbyScreenSize(mainTex, texuv, vec2(1, 1), inverseScreenSize));\r\n    float lumaUpLeft = rgb2luma(textureOffsetbyScreenSize(mainTex, texuv, vec2(-1, 1), inverseScreenSize));\r\n    float lumaDownRight = rgb2luma(textureOffsetbyScreenSize(mainTex, texuv, vec2(1, -1), inverseScreenSize));\r\n\r\n    // Combine the four edges lumas (using intermediary variables for future computations with the same values).\r\n    float lumaDownUp = lumaDown + lumaUp;\r\n    float lumaLeftRight = lumaLeft + lumaRight;\r\n\r\n    // Same for corners\r\n    float lumaLeftCorners = lumaDownLeft + lumaUpLeft;\r\n    float lumaDownCorners = lumaDownLeft + lumaDownRight;\r\n    float lumaRightCorners = lumaDownRight + lumaUpRight;\r\n    float lumaUpCorners = lumaUpRight + lumaUpLeft;\r\n\r\n    // Compute an estimation of the gradient along the horizontal and vertical axis.\r\n    float edgeHorizontal = abs(-2.0 * lumaLeft + lumaLeftCorners) + abs(-2.0 * lumaCenter + lumaDownUp) * 2.0 + abs(-2.0 * lumaRight + lumaRightCorners);\r\n    float edgeVertical = abs(-2.0 * lumaUp + lumaUpCorners) + abs(-2.0 * lumaCenter + lumaLeftRight) * 2.0 + abs(-2.0 * lumaDown + lumaDownCorners);\r\n\r\n    // Is the local edge horizontal or vertical ?\r\n    bool isHorizontal = (edgeHorizontal >= edgeVertical);\r\n\r\n    // Choose the step size (one pixel) accordingly.\r\n    float stepLength = isHorizontal ? inverseScreenSize.y : inverseScreenSize.x;\r\n\r\n    // Select the two neighboring texels lumas in the opposite direction to the local edge.\r\n    float luma1 = isHorizontal ? lumaDown : lumaLeft;\r\n    float luma2 = isHorizontal ? lumaUp : lumaRight;\r\n    // Compute gradients in this direction.\r\n    float gradient1 = luma1 - lumaCenter;\r\n    float gradient2 = luma2 - lumaCenter;\r\n\r\n    // Which direction is the steepest ?\r\n    bool is1Steepest = abs(gradient1) >= abs(gradient2);\r\n\r\n    // Gradient in the corresponding direction, normalized.\r\n    float gradientScaled = 0.25 * max(abs(gradient1), abs(gradient2));\r\n\r\n    // Average luma in the correct direction.\r\n    float lumaLocalAverage = 0.0;\r\n    if (is1Steepest)\r\n\t{\r\n\t    // Switch the direction\r\n\t    stepLength = -stepLength;\r\n\t    lumaLocalAverage = 0.5 * (luma1 + lumaCenter);\r\n\t}\r\n    else\r\n\t{\r\n\t    lumaLocalAverage = 0.5 * (luma2 + lumaCenter);\r\n\t}\r\n\r\n    // Shift UV in the correct direction by half a pixel.\r\n    vec2 currentUv = texuv;\r\n    if (isHorizontal)\r\n\t{\r\n\t    currentUv.y += stepLength * 0.5;\r\n\t}\r\n    else\r\n\t{\r\n\t    currentUv.x += stepLength * 0.5;\r\n\t}\r\n\r\n    // Compute offset (for each iteration step) in the right direction.\r\n    vec2 offset = isHorizontal ? vec2(inverseScreenSize.x, 0.0) : vec2(0.0, inverseScreenSize.y);\r\n    // Compute UVs to explore on each side of the edge, orthogonally. The QUALITY allows us to step faster.\r\n    vec2 uv1 = currentUv - offset * QUALITY(0);\r\n    vec2 uv2 = currentUv + offset * QUALITY(0);\r\n\r\n    // Read the lumas at both current extremities of the exploration segment, and compute the delta wrt to the local average luma.\r\n    float lumaEnd1 = rgb2luma(textureOffsetbyScreenSize(mainTex, uv1, vec2(0.0, 0.0), inverseScreenSize));\r\n    float lumaEnd2 = rgb2luma(textureOffsetbyScreenSize(mainTex, uv2, vec2(0.0, 0.0), inverseScreenSize));\r\n    lumaEnd1 -= lumaLocalAverage;\r\n    lumaEnd2 -= lumaLocalAverage;\r\n\r\n    // If the luma deltas at the current extremities is larger than the local gradient, we have reached the side of the edge.\r\n    bool reached1 = abs(lumaEnd1) >= gradientScaled;\r\n    bool reached2 = abs(lumaEnd2) >= gradientScaled;\r\n    bool reachedBoth = reached1 && reached2;\r\n\r\n    // If the side is not reached, we continue to explore in this direction.\r\n    if (!reached1)\r\n\t{\r\n\t    uv1 -= offset * QUALITY(1);\r\n\t}\r\n    if (!reached2)\r\n\t{\r\n\t    uv2 += offset * QUALITY(1);\r\n\t}\r\n\r\n    // If both sides have not been reached, continue to explore.\r\n    if (!reachedBoth)\r\n\t{\r\n\r\n\t    for (int i = 2; i < ITERATIONS; i++)\r\n\t\t{\r\n\t\t    // If needed, read luma in 1st direction, compute delta.\r\n\t\t    if (!reached1)\r\n\t\t\t{\r\n\t\t\t    lumaEnd1 = rgb2luma(textureOffsetbyScreenSize(mainTex, uv1, vec2(0.0, 0.0), inverseScreenSize));\r\n\t\t\t    lumaEnd1 = lumaEnd1 - lumaLocalAverage;\r\n\t\t\t}\r\n\t\t    // If needed, read luma in opposite direction, compute delta.\r\n\t\t    if (!reached2)\r\n\t\t\t{\r\n\t\t\t    lumaEnd2 = rgb2luma(textureOffsetbyScreenSize(mainTex, uv2, vec2(0.0, 0.0), inverseScreenSize));\r\n\t\t\t    lumaEnd2 = lumaEnd2 - lumaLocalAverage;\r\n\t\t\t}\r\n\t\t    // If the luma deltas at the current extremities is larger than the local gradient, we have reached the side of the edge.\r\n\t\t    reached1 = abs(lumaEnd1) >= gradientScaled;\r\n\t\t    reached2 = abs(lumaEnd2) >= gradientScaled;\r\n\t\t    reachedBoth = reached1 && reached2;\r\n\r\n\t\t    // If the side is not reached, we continue to explore in this direction, with a variable quality.\r\n\t\t    if (!reached1)\r\n\t\t\t{\r\n\t\t\t    uv1 -= offset * QUALITY(i);\r\n\t\t\t}\r\n\t\t    if (!reached2)\r\n\t\t\t{\r\n\t\t\t    uv2 += offset * QUALITY(i);\r\n\t\t\t}\r\n\r\n\t\t    // If both sides have been reached, stop the exploration.\r\n\t\t    if (reachedBoth)\r\n\t\t\t{\r\n\t\t\t    break;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n    // Compute the distances to each side edge of the edge (!).\r\n    float distance1 = isHorizontal ? (texuv.x - uv1.x) : (texuv.y - uv1.y);\r\n    float distance2 = isHorizontal ? (uv2.x - texuv.x) : (uv2.y - texuv.y);\r\n\r\n    // In which direction is the side of the edge closer ?\r\n    bool isDirection1 = distance1 < distance2;\r\n    float distanceFinal = min(distance1, distance2);\r\n\r\n    // Thickness of the edge.\r\n    float edgeThickness = (distance1 + distance2);\r\n\r\n    // Is the luma at center smaller than the local average ?\r\n    bool isLumaCenterSmaller = lumaCenter < lumaLocalAverage;\r\n\r\n    // If the luma at center is smaller than at its neighbour, the delta luma at each end should be positive (same variation).\r\n    bool correctVariation1 = (lumaEnd1 < 0.0) != isLumaCenterSmaller;\r\n    bool correctVariation2 = (lumaEnd2 < 0.0) != isLumaCenterSmaller;\r\n\r\n    // Only keep the result in the direction of the closer side of the edge.\r\n    bool correctVariation = isDirection1 ? correctVariation1 : correctVariation2;\r\n\r\n    // UV offset: read in the direction of the closest side of the edge.\r\n    float pixelOffset = -distanceFinal / edgeThickness + 0.5;\r\n\r\n    // If the luma variation is incorrect, do not offset.\r\n    float finalOffset = correctVariation ? pixelOffset : 0.0;\r\n\r\n    // Sub-pixel shifting\r\n    // Full weighted average of the luma over the 3x3 neighborhood.\r\n    float lumaAverage = (1.0 / 12.0) * (2.0 * (lumaDownUp + lumaLeftRight) + lumaLeftCorners + lumaRightCorners);\r\n    // Ratio of the delta between the global average and the center luma, over the luma range in the 3x3 neighborhood.\r\n    float subPixelOffset1 = clamp(abs(lumaAverage - lumaCenter) / lumaRange, 0.0, 1.0);\r\n    float subPixelOffset2 = (-2.0 * subPixelOffset1 + 3.0) * subPixelOffset1 * subPixelOffset1;\r\n    // Compute a sub-pixel offset based on this delta.\r\n    float subPixelOffsetFinal = subPixelOffset2 * subPixelOffset2 * SUBPIXEL_QUALITY;\r\n\r\n    // Pick the biggest of the two offsets.\r\n    finalOffset = max(finalOffset, subPixelOffsetFinal);\r\n\r\n    // Compute the final UV coordinates.\r\n    vec2 finalUv = texuv;\r\n    if (isHorizontal)\r\n\t{\r\n\t    finalUv.y += finalOffset * stepLength;\r\n\t}\r\n    else\r\n\t{\r\n\t    finalUv.x += finalOffset * stepLength;\r\n\t}\r\n\r\n    // Read the color at the new UV coordinates, and use it.\r\n    return texture2D(mainTex, finalUv);\r\n}\r\n#endif//FXAA\r\n#endif // Color_lib\r\n";

    var ColorGradingGLSL = "#if !defined(ColorGrading_lib)\r\n    #define ColorGrading_lib\r\n\r\nconst float ACEScc_MAX = 1.4679964;\r\nconst float ACEScc_MIDGRAY = 0.4135884;\r\n\r\nconst float LogC_cut = 0.011361;\r\nconst float LogC_a = 5.555556;\r\nconst float LogC_b = 0.047996;\r\nconst float LogC_c = 0.244161;\r\nconst float LogC_d = 0.386036;\r\nconst float LogC_e = 5.301883;\r\nconst float LogC_f = 0.092819;\r\n\r\nfloat linearToLogC(float x)\r\n{\r\n    float o;\r\n    if (x > LogC_cut)\r\n\t{\r\n\t    o = LogC_c * log10(max(LogC_a * x + LogC_b, 0.0)) + LogC_d;\r\n\t}\r\n    else\r\n\t{\r\n\t    o = LogC_e * x + LogC_f;\r\n\t}\r\n    return o;\r\n}\r\n\r\nvec3 linearToLogC(vec3 x)\r\n{\r\n    vec3 logc;\r\n    logc.x = linearToLogC(x.x);\r\n    logc.y = linearToLogC(x.y);\r\n    logc.z = linearToLogC(x.z);\r\n    return logc;\r\n}\r\n\r\nfloat logCToLinear(float x)\r\n{\r\n    float o;\r\n    if (x > LogC_e * LogC_cut + LogC_f)\r\n\to = (pow(10.0, (x - LogC_d) / LogC_c) - LogC_b) / LogC_a;\r\n    else\r\n\to = (x - LogC_f) / LogC_e;\r\n    return o;\r\n}\r\n\r\nvec3 logCToLinear(vec3 x)\r\n{\r\n    vec3 linear;\r\n    linear.x = logCToLinear(x.x);\r\n    linear.y = logCToLinear(x.y);\r\n    linear.z = logCToLinear(x.z);\r\n    return linear;\r\n}\r\n\r\n// Hue, Saturation, Value\r\n// Ranges:\r\n//  Hue [0.0, 1.0]\r\n//  Sat [0.0, 1.0]\r\n//  Lum [0.0, HALF_MAX]\r\nvec3 RgbToHsv(vec3 c)\r\n{\r\n    const vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\r\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\r\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\r\n    float d = q.x - min(q.w, q.y);\r\n    const float e = 1.0e-4;\r\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\r\n}\r\n\r\nvec3 HsvToRgb(vec3 c)\r\n{\r\n    const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\r\n    vec3 p = abs(fract(vec3(c.x) + K.xyz) * 6.0 - K.www);\r\n    return c.z * mix(vec3(K.x) , saturate(p - vec3(K.x)), c.y);\r\n}\r\n\r\nfloat RotateHue(float value, float low, float hi)\r\n{\r\n    return (value < low)\r\n            ? value + hi\r\n            : (value > hi)\r\n                ? value - hi\r\n                : value;\r\n}\r\n\r\n\r\nconst mat3 Linear_to_LMS_MAT = mat3(\r\n    vec3(3.90405e-1, 7.08416e-2, 2.31082e-2),\r\n    vec3(5.49941e-1, 9.63172e-1, 1.28021e-1),\r\n    vec3(8.92632e-3, 1.35775e-3, 9.36245e-1));\r\n\r\nconst mat3 LMS_to_Linear_MAT = mat3(\r\n    vec3(2.85847e+0, -2.10182e-1, -4.18120e-2),\r\n    vec3(-1.62879e+0, 1.15820e+0, -1.18169e-1),\r\n    vec3(-2.48910e-2, 3.24281e-4, 1.06867e+0));\r\n\r\n// white balance\r\nuniform vec3 u_ColorBalance;\r\n\r\n// split toning\r\nuniform vec4 u_SplitShadows;\r\nuniform vec3 u_Splithighlights;\r\n\r\n// shadows, midtones, highlights\r\nuniform vec3 u_Shadows;\r\nuniform vec3 u_Midtones;\r\nuniform vec3 u_Highlights;\r\nuniform vec4 u_Limits;\r\n\r\n// lift, gamma, gain\r\nuniform vec3 u_Lift;\r\nuniform vec3 u_Gamma;\r\nuniform vec3 u_Gain;\r\n\r\n//color adjusted\r\nuniform vec4 u_ColorFilter;\r\nuniform vec4 u_HueSatCon;\r\n\r\nfloat luminance(in vec3 color)\r\n{\r\n    #ifdef ACES\r\n    float luma = dot(color, AP1_RGB2Y);\r\n    #else\r\n    float luma = dot(color, vec3(0.2126729, 0.7151522, 0.0721750));\r\n    #endif // ACES\r\n    return luma;\r\n}\r\n\r\nvec3 softlight(vec3 base, vec3 blend)\r\n{\r\n    vec3 r1 = 2.0 * base * blend + base * base * (1.0 - 2.0 * blend);\r\n    vec3 r2 = sqrt(base) * (2.0 * blend - 1.0) + 2.0 * base * (1.0 - blend);\r\n    vec3 t = step(0.5, blend);\r\n    return r2 * t + (1.0 - t) * r1;\r\n}\r\n\r\n// input linear sRGB\r\n// if ACES tonemap, calculate in ACEScg, return ACEScg\r\n// else calculate in logC, return linear sRGB\r\nvec3 colorGrade(in vec3 color)\r\n{\r\n    // White balance in LMS space\r\n    vec3 colorLMS = Linear_to_LMS_MAT * color;\r\n    colorLMS *= u_ColorBalance.xyz;\r\n    color = LMS_to_Linear_MAT * colorLMS;\r\n\r\n    // Do contrast in log after white balance\r\n    #ifdef ACES\r\n        vec3 colorLog = ACES_to_ACEScc(sRGB_to_AP0_MAT * color);\r\n    #else\r\n        vec3 colorLog = linearToLogC(color);\r\n    #endif\r\n    \r\n    colorLog = (colorLog - vec3(ACEScc_MIDGRAY)) * u_HueSatCon.z + vec3(ACEScc_MIDGRAY);\r\n\r\n\r\n    #ifdef ACES\r\n        //colorLinear = ACES_to_ACEScg(ACEScc_to_ACES(colorLog));\r\n        color = AP0_to_AP1_MAT * ACEScc_to_ACES(colorLog);\r\n    #else\r\n        color = logCToLinear(colorLog);\r\n    #endif // ACES\r\n\r\n    // Color filter is just an unclipped multiplier\r\n    color = color * u_ColorFilter.rgb;\r\n\r\n    color = max(vec3(0.0), color);\r\n\r\n    // split toning\r\n    float balance = u_SplitShadows.w;\r\n    vec3 gamma = linearToGamma(color);\r\n    float splitLuma = saturate(luminance(color)) + balance;\r\n    vec3 splitShadows = mix(vec3(0.5, 0.5, 0.5), u_SplitShadows.xyz, 1.0 - splitLuma);\r\n    vec3 splitHeighlights = mix(vec3(0.5, 0.5, 0.5), u_Splithighlights.xyz, splitLuma);\r\n    gamma = softlight(gamma, splitShadows);\r\n    gamma = softlight(gamma, splitHeighlights);\r\n    color = gammaToLinear(gamma);\r\n\r\n    // shadows, midtones, highlights\r\n    float luma = luminance(color);\r\n    float shadowFactor = 1.0 - smoothstep(u_Limits.x, u_Limits.y, luma);\r\n    float highlightsFactor = smoothstep(u_Limits.z, u_Limits.w, luma);\r\n    float midtonesFactor = 1.0 - shadowFactor - highlightsFactor;\r\n    color = color * u_Shadows.xyz * shadowFactor + color * u_Midtones.xyz * midtonesFactor + color * u_Highlights.xyz * highlightsFactor;\r\n\r\n    // Lift, gamma, gain\r\n    color = color * u_Gain.xyz + u_Lift.xyz;\r\n    color = sign(color) * pow(abs(color), u_Gamma.xyz);\r\n    \r\n    // HSV operations\r\n    vec3 hsv = RgbToHsv(color);\r\n    // Hue Shift & Hue Vs Hue\r\n    float hue = hsv.x + u_HueSatCon.x;\r\n    hsv.x = RotateHue(hsv.x, 0.0, 1.0);\r\n    color = HsvToRgb(hsv);\r\n\r\n    // Global saturation\r\n    luma = luminance(color);\r\n    color = vec3(luma) + (vec3(u_HueSatCon.y)) * (color - vec3(luma));\r\n    \r\n    return color;\r\n}\r\n\r\n#endif // ColorGrading_lib";

    var TonemappingGLSL = "#if !defined(Tonemapping_lib)\r\n    #define Tonemapping_lib\r\n\r\n// ACES Tonemapping color grading in ACEScg space\r\nvec3 tonemap(in vec3 ap1)\r\n{\r\n    vec3 color = ap1;\r\n\r\n    #ifdef ACES\r\n    vec3 aces = AP1_to_AP0_MAT * color;\r\n    vec3 oces = RRT(aces);\r\n    color = ODT_sRGB_100nits(oces);\r\n    #endif // ACES\r\n\r\n    // todo other tonemap\r\n\r\n    return color;\r\n}\r\n\r\n#endif // Tonemapping_lib";

    var LUTGLSL = "#if !defined(LUT_lib)\r\n    #define LUT_lib\r\n\r\n// scaleOffset = (1 / lut_width, 1 / lut_height, lut_height - 1)\r\nvec3 applyLut(sampler2D lut, vec3 uvw, vec3 scaleOffset)\r\n{\r\n    uvw.z *= scaleOffset.z;\r\n\r\n    float shift = floor(uvw.z);\r\n    uvw.xy = uvw.xy * scaleOffset.z * scaleOffset.xy + scaleOffset.xy * 0.5;\r\n    uvw.x += shift * scaleOffset.y;\r\n\r\n    uvw.xyz = mix(\r\n\ttexture2DLodEXT(lut, uvw.xy, 0.0).rgb,\r\n\ttexture2DLodEXT(lut, uvw.xy + vec2(scaleOffset.y, 0.0), 0.0).rgb,\r\n\tuvw.z - shift);\r\n    return uvw;\r\n}\r\n\r\n#endif // LUT_lib";

    var LUTBuilderFS = "#define SHADER_NAME LutBuilder\r\n\r\n#include \"Color.glsl\";\r\n\r\n#ifdef ACES\r\n    #include \"ACES.glsl\";\r\n#endif // ACES\r\n\r\n#include \"ColorGrading.glsl\";\r\n\r\n#include \"Tonemapping.glsl\";\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\n// lut params: (lutHeight, 0.5 / lutWidth, 0.5 / lutHeight, lutHeidht / (lutHeight - 1))\r\nvec3 lutValue(vec2 uv, vec4 params)\r\n{\r\n    vec3 color;\r\n    uv -= params.yz;\r\n    color.r = fract(uv.x * params.x);\r\n    color.b = uv.x - color.r / params.x;\r\n    color.g = uv.y;\r\n    return color * params.w;\r\n}\r\n\r\n// internal lut logC space\r\nvoid main()\r\n{\r\n    vec2 uv = v_Texcoord0;\r\n    vec3 color = lutValue(uv, u_LutParams);\r\n    color = logCToLinear(color);\r\n    vec3 grade = colorGrade(color);\r\n    vec3 tone = tonemap(grade);\r\n\r\n    gl_FragColor = vec4(tone, 1.0);\r\n}";

    class BlitScreenShaderInit {
        static init() {
            Laya.Shader3D.addInclude("FastApproximateAntiAliasing.glsl", FXAA);
            Laya.Shader3D.addInclude("ColorGrading.glsl", ColorGradingGLSL);
            Laya.Shader3D.addInclude("Tonemapping.glsl", TonemappingGLSL);
            Laya.Shader3D.addInclude("LUT.glsl", LUTGLSL);
            let attributeMap = {
                "a_PositionTexcoord": [Laya.VertexMesh.MESH_POSITION0, Laya.ShaderDataType.Vector4]
            };
            let uniformMap = {
                "u_OffsetScale": Laya.ShaderDataType.Vector4,
                "u_MainTex": Laya.ShaderDataType.Texture2D,
                "u_MainTex_TexelSize": Laya.ShaderDataType.Vector4,
            };
            let shader = Laya.Shader3D.add("BlitScreen");
            let subShader = new Laya.SubShader(attributeMap, uniformMap);
            shader.addSubShader(subShader);
            let blitPass = subShader.addShaderPass(BlitVS, BlitFS);
            blitPass.statefirst = true;
            let blitState = blitPass.renderState;
            blitState.depthTest = Laya.RenderState.DEPTHTEST_ALWAYS;
            blitState.depthWrite = false;
            blitState.cull = Laya.RenderState.CULL_NONE;
            blitState.blend = Laya.RenderState.BLEND_DISABLE;
            let transparentShader = Laya.Shader3D.add("BlitScreen_Transparnet");
            let transparentSubShader = new Laya.SubShader(attributeMap, uniformMap);
            transparentShader.addSubShader(transparentSubShader);
            let blitPassTrans = transparentSubShader.addShaderPass(BlitVS, BlitFS);
            blitPass.statefirst = true;
            blitState = blitPassTrans.renderState;
            blitState.depthTest = Laya.RenderState.DEPTHTEST_ALWAYS;
            blitState.depthWrite = false;
            blitState.cull = Laya.RenderState.CULL_NONE;
            blitState.blend = Laya.RenderState.BLEND_ENABLE_ALL;
            blitState.srcBlend = Laya.RenderState.BLENDPARAM_SRC_ALPHA;
            blitState.dstBlend = Laya.RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA;
            this.lutBuilderInit();
        }
        static lutBuilderInit() {
            let attributeMap = {
                "a_PositionTexcoord": [Laya.VertexMesh.MESH_POSITION0, Laya.ShaderDataType.Vector4]
            };
            let uniformMap = {
                "u_OffsetScale": Laya.ShaderDataType.Vector4,
                "u_MainTex": Laya.ShaderDataType.Texture2D,
                "u_MainTex_TexelSize": Laya.ShaderDataType.Vector4,
                "u_LutParams": Laya.ShaderDataType.Vector4
            };
            let shader = Laya.Shader3D.add("LUTBuilder");
            let subShader = new Laya.SubShader(attributeMap, uniformMap);
            shader.addSubShader(subShader);
            let pass = subShader.addShaderPass(BlitVS, LUTBuilderFS);
            pass.renderState.depthTest = Laya.RenderState.DEPTHTEST_ALWAYS;
            pass.renderState.depthWrite = false;
            pass.renderState.cull = Laya.RenderState.CULL_NONE;
            pass.renderState.blend = Laya.RenderState.BLEND_DISABLE;
            pass.statefirst = true;
        }
    }

    var UnlitVS = "\r\n#define SHADER_NAME UnlitVS\r\n\r\n#include \"Camera.glsl\";\r\n#include \"Sprite3DVertex.glsl\";\r\n\r\n#include \"VertexCommon.glsl\";\r\n#include \"Color.glsl\";\r\n#include \"Scene.glsl\"\r\n#include \"SceneFogInput.glsl\"\r\n\r\nvarying vec4 v_Color;\r\nvarying vec2 v_Texcoord0;\r\n\r\nvoid main()\r\n{\r\n    Vertex vertex;\r\n    getVertexParams(vertex);\r\n\t\r\n#if defined(UV)\r\n    v_Texcoord0 = transformUV(vertex.texCoord0, u_TilingOffset);\r\n#else\r\n\tv_Texcoord0 = vec2(0);\r\n#endif // UV\r\n\r\n#if defined(COLOR) && defined(ENABLEVERTEXCOLOR)\r\n    v_Color = gammaToLinear(vertex.vertexColor);\r\n#endif // COLOR && ENABLEVERTEXCOLOR\r\n\r\n    mat4 worldMat = getWorldMatrix();\r\n\r\n    vec3 positionWS = (worldMat * vec4(vertex.positionOS, 1.0)).xyz;\r\n\r\n    gl_Position = getPositionCS(positionWS);\r\n\r\n    gl_Position = remapPositionZ(gl_Position);\r\n    \r\n    #ifdef FOG\r\n        FogHandle(gl_Position.z);\r\n    #endif\r\n}\r\n";

    var UnlitFS = "\r\n#define SHADER_NAME UNLITFS\r\n\r\n#include \"Color.glsl\";\r\n\r\n#include \"Scene.glsl\";\r\n#include \"SceneFog.glsl\";\r\n\r\nvarying vec4 v_Color;\r\nvarying vec2 v_Texcoord0;\r\n\r\nvoid main()\r\n{\r\n    vec2 uv = v_Texcoord0;\r\n\r\n    vec3 color = u_AlbedoColor.rgb;\r\n    float alpha = u_AlbedoColor.a;\r\n#ifdef ALBEDOTEXTURE\r\n    vec4 albedoSampler = texture2D(u_AlbedoTexture, uv);\r\n\r\n    #ifdef Gamma_u_AlbedoTexture\r\n    albedoSampler = gammaToLinear(albedoSampler);\r\n    #endif // Gamma_u_AlbedoTexture\r\n\r\n    color *= albedoSampler.rgb;\r\n    alpha *= albedoSampler.a;\r\n#endif // ALBEDOTEXTURE\r\n\r\n#if defined(COLOR) && defined(ENABLEVERTEXCOLOR)\r\n    vec4 vertexColor = v_Color;\r\n    color *= vertexColor.rgb;\r\n    alpha *= vertexColor.a;\r\n#endif\r\n\r\n#ifdef ALPHATEST\r\n    if (alpha < u_AlphaTestValue)\r\n\tdiscard;\r\n#endif // ALPHATEST\r\n\r\n#ifdef FOG\r\n    color = scenUnlitFog(color);\r\n#endif // FOG\r\n\r\n    gl_FragColor = vec4(color, alpha);\r\n}";

    var DepthVS = "#define SHADER_NAME DepthVS\r\n\r\n#include \"DepthVertex.glsl\";\r\n\r\nvoid main()\r\n{\r\n    Vertex vertex;\r\n    getVertexParams(vertex);\r\n\r\n    mat4 worldMat = getWorldMatrix();\r\n    vec3 positionWS = (worldMat * vec4(vertex.positionOS, 1.0)).xyz;\r\n\r\n    vec3 normalWS = normalize((worldMat * vec4(vertex.normalOS, 0.0)).xyz);\r\n\r\n    vec4 positionCS = DepthPositionCS(positionWS, normalWS);\r\n    gl_Position = remapPositionZ(positionCS);\r\n}";

    var DepthFS = "#define SHADER_NAME DepthFS\r\n\r\n#include \"DepthFrag.glsl\";\r\n\r\nvoid main()\r\n{\r\n    gl_FragColor = getDepthColor();\r\n}";

    class UnlitShaderInit {
        static init() {
            let uniformMap = {
                "UnlitBlock": {
                    "u_AlbedoColor": Laya.ShaderDataType.Color,
                    "u_TilingOffset": Laya.ShaderDataType.Vector4,
                },
                "u_AlbedoTexture": Laya.ShaderDataType.Texture2D,
                "u_AlphaTestValue": Laya.ShaderDataType.Float,
            };
            let defaultValue = {
                "u_AlbedoColor": Laya.Color.WHITE,
                "u_TilingOffset": new Laya.Vector4(1, 1, 0, 0),
                "u_AlphaTestValue": 0.5
            };
            let shader = Laya.Shader3D.add("Unlit", true, false);
            let subShader = new Laya.SubShader(Laya.SubShader.DefaultAttributeMap, uniformMap, defaultValue);
            shader.addSubShader(subShader);
            subShader.addShaderPass(UnlitVS, UnlitFS);
            subShader.addShaderPass(DepthVS, DepthFS, "ShadowCaster");
        }
    }

    var BlinnPhongCommonGLSL = "#if !defined(BlinnPhongCommon_lib)\r\n    #define BlinnPhongCommon_lib\r\n\r\n// varying\r\nvarying vec3 v_PositionWS;\r\nvarying vec3 v_NormalWS;\r\n\r\n    #ifdef UV\r\nvarying vec2 v_Texcoord0;\r\n    #endif // UV\r\n\r\n    #ifdef UV1\r\n\t#ifdef LIGHTMAP\r\nvarying vec2 v_Texcoord1;\r\n\t#endif // LIGHTMAP\r\n    #endif // UV1\r\n\r\n    #ifdef NEEDTBN\r\nvarying vec3 v_TangentWS;\r\nvarying vec3 v_BiNormalWS;\r\n    #endif // NEEDTBN\r\n\r\n    #ifdef COLOR\r\nvarying vec4 v_VertexColor;\r\n    #endif // COLOR\r\n\r\n// 记录顶点信息, 用于由vs向fs传递数据\r\nstruct PixelParams {\r\n    vec3 positionWS;\r\n    vec3 normalWS;\r\n\r\n    #ifdef UV\r\n    vec2 uv0;\r\n    #endif // UV\r\n\r\n    #ifdef UV1\r\n\t#ifdef LIGHTMAP\r\n    vec2 uv1;\r\n\t#endif // LIGHTMAP\r\n    #endif // UV1\r\n\r\n    #ifdef NEEDTBN\r\n    vec3 tangentWS;\r\n    vec3 biNormalWS;\r\n    #endif // NEEDTBN\r\n\r\n    #ifdef COLOR\r\n    vec4 vertexColor;\r\n    #endif // COLOR\r\n\r\n    vec3 viewDir;\r\n};\r\n\r\n#endif // BlinnPhongCommon_lib";

    var BlinnPhongVertexGLSL = "#if !defined(BlinnPhongVertex_lib)\r\n    #define BlinnPhongVertex_lib\r\n\r\n    #include \"BlinnPhongCommon.glsl\";\r\n\r\nvoid initPixelParams(inout PixelParams params, in Vertex vertex)\r\n{\r\n    mat4 worldMat = getWorldMatrix();\r\n    params.positionWS = (worldMat * vec4(vertex.positionOS, 1.0)).xyz;\r\n    v_PositionWS = params.positionWS;\r\n\r\n    params.normalWS = normalize((worldMat * vec4(vertex.normalOS, 0.0)).xyz);\r\n    v_NormalWS = params.normalWS;\r\n\r\n    #ifdef TANGENT\r\n\t#ifdef NEEDTBN\r\n    params.tangentWS = normalize((worldMat * vec4(vertex.tangentOS.xyz, 0.0)).xyz);\r\n    params.biNormalWS = normalize(cross(params.normalWS, params.tangentWS) * sign(vertex.tangentOS.w));\r\n    v_TangentWS = params.tangentWS;\r\n    v_BiNormalWS = params.biNormalWS;\r\n\t#endif // NEEDTBN\r\n    #endif // TANGENT\r\n\r\n    #ifdef UV\r\n    params.uv0 = transformUV(vertex.texCoord0, u_TilingOffset);\r\n    v_Texcoord0 = params.uv0;\r\n    #endif // UV\r\n\r\n    #ifdef UV1\r\n\t#ifdef LIGHTMAP\r\n    params.uv1 = tranformLightMapUV(vertex.texCoord1, u_LightmapScaleOffset);\r\n    v_Texcoord1 = params.uv1;\r\n\t#endif // LIGHTMAP\r\n    #endif // UV1\r\n\r\n    #ifdef COLOR\r\n    params.vertexColor = a_Color;\r\n    v_VertexColor = params.vertexColor;\r\n    #endif // COLOR\r\n}\r\n\r\n#endif // BlinnPhongVertex_lib";

    var BlinnPhongFragGLSL = "#if !defined(BlinnPhongFrag_lib)\r\n    #define BlinnPhongFrag_lib\r\n\r\n    #include \"BlinnPhongLighting.glsl\";\r\n\r\n    #include \"BlinnPhongCommon.glsl\";\r\n\r\nvoid getPixelParams(inout PixelParams params)\r\n{\r\n    params.positionWS = v_PositionWS;\r\n    params.normalWS = normalize(v_NormalWS);\r\n\r\n    #ifdef UV\r\n    params.uv0 = v_Texcoord0;\r\n    #endif // UV\r\n\r\n    #ifdef UV1\r\n\t#ifdef LIGHTMAP\r\n    params.uv1 = v_Texcoord1;\r\n\t#endif // LIGHTMAP\r\n    #endif // UV1\r\n\r\n    #ifdef COLOR\r\n    params.vertexColor = v_VertexColor;\r\n    #endif // COLOR\r\n\r\n    params.viewDir = normalize(u_CameraPos - params.positionWS);\r\n\r\n    #ifdef TANGENT\r\n\t#ifdef NEEDTBN\r\n    params.tangentWS = normalize(v_TangentWS);\r\n    params.biNormalWS = normalize(v_BiNormalWS);\r\n    mat3 TBN = mat3(params.tangentWS, params.biNormalWS, params.normalWS);\r\n\r\n\t    #ifdef NORMALMAP\r\n    vec3 normalSampler = texture2D(u_NormalTexture, params.uv0).rgb;\r\n    normalSampler = normalize(normalSampler * 2.0 - 1.0);\r\n    normalSampler.y *= -1.0;\r\n    params.normalWS = normalize(TBN * normalSampler);\r\n\t    #endif // NORMALMAP\r\n\r\n\t#endif // NEEDTBN\r\n    #endif TANGENT\r\n}\r\n\r\nvoid getPixelInfo(inout PixelInfo info, const in PixelParams pixel)\r\n{\r\n    info.positionWS = pixel.positionWS;\r\n    info.normalWS = pixel.normalWS;\r\n    info.viewDir = pixel.viewDir;\r\n\r\n    #ifdef LIGHTMAP\r\n\t#ifdef UV1\r\n    info.lightmapUV = pixel.uv1;\r\n\t#endif // UV1\r\n    #endif // LIGHTMAP\r\n}\r\n\r\nvec3 BlinnPhongLighting(const in Surface surface, const in PixelParams pixel)\r\n{\r\n    vec3 positionWS = pixel.positionWS;\r\n    vec3 v = pixel.viewDir;\r\n    vec3 normalWS = pixel.normalWS;\r\n\r\n    PixelInfo info;\r\n    getPixelInfo(info, pixel);\r\n\r\n    vec3 lightColor = vec3(0.0, 0.0, 0.0);\r\n\r\n    #ifdef DIRECTIONLIGHT\r\n    for (int i = 0; i < CalculateLightCount; i++)\r\n\t{\r\n\t    if (i >= DirectionCount)\r\n\t\tbreak;\r\n\t    DirectionLight directionLight = getDirectionLight(i, positionWS);\r\n\t    if (directionLight.lightMode == LightMode_Mix)\r\n\t\t{\r\n\t\t    continue;\r\n\t\t}\r\n\t    Light light = getLight(directionLight);\r\n\t    lightColor += BlinnPhongLighting(surface, light, info) * light.attenuation;\r\n\t}\r\n    #endif // DIRECTIONLIGHT\r\n\r\n    #if defined(POINTLIGHT) || defined(SPOTLIGHT)\r\n    ivec4 clusterInfo = getClusterInfo(u_View, u_Viewport, positionWS, gl_FragCoord, u_ProjectionParams);\r\n    #endif // POINTLIGHT || SPOTLIGHT\r\n\r\n    #ifdef POINTLIGHT\r\n    for (int i = 0; i < CalculateLightCount; i++)\r\n\t{\r\n\t    if (i >= clusterInfo.x)\r\n\t\tbreak;\r\n\t    PointLight pointLight = getPointLight(i, clusterInfo, positionWS);\r\n\t    if (pointLight.lightMode == LightMode_Mix)\r\n\t\t{\r\n\t\t    continue;\r\n\t\t}\r\n\t    Light light = getLight(pointLight, normalWS, positionWS);\r\n\t    lightColor += BlinnPhongLighting(surface, light, info) * light.attenuation;\r\n\t}\r\n    #endif // POINTLIGHT\r\n\r\n    #ifdef SPOTLIGHT\r\n    for (int i = 0; i < CalculateLightCount; i++)\r\n\t{\r\n\t    if (i >= clusterInfo.y)\r\n\t\tbreak;\r\n\t    SpotLight spotLight = getSpotLight(i, clusterInfo, positionWS);\r\n\t    if (spotLight.lightMode == LightMode_Mix)\r\n\t\t{\r\n\t\t    continue;\r\n\t\t}\r\n\t    Light light = getLight(spotLight, normalWS, positionWS);\r\n\t    lightColor += BlinnPhongLighting(surface, light, info) * light.attenuation;\r\n\t}\r\n    #endif // SPOTLIGHT\r\n\r\n    vec3 giColor = BlinnPhongGI(surface, info);\r\n\r\n    return lightColor + giColor;\r\n}\r\n\r\n#endif // BlinnPhongFrag_lib";

    var BlinnPhongVS = "#define SHADER_NAME BlinnPhongVS\r\n\r\n#include \"Color.glsl\";\r\n\r\n#include \"Scene.glsl\";\r\n#include \"Camera.glsl\";\r\n#include \"Sprite3DVertex.glsl\";\r\n\r\n#include \"VertexCommon.glsl\";\r\n\r\n#include \"BlinnPhongVertex.glsl\";\r\n#include \"SceneFogInput.glsl\"\r\n\r\nvoid main()\r\n{\r\n    Vertex vertex;\r\n    getVertexParams(vertex);\r\n\r\n    PixelParams pixel;\r\n    initPixelParams(pixel, vertex);\r\n\r\n    gl_Position = getPositionCS(pixel.positionWS);\r\n\r\n    gl_Position = remapPositionZ(gl_Position);\r\n    #ifdef FOG\r\n        FogHandle(gl_Position.z);\r\n    #endif\r\n}\r\n";

    var BlinnPhongFS = "#define SHADER_NAME BlinnPhongFS\r\n\r\n#include \"Color.glsl\";\r\n\r\n#include \"Scene.glsl\";\r\n#include \"Camera.glsl\";\r\n#include \"Sprite3DFrag.glsl\";\r\n\r\n#include \"SceneFog.glsl\";\r\n\r\n#include \"BlinnPhongFrag.glsl\";\r\n\r\nvoid getBinnPhongSurfaceParams(inout Surface surface, in PixelParams pixel)\r\n{\r\n    surface.diffuseColor = u_DiffuseColor.rgb;\r\n    surface.alpha = u_DiffuseColor.a;\r\n\r\n#if defined(COLOR) && defined(ENABLEVERTEXCOLOR)\r\n    surface.diffuseColor *= pixel.vertexColor.xyz;\r\n    surface.alpha *= pixel.vertexColor.a;\r\n#endif // COLOR && ENABLEVERTEXCOLOR\r\n\r\n#ifdef UV\r\n    vec2 uv = pixel.uv0;\r\n#else // UV\r\n    vec2 uv = vec2(0.0);\r\n#endif // UV\r\n\r\n#ifdef DIFFUSEMAP\r\n    vec4 diffuseSampler = texture2D(u_DiffuseTexture, uv);\r\n    #ifdef Gamma_u_DiffuseTexture\r\n    diffuseSampler = gammaToLinear(diffuseSampler);\r\n    #endif // Gamma_u_DiffuseTexture\r\n    surface.diffuseColor *= u_DiffuseColor.rgb * diffuseSampler.rgb * u_AlbedoIntensity;\r\n    surface.alpha *= diffuseSampler.a;\r\n#endif // DIFFUSEMAP\r\n\r\n    surface.diffuseColor *= u_AlbedoIntensity;\r\n\r\n#ifdef ALPHATEST\r\n    if (surface.alpha < u_AlphaTestValue)\r\n\t{\r\n\t    discard;\r\n\t}\r\n#endif // ALPHATEST\r\n\r\n#ifdef SPECULARMAP\r\n    vec4 specularSampler = texture2D(u_SpecularTexture, uv);\r\n    #ifdef Gamma_u_SpecularTexture\r\n    specularSampler = gammaToLinear(specularSampler);\r\n    #endif // Gamma_u_SpecularTexture\r\n    surface.gloss = specularSampler.rgb;\r\n#else // SPECULARMAP\r\n    #ifdef DIFFUSEMAP\r\n    surface.gloss = vec3(diffuseSampler.a);\r\n    #else // DIFFUSEMAP\r\n    surface.gloss = vec3(1.0, 1.0, 1.0);\r\n    #endif // DIFFUSEMAP\r\n#endif // SPECULARMAP\r\n    surface.specularColor = u_MaterialSpecular.rgb;\r\n    surface.shininess = u_Shininess;\r\n}\r\n\r\nvoid main()\r\n{\r\n    PixelParams pixel;\r\n    getPixelParams(pixel);\r\n\r\n    Surface surface;\r\n    getBinnPhongSurfaceParams(surface, pixel);\r\n\r\n    vec3 surfaceColor = vec3(0.0);\r\n\r\n    surfaceColor = BlinnPhongLighting(surface, pixel);\r\n\r\n#ifdef FOG\r\n    surfaceColor = sceneLitFog(surfaceColor);\r\n#endif // FOG\r\n\r\n    gl_FragColor = vec4(surfaceColor, surface.alpha);\r\n}\r\n";

    var DepthNormalVS = "#define SHADER_NAME DepthNormalVS\r\n\r\n#include \"Scene.glsl\";\r\n#include \"Sprite3DVertex.glsl\";\r\n\r\n#include \"VertexCommon.glsl\";\r\n#include \"Camera.glsl\";\r\n\r\n\r\n\r\n// uniform mat4 u_View;\r\n// uniform mat4 u_ViewProjection;\r\n// uniform vec4 u_ProjectionParams;\r\n\r\n//传入法线\r\nvarying vec4 v_depthNormals;\r\n\r\n\r\nvec4 depthNormalsVertex()\r\n{\r\n\t Vertex vertex;\r\n    getVertexParams(vertex);\r\n\r\n    mat4 worldMat = getWorldMatrix();\r\n    vec3 positionWS = (worldMat * vec4(vertex.positionOS, 1.0)).xyz;\r\n\r\n    vec3 normalWS = normalize((worldMat * vec4(vertex.normalOS, 0.0)).xyz);\r\n\t\r\n\t//存储View空间法线\r\n\tvec3 normalVS = mat3(u_View) * normalWS;\r\n\tv_depthNormals.xyz = normalVS;\r\n\t\r\n\tvec4 positionCS = u_ViewProjection * vec4(positionWS,1.0);\r\n\tv_depthNormals.w = (positionCS.z * 2.0 - positionCS.w)*u_ProjectionParams.w;\r\n\t\r\n    return positionCS;\r\n}\r\n\r\nvoid main()\r\n{\r\n\tvec4 positionCS =  depthNormalsVertex();\r\n\tgl_Position=remapPositionZ(positionCS);\r\n}";

    var DepthNormalFS = "#define SHADER_NAME DepthNormalFS\r\n\r\n\r\n#include \"DepthNormalUtil.glsl\";\r\n\r\nvarying vec4 v_depthNormals;\r\n\r\nvoid main()\r\n{\r\n\tgl_FragColor=depthNormalsFragment(v_depthNormals);\r\n}";

    class BlinnPhongShaderInit {
        static init() {
            Laya.Shader3D.addInclude("BlinnPhongCommon.glsl", BlinnPhongCommonGLSL);
            Laya.Shader3D.addInclude("BlinnPhongVertex.glsl", BlinnPhongVertexGLSL);
            Laya.Shader3D.addInclude("BlinnPhongFrag.glsl", BlinnPhongFragGLSL);
            let uniformMap = {
                "u_DiffuseTexture": Laya.ShaderDataType.Texture2D,
                "u_NormalTexture": Laya.ShaderDataType.Texture2D,
                "u_SpecularTexture": Laya.ShaderDataType.Texture2D,
                "u_DiffuseColor": Laya.ShaderDataType.Color,
                "u_MaterialSpecular": Laya.ShaderDataType.Color,
                "u_Shininess": Laya.ShaderDataType.Float,
                "u_TilingOffset": Laya.ShaderDataType.Vector4,
                "u_AlbedoIntensity": Laya.ShaderDataType.Float,
                "u_AlphaTestValue": Laya.ShaderDataType.Float
            };
            let defaultValue = {
                "u_AlbedoIntensity": 1.0,
                "u_DiffuseColor": Laya.Color.WHITE,
                "u_MaterialSpecular": Laya.Color.WHITE,
                "u_Shininess": 0.078125,
                "u_AlphaTestValue": 0.5,
                "u_TilingOffset": new Laya.Vector4(1, 1, 0, 0),
            };
            let shader = Laya.Shader3D.add("BLINNPHONG", true, true);
            let subShader = new Laya.SubShader(Laya.SubShader.DefaultAttributeMap, uniformMap, defaultValue);
            shader.addSubShader(subShader);
            subShader.addShaderPass(BlinnPhongVS, BlinnPhongFS);
            subShader.addShaderPass(DepthVS, DepthFS, "ShadowCaster");
            subShader.addShaderPass(DepthNormalVS, DepthNormalFS, "DepthNormal");
        }
    }

    var TrailVS = "#define SHADER_NAME TrailVS\r\n\r\n#include \"Camera.glsl\";\r\n#include \"Scene.glsl\"\r\n#include \"SceneFogInput.glsl\"\r\n\r\n// Sprite uniform\r\nuniform float u_CurTime;\r\nuniform float u_LifeTime;\r\nuniform vec4 u_WidthCurve[10];\r\nuniform int u_WidthCurveKeyLength;\r\n\r\nvarying vec2 v_Texcoord0;\r\nvarying vec4 v_Color;\r\n\r\nfloat hermiteInterpolate(float t, float outTangent, float inTangent, float duration, float value1, float value2)\r\n{\r\n    float t2 = t * t;\r\n    float t3 = t2 * t;\r\n    float a = 2.0 * t3 - 3.0 * t2 + 1.0;\r\n    float b = t3 - 2.0 * t2 + t;\r\n    float c = t3 - t2;\r\n    float d = -2.0 * t3 + 3.0 * t2;\r\n    return a * value1 + b * outTangent * duration + c * inTangent * duration + d * value2;\r\n}\r\n\r\nfloat getCurWidth(in float normalizeTime)\r\n{\r\n    float width;\r\n    if (normalizeTime == 0.0)\r\n\t{\r\n\t    width = u_WidthCurve[0].w;\r\n\t}\r\n    else if (normalizeTime >= 1.0)\r\n\t{\r\n\t    width = u_WidthCurve[u_WidthCurveKeyLength - 1].w;\r\n\t}\r\n    else\r\n\t{\r\n\t    for (int i = 0; i < 10; i++)\r\n\t\t{\r\n\t\t    if (normalizeTime == u_WidthCurve[i].x)\r\n\t\t\t{\r\n\t\t\t    width = u_WidthCurve[i].w;\r\n\t\t\t    break;\r\n\t\t\t}\r\n\r\n\t\t    vec4 lastFrame = u_WidthCurve[i];\r\n\t\t    vec4 nextFrame = u_WidthCurve[i + 1];\r\n\t\t    if (normalizeTime > lastFrame.x && normalizeTime < nextFrame.x)\r\n\t\t\t{\r\n\t\t\t    float duration = nextFrame.x - lastFrame.x;\r\n\t\t\t    float t = (normalizeTime - lastFrame.x) / duration;\r\n\t\t\t    float outTangent = lastFrame.z;\r\n\t\t\t    float inTangent = nextFrame.y;\r\n\t\t\t    float value1 = lastFrame.w;\r\n\t\t\t    float value2 = nextFrame.w;\r\n\t\t\t    width = hermiteInterpolate(t, outTangent, inTangent, duration, value1, value2);\r\n\t\t\t    break;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n    return width;\r\n}\r\n\r\nvoid main()\r\n{\r\n    float normalizeTime = (u_CurTime - a_BirthTime) / u_LifeTime;\r\n\r\n    v_Texcoord0 = vec2(a_Texcoord0X, 1.0 - a_Texcoord0Y) * u_TilingOffset.xy + u_TilingOffset.zw;\r\n\r\n    v_Color = a_Color;\r\n\r\n    vec3 cameraPos = (u_View * a_Position).rgb;\r\n    gl_Position = u_Projection * vec4(cameraPos + a_OffsetVector * getCurWidth(normalizeTime), 1.0);\r\n\r\n    gl_Position = remapPositionZ(gl_Position);\r\n\t#ifdef FOG\r\n        FogHandle(gl_Position.z);\r\n    #endif\r\n}";

    var TrailFS = "#define SHADER_NAME TrailFS\r\n\r\n#include \"Scene.glsl\";\r\n#include \"SceneFog.glsl\";\r\n\r\nvarying vec2 v_Texcoord0;\r\nvarying vec4 v_Color;\r\n\r\nvoid main()\r\n{\r\n    vec4 color = 2.0 * u_MainColor * v_Color;\r\n#ifdef MAINTEXTURE\r\n    vec4 mainTextureColor = texture2D(u_MainTexture, v_Texcoord0);\r\n    color *= mainTextureColor;\r\n#endif\r\n\r\n#ifdef FOG\r\n    color.xyz = scenUnlitFog(color.xyz);\r\n#endif // FOG\r\n    gl_FragColor = color;\r\n}\r\n";

    class TrailShaderInit {
        static init() {
            let attributeMap = {
                'a_Position': [VertexTrail.TRAIL_POSITION0, Laya.ShaderDataType.Vector4],
                'a_OffsetVector': [VertexTrail.TRAIL_OFFSETVECTOR, Laya.ShaderDataType.Vector3],
                'a_Texcoord0X': [VertexTrail.TRAIL_TEXTURECOORDINATE0X, Laya.ShaderDataType.Float],
                'a_Texcoord0Y': [VertexTrail.TRAIL_TEXTURECOORDINATE0Y, Laya.ShaderDataType.Float],
                'a_BirthTime': [VertexTrail.TRAIL_TIME0, Laya.ShaderDataType.Float],
                'a_Color': [VertexTrail.TRAIL_COLOR, Laya.ShaderDataType.Vector4],
            };
            let uniformMap = {
                "u_TilingOffset": Laya.ShaderDataType.Vector4,
                "u_MainTexture": Laya.ShaderDataType.Texture2D,
                "u_MainColor": Laya.ShaderDataType.Color,
            };
            let defaultValue = {
                "u_MainColor": Laya.Color.WHITE,
                "u_TilingOffset": new Laya.Vector4(1, 1, 0, 0),
            };
            let shader = Laya.Shader3D.add("Trail", false, false);
            let subShader = new Laya.SubShader(attributeMap, uniformMap, defaultValue);
            shader.addSubShader(subShader);
            subShader.addShaderPass(TrailVS, TrailFS);
        }
    }

    var BRDFGLSL = "#if !defined(BRDF)\r\n    #define BRDF\r\n\r\n// Specular implementations\r\nfloat D_GGX(float roughness, float NoH, vec3 h, vec3 n)\r\n{\r\n    // todo 精度\r\n    #if !defined(GL_FRAGMENT_PRECISION_HIGH)\r\n    vec3 NxH = cross(n, h);\r\n    float oneMinusNoHSquared = dot(NxH, NxH);\r\n    #else\r\n    float oneMinusNoHSquared = 1.0 - NoH * NoH;\r\n    #endif\r\n\r\n    float a = NoH * roughness;\r\n    float k = roughness / (oneMinusNoHSquared + a * a);\r\n    float d = k * k * INVERT_PI;\r\n\r\n    return saturateMediump(d);\r\n}\r\n\r\nfloat D_GGX_Anisotropic(float NoH, const vec3 h, const vec3 t, const vec3 b, float at, float ab)\r\n{\r\n    float ToH = dot(t, h);\r\n    float BoH = dot(b, h);\r\n    float a2 = at * ab;\r\n    highp vec3 v = vec3(ab * ToH, at * BoH, a2 * NoH);\r\n    highp float v2 = dot(v, v);\r\n    float w2 = a2 / v2;\r\n    return a2 * w2 * w2 * INVERT_PI;\r\n}\r\n\r\nfloat V_SmithGGXCorrelated(float roughness, float NoV, float NoL)\r\n{\r\n    float a2 = roughness * roughness;\r\n    float lambdaV = NoL * sqrt((NoV - a2 * NoV) * NoV + a2);\r\n    float lambdaL = NoV * sqrt((NoL - a2 * NoL) * NoL + a2);\r\n    float v = 0.5 / (lambdaV + lambdaL);\r\n\r\n    return saturateMediump(v);\r\n}\r\n\r\nfloat V_SmithGGXCorrelated_Anisotropic(float at, float ab, float ToV, float BoV, float ToL, float BoL, float NoV, float NoL)\r\n{\r\n    float lambdaV = NoL * length(vec3(at * ToV, ab * BoV, NoV));\r\n    float lambdaL = NoV * length(vec3(at * ToL, ab * BoL, NoL));\r\n    float v = 0.5 / (lambdaV + lambdaL);\r\n    return saturateMediump(v);\r\n}\r\n\r\nvec3 F_Schlick(vec3 f0, float f90, float VoH)\r\n{\r\n    return f0 + (f90 - f0) * pow5(1.0 - VoH);\r\n}\r\n\r\nvec3 F_Schlick(vec3 f0, float VoH)\r\n{\r\n    return f0 + (1.0 - f0) * pow5(1.0 - VoH);\r\n}\r\n\r\nfloat F_Schlick(float f0, float f90, float VoH)\r\n{\r\n    return f0 + (f90 - f0) * pow5(1.0 - VoH);\r\n}\r\n\r\n// Specular dispatch\r\n\r\n// D\r\nfloat distribution(float roughness, float NoH, vec3 h, vec3 n)\r\n{\r\n    return D_GGX(roughness, NoH, h, n);\r\n}\r\n\r\n// V\r\nfloat visibility(float roughness, float NoV, float NoL)\r\n{\r\n    return V_SmithGGXCorrelated(roughness, NoV, NoL);\r\n}\r\n\r\n// F\r\nvec3 fresnel(vec3 f0, float LoH)\r\n{\r\n    float f90 = saturate(dot(f0, vec3(50.0 * 0.33)));\r\n    return F_Schlick(f0, f90, LoH);\r\n\r\n    // return F_Schlick(f0, LoH);\r\n}\r\n\r\n// diffuse BRDF implementations\r\n\r\nfloat Fd_Lambert()\r\n{\r\n    // return 1.0 / PI;\r\n    return 1.0;\r\n}\r\n\r\nfloat Fd_Burley(float roughness, float NoV, float NoL, float LoH)\r\n{\r\n    float f90 = 0.5 + 2.0 * roughness * LoH * LoH;\r\n    float lightScatter = F_Schlick(1.0, f90, NoL);\r\n    float veiwScatter = F_Schlick(1.0, f90, NoV);\r\n    return lightScatter * veiwScatter;\r\n}\r\n\r\n// diffuse dispatch \r\nfloat diffuse()\r\n{\r\n    return Fd_Lambert();\r\n}\r\n\r\n#endif // BRDF";

    var PBRGIGLSL = "#if !defined(pbrGI_lib)\r\n    #define pbrGI_lib\r\n\r\n    #include \"globalIllumination.glsl\";\r\n\r\n    // todo cpu 拼接？\r\n    #define IBL_ROUGHNESS_LEVEL 4.0\r\n\r\nvec2 prefilteredDFG_LUT(float coord, float NoV)\r\n{\r\n    return texture2DLodEXT(u_IBLDGF, vec2(NoV, 1.0 - coord), 0.0).rg;\r\n}\r\n\r\nvec2 EnvBRDFApproxLazarov(float roughness, float NoV)\r\n{\r\n    vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);\r\n    vec4 c1 = vec4(1, 0.0425, 1.04, -0.04);\r\n    vec4 r = roughness * c0 + c1;\r\n    float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\r\n    vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\r\n    return AB;\r\n}\r\n\r\nvec3 PBRGI(const in Surface surface, const in PixelInfo info)\r\n{\r\n    vec3 indirect = vec3(0.0);\r\n\r\n    #ifdef LIGHTMAP\r\n\r\n\t#ifdef UV1\r\n    vec2 lightmapUV = info.lightmapUV;\r\n    vec3 bakedColor = getBakedLightmapColor(lightmapUV);\r\n    // todo  surface.diffuseColor ？\r\n    vec3 Fd = bakedColor;\r\n\t#endif // UV1\r\n\r\n    #else // LIGHTMAP\r\n\r\n    vec3 n = info.normalWS;\r\n    vec3 Fd = diffuseIrradiance(n) * surface.diffuseColor * surface.occlusion * u_AmbientIntensity;\r\n\r\n    #endif // LIGHTMAP\r\n\r\n    // specular\r\n    float perceptualRoughness = surface.perceptualRoughness;\r\n    float NoV = info.NoV;\r\n    vec2 env = EnvBRDFApproxLazarov(perceptualRoughness, NoV);\r\n    vec3 f0 = surface.f0;\r\n    // todo f90 用 1.0 近似 f90\r\n    float f90 = 1.0;\r\n    vec3 specularColor = f0 * env.x + f90 * env.y;\r\n\r\n    vec3 r = getReflectedVector(surface, info);\r\n\r\n    #ifdef SPECCUBE_BOX_PROJECTION\r\n    r = getBoxProjectionReflectedVector(r, info.positionWS, u_SpecCubeProbePosition, u_SpecCubeBoxMin, u_SpecCubeBoxMax);\r\n    #endif // SPECCUBE_BOX_PROJECTION\r\n\r\n    vec3 indirectSpecular = specularIrradiance(r, perceptualRoughness) * u_ReflectionIntensity;\r\n\r\n    vec3 Fr = indirectSpecular * specularColor * surface.occlusion;\r\n\r\n    indirect = Fd + Fr;\r\n\r\n    return indirect;\r\n}\r\n\r\n#endif // pbrGI_lib";

    var PBRCommonGLSL = "#if !defined(pbrCommon_lib)\r\n    #define pbrCommon_lib\r\n\r\n// varying\r\nvarying vec3 v_PositionWS;\r\nvarying vec3 v_NormalWS;\r\n\r\n    #ifdef UV\r\nvarying vec2 v_Texcoord0;\r\n    #endif // UV\r\n\r\n    #ifdef UV1\r\n\t#ifdef LIGHTMAP\r\nvarying vec2 v_Texcoord1;\r\n\t#endif // LIGHTMAP\r\n    #endif // UV1\r\n\r\n    #ifdef NEEDTBN\r\nvarying vec3 v_TangentWS;\r\nvarying vec3 v_BiNormalWS;\r\n    #endif // NEEDTBN\r\n\r\n    #ifdef COLOR\r\nvarying vec4 v_VertexColor;\r\n    #endif // COLOR\r\n\r\n// 记录顶点信息, 用于由vs向fs传递数据\r\nstruct PixelParams {\r\n    vec3 positionWS;\r\n    vec3 normalWS;\r\n    vec3 normalTS;\r\n\r\n    #ifdef UV\r\n    vec2 uv0;\r\n    #endif // UV\r\n\r\n    #ifdef UV1\r\n\t#ifdef LIGHTMAP\r\n    vec2 uv1;\r\n\t#endif // LIGHTMAP\r\n    #endif // UV1\r\n\r\n    #ifdef NEEDTBN\r\n    vec3 tangentWS;\r\n    vec3 biNormalWS;\r\n    mat3 TBN;\r\n\t#ifdef ANISOTROPIC\r\n    float ToV;\r\n    float BoV;\r\n\t#endif // ANISOTROPIC\r\n\r\n    #endif // NEEDTBN\r\n\r\n    #ifdef COLOR\r\n    vec4 vertexColor;\r\n    #endif // COLOR\r\n\r\n    vec3 viewDir;\r\n    float NoV;\r\n};\r\n\r\n#endif // pbrCommon_lib";

    var PBRVertexGLSL = "#if !defined(pbrVertex_lib)\r\n    #define pbrVertex_lib\r\n\r\n    #include \"PBRCommon.glsl\";\r\n\r\nvoid initPixelParams(inout PixelParams params, in Vertex vertex)\r\n{\r\n    mat4 worldMat = getWorldMatrix();\r\n    params.positionWS = (worldMat * vec4(vertex.positionOS, 1.0)).xyz;\r\n    v_PositionWS = params.positionWS;\r\n\r\n    params.normalWS = normalize((worldMat * vec4(vertex.normalOS, 0.0)).xyz);\r\n    v_NormalWS = params.normalWS;\r\n\r\n    #ifdef NEEDTBN\r\n\t#ifdef TANGENT\r\n    params.tangentWS = normalize((worldMat * vec4(a_Tangent0.xyz, 0.0)).xyz);\r\n    params.biNormalWS = normalize(cross(params.normalWS, params.tangentWS) * sign(a_Tangent0.w));\r\n\t#else // TANGENT\r\n    params.tangentWS = normalize((worldMat * vec4(1.0, 0.0, 0.0, 0.0)).xyz);\r\n    params.biNormalWS = normalize(cross(params.normalWS, params.tangentWS));\r\n\t#endif // TANGENT\r\n    v_TangentWS = params.tangentWS;\r\n    v_BiNormalWS = params.biNormalWS;\r\n    #endif // NEEDTBN\r\n\r\n    #ifdef UV\r\n    params.uv0 = transformUV(vertex.texCoord0, u_TilingOffset);\r\n    v_Texcoord0 = params.uv0;\r\n    #endif // UV\r\n\r\n    #ifdef UV1\r\n\t#ifdef LIGHTMAP\r\n    params.uv1 = tranformLightMapUV(vertex.texCoord1, u_LightmapScaleOffset);\r\n    v_Texcoord1 = params.uv1;\r\n\t#endif LIGHTMAP\r\n    #endif // UV1\r\n\r\n    #ifdef COLOR\r\n    params.vertexColor = a_Color;\r\n    v_VertexColor = params.vertexColor;\r\n    #endif // COLOR\r\n}\r\n\r\n#endif // pbrVertex_lib";

    var PBRFragGLSL = "#if !defined(pbrFrag_lib)\r\n    #define pbrFrag_lib\r\n\r\n    #include \"PBRLighting.glsl\";\r\n\r\n    #include \"PBRCommon.glsl\";\r\n\r\nvoid getPixelParams(inout PixelParams params)\r\n{\r\n    params.positionWS = v_PositionWS;\r\n    params.normalWS = normalize(v_NormalWS);\r\n    params.normalTS = vec3(0.0,0.0,1.0);\r\n    #ifdef UV\r\n    params.uv0 = v_Texcoord0;\r\n    #endif // UV\r\n\r\n    #ifdef UV1\r\n\t#ifdef LIGHTMAP\r\n    params.uv1 = v_Texcoord1;\r\n\t#endif // LIGHTMAP\r\n    #endif // UV1\r\n\r\n    #ifdef COLOR\r\n    params.vertexColor = v_VertexColor;\r\n    #endif // COLOR\r\n\r\n    params.viewDir = normalize(u_CameraPos - params.positionWS);\r\n    // todo NoV varying ?\r\n    params.NoV = max(abs(dot(params.normalWS, params.viewDir)), MIN_N_DOT_V);\r\n\r\n    #ifdef NEEDTBN\r\n    params.tangentWS = normalize(v_TangentWS);\r\n    params.biNormalWS = normalize(v_BiNormalWS);\r\n    mat3 TBN = mat3(params.tangentWS, params.biNormalWS, params.normalWS);\r\n    params.TBN = TBN;\r\n    \r\n\t#ifdef NORMALTEXTURE\r\n    vec3 normalSampler = texture2D(u_NormalTexture, params.uv0).rgb;\r\n    normalSampler = normalize(normalSampler * 2.0 - 1.0);\r\n    normalSampler.y *= -1.0;\r\n    params.normalTS = normalSampler;\r\n    params.normalWS = normalize(TBN * normalSampler);\r\n\t// params.normalWS = normalize(TBN * normalSampler);\r\n\t#endif // NORMALTEXTURE\r\n\r\n\t#ifdef TANGENTTEXTURE\r\n    vec3 tangentSampler = texture2D(u_TangentTexture, params.uv0).rgb;\r\n    tangentSampler = normalize(tangentSampler * 2.0 - 1.0);\r\n    params.tangentWS = normalize(TBN * tangentSampler);\r\n    params.biNormalWS = normalize(cross(params.normalWS, params.tangentWS));\r\n\t#endif // TANGENTTEXTURE\r\n\r\n\t#ifdef ANISOTROPIC\r\n    params.ToV = dot(params.tangentWS, params.viewDir);\r\n    params.BoV = dot(params.biNormalWS, params.viewDir);\r\n\t#endif // ANISOTROPIC\r\n\r\n    #endif // NEEDTBN\r\n}\r\n\r\nvoid getPixelInfo(inout PixelInfo info, const in PixelParams pixel)\r\n{\r\n    info.positionWS = pixel.positionWS;\r\n    info.normalWS = pixel.normalWS;\r\n    info.viewDir = pixel.viewDir;\r\n    info.NoV = pixel.NoV;\r\n\r\n    #ifdef LIGHTMAP\r\n\t#ifdef UV1\r\n    info.lightmapUV = pixel.uv1;\r\n\t#endif // UV1\r\n    #endif // LIGHTMAP\r\n\r\n    #ifdef NEEDTBN\r\n    info.tangentWS = pixel.tangentWS;\r\n    info.biNormalWS = pixel.biNormalWS;\r\n\r\n\t#ifdef ANISOTROPIC\r\n    info.ToV = pixel.ToV;\r\n    info.BoV = pixel.BoV;\r\n\t#endif // ANISOTROPIC\r\n\r\n    #endif // NEEDTBN\r\n}\r\n\r\nvec3 PBRLighting(const in Surface surface, const in PixelParams pixel)\r\n{\r\n\r\n    PixelInfo info;\r\n    getPixelInfo(info, pixel);\r\n\r\n    vec3 lightColor = vec3(0.0);\r\n    #ifdef DIRECTIONLIGHT\r\n    for (int i = 0; i < CalculateLightCount; i++)\r\n\t{\r\n\t    if (i >= DirectionCount)\r\n\t\tbreak;\r\n\t    DirectionLight directionLight = getDirectionLight(i, pixel.positionWS);\r\n        if (directionLight.lightMode == LightMode_Mix)\r\n\t\t{\r\n\t\t    continue;\r\n\t\t}\r\n\t    Light light = getLight(directionLight);\r\n\t    lightColor += PBRLighting(surface, info, light) * light.attenuation;\r\n\t}\r\n    #endif // DIRECTIONLIGHT\r\n\r\n    #if defined(POINTLIGHT) || defined(SPOTLIGHT)\r\n    ivec4 clusterInfo = getClusterInfo(u_View, u_Viewport, pixel.positionWS, gl_FragCoord, u_ProjectionParams);\r\n    #endif // POINTLIGHT || SPOTLIGHT\r\n\r\n    #ifdef POINTLIGHT\r\n    for (int i = 0; i < CalculateLightCount; i++)\r\n\t{\r\n\t    if (i >= clusterInfo.x)\r\n\t\tbreak;\r\n\t    PointLight pointLight = getPointLight(i, clusterInfo, pixel.positionWS);\r\n        if (pointLight.lightMode == LightMode_Mix)\r\n\t\t{\r\n\t\t    continue;\r\n\t\t}\r\n\t    Light light = getLight(pointLight, pixel.normalWS, pixel.positionWS);\r\n\t    lightColor += PBRLighting(surface, info, light) * light.attenuation;\r\n\t}\r\n    #endif // POINTLIGHT\r\n\r\n    #ifdef SPOTLIGHT\r\n    for (int i = 0; i < CalculateLightCount; i++)\r\n\t{\r\n\t    if (i >= clusterInfo.y)\r\n\t\tbreak;\r\n\t    SpotLight spotLight = getSpotLight(i, clusterInfo, pixel.positionWS);\r\n        if (spotLight.lightMode == LightMode_Mix)\r\n\t\t{\r\n\t\t    continue;\r\n\t\t}\r\n\t    Light light = getLight(spotLight, pixel.normalWS, pixel.positionWS);\r\n\t    lightColor += PBRLighting(surface, info, light) * light.attenuation;\r\n\t}\r\n    #endif // SPOTLIGHT\r\n\r\n    vec3 giColor = PBRGI(surface, info);\r\n\r\n\r\n    return lightColor + giColor;\r\n}\r\n\r\n#endif // pbrFrag_lib";

    var PBRMetallicGLSL = "#include \"PBRFrag.glsl\";\r\n\r\nstruct SurfaceInputs {\r\n    vec3 diffuseColor;\r\n    float alpha;\r\n    float alphaTest;\r\n    float metallic;\r\n    float smoothness;\r\n    float occlusion;\r\n    vec3 emissionColor;\r\n    float anisotropy;\r\n};\r\n\r\nvoid initSurface(inout Surface surface, const in SurfaceInputs inputs)\r\n{\r\n    surface.alpha = inputs.alpha;\r\n\r\n    vec3 baseColor = inputs.diffuseColor;\r\n    float metallic = inputs.metallic;\r\n    float perceptualRoughness = 1.0 - inputs.smoothness;\r\n    float reflectance = 0.5;\r\n\r\n    surface.diffuseColor = (1.0 - metallic) * baseColor;\r\n    surface.perceptualRoughness = clamp(perceptualRoughness, MIN_PERCEPTUAL_ROUGHNESS, 1.0);\r\n    surface.roughness = surface.perceptualRoughness * surface.perceptualRoughness;\r\n    surface.f0 = baseColor * metallic + (0.16 * reflectance * reflectance * (1.0 - metallic));\r\n\r\n    surface.occlusion = inputs.occlusion;\r\n#ifdef ANISOTROPIC\r\n    surface.anisotropy = inputs.anisotropy;\r\n#endif // ANISOTROPIC\r\n}\r\n\r\nvec4 PBR_Metallic_Flow(const in SurfaceInputs inputs, in PixelParams pixel)\r\n{\r\n#ifdef ALPHATEST\r\n    if (inputs.alpha < inputs.alphaTest)\r\n\t{\r\n\t    discard;\r\n\t}\r\n#endif // ALPHATEST\r\n\r\n    Surface surface;\r\n    initSurface(surface, inputs);\r\n\r\n    vec3 surfaceColor = vec3(0.0);\r\n\r\n    surfaceColor += PBRLighting(surface, pixel);\r\n\r\n// todo emission calculate\r\n#ifdef EMISSION\r\n    surfaceColor += inputs.emissionColor;\r\n#endif // EMISSION\r\n\r\n    return vec4(surfaceColor, surface.alpha);\r\n}\r\n";

    const defaultdfg = "Iz9SQURJQU5DRQojIGNtZ2VuCkZPUk1BVD0zMi1iaXRfcmxlX3JnYmUKR0FNTUE9MQpFWFBPU1VSRT0wCgotWSAxMjggK1ggMTI4CgICAICA7enk39rV0MvHxMG+u7m3tLKwrqyqqKakoqCfnZuZmJaVk5KRj46Ni4qJiIaFhIOCgYD+/Pr49vTy8e/t6+nn5eTi4N/d3NrZ19bV09LQz87My8rIx8bFxMPBwL++vby6ubi3trW0s7KxsK+urayrqqqpqKempaSko6KhoKCfnp0JCwoKCQkICAcHAwcGBgMGBQUEBQUEBIQEhwOKAooBiAKQAbYA/wABALKAzn8CAgCAgO3p5N/a1dDLx8TBvry5t7WzsK6sqqimpKOhn52cmpiXlZSTkZCPjYyLiYiHhoWDgoGA//37+fj29PLw7uzr6efl5OLg397c29nY1tXU0tHQzs3MysnIx8XEw8LBwL+9vLu6ubi3trW0s7KxsK+uraysq6qpqKempqWko6KioaCfCQsKCgkJCAgHBwMHBgYDBgUFgwWFBIgDigKJAYgCkAG2AP8AAQCygM5/AgIAgIDt6eTf2tXRzMfFwr+8uri1s7Gvraupp6WkoqCfnZuamJaVlJKRkI+NjIuKiIeGhYSDgoGA/vz7+ff18/Lw7uzq6efl5OLh397d29rY19bU09LQz87Ny8rJyMfGxcPCwcC/vr28u7q5uLe2tbSzsrGwsK+urayrqqqpqKempqWkowcLCgoJCQgIBQgHBwYGBAYGBQUEBQUEBIQEhwOKAosBhwKQAbUA/wABALSAzH8CAgCAgO3p5N/a1tHMyMXCwL27uLa0srCurKqopqWjoaCenJuZmJaVlJKRkI+OjIuKiYeGhYSDgoGA//38+vj39fPx7+7s6unn5uTj4eDf3dzb2djX1dTT0tDPzs3MysnIx8bFxMPCwcC/vr28u7q5uLe2tbS0s7KxsK+vrq2sq6uqqainCgsLCgoJCQgIBwcDBwYGBAYGBQUEBQUEBIMEiAOKAosBhwKQAbQA/wABALWAy38CAgCAgO3o5N/b1tHNyMbDwL67ube1s7Gvraupp6akoqGfnpyamZeWlZSSkZCPjoyLiomIh4aFhIOCgYD//fv6+Pb18/Hv7uzr6ejm5ePi4d/e3dza2djX1dTT0tDPzs3My8rJyMfGxcTDwsHAv769vLu6ubm4t7a1tLOzsrGwsK+uraysCgsLCgoJCQgIBwcDBwYGBAYGBQWDBYUEiAOKAowBhQKQAbQA/wABALeAyX8CAgCAgO3o5N/b1tLNycbDwb68uri1s7KwrqyqqKelo6Kgn52cmpmXlpWUk5GQj46NjIqJiIeGhYSDgoKBgP79+/r49vXz8fDu7evq6Ofm5OPi4N/e3dva2djX1dTT0tHQz87NzMvKycjHxsXEw8LBwL++vr28u7q5uLi3trW1tLOysrGwCAwLCgoJCQgIAwgHBwMHBgYEBgYFBQQFBQQEhASHA4sCjQGEApABswD/AAEAuYDHfwICAICA7ejk4NvX0s7JxsTBv7y6uLa0srCvraupqKako6Ggnp2bmpmXlpWUk5KQj46NjIuKiYiHhoWEg4KBgID+/fv6+Pb18/Lw7+3s6uno5+Xk4+Lg397d3NrZ2NfW1dTT0tHQz87NzMvKycjHxsXEw8PCwcC/vr29vLu6urm4t7e2tbQLDAsLCgoJCQgIBwcDBwYGBAYGBQWDBYYEhwOLAo4BgwKQAbIA/wABALuAxX8CAgCAgO3o5ODb19POysfEwr+9u7m3tbOxr66sqqinpaSioZ+enJuamJeWlZSTkpGPjo2Mi4qJiIeGhYWEg4KBgID+/fv6+Pf19PLx7+7t6+rp6Obl5OPi4d/e3dzb2tnY19bV1NPS0dDPzs3My8rJyMjHxsXEw8PCwcDAv769vby7urq5CQwLCwoKCQkICAMIBwcDBwYGBAYGBQWDBYUEiAOKApABBAICAQGNAbIA/wABAL2Aw38CAgCAgOzo5ODc19PPy8fFwsC+u7q4trSysK+tq6mopqWjoqGfnpybmpiXlpWUk5KRkI+OjYyLiomIh4aFhISDgoGBgP/9/Pr59/b08/Lw7+7s6+rp6Ofl5OPi4eDf3t3b2tnZ2NfW1dTT0tHQz87OzczLysnJyMfGxcXEw8LCwcDAv769BwwMCwoKCQkFCQgIBwcEBwcGBgMGBQWDBYYEiAOKAqEBsQD/AAEAv4DBfwICAICA7Ojk4NzY1M/LyMXDwL68uri2tbOxr66sqqmnpqWjoqCfnpybmpiXlpWUk5KRkI+OjYyLiomIiIeGhYSEg4KBgYD//vz7+fj39fTz8fDv7u3r6uno5+bl5OPi4eDf3d3c29rZ2NfW1dTU09LR0M/Ozs3MzMvKycjIx8bGxcTDw8IKDAwLCwoKCQkICAMIBwcDBwYGBAYGBQWDBYYEhwOLApEBAwABAY0BsAD/AAEAwYC/fwICAICA7Ojk4NzY1NDMyMbDwb+9u7m3tbSysK+tq6qop6ako6Ggn52cm5qZmJeWlZSTkpGQj46NjIuKiYiIh4aFhISDgoKBgID+/fv6+ff29fTz8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2tnY19bV1NTT0tHR0M/Pzs3MzMvKysnIyMcIDQwLCwoKCQkFCQgIBwcEBwcGBgQGBgUFgwWGBIcDiwKRAYMAjAGwAP8AAQDEgLx/AgIAgIDs6OTg3NjU0MzIxsTCv727uri2tLOxsK6sq6mop6Wko6Ggn52cm5qZmJeWlZSTkpGQj46NjIuLiomIiIeGhYWEg4OCgYGA//78+/r59/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg4N/e3dzb29rZ2NfX1tXU1NPS0tHQ0M/Ozs3MzAsNDAwLCwoKCQkICAMIBwcDBwYGBAYGBQWDBYYEiAOLApEBhACLAa8A/wABAMaAun8CAgCAgOzo5ODc2dXRzcnHxMLAvry6uLe1s7Kwr62sqqmopqWkoqGgn52cm5qZmJeWlZSTkpKRkI+OjYyLi4qJiIiHhoaFhISDgoKBgID//vz7+vn49/b19PPx8fDv7u3s6+rp6Ofm5eXk4+Lh4eDf3t3d3Nva2tnY2NfW1tXU1NPS0tHRCQ0MDAsLCgoJCQMJCAgDCAcHAwcGBgQGBgUFgwWGBIgDigKSAYYAiQGuAP8AAQDJgLd/AgIAgIDs6OTg3dnV0c3Kx8XDwL68u7m3trSzsbCurauqqaempaSioaCfnZybmpmZmJeWlZSTkpGQj4+OjYyLi4qJiYiHh4aFhYSEg4KCgYCA//79/Pr5+Pf29fT08/Lx8O/u7ezr6urp6Ofm5uXk4+Pi4eHg397e3dzc29va2dnY19fW1gwNDQwMCwsKCgkJCAgDCAcHBAcHBgYEBgYFBYMFhgSIA4oCkQGJAIYBrgD/AAEAzIC0fwICAICA6+jk4N3Z1dLOysfFw8G/vbu6uLe1tLKxr66sq6qop6alo6KhoJ+enZybmpmYl5aVlJSTkpGQj46OjYyMi4qKiYiIh4aGhYWEg4OCgoGBgP/+/fz7+vn5+Pf29fTz8vHx8O/u7ezs6+rp6ejn5+bl5OTj4uLh4ODf397d3dzc29sKDg0MDAsLCgoJCQMJCAgDCAcHAwcGBoMGhQWGBIcDiwKRAYsAhAGtAP8AAQDPgLF/AgIAgIDr6OTh3dnW0s7LyMbEwsC+vLq5t7a0s7Gwr62sq6mop6alo6KhoJ+enZybmpmZmJeWlZSTkpKRkI+Pjo2NjIuLiomJiIiHhoaFhYSEg4KCgYGAgP/+/f38+/r5+Pf39vX08/Ly8fDv7+7t7Ozr6urp6Ojn5ubl5eTj4+Li4eHg4A0ODQ0MDAsLCgoJCQgIBAgIBwcDBwYGBAYGBQWDBYYEiAOLApEBjgADAQAAqgD/AAEA04CtfwICAIBX6+jk4d3a1tLPy8jGxMLAvr27uri2tbSysbCurauqqainpqWjoqGgn56dnJubmpmYl5eWlZSTkpKRkJCPjo6NjIyLioqJiYiIh4eGhYWEhIODgoKBgYCAKYD//v38/Pv6+fj49/b19PTz8vLx8PDv7u7t7ezr6+rq6ejo5+fm5uXlCw4NDQwMCwsKCgkJAwkICAMIBwcEBwcGBgQGBgUFgwWGBIgDiwKQAbsA/wABANiAqH8CAgCAV+vn5OHd2tbTz8zIxsXDwb+9vLq5t7a0s7Kwr66sq6qpqKempaSioaCfnp2dnJuampmYl5aWlZSTkpKRkJCPj46NjYyLi4qKiYmIiIeHhoaFhYSEg4OCggWCgYGAgByA//7+/fz7+/r5+Pj39vb19PTz8/Ly8fDw7+7uCO7t7ezs6+vqDA4ODQ0MDAsLCgoJCQMJCAgDCAcHBAcHBgYEBgYFBYMFhgSIA4sCkAG6AP8AAQDdgKN/AgIAgFfq5+Th3drX09DMycfFw8G/vry7ubi2tbSzsbCvrayrqqmop6alpKOioaCfnp2cnJuamZmYl5aWlZSTk5KRkZCQj46OjY2MjIuLioqJiYiIh4eGhoWFhIQFhIODgoIDgoGBA4GAgB6A//7+/fz8+/r6+fn49/f29vX19PTz8/Ly8fHw8O8KDw4NDQwMCwsKCgUKCQkICAQICAcHAwcGBoMGhQWGBIgDigKRAbkA/wABAOOAnX8CAgCASurn5OHd2tfU0M3Kx8XEwsC+vbu6ube2tbOysbCurayrqqmop6alpKOioaCfnp6dnJybmpmZmJeWlpWUlJOSkpGRkJCPjo6NjYyMC4yLi4qKiYmIiIeHBYeGhoWFBYWEhIODA4OCggSCgoGBA4GAgBSA///+/f38/Pv7+vr5+fj49/f29gP29fUNDw4ODQ0MDAsLCgoJCQMJCAgDCAcHBAcHBgYEBgYFBYMFhwSIA4oCkQG4AP8AAQDqgJZ/AgIAgEzq5+Th3drX1NHNysjGxMLAv728u7m4t7W0s7Kxr66trKuqqainpqWko6KhoKCfnp2dnJubmpmZmJeXlpWVlJOTkpKRkZCQj4+Ojo2NCY2MjIuLioqJiQWJiIiHhwOHhoYDhoWFA4WEhAOEg4MEg4OCggOCgYEEgYGAgAaAgP///v4H/v39/Pz7+wL7+gsPDw4NDQwMCwsKCgMKCQkDCQgIAwgHBwQHBwYGBAYGBQWDBYcEhwOLApABuAD/AAEA84CNfwICAIBD6ufk4d3a19TRzsvIxsTDwb++vbu6ube2tbSzsbCvrq2sq6qpqKempaSjo6KhoJ+fnp2dnJybmpqZmJiXlpaVlZSTkwaTkpGRkJAFkI+Pjo4Hjo2NjIyLiwOLiooFiomJiIgEiIiHhwOHhoYEhoaFhQOFhIQEhISDgwSDg4KCg4KEgYaADA8PDg4NDQwMCwsKCgUKCQkICAQICAcHBAcHBgYEBgYFBYMFhgSIA4sCkAG3AP8AAQD/gAGAAgIAgEvp5uTh3tvX1NHOy8jGxcPCwL69vLu5uLe2tbOysbCvrq2sq6qpqKenpqWko6KhoaCfn56enZycm5qamZmYl5eWlpWVlJSTk5KSkZEDkZCQB5CPj46OjY0DjYyMA4yLiwOLiooDiomJBImJiIgEiIiHhwSHh4aGBIaGhYUEhYWEhISEhYMCgoIKEA8PDg0NDAwLCwULCgoJCQMJCAgECAgHBwMHBgaDBoUFhgSIA4sCkAG2AP8AAQD/gAGAAgIAgEbp5uPg3tvY1dLPzMnHxcTCwL++vLu6ube2tbSzsrGwr66trKuqqamop6alpKSjoqGhoKCfnp6dnZybm5qamZiYl5eWlpWVB5WUlJOTkpIDkpGRA5GQkAWQj4+OjgOOjY0EjY2MjAOMi4sEi4uKigSKiomJBImJiIiDiIWHh4aDhQ0QEA8ODg0NDAwLCwoKAwoJCQMJCAgDCAcHBAcHBgaDBoUFhgSIA4oCkQG1AP8AAQD/gAGAAgIAgEjp5uPg3tvY1dLPzMnHxsTDwcC+vby7ubi3trW0s7KxsK+urayrq6qpqKempqWko6OioaGgoJ+fnp6dnJybm5qamZmYmJeXlpYFlpWVlJQDlJOTA5OSkgOSkZEDkZCQA5CPjwOPjo4Ejo6NjQSNjYyMg4yFi4WKh4mFiA4QEA8PDg4NDQwMCwsKCgMKCQkDCQgIAwgHBwQHBwYGgwaFBYYEiAOKApABtQD/AAEA/4ABgAICAIBF6ebj4N7b2NXS0M3Kx8bEw8HAv728u7q5uLe2tbSzsrGwr66trKyrqqmoqKempaWko6OioqGhoKCfnp6dnZycm5uampmZBZmYmJeXBZeWlpWVBJWVlJQDlJOTA5OSkgSSkpGRA5GQkASQkI+Pg4+GjoWNh4yHiwwREBAPDg4NDQwMCwsDCwoKAwoJCQMJCAgDCAcHBAcHBgYEBgYFBYQFhgSIA4oCkAG0AP8AAQD/gAGAAgIAgELo5uPg3tvY1dPQzcrIxsXDwsC/vr28u7q4t7a2tbSzsrGwr66trayrqqqpqKenpqWlpKOjoqKhoaCgn5+enp2dnJwFnJubmpoFmpmZmJgDmJeXA5eWlgSWlpWVBJWVlJQDlJOTBJOTkpKDkoWRh5CHj4iOAY0NEREQDw8ODg0NDAwLCwULCgoJCQMJCAgECAgHBwQHBwYGBAYGBQWDBYcEiAOKApABswD/AAEA/4ABgAICAIA76OXj4N3b2NbT0M7LyMfFxMLBwL69vLu6ubi3trW0tLOysbCvrq6trKyrqqmpqKenpqWlpKSjo6KioaELoaCgn5+enp2dnJwDnJubA5uamgOamZkDmZiYBJiYl5cEl5eWlgSWlpWVg5WFlIaTiJKKkQKQkBASERAQDw8ODg0NDAwLCwoKAwoJCQMJCAgECAgHBwQHBwYGBAYGBQWDBYcEhwOLAo8BswD/AAEA/4ABgAICAIA15+Xi4N3b2NbT0c7LycfGxMPBwL++vby7urm4t7a1tLSzsrGwr6+ura2sq6uqqaiop6empaUHpaSko6OiogeioaGgoJ+fBZ+enp2dA52cnAOcm5sEm5uamgSampmZg5mEmIWXhpaJlYqUhZMMEhEREBAPDg4NDQwMBQwLCwoKAwoJCQMJCAgECAgHBwQHBwYGBAYGBQWDBYcEhwOKApABsgD/AAEA/4ABgAICAIA45+Xi4N3b2NbT0c7MycfGxcPCwb++vby7urm5uLe2tbS0s7KxsLCvrq6trKyrqqqpqKinp6ampaUDpaSkB6Sjo6KioaEFoaCgn58En5+engOenZ0EnZ2cnAScnJubg5uFmoeZh5iMl4iWDxISERAQDw8ODg0NDAwLCwMLCgoDCgkJAwkICAQICAcHAwcGBoMGhQWGBIgDigKQAbEA/wABAP+AAYACAgCAOefk4uDd29jW1NHPzMrHxsXEwsHAv769vLu6ubi4t7a1tLSzsrGxsK+vrq2trKyrqqqpqaiop6empgOmpaUDpaSkBaSjo6KiA6KhoQOhoKAEoKCfnwSfn56eBJ6enZ2EnYach5uMmo2ZEBMSEhEQEA8PDg4NDQwMCwsDCwoKAwoJCQMJCAgDCAcHBAcHBgaDBoUFhgSIA4oCjwGxAP8AAQD/gAGAAgIAgDfm5OLf3dvY1tTRz83KyMbFxMPCwL++vby8u7q5uLe3trW0tLOysrGwsK+vrq2trKyrqqqpqaioA6inpwOnpqYDpqWlA6WkpAOko6MDo6KiBKKioaEEoaGgoIOgh5+HnoqdlJwMExMSEREQEA8ODg0NBQ0MDAsLAwsKCgMKCQkDCQgIAwgHBwQHBwYGgwaFBYYEiAOKAo8BsAD/AAEA/4ABgAICAIA45uTh393b2NbU0s/Ny8jHxcTDwsHAv769vLu7urm4t7e2tbW0s7OysbGwsK+vrq2trKyrq6qqqakDqaioBKiop6cDp6amA6alpQSlpaSkA6Sjo4OjhaKIoYqgmp8PFBMSEhEREA8PDg4NDQwMAwwLCwULCgoJCQQJCQgIAwgHBwQHBwYGgwaFBYYEiAOJApABrwD/AAEA/4ABgAICAIA55ePh393b2NbU0tDNy8nHxsXDwsHAv769vby7urq5uLe3trW1tLOzsrKxsbCwr6+urq2trKyrq6qqA6qpqQSpqaioBKiop6cEp6empgSmpqWlg6WGpIqjkKKPoQKiohAUExMSEhEQEA8PDg4NDQwMBQwLCwoKAwoJCQQJCQgIAwgHBwQHBwYGgwaFBYYEhwOKAo8BrwD/AAEA/4ABgAICAIAz5ePh393a2NbU0tDOy8nHxsXEw8LBwL++vby8u7q5ubi4t7a2tbS0s7OysrGxsLCvr66uB66traysq6sEq6uqqgSqqqmpg6mEqIWniKaMpZ6kERUUExMSEREQEA8PDg4NDQwMBQwLCwoKAwoJCQQJCQgIAwgHBwQHBwYGgwaFBYYEhwOKAo8BrgD/AAEA/4ABgAICAIAv5ePg3tza2NbU0tDOzMrIxsXEw8LBwL++vr28u7u6ubm4uLe2trW1tLSzs7KysbEHsbCwr6+urgOura0DraysBKysq6uDq4WqhqmIqKqnEhUUFBMTEhEREBAPDw4ODQ0MDAUMCwsKCgMKCQkECQkICAMIBwcEBwcGBoMGhQWGBIcDigKOAa4A/wABAP+AAYACAgCAL+Ti4N7c2tjW1NLQzszKyMbFxMPCwcDAv769vby7u7q5ubi4t7e2trW1tLSzs7KyA7KxsQWxsLCvrwOvrq4Drq2thK2GrIari6qcqYyqExYVFBQTEhIRERAQDw8ODg0NDAwFDAsLCgoDCgkJBAkJCAgDCAcHBAcHBgaDBoUFhgSHA4oCjgGtAP8AAQD/gAGAAgIAgCTk4uDe3NrY1tTS0M7MysjGxcTEw8LBwL++vr28vLu7urq5uLgGuLe3trW1A7W0tAW0s7OysgOysbEDsbCwA7CvrwSvr66uh66HrY2sh6uarIWtDxYVFRQUExISEREQDw8ODgcODQ0MDAsLAwsKCgMKCQkDCQgIBAgIBwcEBwcGBgQGBgUFhAWGBIcDiQKOAa0A/wABAP+AAYACAgCAKuPh393c2tjW1NLQzs3LycfGxcTDwsHAwL++vb28vLu7urq5ubi4t7e2tgO2tbUDtbS0A7SzswOzsrIDsrGxBLGxsLCDsIyvpK6OrwKwsBAXFhUVFBMTEhIREBAPDw4OBw4NDQwMCwsDCwoKAwoJCQMJCAgECAgHBwQHBwYGBAYGBQWEBYUEiAOJAo4BrAD/AAEA/4ABgAICAIAl4uHf3dvZ2NbU0tDPzcvJx8bFxMPCwcHAv76+vb28vLu7urq5uQe5uLi3t7a2A7a1tQS1tbS0BLS0s7MEs7OysgSysrGxi7GhsIuxirITFxcWFRUUExMSEhEQEA8PDg4NDQUNDAwLCwMLCgoDCgkJAwkICAQICAcHBAcHBgYEBgYFBYMFhgSHA4oCjQGsAP8AAQD/gAGAAgIAgCTi4N7d29nX1tTS0M/Ny8nIxsXEw8PCwcC/v76+vb28vLu7uroDurm5Bbm4uLe3A7e2tgS2trW1g7WEtIazo7KNs4m0h7UUGBcWFhUUFBMTEhEREBAPDw4ODQ0FDQwMCwsDCwoKAwoJCQMJCAgECAgHBwQHBwYGBAYGBQWDBYYEhwOJAo4BqwD/AAEA/4ABgAICAIAj4eDe3NvZ19bU0tDPzcvKyMbFxMPDwsHAwL+/vr69vby8u7sDu7q6A7q5uQO5uLgDuLe3g7eFtoa1o7SLtYm2iLeEuBUZGBcWFhUUFBMTEhEREBAPDw4ODQ0FDQwMCwsDCwoKAwoJCQMJCAgECAgHBwQHBwYGBAYGBQWDBYYEhwOJAo0BqwD/AAEA/4ABgAICAIAd4d/d3NrZ19XU0tDPzczKyMfFxMTDwsHBwL+/vr4Fvr29vLwDvLu7A7u6ugS6urm5A7m4uIO4h7eItoi1k7aLt4m4h7mHugK7uxYZGBgXFhYVFBQTExIRERAQDw8ODg0NBQ0MDAsLAwsKCgMKCQkDCQgIBAgIBwcEBwcGBgQGBgUFgwWGBIcDiQKNAaoA/wABAP+AAYACAgCAHuDe3dva2NfV09LQz83MysjHxcTEw8LCwcDAv7++vgO+vb0Dvby8A7y7uwS7u7q6BLq6ubmDuYq4kbeOuIq5h7qHu4e8hr0XGhkYGBcWFhUUFBMTEhEREBAPDw4ODQ0FDQwMCwsDCwoKAwoJCQMJCAgECAgHBwQHBwYGBAYGBQWDBYYEhgOJAo0BqgD/AAEA/4ABgAICAIAf397c29nY1tXT0tDPzczKycfGxMTDwsLBwcDAv7++vgO+vb0Dvby8BLy8u7uDu4a6nbmLuoi7h7yHvYe+hr+DwBgbGhkYGBcWFhUUFBMTEhEREBAPDw4ODQ0FDQwMCwsDCwoKAwoJCQMJCAgECAgHBwQHBwYGBAYGBQWDBYUEhwOJAo0BqQD/AAEA/4ABgAICAIAf393c2tnX1tTT0tDPzczKycfGxMTDw8LBwcDAv7++vgS+vr29BL29vLyEvIe7mbqGu4i8h72Hvoa/h8CFwYbCAcMXGxoaGRgYFxYWFRQUExMSEREQEA8PDg4HDg0NDAwLCwMLCgoDCgkJAwkICAQICAcHBAcHBgYEBgYFBYMFhQSHA4gCjQGpAP8AAQD/gAGAAgIAgCDe3Nva2NfV1NPR0M/NzMrJyMbFxMPDwsLBwcDAv7++voO+hr2KvIW7lbyFvYa+iL+FwIbBhcKHw4XEhMUYHBsaGhkYGBcWFhUUFBMTEhEREBAPDw4OBQ4NDQwMBQwLCwoKAwoJCQMJCAgECAgHBwQHBwYGBAYGBQUEBQUEBIQEhwOIAo0BqAD/AAEA/4ABgAICAIAe3dza2djW1dTS0dDOzczKycjGxcTDw8LCwcHAwL+/BL+/vr6Evo69A7y9vY+9iL6Fv4XAh8GFwobDhcSGxYXGhccByBkdHBsaGhkYGBcWFhUUFBMTEhEREBAPDw4OBQ4NDQwMBQwLCwoKAwoJCQMJCAgECAgHBwMHBgaDBoQFhgSGA4kCjAGoAP8AAQD/gAGAAgIAgBzc29rY19bV09LRz87NzMrJyMfFxMPDwsLBwcDAA8C/v4O/nb6Jv4fAhcGEwobDhsSExYbGhceFyIXJg8oaHh0cGxoaGRgYFxYWFRQUExMSEREQEA8PDg4FDg0NDAwFDAsLCgoDCgkJAwkICAQICAcHAwcGBgQGBgUFgwWFBIcDiAKMAagA/wABAP+AAYACAgCAGtza2djW1dTT0tDPzs3LysnIx8XEw8PCwsHBA8HAwAPAv7+Gv4i+jr+HwIfBhsKEw4XEhMWGxoTHhsiEyYXKhcuFzBkeHh0cGxoaGRgYFxYWFRQUExMSEhEQEA8PBw8ODg0NDAwFDAsLCgoDCgkJAwkICAQICAcHAwcGBgQGBgUFgwWFBIcDiAKMAacA/wABAP+AAYACAgCAF9vZ2NfW1dPS0dDPzszLysnIx8bEw8LCA8LBwQPBwMAEwMC/v5C/icCGwYXCh8OFxITFhMaEx4XIhcmFyoTLhMyFzYbOAc8YHx4eHRwbGhoZGBgXFhYVFBQTExISERAQCRAPDw4ODQ0MDAUMCwsKCgMKCQkDCQgIBAgIBwcDBwYGBAYGBQWDBYUEhgOIAowBpwD/AAEA/4ABgAICAIAX2tnX1tXU09LRz87NzMvKycjHxsTDwsIDwsHBBMHBwMAEwMC/v4e/icCHwYXChMOFxIbFhcaEx4PIhMmEyoXLhMyFzYTOhc+F0IPRIiAfHh4dHBsbGhkYGBcWFhUVFBMTEhIRERAQDw8ODg0NDAwFDAsLCgoDCgkJAwkICAQICAcHAwcGBgQGBgUFBAUFBASEBIYDiAKLAacA/wABAP+AAYACAgCAGtnY19XU09LR0M/OzczLysnIx8bFxMPCwsHBBMHBwMCPwIbBhcKFw4TEhMWExoXHhMiEyYPKhMuEzIXNhM6Ez4XQhNGF0oTTIyEgHx8eHRwbGxoZGBgXFhYVFRQTExISEREQEA8PDg4NDQwMBQwLCwoKAwoJCQMJCAgDCAcHBAcHBgYEBgYFBQQFBQQEgwSGA4gCjAGmAP8AAQD/gAGAAgIAgBnY19bV1NLR0M/OzczLysnIx8bGxcTDwsHBg8GNwIbBhMKEw4XEg8WExoPHhMiEyYTKhMuEzIPNg86Fz4TQhNGF0oTThdSF1SQiISAfHx4dHBsbGhkZGBcXFhUVFBMTEhIRERAQDw8ODg0NDAwFDAsLCgoDCgkJAwkICAMIBwcEBwcGBgQGBgUFBAUFBASDBIYDhwKMAaYA/wABAP+AAYACAgCAGdfW1dTT0tHQz87NzMvKycjHxsXFxMPCwcGEwYrAhMGFwoPDhMSDxYTGg8eDyITJg8qEy4TMg82EzoPPg9CE0YTShNOF1IXVhNaF1wHYJSMiISAgHx4dHBwbGhkZGBcXFhUVFBMTEhIRERAQDw8ODg0NDAwFDAsLCgoDCgkJAwkICAMIBwcEBwcGBgMGBQWDBYUEhQOIAosBpgD/AAEA/4ABgAICAIAZ1tXU09LR0M/OzczLysnJyMfGxcTEw8LBwYXBhsCFwYTChMODxIPFg8aDx4PIg8mDyoPLg8yEzYPOhM+D0IPRhNKD04TUhNWE1obXhNiF2QHaJiQjIiEgIB8eHRwcGxoZGRgXFxYVFRQUExISEREQEA8PDg4NDQwMBQwLCwoKAwoJCQMJCAgDCAcHAwcGBgQGBgUFBAUFBASDBIYDhwKLAaYA/wABAP+AAYACAgCAGdXU09LR0M/OzczLy8rJyMfHxsXExMPCwcEGwcHAwMHBicGDwoPDg8SDxYPGBMfHyMgDyMnJA8nKygPKy8sFy8zMzc0Dzc7OA87PzwPP0NAE0NDR0QPR0tID0tPTBNPT1NQD1NXVA9XW1gTW1tfXg9eE2ITZhdqF2wHcJyUkIyIhISAfHh0dHBsaGhkYFxcWFRUUFBMSEhEREBAPDw4ODQ0MDAUMCwsKCgMKCQkDCQgIAwgHBwMHBgYEBgYFBQQFBQQEgwSFA4gCigGmAP8AAQD/gAGAAgIAgBvU09LR0M/OzczMy8rJyMjHxsXFxMPDwsHBwMCDwIjBhMIEw8PExAPExcUFxcbGx8cFx8jIyckFycrKy8sDy8zMB8zNzc7Oz88Dz9DQA9DR0QPR0tID0tPTBNPT1NQD1NXVA9XW1gPW19cE19fY2APY2dmD2YTahNuF3IXdAd4oJiUkIyIiISAfHh0dHBsaGhkYGBcWFhUUFBMTEhEREBAPDw4ODQ0MDAUMCwsKCgMKCQkDCQgIAwgHBwMHBgYEBgYFBQQFBQQEBAQEAwOEA4cCiwGlAP8AAQD/gAGAAgIAgBvT0tHQz87NzMvLysnIyMfGxsXExMPDwsLBwMCDwIbBhMKDwwTExMXFBcXGxsfHC8fIyMnJysrLy8zMBczNzc7OBc7Pz9DQBdDR0dLSA9LT0wPT1NQD1NXVA9XW1gTW1tfXA9fY2APY2dkE2dna2gPa29sE29vc3IPchN2F3oXfKScmJSQkIyIhIB8eHh0cGxsaGRgYFxYWFRQUExMSEREQEA8PDg4NDQwMBQwLCwoKAwoJCQUJCAgHBwQHBwYGAwYFBQQFBQQEgwSFA4cCiwGlAP8AAQD/gAGAAgIAgBnS0dDPzs3My8vKycjIx8bGxcXEw8PCwsHBA8HAwATAwMHBg8GEwoPDCMTExcXGxsfHEcfIyMnJysrLy8zMzc3Ozs/PB8/Q0NHR0tIF0tPT1NQF1NXV1tYD1tfXBNfX2NgD2NnZA9na2gTa2tvbBNvb3NwD3N3dBN3d3t6D3oPfheCF4SooKCcmJSQjIiEgHx8eHRwbGxoZGRgXFhYVFRQTExISERAQDw8ODg0NDAwFDAsLCgoFCgkJCAgDCAcHAwcGBgQGBgUFBAUFBAQEBAQDA4QDhwKKAaUA/wABAP+AAYACAgCAGdDPzs7NzMvKysnIx8fGxsXFxMTDw8LCwcEDwcDAg8CDwYPCg8ODxBfFxcbGx8fIyMnJysrLy8zMzc3Ozs/Q0AnQ0dHS0tPT1NQF1NXV1tYF1tfX2NgD2NnZBNnZ2toD2tvbA9vc3ATc3N3dBN3d3t4D3t/fBN/f4OAE4ODh4YPhheKD4ysqKSgnJiUkIyIhICAfHh0cHBsaGRkYFxcWFRUUExMSEhEQEA8PDg4NDQwMBwwLCwoKCQkDCQgIAwgHBwMHBgYEBgYFBQMFBASDBIUDhwKKAaUA/wABAP+AAYACAgCAE8/OzczMy8rJyMjHx8bFxcTEw8MDw8LCA8LBwQPBwMCDwIPBBMLCw8MDw8TEIcTFxcbGx8fIycnKysvLzMzNzc7Pz9DQ0dHS0tPT1NTV1QfV1tbX19jYBdjZ2draA9rb2wPb3NwE3Nzd3QPd3t4E3t7f3wPf4OAE4ODh4QTh4eLig+KE44bkAeUsKyopKCcmJSQjIiEhIB8eHR0cGxoaGRgXFxYVFRQTExISERAQDw8ODg0NDAwHDAsLCgoJCQMJCAgDCAcHAwcGBgMGBQUEBQUEBAQEBAMDhAOGAooBpQD/AAEA/4ABgAICAIAUzs3My8rKycjHx8bGxcXExMPDwsIEwsLBwQTBwcDAg8CDwQrCwsPDxMTFxcbGH8bHx8jJycrKy8zMzc3Oz8/Q0NHS0tPT1NTV1dbW19cH19jY2dna2gXa29vc3APc3d0D3d7eBN7e398D3+DgBODg4eED4eLiBOLi4+OD44XkheWE5i8sKyopKCcmJSQjIyIhIB8eHR0cGxoaGRgXFxYVFRQTExISEREQDw8ODg0NDAwLCwULCgoJCQUJCAgHBwMHBgYEBgYFBQMFBASDBIUDhgKKAaUA/wABAP+AAYACAgCAEszLy8rJyMjHxsbFxcTEw8PCwgTCwsHBg8GGwATBwcLCKcLDw8TFxcbGx8fIyMnJysvLzM3Nzs/P0NDR0tLT09TV1dbW19fY2NnZCdna2tvb3Nzd3QXd3t7f3wTf3+DgA+Dh4QTh4eLiBOLi4+ME4+Pk5ATk5OXlg+WF5oXnAujoMi4tLCopKCgnJiUkIyIhIB8eHh0cGxsaGRgYFxYVFRQUExISEREQDw8ODg0NDAwLCwoKBQoJCQgIAwgHBwMHBgYDBgUFBAUFBAQEBAQDA4MDhwKJAaUA/wABAP+AAYACAgCADcvKycjIx8bGxcTEw8MDw8LCA8LBwYPBisAtwcLCw8PExMXGxsfHyMjJysrLy8zNzs7P0NDR0dLT09TV1dbW19fY2dna2tvbCdvc3N3d3t7f3wPf4OAD4OHhA+Hi4gPi4+ME4+Pk5ATk5OXlg+WE5oXnheiF6TUvLi0sKyopKCcmJSQjIiEgIB8eHRwbGxoZGBgXFhYVFBQTEhIRERAPDw4ODQ0MDAsLCgoJCQMJCAgDCAcHAwcGBgMGBQUDBQQEgwSFA4YCigGkAP8AAQD/gAGAAgIAgA/JycjHxsbFxMTDw8LCwcEEwcHAwIzAg8EqwsPDxMXFxsfHyMnJysrLzMzNzs7P0NHR0tPT1NXV1tbX2NjZ2dra29zcCdzd3d7e39/g4AXg4eHi4gPi4+MD4+TkA+Tl5QTl5ebmg+aE54XohemG6gLr6zYxLy4tLCsqKSgnJiUkIyIhISAfHh0cHBsaGRkYFxYWFRQUExISEREQDw8ODg0NDAwLCwoKCQkFCQgIBwcDBwYGAwYFBQQFBQQEBAQEAwODA4YCigGkAP8AAQD/gAGAAgIAgAzIx8bFxcTDw8LCwcEDwcDAg8CFv4fAhMEywsPExMXGxsfIycnKy8vMzc3Oz8/Q0dLS09TU1dbW19jY2dna29vc3N3d3t7f3+Dg4eEH4eLi4+Pk5APk5eUD5ebmBObm5+cE5+fo6IPohemE6ofrhOw5MjEwLy4tKyopKCcmJSQkIyIhIB8eHR0cGxoZGRgXFhYVFBQTEhIREBAPDw4ODQ0MDAsLCgoJCQgIAwgHBwMHBgYDBgUFAwUEBAQEBAMDgwOGAooBpAD/AAEA/4ABgAICAIALxsbFxMPDwsHBwMADwL+/hL8Dvr+/hb+EwIPBNMLCw8TFxcbHyMjJysvLzM3Ozs/Q0NHS09PU1dbW19jY2dra29vc3d3e3t/f4ODh4eLi4+MF4+Tk5eUD5ebmA+bn5wPn6OgE6Ojp6YPphOqG64TsiO01NDIxMC8uLSwrKikoJyYlJCMiISAfHh4dHBsaGhkYFxYWFRQUExISERAQDw8ODQ0MDAsLCgoHCgkJCAgHBwMHBgYDBgUFBAUFBAQEBAQDAwQDAwIChAKKAaQA/wABAP+AAYACAgCADMXEw8LCwcDAv7++voO+hL2FvoO/g8AEwcHCwjLCw8TFxsbHyMnKy8vMzc7Pz9DR0tLT1NXV1tfY2Nna2tvc3N3d3t7f4ODh4eLi4+Pk5AXk5eXm5gPm5+cD5+joA+jp6QTp6erqA+rr64PrhuyF7YjuAe84NTQzMjEvLi0sKyopKCcmJSQjIiEgHx8eHRwbGhoZGBcXFhUUFBMSEhEQEA8PDg0NDAwLCwoKCQkFCQgIBwcDBwYGAwYFBQMFBAQEBAQDA4MDhgKJAaQA/wABAP+AAYACAgCAC8PCwcHAv7++vr29A728vIW8hL0Evr6/vzi/wMDBwcLCw8PExcbHyMnJysvMzc7P0NHR0tPU1NXW1tfY2dna29zc3d7e39/g4OHi4uPj5OTl5QXl5ubn5wPn6OgD6OnpA+nq6gPq6+sE6+vs7ATs7O3thO2H7ofvAvDwPTc2NDMyMTAvLiwrKikoJyYlJCMiISEgHx4dHBsaGhkYFxcWFRQUExISERAQDw4ODQ0MDAsLCgoJCQgIBwcDBwYGAwYFBQMFBAQEBAQDA4MDhgKJAaQA/wABAP+AAYACAgCACcHAwL++vb28vAO8u7uHu4O8PL29vr6/v8DAwcLCw8PExMXGx8jJysvMzc7P0NHS0tPU1dbW19jZ2drb29zd3t7f4ODh4eLi4+Pk5OXm5gXm5+fo6APo6ekD6erqA+rr6wPr7OwE7Ozt7QTt7e7uhO6H74bwhPE5OTc2NTQzMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsbGhkYFxcWFRQTExIRERAQDw4ODQ0MCwsKCgkJBQkICAcHBQcGBgUFBAUFBAQDBAMDgwOGAokBpAD/AAEA/4ABgAICAIAKwL++vby8u7u6ugO6ubmDuYS6Qru7vLy9vr6/v8DBwsLDxMTFxsbHyMrLzM3Oz9DR0tPT1NXW19jY2drb29zd3d7f4ODh4eLj4+Tk5eXm5ufn6Ojp6QPp6uoD6uvrA+vs7ATs7O3tA+3u7gTu7u/vhO+I8IbxhPI+Ojk4NzU0MzIxLy4tLCsqKSgnJiUkIyIhIB8eHRwbGxoZGBcWFhUUExMSEREQDw8ODQ0MDAsLCgoJCQgIBwcDBwYGAwYFBQMFBAQEBAQDAwQDAwIChAKJAaQA/wABAP+AAYACAgCACr69vLu6urm5uLiIuD+5ubq6u7y8vb6+v8DBwsLDxMXGxsfIycrLzM3Oz9DR0tPU1dbX2Nna29vc3d3e3+Dg4eHi4+Pk5eXm5ufn6OgH6Onp6urr6wPr7OwD7O3tBO3t7u4E7u7v7wTv7/Dwg/CJ8Yfyg/M6PDs6ODc2NTMyMTAvLi0rKikoJyYlJCMiISAfHh0cHBsaGRgXFhYVFBMTEhEREA8PDg0NDAwLCgoJCQcJCAgHBwYGAwYFBQMFBAQEBAQDAwQDAwIChAKJAaQA/wABAP+AAYACAgCACry7urm4uLe3traGtkO3t7i4ubm6u7u8vb6/wMHCwsPExcbHyMnKyszNzs/Q0dLT1NXW19jZ2tvc3d3e3+Dg4eLi4+Pk5eXm5ufn6Ojp6erqBerr6+zsA+zt7QPt7u4D7u/vBO/v8PCD8IXxiPKI84P0Pz49Ozo5ODY1NDMxMC8uLSwrKignJiUkIyIhIB8eHRwcGxoZGBcWFhUUExISERAQDw4ODQwMCwsKCgkJCAgHBwMHBgYDBgUFAwUEBAMEAwMEAwMCAoQCiQGkAP8AAQD/gAGAAgIAgAq6ubi3tra1tbS0hbRBtbW2tre3uLm6u7y8vb6/wMHCw8XGx8jJysvLzM3P0NHS09TV1tfY2drb3N3e3+Dg4eLi4+Tk5eXm5+fo6Onp6uoF6uvr7OwD7O3tBe3u7u/vBO/v8PAE8PDx8YPxhfKG84v0AvX1PUA/PTw7OTg3NjQzMjEwLi0sKyopKCcmJCMiISAfHh0cGxsaGRgXFhUVFBMSEhEQDw8ODQ0MDAsKCgkJCAgFCAcHBgYDBgUFAwUEBAMEAwODA4UCiQGkAP8AAQD/gAGAAgIAgAq4t7a1tLSzs7KyhLJEs7O0tLW1tre4ubq7vL2+v8DBwsTFxsfIycrLzM3Oz9DS09TV1tfY2drb3N3e3+Dh4uLj5OTl5ubn5+jo6enq6uvr7OwF7O3t7u4D7u/vA+/w8ATw8PHxBPHx8vKE8oTzhvSM9QH2QkJBPz49Ozo5NzY1NDIxMC8uLCsqKSgnJiUkIiEgHx4dHBsbGhkYFxYVFBQTEhEREA8ODg0NDAsLCgoJCQgIBwcGBgMGBQUDBQQEAwQDA4MDhQKIAaUA/wABAP+AAYACAgCACba0tLOysbGwsIWwQbGxsrOztLW2t7i5uru8vr/AwcLExcbHycrLzM3Oz9DR0tTV1tfY2drb3N3e3+Dh4uPk5OXm5ufo6Onp6urr6+zsBezt7e7uA+7v7wPv8PAD8PHxBPHx8vIE8vLz84TzhfSG9Yz2QERDQUA/PTw7OTg3NTQzMjAvLi0sKikoJyYlJCMhIB8eHRwbGxoZGBcWFRQTExIREBAPDg0NDAwLCgoJCQgIBwcFBwYGBQUDBQQEBAQEAwMEAwMCAoMCiAGlAP8AAQD/gAGAAgIAgAmzsrGwsK+vrq6FrkWvsLCxsrO0tba3uLm6vL2+wMHCxMXGyMnKzM3Oz9DR0tPU1dfY2drb3N3e3+Dh4uPk5eXm5+jo6enq6uvr7Ozt7e7u7+8D7/DwA/Dx8QTx8fLyBPLy8/OD84X0hvWH9or3RUZFREJBPz48Ozo4NzY0MzIxLy4tLCspKCcmJSQjIiAfHh0cGxoZGBcXFhUUExIRERAPDg4NDAwLCwoKCQkICAcHBgYFBQMFBAQEBAQDAwQDAwICgwKIAaUA/wABAP+AAYACAgCACLGwr66trayshqxCra6ur7CxsrO1tre4uru9vr/BwsTFx8jJy8zNz9DR0tPV1tfY2drb3N3e3+Dh4uPk5ebn5+jp6erq6+zs7e3u7u/vBe/w8PHxA/Hy8gTy8vPzg/OF9Ib1iPaI94b4Q0lHRkRDQUA+PTw6OTg2NTQyMTAvLSwrKignJiUkIyIgHx4dHBsaGRgXFhUUFBMSERAQDw4NDQwLCwoKCQkICAcHBgYFBgUFBAQEBAQDAwQDAwICgwKIAaUA/wABAP+AAYACAgCACa+urKyrqqqpqYOpRqqqq6ytrq+wsbKztba4ubu8vr/BwsTFx8jKy83Oz9HS09XW19jZ2tvc3d7f4OHi4+Tl5ufo6Onq6uvs7O3t7u7v7/Dw8fED8fLyA/Lz8wTz8/T0BPT09fWF9Yb2ifeM+ENLSUhGRUNCQD8+PDs5ODc1NDMxMC8uLCsqKScmJSQjIiAfHh0cGxoZGBcWFRQTEhIREA8ODg0MDAsKCgkJCAgHBwYGAwYFBQMFBAQDBAMDBAMDAgKDAogBpQD/AAEA/4ABgAICAIAIrKuqqaiop6eEp0GoqKmqq6ytrq+xsrS1t7i6vL2/wcLExcfJyszNz9DS09TV19jZ2tvc3d7f4OHi4+Tl5ufo6Onq6+vs7e3u7u/w8AXw8fHy8gPy8/ME8/P09AP09fWD9YX2iveJ+In5Q01MSklHRkRDQUA+PTs6OTc2NDMyMC8uLSsqKScmJSQjISAfHh0cGxoZGBcWFRQTEhEQEA8ODQ0MCwsKCQkICAcHBgYDBgUFAwUEBAMEAwMEAwMCAoMCiAGlAP8AAQD/gAGAAgIAgAmqqKempqWlpKRJpKSlpaanqKmqq62usLGztLa4ubu9v8DCxMXHycrMzs/R0tTV1tjZ2tvc3d7f4OHi4+Tl5ufo6enq6+zs7e7u7+/w8PHx8vLz8wPz9PQE9PT19QT19fb2BPb29/eE9434i/mD+kFQTk1LSUhGRUNCQD89PDo5ODY1MzIxLy4tKyopJyYlJCIhIB8eHRsaGRgXFhUUExISERAPDg4NDAsLCgoJCQgHBwUHBgYFBQMFBAQDBAMDBAMDAgKDAogBpQD/AAEA/4ABgAICAIAHp6alpKOiogSioaKiRaKjpKWmp6iqq62usLKztbe5u72+wMLExsfJy8zO0NHT1NbX2drb3N7f4OHi4uPk5ebn6Onp6uvs7e3u7+/w8PHx8vLz8wPz9PQD9PX1A/X29oP2hPeI+JL5hvpGUlFPTUxKSUdFREJBPz48Ozk4NzU0MjEwLi0rKiknJiUjIiEgHh0cGxoZGBcWFRQTEhEQDw8ODQwMCwoKCQkICAcHBgYFBQMFBAQDBAMDBAMDAgKDAogBpQD/AAEA/4ABgAICAIAHpKOioaCfn4SfQ6ChoqOkpaaoqqutr7GztLa4ury+wMLExsfJy83P0NLT1dfY2dvc3d/g4eLj5OXl5ufo6erq6+zt7u7v7/Dx8fLy8/MF8/T09fUD9fb2BPb29/cE9/f4+IX4ivmQ+oP7RlVTUlBOTUtJSEZFQ0FAPj07Ojg3NjQzMTAuLSsqKScmJSMiIR8eHRwbGRgXFhUUExIRERAPDg0NDAsLCgkJCAgHBwYGBQUDBQQEAwQDAwQDAwICgwKHAaYA/wABAP+AAYACAgCAB6Kgn56dnJyDnEednZ6foKKjpaaoqqyusLK0tri6vL7AwsTGyMrLzc/R0tTW19na293e3+Hi4+Tl5ufo6Onq6+vs7e7u7/Dw8fHy8vPz9PT19QP19vYD9vf3BPf3+PiD+In5ivqP+0ZYVlRSUU9NTEpIR0VEQkA/PTw6OTc2NDMxMC4tKyooJyYkIyIgHx4cGxoZGBcWFRQTEhEQDw4NDQwLCwoJCQgIBwcGBgUFAwUEBAMEAwMEAwMCAoMChwGmAP8AAQD/gAGAAgIAgAefnZybmpmZg5lDmpucnZ6goaOlp6iqra+xs7W3ubu+wMLExsjKzM7P0dPV1tjZ29ze3+Dh4+Tl5ufo6err6+zs7e7u7/Dw8fHy8/P09AX09fX29gP29/cE9/f4+AT4+Pn5hfmK+pT7RlpZV1VTUVBOTEtJR0ZEQ0E/Pjw7OTg2NDMxMC4tKyooJyUkIiEgHh0cGxkYFxYVFBMSERAPDg4NDAwLCgoJCAgHBwYGBQUDBQQEAwQDAwQDAwICgwKHAaYA/wABAP+AAYACAgCAB5yamZiXlpZHlpaXl5iZmpyen6Gjpaepq66wsrS3ubu9wMLExsjKzM7Q0tPV19ja293e4OHi4+Xm5+jp6uvs7O3u7u/v8PDx8vLz8/T09fUF9fb29/cE9/f4+AT4+Pn5g/mI+o37jfxGXVtaWFZUUlFPTUtKSEZFQ0JAPj07OTg2NDMxMC4sKykoJiUjIiEfHh0bGhkYFxUUExIREBAPDg0MDAsKCgkICAcHBgYFBQMFBAQDBAMDBAMDAgKDAocBpgD/AAEA/4ABgAICAIAHmZeWlZSTk0iTk5SUlZeYmpudn6Gkpqiqra+ytLa5u73AwsTGyMrMztDS1NbX2dvc3t/g4uPk5ufo6err7Ozt7u/v8PDx8fLy8/P09PX19vYD9vf3A/f4+AP4+fmD+Yf6jfuR/ERgXlxaWVdVU1FQTkxKSUdFREJAPz07Ojg2NDMxLy4sKiknJiQjISAfHRwbGRgXFhUUExIREA8ODQ0MCwoKCQkIBwcGBgUGBQUEBAMEAwMEAwMCAgQCAgEBhgGmAP8AAQD/gAGAAgIAgAaWlJKRkJCDkD2RkpOUlpeZm56goqWnqayusbO2uLu9v8LExsjLzc/R0tTW2Nrb3d7g4eLk5ebn6Orr6+zt7u/v8PHx8vPzBfP09PX1BfX29vf3A/f4+AT4+Pn5BPn5+vqE+oj7kvyH/URjYV9dW1lYVlRSUE9NS0lIRkRCQT89Ozo4NjQyMS8tLCooJyUkIiEfHhwbGhkXFhUUExIREA8ODQ0MCwoKCQkIBwcGBgUGBQUEBAMEAwMEAwMCAgQCAgEBhgGmAP8AAQD/gAGAAgIAgAeTkY+OjYyMRIyNjo+QkpOVl5qcnqGjpqirrrCztri7vb/CxMbJy83P0dPV19ja3N3f4OLj5Obn6Onq6+zt7u/v8PHy8vPz9PT19fb2BPb29/cD9/j4A/j5+QT5+fr6g/qI+4z8kP1EZmRiYF5cWlhXVVNRT05MSkhGRUNBPz07OTg2NDIwLi0rKSgmJCMhIB4dHBoZGBcVFBMSERAPDg4NDAsLCgkJCAcHBgYFBgUFBAQDBAMDBAMDAgIEAgIBAYUBpwD/AAEA/4ABgAICAIAGj42MiomJRYmJiouMjY+Rk5WYmp2foqWoqq2ws7W4ur2/wsTHycvNz9HT1dfZ29ze4OHi5OXm5+nq6+zt7u/v8PHy8vP09PX19vb39wT39/j4g/iE+YT6h/uL/JT9RGpnZWNhX11bWVdWVFJQTkxKSUdFQ0E/PTs5NzUzMjAuLCopJyUkIiEfHhwbGRgXFhUUEhEQDw8ODQwLCwoJCQgIBwYGBQYFBQQEAwQDAwMDAgKDAocBpwD/AAEA/4ABgAICAIBKjIqIh4aFhYaGiImLjY+Rk5aZm56hpKeqrK+ytbi6vcDCxMfJy87Q0tTW2Nnb3d/g4uPk5ufo6err7O3u7/Dx8vLz9PT19fb29/cD9/j4A/j5+YT5hPqH+4n8l/0B/kRta2hmZGJgXlxaWFZVU1FPTUtJR0VDQT89Ozk3NTMxLy0rKSgmJCMhIB4dGxoZFxYVFBMSERAPDg0MCwsKCQkICAcGBgUGBQUEBAMEAwMDAwICgwKHAacA/wABAP+AAYACAgCABoiGhIOCgkOCgoOEhoiKjI+RlJeanaCjpqmsr7K1t7q9wMLFx8nMztDS1NbY2tzd3+Hi4+Xm5+nq6+zt7u/w8fHy8/P09fX29vf3Bff4+Pn5BPn5+vqE+of7h/yS/Yr+RHBua2lnZWNhX11bWVdVU1FPTUtJR0VDQT88Ojg2NDIwLiwqKSclIyIgHx0cGhkYFhUUExIREA8ODQwMCwoJCQgIBwYGBQYFBQQEAwQDAwMDAgKDAocBpwD/AAEA/4ABgAICAIAGhYOB//39RP3+gIGDhYiKjZCTlpmcn6KlqKuusbS3ur3AwsXHyszO0dPV19na3N7f4ePk5efo6err7O3u7/Dx8vLz9PT19vb39/j4A/j5+QP5+voD+vv7iPuH/JD9jv5EdHFv2dXQzMhiYF5cWlhWVFJQTktJR0VCQD48Ojc1MzEvLSspJyYkIiEfHhwbGRgXFRQTEhEQDw4NDAwLCgkJCAgHBgYFBgUFBAQDBAMDAwMCAoMChwGnAP8AAQCDgIV/+IACAgCAToH++vf29fb3+v2Ag4WIi46RlJebnqGkqKuusbS3ur3AwsXIyszP0dPV19nb3d7g4ePk5ufo6uvs7e7v8PHx8vP09PX19vb39/j4+fn6+gT6+vv7BPv7/PyJ/JD9kf5Gd+rl4NvX0s7KxmFfXVtZV1RSUE5LSUdEQkA9Ozk3NDIwLiwqKCYlIyEgHhwbGhgXFhQTEhEQDw4NDAwLCgkJCAgHBgYFBQMFBAQDBAMDAwMCAoMChgGoAP8AAQADgH9/h3/2gAICAIAG/Pby7+7uR+7w8/f7gIOGiYyPk5aanaCkp6uusbS3ur3Aw8XIys3P0dPW2Nnb3d/g4uTl5ujp6uvs7e7v8PHy8vP09fX29vf3+Pj5+fr6A/r7+4P7hfyU/ZT+Rvbx6+bi3dnU0MzIYmBeXFlXVVJQTUtIRkRBPzw6ODUzMS8tKyknJSMiIB4dGxoYFxYVExIREA8ODQwMCwoJCQgIBwYGBQUDBQQEAwQDAwMDAgIEAgIBAYUBqAD/AAEAi3/1gAICAIBK9O7q5+bm5+nt8fb7gISHio6RlZmcoKOnqq6xtLe6vcDDxcjLzc/S1NbY2tzd3+Hi5OXn6Onq7O3u7/Dw8fLz9PT19vb39/j4+fkD+fr6A/r7+wP7/PyD/In9g/6G/Zj+Rv348u3o49/b19PPymNhXlxZV1VST01KSEVDQD47OTc0MjAuLCooJiQiIB8dHBoZFxYVFBIREA8ODQwMCwoJCQgIBwYGBQUDBQQEAwQDAwMDAgIEAgIBAYUBqAD/AAEAjH/0gAICAIBJdubi397e4OLm6/D2/YKFiY2QlJibn6Omqq2xtLe6vcDDxsjLzdDS1NbY2tze4OHj5Obn6Orr7O3u7/Dx8vPz9PX29vf3+Pj5+QX5+vr7+wT7+/z8BPz8/f2F/aD+hf9Ggv/59O/q5uHd2dXRzGRhX1xaV1RST0xKR0RCPzw6ODUzMS4sKigmJCIhHx0cGhkXFhUUEhEQDw4NDQwLCgkJCAgHBgYFBQUFBAQDAwQDAwICBAICAQGFAagA/wABAAOAf3+Kf/OAAgIAgEhyb2zX1tbY2+Dl6/L5gIOHi4+Tl5ufoqaqrbG0t7q9wMPGycvO0NLV19nb3N7g4uPl5ujp6uvs7e/w8PHy8/T19fb39/j4+fkF+fr6+/sD+/z8BPz8/f2G/Zz+iv9GhoOA+/Xx7Ojk4NvX0mdkYV9cWVZUUU5LSEZDQD47OTY0MS8tKyknJSMhHx4cGxkYFhUUExEQDw4NDQwLCgoJCAgHBgYFBQUFBAQDAwQDAwICBAICAQGFAagA/wABAIOAin/zgAICAIBMbmpoZ83O0dXa3+bt9PyChoqOkpaanqKmqa2xtLe6vsDDxsnLztDT1dfZ293f4OLk5ebo6ers7e7v8PHy8/T09fb29/f4+Pn5+vr7+wP7/PyD/Ib9jf6L/wP+//+N/0aKhoOA/Pjz7+vn4t7Z1GdkYV9cWVZTUE1KR0RCPzw6NzQyMC0rKSclIyEgHhwbGRgWFRQTEhAPDg4NDAsKCgkICAcGBgUFBQUEBAMDBAMDAgIEAgIBAYUBqAD/AAEAhICKf/KAAgIAgEtqZmRiYsbJztPa4enx+YCFiY2RlpqeoqaprbG0t7u+wcTGyczO0dPV19nb3d/h4uTl5+jq6+zt7vDx8fLz9PX19vf3+Pj5+fr6+/sD+/z8g/yF/Yr+oP9GjoqHhIH/+vby7unk39pqZ2RhXltYVVJOS0lGQ0A9Ojg1MzAuLCooJSQiIB4dGxkYFxUUExIREA8ODQwLCgkJCAgHBgYFBQUFBAQDAwQDAwICBAICAQGEAakA/wABAIWAiX/ygAICAIBIZWJfXl5fYcfO1dzk7fb/g4iMkZWZnaGlqa2wtLe7vsHEx8nMztHT1dja3N3f4ePk5ufp6uvt7u/w8fLz8/T19vb3+Pj5+fr6A/r7+wP7/PwE/Pz9/YP9iv6h/0aSjoqIhYOB/fn18Ovm4NpqZ2NgXVpWU1BNSkdEQT47OTYzMS8sKigmJCIgHh0bGhgXFRQTEhEQDw4NDAsKCQkICAcGBgUFBQUEBAMDAwMCAoMChgGpAP8AAQCHgIh/8YACAgCASGFdW1paW11gZNDY4erz/IKHjJCUmZ2hpamtsLS3u77BxMfJzM/R09bY2tze4OHj5ebo6ers7e7v8PHy8/T09fb39/j4+fn6+gP6+/sD+/z8A/z9/YP9iP6k/0iWko6LiYaEgoD89/Ls5uBsaWZiX1xYVVJOS0hFQj88OTc0MS8tKigmJCIgHx0bGhgXFhQTEhEQDw4NDAsKCQkICAcGBgUFBAQDBAMDAwMCAoMChgGpAP8AAQCJgIZ/8YACAgCASl1ZVlVWV1pdYWXU3ebw+oGGi4+UmJ2hpamtsLS3u77BxMfKzM/R1NbY2tze4OLj5efo6evs7e7v8PHy8/T19fb39/j4+fn6+vv7A/v8/AT8/P39g/2G/qb/SJqVko+MioiGhIH++fLs5m9saGRhXVpWU09MSUZDQD06NzQyLy0rKSYkIiEfHRsaGBcWFBMSERAPDg0MCwoJCQgHBwYGBQUEBAMEAwMDAwICBAICAQGFAakA/wABAIqAhX/xgAICAIBHWFRSUVJUV1peY2ja5O74gYWKj5SYnKGlqa2wtLe7vsHEx8rMz9HU1tja3N7g4uTl5+jp6+zt7u/w8fLz9PX19vf3+Pj5+voD+vv7A/v8/AP8/f0E/f3+/oX+p/9InpmVkpCOjIqIhYL/+fLrcm5qZmNfW1hUUE1KRkNAPTo4NTIwLSspJyUjIR8dHBoYFxYUExIREA8ODQwLCgkJCAcHBgYFBQQEAwQDAwMDAgIEAgIBAYUBqQD/AAEAi4CEf/GAAgIAgEdUT01NTlBUWFxhZmvh6/aAhYqOk5icoKSprLC0t7u+wcTHys3P0tTW2dvd3uDi5OXn6Orr7O3v8PHy8vP09fb29/j4+fn6+gX6+/v8/AP8/f0E/f3+/oX+qP9Iop2ZlpSSkI6MiYaD//jwdHBsaGRgXVlVUk5KR0RBPjs4NTMwLispJyUjIR8dHBoYFxYUExIREA8ODQwLCgkJCAcHBgYFBQQEAwQDAwMDAgIEAgIBAYUBqQD/AAEAjICDf/GAAgIAgElPS0hISk1RVVpfZGpv6fT+hImOk5ecoKSorLC0t7u+wcTHys3P0tTW2dvd3+Hi5Obn6Orr7O3v8PHy8/P09fb29/j4+fn6+vv7A/v8/AP8/f0E/f3+/oX+o/+EgAH/SKahnZqYlpSSkI2JhoL99e1ybmpmYl5aVlJPS0hFQT47ODYzMC4sKSclIyEfHRwaGRcWFBMSERAPDg0MCwoJCQgHBwYGBQUEBAMEAwMDAwICBAICAQGFAakA/wABAI2Ag3/rgISBAYACAgCARkpGRERGSk5TWF1jaG5z8v2DiY2Sl5ugpKissLS3u77BxMfKzc/S1NfZ293f4eLk5ufp6uvs7u/w8fLz9PT19vf3+Pj5+voF+vv7/PwD/P39g/2H/p//iYBIqqSgnpyamJaTkI2JhYH68nRwa2djX1tXU1BMSEVCPzw5NjMxLiwpJyUjIR8dHBoZFxYUExIREA8ODQwLCgkJCAcHBgYFBQQEAwQDAwMDAgIEAgIBAYUBqQD/AAEAjoAEf3+AgOWAiYECAgCASEZBP0BDRktQVlxhZ21z8fyDiI2Sl5ugpKissLS3u77BxMfKzc/S1NfZ293f4eLk5ufp6uvt7u/w8fLz9PX19vf3+Pn5+vr7+wP7/PwD/P39g/2H/pz/jIBIrqikoqCfnZqXlJCMiIT/9XZxbWhkYFxYVFBNSUZCPzw5NjQxLiwqJyUjIR8dHBoZFxYUExIREA8ODQwLCgkJCAcHBgYFBQQEAwQDAwMDAgIEAgIBAYQBqgD/AAEAjoAEf3+AgOKAjIECAgCASEE8Ozw/RElOVFpgZmxyd/qCiI2SlpufpKissLS3u77BxMfKzdDS1NfZ293f4ePk5ufp6uvt7u/w8fLz9PX19vf4+Pn5+vr7+wP7/PwD/P39g/2G/pr/j4BIsquopqWjoZ6bl5OPioaB+XdzbmplYV1ZVVFNSkZDPzw5NzQxLywqJyUjIR8eHBoZFxYUExIREA8ODQwLCgkJCAcHBgYFBQQEAwQDAwMDAgIEAgIBAYQBqgD/AAEAj4ADf4CA34CPgQICAIBIPDc3ODxBR0xTWV9la3F3+YKHjJGWm5+kqKywtLe7vsHEx8rN0NLU19nb3d/h4+Tm5+nq7O3u7/Dx8vP09fb29/j4+fn6+vv7A/v8/AP8/f0E/f3+/oX+mf+QgEi2r6uqqailop+blpKNiIP8eXRva2ZiXllVUU5KRkNAPTo3NDEvLCooJSMhHx4cGhkXFhQTEhEQDw4NDAsKCQkIBwcGBgUFBAQDBAMDAwMCAgQCAgEBhAGqAP8AAQCPgAN/gIDegJCBAgIAgEg4MzI1OT9FS1FYXmRqcHb4gYeMkZabn6SorLC0t7u+wcTHys3Q0tTX2dvd3+Hj5ebo6ers7e7v8PHy8/T19vb3+Pj5+fr6+/sD+/z8A/z9/QT9/f7+hf6Z/5CASLqyr66urKqmop6ZlI+KhP96dXBsZ2NeWlZSTkpHQ0A9Ojc0MS8sKiglIyEfHhwaGRcWFBMSERAPDg0MCwoJCQgHBwYGBQUEBAMEAwMDAwICBAICAQGEAaoA/wABAI+AA3+AgN6AkIECAgCASDMuLjI3PUNJUFddZGpwdnyBh4yRlpqfo6issLO3u77BxMfKzdDS1dfZ293f4ePl5ujp6uzt7u/w8fLz9PX29vf4+Pn5+vr7+wP7/PwD/P39BP39/v6E/pn/kYBKvbazs7KxrqqmoZuWkYuGgHt2cWxoY19aVlJOS0dEQD06NzQxLywqKCYjISAeHBoZFxYUExIREA4ODQwLCgkJCAcHBgYFBQQEAwMEAwMCAgQCAgEBhAGqAP8AAQDvgJGBAgIAgEguKisvNDtBSE9WXGNpb3V7gYaMkZaan6OorLCzt7u+wcTHys3Q0tXX2dvd3+Hj5ebo6evs7e7v8PHy8/T19vb3+Pj5+fr6+/sD+/z8A/z9/QT9/f7+hP6Z/5GASsG5uLi3tbKtqKOdmJKNh4J8d3JtaGRfW1dTT0tHREA9Ojc0Mi8tKigmIyEgHhwaGRcWFBMSERAODQ0MCwoJCQgHBwYGBQUEBAMDBAMDAgIEAgIBAYQBqgD/AAEA74CRgQICAIBKKSUnLDI5QEdOVVxiaW91e4CGi5CVmp+jp6yws7e7vsHEx8rN0NLV19nb3d/h4+Xm6Onr7O3u7/Dx8vP09fb29/j4+fn6+vv7/PwE/Pz9/QT9/f7+hP6Z/5GAA8S9vUe9vLq1sKuln5mUjoiDfXhzbmlkX1tXU09LR0RBPTo3NDIvLSooJiQhIB4cGhkXFhQTEhEQDg0NDAsKCQkIBwcGBgUFBAQDAwQDAwICBAICAQGEAaoA/wABAO+AkYECAgCASiUhJCowOD9GTVRbYmhvdXqAhouQlZqfo6ersLO3u77BxMfKzdDS1dfZ293f4ePl5ujp6+zt7u/w8fLz9PX29vf4+Pn5+vr7+/z8A/z9/YP9hv6Z/5GASsfAwsLBvbmzraehm5WPiYN+eHNuaWRgW1dTT0tIREE+Ojc1Mi8tKigmJCEgHhwaGRcWFBMSEQ8ODQwMCwoJCQgHBwYGBQUEBAMDBAMDAgIEAgIBAYQBqgD/AAEA74CRgQICAIBKIB4hKC82PkVNVFthaG50eoCFi5CVmp+jp6yws7e7vsHEx8rN0NLV19nb3d/h4+Xm6Onr7O3u7/Hy8vP09fb29/j4+fn6+vv7/PwD/P39g/2G/pn/kYBKysTHyMXBu7WvqaKclpCKhH55c25pZWBcV1NPTEhEQT46NzUyLy0qKCYkISAeHBoZFxYUExIREA4NDQwLCgkJCAcHBgYFBQQEAwMDAwICgwKGAaoA/wABAO+AkYECAgCAShsaHyYuNT1FTFNaYWdudHqAhYuQlZqeo6err7O3u77BxMfKzdDS1dfZ293f4ePl5ujp6+zt7u/x8vLz9PX29vf4+Pn5+vr7+/z8A/z9/YP9hv6a/5CASs3Jzc3JxL63saqjnZeQioR/eXRvamVgXFhTT0xIREE+Ozc1Mi8tKigmJCEgHhwaGRcWFBMSERAODQ0MCwoJCQgHBwYGBQUEBAMDAwMCAoMChgGqAP8AAQDwgJCBAgIAgEoXFx0lLTQ8REtTWmFnbnR6gIWLkJWanqOnq6+zt7q+wcTHys3Q0tXX2dvd3+Hj5ebo6evs7e7w8fLz8/T19vf3+Pj5+fr6+/v8/AP8/f0E/f3+/oX+mv+QgErPz9PRzcbAubKrpJ6XkYuFf3p0b2plYFxYVFBMSERBPjs4NTIvLSooJiQiIB4cGhkXFhQTEhEQDg0MDAsKCQkIBwcGBgUFBAQDAwMDAgKDAoYBqgD/AAEA8ICQgQICAIBKExUcJCw0PENLUllgZ210ev+Fi5CVmp6jp6uvs7e6vsHEx8rN0NLV19nb3d/h4+Xm6Onr7O3u8PHy8/P09fb39/j4+fn6+vv7/PwD/P39BP39/v6F/pv/j4BK0dXY1c/JwrqzrKWemJGLhf96dG9qZWFcWFRQTEhEQT47ODUyLy0qKCYkIiAeHBoZFxYUExIRDw4NDAwLCgkICAcHBgYFBQQEAwMDAwICgwKGAaoA/wABAJCAA3+AgN6Aj4ECAgCASg8TGiMrMztDS1JZYGdtdHp/hYqQlZqeo6err7O3ur7BxMfKzdDS1dfZ293f4ePl5ujp6+zt7vDx8vPz9PX29/f4+Pn5+vr7+/z8A/z9/QT9/f7+hf6b/4+AStPb3djSysO7tKyln5iSi4WAenRvamVhXFhUUExIRUE+Ozg1Mi8tKigmJCIgHhwaGRcWFBMSEQ8ODQwMCwoJCAgHBwYGBQUEBAMDAwMCAoMChgGqAP8AAQDxgI+BAgIAgEoMERkiKjM7Q0pSWWBnbXN5f4WKkJWanqOnq6+zt7q+wcTHys3Q0tXX2dvd3+Hj5ebo6evs7e7w8fLz8/T19vf3+Pj5+fr6+/v8/AP8/f0E/f3+/oX+nP+OgErW4uHb08vDvLStpp+YkoyFgHp1b2plYVxYVFBMSEVBPjs4NTIvLSooJiQiIB4cGhkXFhQTEhEPDg0MDAsKCQgIBwcGBgUFBAQDAwMDAgKDAoYBqgD/AAEA8oCOgQICAIBKCRAZISoyO0NKUllgZ21zeX+FipCVmZ6jp6uvs7e6vsHEx8rN0NLV19nb3d/h4+Xm6Onr7O3u8PHy8/P09fb39/j4+fn6+vv7/PwD/P39BP39/v6F/p3/jYBK2+jk3NTMxLy1raafmJKMhoB6dW9qZmFcWFRQTEhFQT47ODUyLy0qKCYkIiAeHBoZFxYUExIRDw4NDAwLCgkICAcHBgYFBQQEAwMDAwICgwKGAaoA/wABAPOAjYECAgCASgcPGCEqMjpCSlJZYGZtc3l/hYqQlZmeo6err7O3ur7BxMfKzdDS1dfZ293f4ePl5ujp6+zt7vDx8vPz9PX29/f4+Pn5+vr7+/z8A/z9/QT9/f7+hf6e/4yASuLs5d3VzcS8ta2mn5mSjIaAenVvamZhXFhUUExIRUE+Ozg1Mi8tKigmJCIgHhwaGRcWFBMSEQ8ODQwMCwoJCAgHBwYGBQUEBAMDAwMCAgQCAgEBhQGqAP8AAQD0gIyBAgIAgEoGDxghKjI6QkpRWWBmbXN5f4WKkJWZnqOnq6+zt7q+wcTHys3Q0tXX2dvd3+Hj5ebo6evs7e7w8fLz8/T19vf3+Pj5+fr6+/v8/AP8/f0E/f3+/oX+nv+MgErs7+fe1c3FvbWupp+ZkoyGgHp1cGpmYVxYVFBMSEVBPjs4NTIvLSooJiQiIB4cGhkXFhQTEhEPDg0MDAsKCQgIBwcGBgUFBAQDAwMDAgIEAgIBAYUBqgD/AAEA9ICMgQICAIBKBQ4YISoyOkJKUVlgZm1zeX+Fio+VmZ6jp6uvs7e6vsHEx8rN0NLV19nb3d/h4+Xm6Onr7O3u8PHy8/P09fb39/j4+fn6+vv7/PwD/P39BP39/v6F/p7/jIBK9PDn3tXNxb21rqafmZKMhoB6dXBqZmFcWFRQTEhFQT47ODUyLy0qKCYkIiAeHBoZFxYUExIRDw4NDAwLCgkICAcHBgYFBQQEAwMDAwICBAICAQGFAaoA/wABAPSAjIECAgCASgUOGCEqMjpCSlFZYGZtc3l/hYqPlZmeo6err7O3ur7BxMfKzdDS1dfZ293f4ePl5ujp6+zt7vDx8vPz9PX29/f4+Pn5+vr7+/z8A/z9/QT9/f7+hf6d/42ASvrx6N7WzcW9ta6mn5mSjIaAenVwamZhXFhUUExIRUE+Ozg1Mi8tKigmJCIgHhwaGRcWFBMSEQ8ODQwMCwoJCAgHBwYGBQUEBAMDAwMCAgQCAgEBhQGqAP8AAQDzgI2BAgIAgEoFDhghKTI6QkpRWWBmbXN5f4WKj5WZnqOnq6+zt7q+wcTHys3Q0tXX2dvd3+Hj5ebo6evs7e7w8fLz8/T19vf3+Pj5+fr6+/v8/AP8/f0E/f3+/oX+ov8IgP+AgP+A//9K+vHn3tbNxb21rqafmZKMhoB6dXBqZmFcWFRQTEhFQT47ODUyLy0qKCYkIiAeHBoZFxYUExIRDw4NDAwLCgkICAcHBgYFBQQEAwMDAwICBAICAQGFAaoA/wABAPiACIGAgYGAgYCA";
    class PBRDefaultDFG {
        static get defaultDFG() {
            return PBRDefaultDFG._defaultDFG;
        }
        static set defaultDFG(value) {
            PBRDefaultDFG._defaultDFG = value;
        }
        static DefaultDfgTexture() {
            let hdrBuffer = Laya.Base64Tool.decode(defaultdfg);
            let hdrInfo = Laya.HDRTextureInfo.getHDRInfo(hdrBuffer);
            let tex = new Laya.Texture2D(hdrInfo.width, hdrInfo.height, hdrInfo.format, false, false, false);
            tex.setHDRData(hdrInfo);
            tex.lock = true;
            tex.wrapModeU = Laya.WrapMode.Clamp;
            tex.wrapModeV = Laya.WrapMode.Clamp;
            tex.anisoLevel = 1;
            this._defaultDFG = tex;
        }
    }

    class PBRShaderLib {
        static init() {
            Laya.Shader3D.addInclude("BRDF.glsl", BRDFGLSL);
            Laya.Shader3D.addInclude("PBRGI.glsl", PBRGIGLSL);
            Laya.Shader3D.addInclude("PBRCommon.glsl", PBRCommonGLSL);
            Laya.Shader3D.addInclude("PBRVertex.glsl", PBRVertexGLSL);
            Laya.Shader3D.addInclude("PBRFrag.glsl", PBRFragGLSL);
            Laya.Shader3D.addInclude("PBRMetallicFrag.glsl", PBRMetallicGLSL);
            PBRDefaultDFG.DefaultDfgTexture();
            Laya.SubShader.regIncludeBindUnifrom("PBRGI.glsl", { "u_IBLDGF": Laya.ShaderDataType.Texture2D }, { "u_IBLDGF": PBRDefaultDFG.defaultDFG });
        }
    }

    var PBRStandardVS = "#define SHADER_NAME PBRStandardVS\r\n\r\n#include \"Scene.glsl\";\r\n#include \"Camera.glsl\";\r\n#include \"Sprite3DVertex.glsl\";\r\n\r\n#include \"VertexCommon.glsl\";\r\n\r\n#include \"PBRVertex.glsl\";\r\n#include \"SceneFogInput.glsl\"\r\n\r\n#if defined(DETAILTEXTURE)||defined(DETAILNORMAL)\r\n    varying vec2 v_DetailUV;\r\n#endif\r\n\r\nvoid main()\r\n{\r\n    Vertex vertex;\r\n    getVertexParams(vertex);\r\n\r\n    PixelParams pixel;\r\n    initPixelParams(pixel, vertex);\r\n\r\n    #if defined(DETAILTEXTURE)||defined(DETAILNORMAL)\r\n        #ifdef UV\r\n            v_DetailUV = transformUV(vertex.texCoord0, u_DetailTillingOffset);\r\n        #else // UV\r\n            v_DetailUV = vec2(0.0);\r\n        #endif\r\n    #endif\r\n\r\n\r\n    gl_Position = getPositionCS(pixel.positionWS);\r\n\r\n    gl_Position = remapPositionZ(gl_Position);\r\n    \r\n    #ifdef FOG\r\n        FogHandle(gl_Position.z);\r\n    #endif\r\n}";

    var PBRStandardFS = "#define SHADER_NAME PBRStandardFS\r\n\r\n#include \"Color.glsl\";\r\n\r\n#include \"Scene.glsl\";\r\n#include \"Camera.glsl\";\r\n#include \"Sprite3DFrag.glsl\";\r\n#include \"SceneFog.glsl\";\r\n#include \"PBRMetallicFrag.glsl\"\r\n\r\n#if defined(DETAILTEXTURE)|| defined(DETAILNORMAL)\r\n    varying vec2 v_DetailUV;\r\n    #define ColorSpaceDouble vec3(4.59479380, 4.59479380, 4.59479380);\r\n    vec3 BlendNormals(vec3 n1, vec3 n2)\r\n    {\r\n        return normalize(vec3(n1.xy + n2.xy, n1.z*n2.z));\r\n    }\r\n    \r\n#endif\r\n\r\n#if defined(DETAILNORMAL)||defined(NORMALTEXTURE)\r\n    vec3 normalScale(vec3 normal,float scale){\r\n        normal.xy *= scale;    \r\n        normal.z = sqrt(1.0 - clamp(dot(normal.xy, normal.xy),0.0,1.0));\r\n        return normal;\r\n    }\r\n#endif\r\n\r\nvoid initSurfaceInputs(inout SurfaceInputs inputs,inout PixelParams pixel)\r\n{\r\n\r\n#ifdef UV\r\n    vec2 uv = pixel.uv0;\r\n#else // UV\r\n    vec2 uv = vec2(0.0);\r\n#endif // UV\r\n    inputs.diffuseColor = u_AlbedoColor.rgb;\r\n    inputs.alpha = u_AlbedoColor.a;\r\n\r\n#ifdef COLOR\r\n    #ifdef ENABLEVERTEXCOLOR\r\n    inputs.diffuseColor *= pixel.vertexColor.xyz;\r\n    inputs.alpha *= pixel.vertexColor.a;\r\n    #endif // ENABLEVERTEXCOLOR\r\n#endif // COLOR\r\n\r\n    inputs.alphaTest = u_AlphaTestValue;\r\n\r\n#ifdef ALBEDOTEXTURE\r\n    vec4 albedoSampler = texture2D(u_AlbedoTexture, uv);\r\n    #ifdef Gamma_u_AlbedoTexture\r\n    albedoSampler = gammaToLinear(albedoSampler);\r\n    #endif // Gamma_u_AlbedoTexture\r\n    inputs.diffuseColor *= albedoSampler.rgb;\r\n    inputs.alpha *= albedoSampler.a;\r\n#endif // ALBEDOTEXTURE\r\n\r\n//Detail Albedo\r\n#ifdef DETAILTEXTURE\r\n    vec3 detailSampler = texture2D(u_DetailAlbedoTexture,v_DetailUV).rgb;\r\n    #ifdef Gamma_u_DetailAlbedoTexture\r\n        detailSampler = gammaToLinear(detailSampler);\r\n    #endif // Gamma_u_DetailAlbedoTexture\r\n        detailSampler *= ColorSpaceDouble;\r\n        inputs.diffuseColor *=detailSampler;\r\n#endif\r\n\r\n#ifdef NORMALTEXTURE\r\n    vec3 normalTS = pixel.normalTS;\r\n    pixel.normalTS =normalScale(normalTS,u_NormalScale) ;\r\n    pixel.normalWS = normalize(pixel.TBN * pixel.normalTS);\r\n#endif\r\n\r\n#ifdef DETAILNORMAL\r\n    vec3 detailnormalSampler = texture2D(u_DetailNormalTexture, v_DetailUV).rgb;\r\n    detailnormalSampler = normalize(detailnormalSampler * 2.0 - 1.0);\r\n    detailnormalSampler.y *= -1.0;\r\n    detailnormalSampler = normalScale(detailnormalSampler,u_DetailNormalScale);\r\n    pixel.normalTS = BlendNormals(pixel.normalTS,detailnormalSampler);\r\n    pixel.normalWS = normalize(pixel.TBN * pixel.normalTS);\r\n#endif\r\n\r\n    inputs.metallic = u_Metallic;\r\n    inputs.smoothness = u_Smoothness;\r\n\r\n#ifdef SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA\r\n    inputs.smoothness = u_SmoothnessScale;\r\n    #ifdef ALBEDOTEXTURE\r\n    inputs.smoothness *= albedoSampler.a;\r\n    #endif // ALBEDOTEXTURE\r\n#endif // SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA\r\n\r\n#ifdef METALLICGLOSSTEXTURE\r\n\r\n    vec4 metallicSampler = texture2D(u_MetallicGlossTexture, uv);\r\n    #ifdef Gamma_u_MetallicGlossTexture\r\n    metallicSampler = gammaToLinear(metallicSampler);\r\n    #endif // Gamma_u_MetallicGlossTexture\r\n\r\n    inputs.metallic = metallicSampler.x;\r\n    inputs.smoothness = metallicSampler.w * u_SmoothnessScale;\r\n\r\n    #ifdef SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA\r\n    inputs.smoothness = u_SmoothnessScale;\r\n\t#ifdef ALBEDOTEXTURE\r\n    inputs.smoothness *= albedoSampler.a;\r\n\t#endif // ALBEDOTEXTURE\r\n    #endif // SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA\r\n\r\n#endif // METALLICGLOSSTEXTURE\r\n\r\n    inputs.occlusion = 1.0;\r\n#ifdef OCCLUSIONTEXTURE\r\n    vec4 occlusionSampler = texture2D(u_OcclusionTexture, uv);\r\n    #ifdef Gamma_u_OcclusionTexture\r\n    occlusionSampler = gammaToLinear(occlusionSampler);\r\n    #endif // Gamma_u_OcclusionTexture\r\n\r\n    float occlusion = occlusionSampler.g;\r\n    inputs.occlusion = (1.0 - u_OcclusionStrength) + occlusion * u_OcclusionStrength;\r\n#endif // OCCLUSIONTEXTURE\r\n\r\n#ifdef EMISSION\r\n    inputs.emissionColor = u_EmissionColor.rgb * u_EmissionIntensity;\r\n    #ifdef EMISSIONTEXTURE\r\n    vec4 emissionSampler = texture2D(u_EmissionTexture, uv);\r\n\t#ifdef Gamma_u_EmissionTexture\r\n    emissionSampler = gammaToLinear(emissionSampler);\r\n\t#endif // Gamma_u_EmissionTexture\r\n    inputs.emissionColor *= emissionSampler.rgb;\r\n    #endif // EMISSIONTEXTURE\r\n#endif // EMISSION\r\n\r\n#ifdef ANISOTROPIC\r\n    inputs.anisotropy = u_Anisotropy;\r\n#endif // ANISOTROPIC\r\n}\r\n\r\nvoid main()\r\n{\r\n    PixelParams pixel;\r\n    getPixelParams(pixel);\r\n\r\n    SurfaceInputs inputs;\r\n    initSurfaceInputs(inputs, pixel);\r\n\r\n    vec4 surfaceColor = PBR_Metallic_Flow(inputs, pixel);\r\n    \r\n    #ifdef FOG\r\n        surfaceColor.rgb = sceneLitFog(surfaceColor.rgb);\r\n    #endif // FOG\r\n    gl_FragColor = surfaceColor;\r\n\r\n}";

    class PBRStandardShaderInit {
        static init() {
            let uniformMap = {
                "u_AlbedoColor": Laya.ShaderDataType.Color,
                "u_TilingOffset": Laya.ShaderDataType.Vector4,
                "u_NormalScale": Laya.ShaderDataType.Float,
                "u_Metallic": Laya.ShaderDataType.Float,
                "u_Smoothness": Laya.ShaderDataType.Float,
                "u_SmoothnessScale": Laya.ShaderDataType.Float,
                "u_OcclusionStrength": Laya.ShaderDataType.Float,
                "u_AlphaTestValue": Laya.ShaderDataType.Float,
                "u_EmissionColor": Laya.ShaderDataType.Color,
                "u_EmissionIntensity": Laya.ShaderDataType.Float,
                "u_AlbedoTexture": Laya.ShaderDataType.Texture2D,
                "u_NormalTexture": Laya.ShaderDataType.Texture2D,
                "u_OcclusionTexture": Laya.ShaderDataType.Texture2D,
                "u_EmissionTexture": Laya.ShaderDataType.Texture2D,
                "u_MetallicGlossTexture": Laya.ShaderDataType.Texture2D,
                "u_Anisotropy": Laya.ShaderDataType.Float,
                "u_TangentTexture": Laya.ShaderDataType.Texture2D,
                "u_DetailAlbedoTexture": Laya.ShaderDataType.Texture2D,
                "u_DetailNormalTexture": Laya.ShaderDataType.Texture2D,
                "u_DetailNormalScale": Laya.ShaderDataType.Float,
                "u_DetailTillingOffset": Laya.ShaderDataType.Vector4
            };
            let defaultValue = {
                "u_AlbedoColor": Laya.Color.WHITE,
                "u_TilingOffset": new Laya.Vector4(1, 1, 0, 0),
                "u_DetailTillingOffset": new Laya.Vector4(1, 1, 0, 0),
                "u_NormalScale": 1,
                "u_DetailNormalScale": 1,
                "u_Metallic": 0,
                "u_Smoothness": 0.5,
                "u_SmoothnessScale": 1,
                "u_OcclusionStrength": 1,
                "u_EmissionColor": Laya.Color.WHITE,
                "u_EmissionIntensity": 1,
                "u_Anisotropy": 0
            };
            let shader = Laya.Shader3D.add("PBR", true, true);
            let subShader = new Laya.SubShader(Laya.SubShader.DefaultAttributeMap, uniformMap, defaultValue);
            shader.addSubShader(subShader);
            subShader.addShaderPass(PBRStandardVS, PBRStandardFS);
            subShader.addShaderPass(DepthVS, DepthFS, "ShadowCaster");
            subShader.addShaderPass(DepthNormalVS, DepthNormalFS, "DepthNormal");
        }
    }

    var SkyboxVS = "#define SHADER_NAME SkyBoxVS\r\n\r\n#include \"Camera.glsl\";\r\n\r\nconst float c_deg2ang = 3.141593 / 180.0;\r\n\r\nvec4 rotateAroundYInDegrees(vec4 vertex, float deg)\r\n{\r\n    float angle = deg * c_deg2ang;\r\n    float sina = sin(angle);\r\n    float cosa = cos(angle);\r\n    mat2 m = mat2(cosa, -sina, sina, cosa);\r\n    return vec4(m * vertex.xz, vertex.yw).xzyw;\r\n}\r\n\r\nvec4 remapSkyPositionZ(in vec4 position)\r\n{\r\n    position.z = position.w;\r\n    return position;\r\n}\r\n\r\nvarying vec3 v_Texcoord;\r\n\r\nvoid main()\r\n{\r\n    // todo 这个转换 ？\r\n    v_Texcoord = vec3(-a_Position.x, a_Position.yz); //转换坐标系\r\n\r\n    vec4 position = rotateAroundYInDegrees(a_Position, u_Rotation);\r\n    // gl_Position = getPositionCS(position.xyz);\r\n\r\n    gl_Position = u_ViewProjection * position;\r\n\r\n    gl_Position = remapSkyPositionZ(gl_Position);\r\n}";

    var SkyboxFS = "#define SHADER_NAME SkyBoxFS\r\n\r\n#include \"Color.glsl\";\r\n\r\nvarying vec3 v_Texcoord;\r\n\r\nconst vec4 c_ColorSpace = vec4(4.59479380, 4.59479380, 4.59479380, 2.0);\r\n\r\nvoid main()\r\n{\r\n    vec3 uv = v_Texcoord;\r\n    vec4 cubeSampler = textureCube(u_CubeTexture, uv);\r\n#ifdef Gamma_u_CubeTexture\r\n    cubeSampler = gammaToLinear(cubeSampler);\r\n#endif // Gamma_u_CubeTexture\r\n\r\n    vec3 color = cubeSampler.rgb * u_TintColor.rgb * u_Exposure * c_ColorSpace.rgb;\r\n\r\n    gl_FragColor = vec4(color, 1.0);\r\n}";

    class SkyBoxShaderInit {
        static init() {
            let attributeMap = {
                "a_Position": [Laya.VertexMesh.MESH_POSITION0, Laya.ShaderDataType.Vector4]
            };
            let uniformMap = {
                "u_TintColor": Laya.ShaderDataType.Color,
                "u_Exposure": Laya.ShaderDataType.Float,
                "u_Rotation": Laya.ShaderDataType.Float,
                "u_CubeTexture": Laya.ShaderDataType.TextureCube
            };
            let defaultValue = {
                "u_TintColor": new Laya.Color(0.5, 0.5, 0.5, 0.5),
                "u_Exposure": 1,
                "u_Rotation": 0
            };
            let shader = Laya.Shader3D.add("SkyBox");
            let subShader = new Laya.SubShader(attributeMap, uniformMap, defaultValue);
            shader.addSubShader(subShader);
            let pass = subShader.addShaderPass(SkyboxVS, SkyboxFS);
            pass.renderState.depthTest = Laya.RenderState.DEPTHTEST_LEQUAL;
            pass.statefirst = true;
        }
    }

    var ShurikenVS = "#define SHADER_NAME ParticleVS\r\n\r\n#include \"Camera.glsl\";\r\n#include \"particleShuriKenSpriteVS.glsl\";\r\n#include \"Math.glsl\";\r\n#include \"MathGradient.glsl\";\r\n#include \"Color.glsl\";\r\n#include \"Scene.glsl\"\r\n#include \"SceneFogInput.glsl\"\r\n\r\n\r\n#ifdef RENDERMODE_MESH\r\nvarying vec4 v_MeshColor;\r\n#endif\r\n\r\nvarying vec4 v_Color;\r\nvarying vec2 v_TextureCoordinate;\r\n\r\n//修改这里剔除没有用到的光照函数，增加粒子的编译速度\r\nvec2 TransformUV(vec2 texcoord, vec4 tilingOffset)\r\n{\r\n    vec2 transTexcoord = vec2(texcoord.x, texcoord.y - 1.0) * tilingOffset.xy + vec2(tilingOffset.z, -tilingOffset.w);\r\n    transTexcoord.y += 1.0;\r\n    return transTexcoord;\r\n}\r\n\r\n#if defined(VELOCITYOVERLIFETIMECONSTANT) || defined(VELOCITYOVERLIFETIMECURVE) || defined(VELOCITYOVERLIFETIMERANDOMCONSTANT) || defined(VELOCITYOVERLIFETIMERANDOMCURVE)\r\nvec3 computeParticleLifeVelocity(in float normalizedAge)\r\n{\r\n    vec3 outLifeVelocity;\r\n    #ifdef VELOCITYOVERLIFETIMECONSTANT\r\n    outLifeVelocity = u_VOLVelocityConst;\r\n    #endif\r\n    #ifdef VELOCITYOVERLIFETIMECURVE\r\n    outLifeVelocity = vec3(getCurValueFromGradientFloat(u_VOLVelocityGradientX, normalizedAge),\r\n\tgetCurValueFromGradientFloat(u_VOLVelocityGradientY, normalizedAge),\r\n\tgetCurValueFromGradientFloat(u_VOLVelocityGradientZ, normalizedAge));\r\n    #endif\r\n    #ifdef VELOCITYOVERLIFETIMERANDOMCONSTANT\r\n    outLifeVelocity = mix(u_VOLVelocityConst,\r\n\tu_VOLVelocityConstMax,\r\n\tvec3(a_Random1.y, a_Random1.z, a_Random1.w));\r\n    #endif\r\n    #ifdef VELOCITYOVERLIFETIMERANDOMCURVE\r\n    outLifeVelocity = vec3(\r\n\tmix(getCurValueFromGradientFloat(u_VOLVelocityGradientX, normalizedAge),\r\n\t    getCurValueFromGradientFloat(u_VOLVelocityGradientMaxX, normalizedAge),\r\n\t    a_Random1.y),\r\n\tmix(getCurValueFromGradientFloat(u_VOLVelocityGradientY, normalizedAge),\r\n\t    getCurValueFromGradientFloat(u_VOLVelocityGradientMaxY, normalizedAge),\r\n\t    a_Random1.z),\r\n\tmix(getCurValueFromGradientFloat(u_VOLVelocityGradientZ, normalizedAge),\r\n\t    getCurValueFromGradientFloat(u_VOLVelocityGradientMaxZ, normalizedAge),\r\n\t    a_Random1.w));\r\n    #endif\r\n\r\n    return outLifeVelocity;\r\n}\r\n#endif\r\n\r\n// drag\r\nvec3 getStartPosition(vec3 startVelocity, float age, vec3 dragData)\r\n{\r\n    vec3 startPosition;\r\n    float lasttime = min(startVelocity.x / dragData.x, age);\r\n    startPosition = lasttime * (startVelocity - 0.5 * dragData * lasttime);\r\n    return startPosition;\r\n}\r\n\r\nvec3 computeParticlePosition(in vec3 startVelocity, in vec3 lifeVelocity, in float age, in float normalizedAge, vec3 gravityVelocity, vec4 worldRotation, vec3 dragData)\r\n{\r\n    vec3 startPosition = getStartPosition(startVelocity, age, dragData);\r\n    vec3 lifePosition;\r\n#if defined(VELOCITYOVERLIFETIMECONSTANT) || defined(VELOCITYOVERLIFETIMECURVE) || defined(VELOCITYOVERLIFETIMERANDOMCONSTANT) || defined(VELOCITYOVERLIFETIMERANDOMCURVE)\r\n    #ifdef VELOCITYOVERLIFETIMECONSTANT\r\n    // startPosition = startVelocity * age;\r\n    lifePosition = lifeVelocity * age;\r\n    #endif\r\n    #ifdef VELOCITYOVERLIFETIMECURVE\r\n    // startPosition = startVelocity * age;\r\n    lifePosition = vec3(getTotalValueFromGradientFloat(u_VOLVelocityGradientX, normalizedAge),\r\n\tgetTotalValueFromGradientFloat(u_VOLVelocityGradientY, normalizedAge),\r\n\tgetTotalValueFromGradientFloat(u_VOLVelocityGradientZ, normalizedAge));\r\n    #endif\r\n    #ifdef VELOCITYOVERLIFETIMERANDOMCONSTANT\r\n    // startPosition = startVelocity * age;\r\n    lifePosition = lifeVelocity * age;\r\n    #endif\r\n    #ifdef VELOCITYOVERLIFETIMERANDOMCURVE\r\n    // startPosition = startVelocity * age;\r\n    lifePosition = vec3(\r\n\tmix(\r\n\t    getTotalValueFromGradientFloat(u_VOLVelocityGradientX, normalizedAge),\r\n\t    getTotalValueFromGradientFloat(u_VOLVelocityGradientMaxX, normalizedAge),\r\n\t    a_Random1.y),\r\n\tmix(\r\n\t    getTotalValueFromGradientFloat(u_VOLVelocityGradientY, normalizedAge),\r\n\t    getTotalValueFromGradientFloat(u_VOLVelocityGradientMaxY, normalizedAge),\r\n\t    a_Random1.z),\r\n\tmix(\r\n\t    getTotalValueFromGradientFloat(u_VOLVelocityGradientZ, normalizedAge),\r\n\t    getTotalValueFromGradientFloat(u_VOLVelocityGradientMaxZ, normalizedAge),\r\n\t    a_Random1.w));\r\n    #endif\r\n\r\n    vec3 finalPosition;\r\n    if (u_VOLSpaceType == 0)\r\n\t{\r\n\t    if (u_ScalingMode != 2)\r\n\t\tfinalPosition = rotationByQuaternions(\r\n\t\t    u_PositionScale * (a_ShapePositionStartLifeTime.xyz + startPosition + lifePosition),\r\n\t\t    worldRotation);\r\n\t    else\r\n\t\tfinalPosition = rotationByQuaternions(\r\n\t\t    u_PositionScale * a_ShapePositionStartLifeTime.xyz + startPosition + lifePosition,\r\n\t\t    worldRotation);\r\n\t}\r\n    else\r\n\t{\r\n\t    if (u_ScalingMode != 2)\r\n\t\tfinalPosition = rotationByQuaternions(\r\n\t\t\t\t    u_PositionScale * (a_ShapePositionStartLifeTime.xyz + startPosition),\r\n\t\t\t\t    worldRotation)\r\n\t\t    + lifePosition;\r\n\t    else\r\n\t\tfinalPosition = rotationByQuaternions(\r\n\t\t\t\t    u_PositionScale * a_ShapePositionStartLifeTime.xyz + startPosition,\r\n\t\t\t\t    worldRotation)\r\n\t\t    + lifePosition;\r\n\t}\r\n#else\r\n    // startPosition = startVelocity * age;\r\n    vec3 finalPosition;\r\n    if (u_ScalingMode != 2)\r\n\tfinalPosition = rotationByQuaternions(\r\n\t    u_PositionScale * (a_ShapePositionStartLifeTime.xyz + startPosition),\r\n\t    worldRotation);\r\n    else\r\n\tfinalPosition = rotationByQuaternions(\r\n\t    u_PositionScale * a_ShapePositionStartLifeTime.xyz + startPosition,\r\n\t    worldRotation);\r\n#endif\r\n\r\n    if (u_SimulationSpace == 0)\r\n\tfinalPosition = finalPosition + a_SimulationWorldPostion;\r\n    else if (u_SimulationSpace == 1)\r\n\tfinalPosition = finalPosition + u_WorldPosition;\r\n\r\n    finalPosition += 0.5 * gravityVelocity * age;\r\n\r\n    return finalPosition;\r\n}\r\n\r\nvec4 computeParticleColor(in vec4 color, in float normalizedAge)\r\n{\r\n#ifdef COLOROVERLIFETIME\r\n    color *= getColorFromGradient(u_ColorOverLifeGradientAlphas,\r\n\tu_ColorOverLifeGradientColors,\r\n\tnormalizedAge, u_ColorOverLifeGradientRanges);\r\n#endif\r\n\r\n#ifdef RANDOMCOLOROVERLIFETIME\r\n    color *= mix(getColorFromGradient(u_ColorOverLifeGradientAlphas,\r\n\t\t     u_ColorOverLifeGradientColors,\r\n\t\t     normalizedAge, u_ColorOverLifeGradientRanges),\r\n\tgetColorFromGradient(u_MaxColorOverLifeGradientAlphas,\r\n\t    u_MaxColorOverLifeGradientColors,\r\n\t    normalizedAge, u_MaxColorOverLifeGradientRanges),\r\n\ta_Random0.y);\r\n#endif\r\n\r\n    return color;\r\n}\r\n\r\nvec2 computeParticleSizeBillbard(in vec2 size, in float normalizedAge)\r\n{\r\n#ifdef SIZEOVERLIFETIMECURVE\r\n    size *= getCurValueFromGradientFloat(u_SOLSizeGradient, normalizedAge);\r\n#endif\r\n#ifdef SIZEOVERLIFETIMERANDOMCURVES\r\n    size *= mix(getCurValueFromGradientFloat(u_SOLSizeGradient, normalizedAge),\r\n\tgetCurValueFromGradientFloat(u_SOLSizeGradientMax, normalizedAge),\r\n\ta_Random0.z);\r\n#endif\r\n#ifdef SIZEOVERLIFETIMECURVESEPERATE\r\n    size *= vec2(getCurValueFromGradientFloat(u_SOLSizeGradientX, normalizedAge),\r\n\tgetCurValueFromGradientFloat(u_SOLSizeGradientY, normalizedAge));\r\n#endif\r\n#ifdef SIZEOVERLIFETIMERANDOMCURVESSEPERATE\r\n    size *= vec2(mix(getCurValueFromGradientFloat(u_SOLSizeGradientX, normalizedAge),\r\n\t\t     getCurValueFromGradientFloat(u_SOLSizeGradientMaxX, normalizedAge),\r\n\t\t     a_Random0.z),\r\n\tmix(getCurValueFromGradientFloat(u_SOLSizeGradientY, normalizedAge),\r\n\t    getCurValueFromGradientFloat(u_SOLSizeGradientMaxY, normalizedAge),\r\n\t    a_Random0.z));\r\n#endif\r\n    return size;\r\n}\r\n\r\n#ifdef RENDERMODE_MESH\r\nvec3 computeParticleSizeMesh(in vec3 size, in float normalizedAge)\r\n{\r\n    #ifdef SIZEOVERLIFETIMECURVE\r\n    size *= getCurValueFromGradientFloat(u_SOLSizeGradient, normalizedAge);\r\n    #endif\r\n    #ifdef SIZEOVERLIFETIMERANDOMCURVES\r\n    size *= mix(getCurValueFromGradientFloat(u_SOLSizeGradient, normalizedAge),\r\n\tgetCurValueFromGradientFloat(u_SOLSizeGradientMax, normalizedAge),\r\n\ta_Random0.z);\r\n    #endif\r\n    #ifdef SIZEOVERLIFETIMECURVESEPERATE\r\n    size *= vec3(getCurValueFromGradientFloat(u_SOLSizeGradientX, normalizedAge),\r\n\tgetCurValueFromGradientFloat(u_SOLSizeGradientY, normalizedAge),\r\n\tgetCurValueFromGradientFloat(u_SOLSizeGradientZ, normalizedAge));\r\n    #endif\r\n    #ifdef SIZEOVERLIFETIMERANDOMCURVESSEPERATE\r\n    size *= vec3(mix(getCurValueFromGradientFloat(u_SOLSizeGradientX, normalizedAge),\r\n\t\t     getCurValueFromGradientFloat(u_SOLSizeGradientMaxX, normalizedAge),\r\n\t\t     a_Random0.z),\r\n\tmix(getCurValueFromGradientFloat(u_SOLSizeGradientY, normalizedAge),\r\n\t    getCurValueFromGradientFloat(u_SOLSizeGradientMaxY, normalizedAge),\r\n\t    a_Random0.z),\r\n\tmix(getCurValueFromGradientFloat(u_SOLSizeGradientZ, normalizedAge),\r\n\t    getCurValueFromGradientFloat(u_SOLSizeGradientMaxZ, normalizedAge),\r\n\t    a_Random0.z));\r\n    #endif\r\n    return size;\r\n}\r\n#endif\r\n\r\nfloat computeParticleRotationFloat(in float rotation,\r\n    in float age,\r\n    in float normalizedAge)\r\n{\r\n#ifdef ROTATIONOVERLIFETIME\r\n    #ifdef ROTATIONOVERLIFETIMECONSTANT\r\n    float ageRot = u_ROLAngularVelocityConst * age;\r\n    rotation += ageRot;\r\n    #endif\r\n    #ifdef ROTATIONOVERLIFETIMECURVE\r\n    rotation += getTotalValueFromGradientFloat(u_ROLAngularVelocityGradient, normalizedAge);\r\n    #endif\r\n    #ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\r\n    float ageRot = mix(u_ROLAngularVelocityConst, u_ROLAngularVelocityConstMax, a_Random0.w) * age;\r\n    rotation += ageRot;\r\n    #endif\r\n    #ifdef ROTATIONOVERLIFETIMERANDOMCURVES\r\n    rotation += mix(\r\n\tgetTotalValueFromGradientFloat(u_ROLAngularVelocityGradient, normalizedAge),\r\n\tgetTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMax,\r\n\t    normalizedAge),\r\n\ta_Random0.w);\r\n    #endif\r\n#endif\r\n#ifdef ROTATIONOVERLIFETIMESEPERATE\r\n    #ifdef ROTATIONOVERLIFETIMECONSTANT\r\n    float ageRot = u_ROLAngularVelocityConstSeprarate.z * age;\r\n    rotation += ageRot;\r\n    #endif\r\n    #ifdef ROTATIONOVERLIFETIMECURVE\r\n    rotation += getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientZ,\r\n\tnormalizedAge);\r\n    #endif\r\n    #ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\r\n    float ageRot = mix(u_ROLAngularVelocityConstSeprarate.z,\r\n\t\t       u_ROLAngularVelocityConstMaxSeprarate.z,\r\n\t\t       a_Random0.w)\r\n\t* age;\r\n    rotation += ageRot;\r\n    #endif\r\n    #ifdef ROTATIONOVERLIFETIMERANDOMCURVES\r\n    rotation += mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientZ,\r\n\t\t\tnormalizedAge),\r\n\tgetTotalValueFromGradientFloat(\r\n\t    u_ROLAngularVelocityGradientMaxZ, normalizedAge),\r\n\ta_Random0.w);\r\n    #endif\r\n#endif\r\n    return rotation;\r\n}\r\n\r\n#if defined(RENDERMODE_MESH) && (defined(ROTATIONOVERLIFETIME) || defined(ROTATIONOVERLIFETIMESEPERATE))\r\nvec3 computeParticleRotationVec3(in vec3 rotation,\r\n    in float age,\r\n    in float normalizedAge)\r\n{\r\n    #ifdef ROTATIONOVERLIFETIME\r\n\t#ifdef ROTATIONOVERLIFETIMECONSTANT\r\n    float ageRot = u_ROLAngularVelocityConst * age;\r\n    rotation += ageRot;\r\n\t#endif\r\n\t#ifdef ROTATIONOVERLIFETIMECURVE\r\n    rotation += getTotalValueFromGradientFloat(u_ROLAngularVelocityGradient, normalizedAge);\r\n\t#endif\r\n\t#ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\r\n    float ageRot = mix(u_ROLAngularVelocityConst, u_ROLAngularVelocityConstMax, a_Random0.w) * age;\r\n    rotation += ageRot;\r\n\t#endif\r\n\t#ifdef ROTATIONOVERLIFETIMERANDOMCURVES\r\n    rotation += mix(\r\n\tgetTotalValueFromGradientFloat(u_ROLAngularVelocityGradient, normalizedAge),\r\n\tgetTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMax,\r\n\t    normalizedAge),\r\n\ta_Random0.w);\r\n\t#endif\r\n    #endif\r\n    #ifdef ROTATIONOVERLIFETIMESEPERATE\r\n\t#ifdef ROTATIONOVERLIFETIMECONSTANT\r\n    vec3 ageRot = u_ROLAngularVelocityConstSeprarate * age;\r\n    rotation += ageRot;\r\n\t#endif\r\n\t#ifdef ROTATIONOVERLIFETIMECURVE\r\n    rotation += vec3(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientX,\r\n\t\t\t normalizedAge),\r\n\tgetTotalValueFromGradientFloat(u_ROLAngularVelocityGradientY,\r\n\t    normalizedAge),\r\n\tgetTotalValueFromGradientFloat(u_ROLAngularVelocityGradientZ,\r\n\t    normalizedAge));\r\n\t#endif\r\n\t#ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\r\n    vec3 ageRot = mix(u_ROLAngularVelocityConstSeprarate,\r\n\t\t      u_ROLAngularVelocityConstMaxSeprarate,\r\n\t\t      a_Random0.w)\r\n\t* age;\r\n    rotation += ageRot;\r\n\t#endif\r\n\t#ifdef ROTATIONOVERLIFETIMERANDOMCURVES\r\n    rotation += vec3(mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientX,\r\n\t\t\t     normalizedAge),\r\n\t\t\t getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMaxX,\r\n\t\t\t     normalizedAge),\r\n\t\t\t a_Random0.w),\r\n\tmix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientY,\r\n\t\tnormalizedAge),\r\n\t    getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMaxY,\r\n\t\tnormalizedAge),\r\n\t    a_Random0.w),\r\n\tmix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientZ,\r\n\t\tnormalizedAge),\r\n\t    getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMaxZ,\r\n\t\tnormalizedAge),\r\n\t    a_Random0.w));\r\n\t#endif\r\n    #endif\r\n    return rotation;\r\n}\r\n#endif\r\n\r\nvec2 computeParticleUV(in vec2 uv, in float normalizedAge)\r\n{\r\n#ifdef TEXTURESHEETANIMATIONCURVE\r\n    float cycleNormalizedAge = normalizedAge * u_TSACycles;\r\n    float frame = getFrameFromGradient(\r\n\tu_TSAGradientUVs, cycleNormalizedAge - floor(cycleNormalizedAge));\r\n    float totalULength = frame * u_TSASubUVLength.x;\r\n    float floorTotalULength = floor(totalULength);\r\n    uv.x += totalULength - floorTotalULength;\r\n    uv.y += floorTotalULength * u_TSASubUVLength.y;\r\n#endif\r\n#ifdef TEXTURESHEETANIMATIONRANDOMCURVE\r\n    float cycleNormalizedAge = normalizedAge * u_TSACycles;\r\n    float uvNormalizedAge = cycleNormalizedAge - floor(cycleNormalizedAge);\r\n    float frame = floor(mix(getFrameFromGradient(u_TSAGradientUVs, uvNormalizedAge),\r\n\tgetFrameFromGradient(u_TSAMaxGradientUVs, uvNormalizedAge),\r\n\ta_Random1.x));\r\n    float totalULength = frame * u_TSASubUVLength.x;\r\n    float floorTotalULength = floor(totalULength);\r\n    uv.x += totalULength - floorTotalULength;\r\n    uv.y += floorTotalULength * u_TSASubUVLength.y;\r\n#endif\r\n    return uv;\r\n}\r\n\r\nvoid main()\r\n{\r\n    float age = u_CurrentTime - a_DirectionTime.w;\r\n    float normalizedAge = age / a_ShapePositionStartLifeTime.w;\r\n    vec3 lifeVelocity;\r\n    if (normalizedAge < 1.0)\r\n\t{\r\n\t    vec3 startVelocity = a_DirectionTime.xyz * a_StartSpeed;\r\n#if defined(VELOCITYOVERLIFETIMECONSTANT) || defined(VELOCITYOVERLIFETIMECURVE) || defined(VELOCITYOVERLIFETIMERANDOMCONSTANT) || defined(VELOCITYOVERLIFETIMERANDOMCURVE)\r\n\t    lifeVelocity = computeParticleLifeVelocity(normalizedAge); //计算粒子生命周期速度\r\n#endif\r\n\t    vec3 gravityVelocity = u_Gravity * age;\r\n\r\n\t    vec4 worldRotation;\r\n\t    if (u_SimulationSpace == 0)\r\n\t\tworldRotation = a_SimulationWorldRotation;\r\n\t    else\r\n\t\tworldRotation = u_WorldRotation;\r\n\r\n\t    // drag\r\n\t    vec3 dragData = a_DirectionTime.xyz * mix(u_DragConstanct.x, u_DragConstanct.y, a_Random0.x);\r\n\t    vec3 center = computeParticlePosition(startVelocity, lifeVelocity, age, normalizedAge, gravityVelocity, worldRotation, dragData); //计算粒子位置\r\n\r\n#ifdef SPHERHBILLBOARD\r\n\t    vec2 corner = a_CornerTextureCoordinate.xy; // Billboard模式z轴无效\r\n\t    vec3 cameraUpVector = normalize(u_CameraUp); // TODO:是否外面归一化\r\n\t    vec3 sideVector = normalize(cross(u_CameraDirection, cameraUpVector));\r\n\t    vec3 upVector = normalize(cross(sideVector, u_CameraDirection));\r\n\t    corner *= computeParticleSizeBillbard(a_StartSize.xy, normalizedAge);\r\n    #if defined(ROTATIONOVERLIFETIME) || defined(ROTATIONOVERLIFETIMESEPERATE)\r\n\t    if (u_ThreeDStartRotation)\r\n\t\t{\r\n\t\t    vec3 rotation = vec3(\r\n\t\t\ta_StartRotation0.xy,\r\n\t\t\tcomputeParticleRotationFloat(a_StartRotation0.z, age, normalizedAge));\r\n\t\t    center += u_SizeScale.xzy * rotationByEuler(corner.x * sideVector + corner.y * upVector, rotation);\r\n\t\t}\r\n\t    else\r\n\t\t{\r\n\t\t    float rot = computeParticleRotationFloat(a_StartRotation0.x, age, normalizedAge);\r\n\t\t    float c = cos(rot);\r\n\t\t    float s = sin(rot);\r\n\t\t    mat2 rotation = mat2(c, -s, s, c);\r\n\t\t    corner = rotation * corner;\r\n\t\t    center += u_SizeScale.xzy * (corner.x * sideVector + corner.y * upVector);\r\n\t\t}\r\n    #else\r\n\t    if (u_ThreeDStartRotation)\r\n\t\t{\r\n\t\t    center += u_SizeScale.xzy * rotationByEuler(corner.x * sideVector + corner.y * upVector, a_StartRotation0);\r\n\t\t}\r\n\t    else\r\n\t\t{\r\n\t\t    float c = cos(a_StartRotation0.x);\r\n\t\t    float s = sin(a_StartRotation0.x);\r\n\t\t    mat2 rotation = mat2(c, -s, s, c);\r\n\t\t    corner = rotation * corner;\r\n\t\t    center += u_SizeScale.xzy * (corner.x * sideVector + corner.y * upVector);\r\n\t\t}\r\n    #endif\r\n#endif\r\n\r\n#ifdef STRETCHEDBILLBOARD\r\n\t    vec2 corner = a_CornerTextureCoordinate.xy; // Billboard模式z轴无效\r\n\t    vec3 velocity;\r\n    #if defined(VELOCITYOVERLIFETIMECONSTANT) || defined(VELOCITYOVERLIFETIMECURVE) || defined(VELOCITYOVERLIFETIMERANDOMCONSTANT) || defined(VELOCITYOVERLIFETIMERANDOMCURVE)\r\n\t    if (u_VOLSpaceType == 0)\r\n\t\tvelocity = rotationByQuaternions(u_SizeScale * (startVelocity + lifeVelocity),\r\n\t\t\t       worldRotation)\r\n\t\t    + gravityVelocity;\r\n\t    else\r\n\t\tvelocity = rotationByQuaternions(u_SizeScale * startVelocity, worldRotation) + lifeVelocity + gravityVelocity;\r\n    #else\r\n\t    velocity = rotationByQuaternions(u_SizeScale * startVelocity, worldRotation) + gravityVelocity;\r\n    #endif\r\n\t    vec3 cameraUpVector = normalize(velocity);\r\n\t    vec3 direction = normalize(center - u_CameraPos);\r\n\t    vec3 sideVector = normalize(cross(direction, normalize(velocity)));\r\n\r\n\t    sideVector = u_SizeScale.xzy * sideVector;\r\n\t    cameraUpVector = length(vec3(u_SizeScale.x, 0.0, 0.0)) * cameraUpVector;\r\n\r\n\t    vec2 size = computeParticleSizeBillbard(a_StartSize.xy, normalizedAge);\r\n\r\n\t    const mat2 rotaionZHalfPI = mat2(0.0, -1.0, 1.0, 0.0);\r\n\t    corner = rotaionZHalfPI * corner;\r\n\t    corner.y = corner.y - abs(corner.y);\r\n\r\n\t    float speed = length(velocity); // TODO:\r\n\t    center += sign(u_SizeScale.x) * (sign(u_StretchedBillboardLengthScale) * size.x * corner.x * sideVector + (speed * u_StretchedBillboardSpeedScale + size.y * u_StretchedBillboardLengthScale) * corner.y * cameraUpVector);\r\n#endif\r\n\r\n#ifdef HORIZONTALBILLBOARD\r\n\t    vec2 corner = a_CornerTextureCoordinate.xy; // Billboard模式z轴无效\r\n\t    const vec3 cameraUpVector = vec3(0.0, 0.0, 1.0);\r\n\t    const vec3 sideVector = vec3(-1.0, 0.0, 0.0);\r\n\r\n\t    float rot = computeParticleRotationFloat(a_StartRotation0.x, age, normalizedAge);\r\n\t    float c = cos(rot);\r\n\t    float s = sin(rot);\r\n\t    mat2 rotation = mat2(c, -s, s, c);\r\n\t    corner = rotation * corner * cos(0.78539816339744830961566084581988); // TODO:临时缩小cos45,不确定U3D原因\r\n\t    corner *= computeParticleSizeBillbard(a_StartSize.xy, normalizedAge);\r\n\t    center += u_SizeScale.xzy * (corner.x * sideVector + corner.y * cameraUpVector);\r\n#endif\r\n\r\n#ifdef VERTICALBILLBOARD\r\n\t    vec2 corner = a_CornerTextureCoordinate.xy; // Billboard模式z轴无效\r\n\t    const vec3 cameraUpVector = vec3(0.0, 1.0, 0.0);\r\n\t    vec3 sideVector = normalize(cross(u_CameraDirection, cameraUpVector));\r\n\r\n\t    float rot = computeParticleRotationFloat(a_StartRotation0.x, age, normalizedAge);\r\n\t    float c = cos(rot);\r\n\t    float s = sin(rot);\r\n\t    mat2 rotation = mat2(c, -s, s, c);\r\n\t    corner = rotation * corner * cos(0.78539816339744830961566084581988); // TODO:临时缩小cos45,不确定U3D原因\r\n\t    corner *= computeParticleSizeBillbard(a_StartSize.xy, normalizedAge);\r\n\t    center += u_SizeScale.xzy * (corner.x * sideVector + corner.y * cameraUpVector);\r\n#endif\r\n\r\n#ifdef RENDERMODE_MESH\r\n\t    vec3 size = computeParticleSizeMesh(a_StartSize, normalizedAge);\r\n    #if defined(ROTATIONOVERLIFETIME) || defined(ROTATIONOVERLIFETIMESEPERATE)\r\n\t    if (u_ThreeDStartRotation)\r\n\t\t{\r\n\t\t    vec3 rotation = vec3(\r\n\t\t\ta_StartRotation0.xy,\r\n\t\t\tcomputeParticleRotationFloat(a_StartRotation0.z, age, normalizedAge));\r\n\t\t    center += rotationByQuaternions(\r\n\t\t\tu_SizeScale * rotationByEuler(a_MeshPosition * size, rotation),\r\n\t\t\tworldRotation);\r\n\t\t}\r\n\t    else\r\n\t\t{\r\n\t#ifdef ROTATIONOVERLIFETIME\r\n\t\t    float angle = computeParticleRotationFloat(a_StartRotation0.x, age, normalizedAge);\r\n\t\t    if (a_ShapePositionStartLifeTime.x != 0.0 || a_ShapePositionStartLifeTime.y != 0.0)\r\n\t\t\t{\r\n\t\t\t    center += (rotationByQuaternions(\r\n\t\t\t\trotationByAxis(\r\n\t\t\t\t    u_SizeScale * a_MeshPosition * size,\r\n\t\t\t\t    normalize(cross(vec3(0.0, 0.0, 1.0),\r\n\t\t\t\t\tvec3(a_ShapePositionStartLifeTime.xy, 0.0))),\r\n\t\t\t\t    angle),\r\n\t\t\t\tworldRotation)); //已验证\r\n\t\t\t}\r\n\t\t    else\r\n\t\t\t{\r\n\t    #ifdef SHAPE\r\n\t\t\t    center += u_SizeScale.xzy * (rotationByQuaternions(rotationByAxis(a_MeshPosition * size, vec3(0.0, -1.0, 0.0), angle), worldRotation));\r\n\t    #else\r\n\t\t\t    if (u_SimulationSpace == 0)\r\n\t\t\t\tcenter += rotationByAxis(u_SizeScale * a_MeshPosition * size,\r\n\t\t\t\t    vec3(0.0, 0.0, -1.0),\r\n\t\t\t\t    angle); //已验证\r\n\t\t\t    else if (u_SimulationSpace == 1)\r\n\t\t\t\tcenter += rotationByQuaternions(\r\n\t\t\t\t    u_SizeScale * rotationByAxis(a_MeshPosition * size, vec3(0.0, 0.0, -1.0), angle),\r\n\t\t\t\t    worldRotation); //已验证\r\n\t    #endif\r\n\t\t\t}\r\n\t#endif\r\n\t#ifdef ROTATIONOVERLIFETIMESEPERATE\r\n\t\t    // TODO:是否应合并if(u_ThreeDStartRotation)分支代码,待测试\r\n\t\t    vec3 angle = computeParticleRotationVec3(\r\n\t\t\tvec3(0.0, 0.0, -a_StartRotation0.x), age, normalizedAge);\r\n\t\t    center += (rotationByQuaternions(\r\n\t\t\trotationByEuler(u_SizeScale * a_MeshPosition * size,\r\n\t\t\t    vec3(angle.x, angle.y, angle.z)),\r\n\t\t\tworldRotation)); //已验证\r\n\t#endif\r\n\t\t}\r\n    #else\r\n\t    if (u_ThreeDStartRotation)\r\n\t\t{\r\n\t\t    center += rotationByQuaternions(\r\n\t\t\tu_SizeScale * rotationByEuler(a_MeshPosition * size, a_StartRotation0),\r\n\t\t\tworldRotation); //已验证\r\n\t\t}\r\n\t    else\r\n\t\t{\r\n\t\t    if (a_ShapePositionStartLifeTime.x != 0.0 || a_ShapePositionStartLifeTime.y != 0.0)\r\n\t\t\t{\r\n\t\t\t    if (u_SimulationSpace == 0)\r\n\t\t\t\tcenter += rotationByAxis(\r\n\t\t\t\t    u_SizeScale * a_MeshPosition * size,\r\n\t\t\t\t    normalize(cross(vec3(0.0, 0.0, 1.0),\r\n\t\t\t\t\tvec3(a_ShapePositionStartLifeTime.xy, 0.0))),\r\n\t\t\t\t    a_StartRotation0.x);\r\n\t\t\t    else if (u_SimulationSpace == 1)\r\n\t\t\t\tcenter += (rotationByQuaternions(\r\n\t\t\t\t    u_SizeScale * rotationByAxis(a_MeshPosition * size, normalize(cross(vec3(0.0, 0.0, 1.0), vec3(a_ShapePositionStartLifeTime.xy, 0.0))), a_StartRotation0.x),\r\n\t\t\t\t    worldRotation)); //已验证\r\n\t\t\t}\r\n\t\t    else\r\n\t\t\t{\r\n\t#ifdef SHAPE\r\n\t\t\t    if (u_SimulationSpace == 0)\r\n\t\t\t\tcenter += u_SizeScale * rotationByAxis(a_MeshPosition * size, vec3(0.0, -1.0, 0.0), a_StartRotation0.x);\r\n\t\t\t    else if (u_SimulationSpace == 1)\r\n\t\t\t\tcenter += rotationByQuaternions(\r\n\t\t\t\t    u_SizeScale * rotationByAxis(a_MeshPosition * size, vec3(0.0, -1.0, 0.0), a_StartRotation0.x),\r\n\t\t\t\t    worldRotation);\r\n\t#else\r\n\t\t\t    if (u_SimulationSpace == 0)\r\n\t\t\t\tcenter += rotationByAxis(u_SizeScale * a_MeshPosition * size,\r\n\t\t\t\t    vec3(0.0, 0.0, -1.0),\r\n\t\t\t\t    a_StartRotation0.x);\r\n\t\t\t    else if (u_SimulationSpace == 1)\r\n\t\t\t\tcenter += rotationByQuaternions(\r\n\t\t\t\t    u_SizeScale * rotationByAxis(a_MeshPosition * size, vec3(0.0, 0.0, -1.0), a_StartRotation0.x),\r\n\t\t\t\t    worldRotation); //已验证\r\n\t#endif\r\n\t\t\t}\r\n\t\t}\r\n    #endif\r\n\t    v_MeshColor = a_MeshColor;\r\n#endif\r\n\t    gl_Position = u_Projection * u_View * vec4(center, 1.0);\r\n\t\tvec4 startcolor = gammaToLinear(a_StartColor);\r\n\t    v_Color = computeParticleColor(startcolor, normalizedAge);\r\n#ifdef DIFFUSEMAP\r\n\t    vec2 simulateUV;\r\n    #if defined(SPHERHBILLBOARD) || defined(STRETCHEDBILLBOARD) || defined(HORIZONTALBILLBOARD) || defined(VERTICALBILLBOARD)\r\n\t    simulateUV = a_SimulationUV.xy + a_CornerTextureCoordinate.zw * a_SimulationUV.zw;\r\n\t    v_TextureCoordinate = computeParticleUV(simulateUV, normalizedAge);\r\n    #endif\r\n    #ifdef RENDERMODE_MESH\r\n\t    simulateUV = a_SimulationUV.xy + a_MeshTextureCoordinate * a_SimulationUV.zw;\r\n\t    v_TextureCoordinate = computeParticleUV(simulateUV, normalizedAge);\r\n    #endif\r\n\t    v_TextureCoordinate = TransformUV(v_TextureCoordinate, u_TilingOffset);\r\n#endif\r\n\t}\r\n    else\r\n\t{\r\n\t    gl_Position = vec4(2.0, 2.0, 2.0, 1.0); // Discard use out of X(-1,1),Y(-1,1),Z(0,1)\r\n\t}\r\n    gl_Position = remapPositionZ(gl_Position);\r\n\t#ifdef FOG\r\n        FogHandle(gl_Position.z);\r\n    #endif\r\n}\r\n";

    var ShurikenFS = "#define SHADER_NAME ParticleFS\r\n\r\n#include \"Scene.glsl\";\r\n#include \"SceneFog.glsl\";\r\n#include \"Color.glsl\";\r\n\r\nconst vec4 c_ColorSpace = vec4(4.59479380, 4.59479380, 4.59479380, 2.0);\r\n\r\nvarying vec4 v_Color;\r\nvarying vec2 v_TextureCoordinate;\r\n// uniform sampler2D u_texture;\r\n// uniform vec4 u_Tintcolor;\r\n\r\n#ifdef RENDERMODE_MESH\r\nvarying vec4 v_MeshColor;\r\n#endif\r\n\r\nvoid main()\r\n{\r\n    vec4 color;\r\n#ifdef RENDERMODE_MESH\r\n    color = v_MeshColor;\r\n#else\r\n    color = vec4(1.0);\r\n#endif\r\n\r\n#ifdef DIFFUSEMAP\r\n    vec4 colorT = texture2D(u_texture, v_TextureCoordinate);\r\n    #ifdef Gamma_u_texture\r\n        colorT = gammaToLinear(colorT);\r\n    #endif // Gamma_u_SpecularTexture\r\n    #ifdef TINTCOLOR\r\n    color *= colorT * u_Tintcolor * c_ColorSpace * v_Color;\r\n    #else\r\n    color *= colorT * v_Color;\r\n    #endif // TINTCOLORd\r\n#else\r\n    #ifdef TINTCOLOR\r\n    color *= u_Tintcolor * c_ColorSpace * v_Color;\r\n    #else\r\n    color *= v_Color;\r\n    #endif // TINTCOLOR\r\n#endif\r\n\r\n#ifdef FOG\r\n    color.rgb = scenUnlitFog(color.rgb);\r\n#endif // FOG\r\n    gl_FragColor = color;\r\n\r\n}";

    var MathGradient = "float getCurValueFromGradientFloat(in vec2 gradientNumbers[4], in float normalizedAge)\r\n{\r\n    float curValue;\r\n    for (int i = 1; i < 4; i++)\r\n\t{\r\n\t    vec2 gradientNumber = gradientNumbers[i];\r\n\t    float key = gradientNumber.x;\r\n\t    if (key >= normalizedAge)\r\n\t\t{\r\n\t\t    vec2 lastGradientNumber = gradientNumbers[i - 1];\r\n\t\t    float lastKey = lastGradientNumber.x;\r\n\t\t    float age = (normalizedAge - lastKey) / (key - lastKey);\r\n\t\t    curValue = mix(lastGradientNumber.y, gradientNumber.y, age);\r\n\t\t    break;\r\n\t\t}\r\n\t}\r\n    return curValue;\r\n}\r\n\r\nfloat getTotalValueFromGradientFloat(in vec2 gradientNumbers[4],\r\n    in float normalizedAge)\r\n{\r\n    float totalValue = 0.0;\r\n    for (int i = 1; i < 4; i++)\r\n\t{\r\n\t    vec2 gradientNumber = gradientNumbers[i];\r\n\t    float key = gradientNumber.x;\r\n\t    vec2 lastGradientNumber = gradientNumbers[i - 1];\r\n\t    float lastValue = lastGradientNumber.y;\r\n\r\n\t    if (key >= normalizedAge)\r\n\t\t{\r\n\t\t    float lastKey = lastGradientNumber.x;\r\n\t\t    float age = (normalizedAge - lastKey) / (key - lastKey);\r\n\t\t    totalValue += (lastValue + mix(lastValue, gradientNumber.y, age)) / 2.0 * a_ShapePositionStartLifeTime.w * (normalizedAge - lastKey);\r\n\t\t    break;\r\n\t\t}\r\n\t    else\r\n\t\t{\r\n\t\t    totalValue += (lastValue + gradientNumber.y) / 2.0 * a_ShapePositionStartLifeTime.w * (key - lastGradientNumber.x);\r\n\t\t}\r\n\t}\r\n    return totalValue;\r\n}\r\n\r\nvec4 getColorFromGradient(in vec2 gradientAlphas[COLORCOUNT],\r\n    in vec4 gradientColors[COLORCOUNT],\r\n    in float normalizedAge, in vec4 keyRanges)\r\n{\r\n    float alphaAge = clamp(normalizedAge, keyRanges.z, keyRanges.w);\r\n    vec4 overTimeColor;\r\n    for (int i = 1; i < COLORCOUNT; i++)\r\n\t{\r\n\t    vec2 gradientAlpha = gradientAlphas[i];\r\n\t    float alphaKey = gradientAlpha.x;\r\n\t    if (alphaKey >= alphaAge)\r\n\t\t{\r\n\t\t    vec2 lastGradientAlpha = gradientAlphas[i - 1];\r\n\t\t    float lastAlphaKey = lastGradientAlpha.x;\r\n\t\t    float age = (alphaAge - lastAlphaKey) / (alphaKey - lastAlphaKey);\r\n\t\t    overTimeColor.a = mix(lastGradientAlpha.y, gradientAlpha.y, age);\r\n\t\t    break;\r\n\t\t}\r\n\t}\r\n\r\n    float colorAge = clamp(normalizedAge, keyRanges.x, keyRanges.y);\r\n    for (int i = 1; i < COLORCOUNT; i++)\r\n\t{\r\n\t    vec4 gradientColor = gradientColors[i];\r\n\t    float colorKey = gradientColor.x;\r\n\t    if (colorKey >= colorAge)\r\n\t\t{\r\n\t\t    vec4 lastGradientColor = gradientColors[i - 1];\r\n\t\t    float lastColorKey = lastGradientColor.x;\r\n\t\t    float age = (colorAge - lastColorKey) / (colorKey - lastColorKey);\r\n\t\t    overTimeColor.rgb = mix(gradientColors[i - 1].yzw, gradientColor.yzw, age);\r\n\t\t    break;\r\n\t\t}\r\n\t}\r\n    return overTimeColor;\r\n}\r\n\r\nfloat getFrameFromGradient(in vec2 gradientFrames[4], in float normalizedAge)\r\n{\r\n    float overTimeFrame;\r\n    for (int i = 1; i < 4; i++)\r\n\t{\r\n\t    vec2 gradientFrame = gradientFrames[i];\r\n\t    float key = gradientFrame.x;\r\n\t    if (key >= normalizedAge)\r\n\t\t{\r\n\t\t    vec2 lastGradientFrame = gradientFrames[i - 1];\r\n\t\t    float lastKey = lastGradientFrame.x;\r\n\t\t    float age = (normalizedAge - lastKey) / (key - lastKey);\r\n\t\t    overTimeFrame = mix(lastGradientFrame.y, gradientFrame.y, age);\r\n\t\t    break;\r\n\t\t}\r\n\t}\r\n    return floor(overTimeFrame);\r\n}\r\n";

    var ParticleSpriteVS = "// sprite Uniform\r\nuniform float u_CurrentTime;\r\nuniform vec3 u_Gravity;\r\nuniform vec2 u_DragConstanct;\r\nuniform vec3 u_WorldPosition;\r\nuniform vec4 u_WorldRotation;\r\nuniform bool u_ThreeDStartRotation;\r\nuniform int u_ScalingMode;\r\nuniform vec3 u_PositionScale;\r\nuniform vec3 u_SizeScale;\r\n\r\nuniform float u_StretchedBillboardLengthScale;\r\nuniform float u_StretchedBillboardSpeedScale;\r\nuniform int u_SimulationSpace;\r\n\r\n#if defined(VELOCITYOVERLIFETIMECONSTANT) || defined(VELOCITYOVERLIFETIMECURVE) || defined(VELOCITYOVERLIFETIMERANDOMCONSTANT) || defined(VELOCITYOVERLIFETIMERANDOMCURVE)\r\nuniform int u_VOLSpaceType;\r\n#endif\r\n#if defined(VELOCITYOVERLIFETIMECONSTANT) || defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)\r\nuniform vec3 u_VOLVelocityConst;\r\n#endif\r\n#if defined(VELOCITYOVERLIFETIMECURVE) || defined(VELOCITYOVERLIFETIMERANDOMCURVE)\r\nuniform vec2 u_VOLVelocityGradientX[4]; // x为key,y为速度\r\nuniform vec2 u_VOLVelocityGradientY[4]; // x为key,y为速度\r\nuniform vec2 u_VOLVelocityGradientZ[4]; // x为key,y为速度\r\n#endif\r\n#ifdef VELOCITYOVERLIFETIMERANDOMCONSTANT\r\nuniform vec3 u_VOLVelocityConstMax;\r\n#endif\r\n#ifdef VELOCITYOVERLIFETIMERANDOMCURVE\r\nuniform vec2 u_VOLVelocityGradientMaxX[4]; // x为key,y为速度\r\nuniform vec2 u_VOLVelocityGradientMaxY[4]; // x为key,y为速度\r\nuniform vec2 u_VOLVelocityGradientMaxZ[4]; // x为key,y为速度\r\n#endif\r\n\r\n#ifdef COLORKEYCOUNT_8\r\n    #define COLORCOUNT 8\r\n#else\r\n    #define COLORCOUNT 4\r\n#endif\r\n\r\n#ifdef COLOROVERLIFETIME\r\nuniform vec4 u_ColorOverLifeGradientColors[COLORCOUNT]; // x为key,yzw为Color\r\nuniform vec2 u_ColorOverLifeGradientAlphas[COLORCOUNT]; // x为key,y为Alpha\r\nuniform vec4 u_ColorOverLifeGradientRanges;\r\n#endif\r\n#ifdef RANDOMCOLOROVERLIFETIME\r\nuniform vec4 u_ColorOverLifeGradientColors[COLORCOUNT]; // x为key,yzw为Color\r\nuniform vec2 u_ColorOverLifeGradientAlphas[COLORCOUNT]; // x为key,y为Alpha\r\nuniform vec4 u_ColorOverLifeGradientRanges;\r\nuniform vec4 u_MaxColorOverLifeGradientColors[COLORCOUNT]; // x为key,yzw为Color\r\nuniform vec2 u_MaxColorOverLifeGradientAlphas[COLORCOUNT]; // x为key,y为Alpha\r\nuniform vec4 u_MaxColorOverLifeGradientRanges;\r\n#endif\r\n\r\n#if defined(SIZEOVERLIFETIMECURVE) || defined(SIZEOVERLIFETIMERANDOMCURVES)\r\nuniform vec2 u_SOLSizeGradient[4]; // x为key,y为尺寸\r\n#endif\r\n#ifdef SIZEOVERLIFETIMERANDOMCURVES\r\nuniform vec2 u_SOLSizeGradientMax[4]; // x为key,y为尺寸\r\n#endif\r\n#if defined(SIZEOVERLIFETIMECURVESEPERATE) || defined(SIZEOVERLIFETIMERANDOMCURVESSEPERATE)\r\nuniform vec2 u_SOLSizeGradientX[4]; // x为key,y为尺寸\r\nuniform vec2 u_SOLSizeGradientY[4]; // x为key,y为尺寸\r\nuniform vec2 u_SOLSizeGradientZ[4]; // x为key,y为尺寸\r\n#endif\r\n#ifdef SIZEOVERLIFETIMERANDOMCURVESSEPERATE\r\nuniform vec2 u_SOLSizeGradientMaxX[4]; // x为key,y为尺寸\r\nuniform vec2 u_SOLSizeGradientMaxY[4]; // x为key,y为尺寸\r\nuniform vec2 u_SOLSizeGradientMaxZ[4]; // x为key,y为尺寸\r\n#endif\r\n\r\n#ifdef ROTATIONOVERLIFETIME\r\n    #if defined(ROTATIONOVERLIFETIMECONSTANT) || defined(ROTATIONOVERLIFETIMERANDOMCONSTANTS)\r\nuniform float u_ROLAngularVelocityConst;\r\n    #endif\r\n    #ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\r\nuniform float u_ROLAngularVelocityConstMax;\r\n    #endif\r\n    #if defined(ROTATIONOVERLIFETIMECURVE) || defined(ROTATIONOVERLIFETIMERANDOMCURVES)\r\nuniform vec2 u_ROLAngularVelocityGradient[4]; // x为key,y为旋转\r\n    #endif\r\n    #ifdef ROTATIONOVERLIFETIMERANDOMCURVES\r\nuniform vec2 u_ROLAngularVelocityGradientMax[4]; // x为key,y为旋转\r\n    #endif\r\n#endif\r\n#ifdef ROTATIONOVERLIFETIMESEPERATE\r\n    #if defined(ROTATIONOVERLIFETIMECONSTANT) || defined(ROTATIONOVERLIFETIMERANDOMCONSTANTS)\r\nuniform vec3 u_ROLAngularVelocityConstSeprarate;\r\n    #endif\r\n    #ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\r\nuniform vec3 u_ROLAngularVelocityConstMaxSeprarate;\r\n    #endif\r\n    #if defined(ROTATIONOVERLIFETIMECURVE) || defined(ROTATIONOVERLIFETIMERANDOMCURVES)\r\nuniform vec2 u_ROLAngularVelocityGradientX[4];\r\nuniform vec2 u_ROLAngularVelocityGradientY[4];\r\nuniform vec2 u_ROLAngularVelocityGradientZ[4];\r\n    #endif\r\n    #ifdef ROTATIONOVERLIFETIMERANDOMCURVES\r\nuniform vec2 u_ROLAngularVelocityGradientMaxX[4];\r\nuniform vec2 u_ROLAngularVelocityGradientMaxY[4];\r\nuniform vec2 u_ROLAngularVelocityGradientMaxZ[4];\r\nuniform vec2 u_ROLAngularVelocityGradientMaxW[4];\r\n    #endif\r\n#endif\r\n\r\n#if defined(TEXTURESHEETANIMATIONCURVE) || defined(TEXTURESHEETANIMATIONRANDOMCURVE)\r\nuniform float u_TSACycles;\r\nuniform vec2 u_TSASubUVLength;\r\nuniform vec2 u_TSAGradientUVs[4]; // x为key,y为frame\r\n#endif\r\n#ifdef TEXTURESHEETANIMATIONRANDOMCURVE\r\nuniform vec2 u_TSAMaxGradientUVs[4]; // x为key,y为frame\r\n#endif";

    class ParticleShuriKenShaderInit {
        static init() {
            Laya.Shader3D.addInclude("MathGradient.glsl", MathGradient);
            Laya.Shader3D.addInclude("particleShuriKenSpriteVS.glsl", ParticleSpriteVS);
            let attributeMap = {
                'a_CornerTextureCoordinate': [VertexShuriKenParticle.PARTICLE_CORNERTEXTURECOORDINATE0, Laya.ShaderDataType.Vector4],
                'a_MeshPosition': [VertexShuriKenParticle.PARTICLE_POSITION0, Laya.ShaderDataType.Vector3],
                'a_MeshColor': [VertexShuriKenParticle.PARTICLE_COLOR0, Laya.ShaderDataType.Vector4],
                'a_MeshTextureCoordinate': [VertexShuriKenParticle.PARTICLE_TEXTURECOORDINATE0, Laya.ShaderDataType.Vector2],
                'a_ShapePositionStartLifeTime': [VertexShuriKenParticle.PARTICLE_SHAPEPOSITIONSTARTLIFETIME, Laya.ShaderDataType.Vector4],
                'a_DirectionTime': [VertexShuriKenParticle.PARTICLE_DIRECTIONTIME, Laya.ShaderDataType.Vector4],
                'a_StartColor': [VertexShuriKenParticle.PARTICLE_STARTCOLOR0, Laya.ShaderDataType.Vector4],
                'a_StartSize': [VertexShuriKenParticle.PARTICLE_STARTSIZE, Laya.ShaderDataType.Vector3],
                'a_StartRotation0': [VertexShuriKenParticle.PARTICLE_STARTROTATION, Laya.ShaderDataType.Vector3],
                'a_StartSpeed': [VertexShuriKenParticle.PARTICLE_STARTSPEED, Laya.ShaderDataType.Float],
                'a_Random0': [VertexShuriKenParticle.PARTICLE_RANDOM0, Laya.ShaderDataType.Vector4],
                'a_Random1': [VertexShuriKenParticle.PARTICLE_RANDOM1, Laya.ShaderDataType.Vector4],
                'a_SimulationWorldPostion': [VertexShuriKenParticle.PARTICLE_SIMULATIONWORLDPOSTION, Laya.ShaderDataType.Vector3],
                'a_SimulationWorldRotation': [VertexShuriKenParticle.PARTICLE_SIMULATIONWORLDROTATION, Laya.ShaderDataType.Vector4],
                'a_SimulationUV': [VertexShuriKenParticle.PARTICLE_SIMULATIONUV, Laya.ShaderDataType.Vector4]
            };
            let uniformMap = {
                "u_Tintcolor": Laya.ShaderDataType.Color,
                "u_texture": Laya.ShaderDataType.Texture2D,
                "u_TilingOffset": Laya.ShaderDataType.Vector4
            };
            let defaultValue = {
                "u_Tintcolor": new Laya.Color(0.5, 0.5, 0.5, 0.5),
                "u_TilingOffset": new Laya.Vector4(1, 1, 0, 0),
            };
            let shader = Laya.Shader3D.add("PARTICLESHURIKEN", false, false);
            let subShader = new Laya.SubShader(attributeMap, uniformMap, defaultValue);
            shader.addSubShader(subShader);
            subShader.addShaderPass(ShurikenVS, ShurikenFS);
        }
    }

    var SkyProceduralVS = "#define SHADER_NAME SkyProceduralVS\r\n\r\n#include \"Camera.glsl\";\r\n\r\nconst float c_deg2ang = 3.141593 / 180.0;\r\n\r\n#define OUTER_RADIUS 1.025\r\n#define RAYLEIGH (mix(0.0, 0.0025, pow(u_AtmosphereThickness,2.5)))// Rayleigh constant Rayleigh为夜空光和极光亮度单位\r\n#define MIE 0.0010             // Mie constant 米氏散射\r\n#define SUN_BRIGHTNESS 20.0    // Sun brightness\r\n#define MAX_SCATTER 50.0 // Maximum scattering value, to prevent math overflows on Adrenos\r\n\r\nconst float SKY_GROUND_THRESHOLD = 0.02;\r\nconst float outerRadius = OUTER_RADIUS;\r\nconst float outerRadius2 = OUTER_RADIUS*OUTER_RADIUS;\r\nconst float innerRadius = 1.0;\r\nconst float innerRadius2 = 1.0;\r\nconst float cameraHeight = 0.0001;\r\n\r\nconst float HDSundiskIntensityFactor = 15.0;\r\nconst float simpleSundiskIntensityFactor = 27.0;\r\n\r\nconst float sunScale = 400.0 * SUN_BRIGHTNESS;\r\nconst float kmESun = MIE * SUN_BRIGHTNESS;\r\nconst float km4PI = MIE * 4.0 * 3.14159265;\r\nconst float scale = 1.0 / (OUTER_RADIUS - 1.0);\r\nconst float scaleDepth = 0.25;\r\nconst float scaleOverScaleDepth = (1.0 / (OUTER_RADIUS - 1.0)) / 0.25;\r\nconst float samples = 2.0; // THIS IS UNROLLED MANUALLY, DON'T TOUCH\r\n\r\n// RGB wavelengths        .35 (.62=158), .43 (.68=174), .525 (.75=190)\r\nconst vec3 c_DefaultScatteringWavelength = vec3(0.65, 0.57, 0.475);//默认散射波长\r\nconst vec3 c_VariableRangeForScatteringWavelength = vec3(0.15, 0.15, 0.15);//散射播放的可变范围\r\n\r\n// uniform vec4 u_SkyTint;\r\n// uniform vec4 u_GroundTint;\r\n// uniform float u_Exposure;\r\n// uniform float u_AtmosphereThickness;\r\nvec4 skyRemapGLPositionZ(vec4 position){\r\n\tposition.z = position.w;\r\n\treturn position;\r\n}\r\n//sprite\r\nuniform vec3 u_SunLight_direction;\r\nuniform vec4 u_SunLight_color;\r\n\r\nvarying vec3 v_GroundColor;\r\nvarying vec3 v_SkyColor;\r\n\r\n#ifdef SUN_HIGH_QUALITY\r\n\tvarying vec3 v_Vertex;\r\n#elif defined(SUN_SIMPLE)\r\n\tvarying vec3 v_RayDir;\r\n#else\r\n\tvarying float v_SkyGroundFactor;\r\n#endif\r\n\r\n#if defined(SUN_HIGH_QUALITY)||defined(SUN_SIMPLE)\r\n\tvarying vec3 v_SunColor;\r\n#endif\r\n\r\n// Calculates the Rayleigh phase function\r\nfloat getRayleighPhase(vec3 light, vec3 ray) \r\n{\r\n\tfloat eyeCos = dot(light, ray);\r\n\treturn 0.75 + 0.75*eyeCos*eyeCos;\r\n}\r\n\r\nfloat scaleAngle(float inCos)\r\n{\r\n\tfloat x = 1.0 - inCos;\r\n\treturn 0.25 * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));\r\n}\r\n\r\n\r\nvoid main(){\r\n    gl_Position = u_ViewProjection*a_Position;\r\n\r\n    vec3 skyTintInGammaSpace = pow(u_SkyTint.xyz,vec3(0.45));//u_SkyTint.xyz;//支持非GAMMA空间后要调整\r\n\tvec3 scatteringWavelength = mix(c_DefaultScatteringWavelength-c_VariableRangeForScatteringWavelength,c_DefaultScatteringWavelength+c_VariableRangeForScatteringWavelength,vec3(1.0) - skyTintInGammaSpace); // using Tint in sRGB+ gamma allows for more visually linear interpolation and to keep (0.5) at (128, gray in sRGB) point\r\n\tvec3 invWavelength = 1.0 / pow(scatteringWavelength, vec3(4.0));\r\n\r\n\tfloat krESun = RAYLEIGH * SUN_BRIGHTNESS;\r\n\tfloat kr4PI = RAYLEIGH * 4.0 * 3.14159265;\r\n\r\n\tvec3 cameraPos = vec3(0.0,innerRadius + cameraHeight,0.0); // The camera's current position\r\n\r\n\t// Get the ray from the camera to the vertex and its length (which is the far point of the ray passing through the atmosphere)\r\n\tvec3 eyeRay = normalize(a_Position.xyz);\r\n\r\n\tfloat far = 0.0;\r\n\tvec3 cIn, cOut;\r\n\tif (eyeRay.y >= 0.0) {// Sky\r\n\t\t// Calculate the length of the \"atmosphere\"\r\n\t\tfar = sqrt(outerRadius2 + innerRadius2 * eyeRay.y * eyeRay.y - innerRadius2) - innerRadius * eyeRay.y;\r\n\r\n\t\t// Calculate the ray's starting position, then calculate its scattering offset\r\n\t\tfloat height = innerRadius + cameraHeight;\r\n\t\tfloat depth = exp(scaleOverScaleDepth * -cameraHeight);\r\n\t\tfloat startAngle = dot(eyeRay, cameraPos) / height;\r\n\t\tfloat startOffset = depth*scaleAngle(startAngle);\r\n\r\n\t\t// Initialize the scattering loop variables\r\n\t\tfloat sampleLength = far / samples;\r\n\t\tfloat scaledLength = sampleLength * scale;\r\n\t\tvec3 sampleRay = eyeRay * sampleLength;\r\n\t\tvec3 samplePoint = cameraPos + sampleRay * 0.5;\r\n\r\n\t\tvec3 frontColor = vec3(0.0);\r\n\t\t//unrolling this manually to avoid some platform for loop slow\r\n\t\t{\r\n\t\t\tfloat height = length(samplePoint);\r\n\t\t\tfloat depth = exp(scaleOverScaleDepth * (innerRadius - height));\r\n\t\t\tfloat lightAngle = dot(-u_SunLight_direction, samplePoint) / height;\r\n\t\t\tfloat cameraAngle = dot(eyeRay, samplePoint) / height;\r\n\t\t\tfloat scatter = (startOffset + depth*(scaleAngle(lightAngle) - scaleAngle(cameraAngle)));\r\n\t\t\tvec3 attenuate = exp(-clamp(scatter, 0.0, MAX_SCATTER) * (invWavelength * kr4PI + km4PI));\r\n\r\n\t\t\tfrontColor += attenuate * (depth * scaledLength);\r\n\t\t\tsamplePoint += sampleRay;\r\n\t\t}\r\n\t\t{\r\n\t\t\tfloat height = length(samplePoint);\r\n\t\t\tfloat depth = exp(scaleOverScaleDepth * (innerRadius - height));\r\n\t\t\tfloat lightAngle = dot(-u_SunLight_direction, samplePoint) / height;\r\n\t\t\tfloat cameraAngle = dot(eyeRay, samplePoint) / height;\r\n\t\t\tfloat scatter = (startOffset + depth*(scaleAngle(lightAngle) - scaleAngle(cameraAngle)));\r\n\t\t\tvec3 attenuate = exp(-clamp(scatter, 0.0, MAX_SCATTER) * (invWavelength * kr4PI + km4PI));\r\n\r\n\t\t\tfrontColor += attenuate * (depth * scaledLength);\r\n\t\t\tsamplePoint += sampleRay;\r\n\t\t}\r\n\r\n\t\t// Finally, scale the Mie and Rayleigh colors and set up the varying variables for the pixel shader\r\n\t\tcIn = frontColor * (invWavelength * krESun);\r\n\t\tcOut = frontColor * kmESun;\r\n\t} else {// Ground\r\n\t\tfar = (-cameraHeight) / (min(-0.001, eyeRay.y));\r\n\t\tvec3 pos = cameraPos + far * eyeRay;\r\n\r\n\t\t// Calculate the ray's starting position, then calculate its scattering offset\r\n\t\tfloat depth = exp((-cameraHeight) * (1.0/scaleDepth));\r\n\t\tfloat cameraAngle = dot(-eyeRay, pos);\r\n\t\tfloat lightAngle = dot(-u_SunLight_direction, pos);\r\n\t\tfloat cameraScale = scaleAngle(cameraAngle);\r\n\t\tfloat lightScale = scaleAngle(lightAngle);\r\n\t\tfloat cameraOffset = depth*cameraScale;\r\n\t\tfloat temp = lightScale + cameraScale;\r\n\r\n\t\t// Initialize the scattering loop variables\r\n\t\tfloat sampleLength = far / samples;\r\n\t\tfloat scaledLength = sampleLength * scale;\r\n\t\tvec3 sampleRay = eyeRay * sampleLength;\r\n\t\tvec3 samplePoint = cameraPos + sampleRay * 0.5;\r\n\r\n\t\t// Now loop through the sample rays\r\n\t\tvec3 frontColor = vec3(0.0, 0.0, 0.0);\r\n\t\tvec3 attenuate;\r\n\r\n\t\t// Loop removed because we kept hitting SM2.0 temp variable limits. Doesn't affect the image too much.\r\n\t\t{\r\n\t\t\tfloat height = length(samplePoint);\r\n\t\t\tfloat depth = exp(scaleOverScaleDepth * (innerRadius - height));\r\n\t\t\tfloat scatter = depth*temp - cameraOffset;\r\n\t\t\tattenuate = exp(-clamp(scatter, 0.0, MAX_SCATTER) * (invWavelength * kr4PI + km4PI));\r\n\t\t\tfrontColor += attenuate * (depth * scaledLength);\r\n\t\t\tsamplePoint += sampleRay;\r\n\t\t}\r\n\r\n\t\tcIn = frontColor * (invWavelength * krESun + kmESun);\r\n\t\tcOut = clamp(attenuate, 0.0, 1.0);\r\n\t}\r\n\r\n\t#ifdef SUN_HIGH_QUALITY\r\n\t\tv_Vertex = -a_Position.xyz;\r\n\t#elif defined(SUN_SIMPLE) \r\n\t\tv_RayDir = -eyeRay;\r\n\t#else\r\n\t\tv_SkyGroundFactor = -eyeRay.y / SKY_GROUND_THRESHOLD;\r\n\t#endif\r\n\r\n\t// if we want to calculate color in vprog:\r\n\t// in case of linear: multiply by _Exposure in here (even in case of lerp it will be common multiplier, so we can skip mul in fshader)\r\n\tv_GroundColor = u_Exposure * (cIn + u_GroundTint.xyz * cOut);//u_GroundColor*u_GroundColor is gamma space convert to linear space\r\n\tv_SkyColor    = u_Exposure * (cIn * getRayleighPhase(-u_SunLight_direction, -eyeRay));\r\n\r\n\t\r\n\t// The sun should have a stable intensity in its course in the sky. Moreover it should match the highlight of a purely specular material.\r\n\t// This matching was done using the Unity3D standard shader BRDF1 on the 5/31/2017\r\n\t// Finally we want the sun to be always bright even in LDR thus the normalization of the lightColor for low intensity.\r\n\tfloat lightColorIntensity = clamp(length(u_SunLight_color.xyz), 0.25, 1.0);\r\n\r\n\t#ifdef SUN_HIGH_QUALITY \r\n\t\tv_SunColor = HDSundiskIntensityFactor * clamp(cOut,0.0,1.0) * u_SunLight_color.xyz / lightColorIntensity;\r\n\t#elif defined(SUN_SIMPLE) \r\n\t\tv_SunColor = simpleSundiskIntensityFactor * clamp(cOut * sunScale,0.0,1.0) * u_SunLight_color.xyz / lightColorIntensity;\r\n\t#endif\r\n\tgl_Position=skyRemapGLPositionZ(gl_Position);\r\n}";

    var SkyProceduralFS = "#define SHADER_NAME SkyProceduralFS\r\n\r\nconst float MIE_G = -0.990;\r\nconst float MIE_G2 = 0.9801;\r\nconst float SKY_GROUND_THRESHOLD = 0.02;\r\n\r\n// uniform float u_SunSize;\r\n// uniform float u_SunSizeConvergence;\r\n\r\nuniform vec3 u_SunLight_direction;\r\n\r\nvarying vec3 v_GroundColor;\r\nvarying vec3 v_SkyColor;\r\n\r\n\r\n#ifdef SUN_HIGH_QUALITY\r\n\tvarying vec3 v_Vertex;\r\n#elif defined(SUN_SIMPLE)\r\n\tvarying vec3 v_RayDir;\r\n#else\r\n\tvarying float v_SkyGroundFactor;\r\n#endif\r\n\r\n#if defined(SUN_HIGH_QUALITY)||defined(SUN_SIMPLE)\r\n\tvarying vec3 v_SunColor;\r\n#endif\r\n\r\n// Calculates the Mie phase function\r\nfloat getMiePhase(float eyeCos, float eyeCos2) {\r\n\tfloat temp = 1.0 + MIE_G2 - 2.0 * MIE_G * eyeCos;\r\n\ttemp = pow(temp, pow(u_SunSize,0.65) * 10.0);\r\n\ttemp = max(temp,1.0e-4); // prevent division by zero, esp. in half precision\r\n\ttemp = 1.5 * ((1.0 - MIE_G2) / (2.0 + MIE_G2)) * (1.0 + eyeCos2) / temp;\r\n\treturn temp;\r\n}\r\n\r\n// Calculates the sun shape\r\nfloat calcSunAttenuation(vec3 lightPos, vec3 ray) {\r\n\t#ifdef SUN_HIGH_QUALITY\r\n\t\tfloat focusedEyeCos = pow(clamp(dot(lightPos, ray),0.0,1.0), u_SunSizeConvergence);\r\n\t\treturn getMiePhase(-focusedEyeCos, focusedEyeCos * focusedEyeCos);\r\n\t#else //SUN_SIMPLE\r\n\t\tvec3 delta = lightPos - ray;\r\n\t\tfloat dist = length(delta);\r\n\t\tfloat spot = 1.0 - smoothstep(0.0, u_SunSize, dist);\r\n\t\treturn spot * spot;\r\n\t#endif\r\n}\r\n\r\nvoid main() {\r\n\t// if y > 1 [eyeRay.y < -SKY_GROUND_THRESHOLD] - ground\r\n\t// if y >= 0 and < 1 [eyeRay.y <= 0 and > -SKY_GROUND_THRESHOLD] - horizon\r\n\t// if y < 0 [eyeRay.y > 0] - sky\r\n\tvec3 col = vec3(0.0, 0.0, 0.0);\r\n\r\n\t#ifdef SUN_HIGH_QUALITY\r\n\t\tvec3 ray = normalize(v_Vertex);\r\n\t\tfloat y = ray.y / SKY_GROUND_THRESHOLD;\r\n\t#elif defined(SUN_SIMPLE) \r\n\t\tvec3 ray = v_RayDir;\r\n\t\tfloat y = ray.y / SKY_GROUND_THRESHOLD;\t\r\n\t#else\r\n\t\tfloat y = v_SkyGroundFactor;\r\n\t#endif\r\n\r\n\t// if we did precalculate color in vprog: just do lerp between them\r\n\tcol = mix(v_SkyColor, v_GroundColor, clamp(y,0.0,1.0));\r\n\r\n\t#if defined(SUN_HIGH_QUALITY)||defined(SUN_SIMPLE)\r\n\t\tif (y < 0.0)\r\n\t\t\tcol += v_SunColor * calcSunAttenuation(-u_SunLight_direction, -ray);\r\n\t#endif\r\n\r\n\t//col = sqrt(col);//linear space convert to gamma space\r\n\tgl_FragColor=vec4(col,1.0);\r\n}\r\n";

    class SkyProceduralShaderInit {
        static init() {
            let attributeMap = {
                "a_Position": [Laya.VertexMesh.MESH_POSITION0, Laya.ShaderDataType.Vector4]
            };
            let uniformMap = {
                "u_SunSize": Laya.ShaderDataType.Float,
                "u_SunSizeConvergence": Laya.ShaderDataType.Float,
                "u_AtmosphereThickness": Laya.ShaderDataType.Float,
                "u_SkyTint": Laya.ShaderDataType.Color,
                "u_GroundTint": Laya.ShaderDataType.Color,
                "u_Exposure": Laya.ShaderDataType.Float,
            };
            let defaultValue = {
                "u_SunSize": 0.04,
                "u_SunSizeConvergence": 5,
                "u_AtmosphereThickness": 1.0,
                "u_SkyTint": new Laya.Color(0.5, 0.5, 0.5, 1.0),
                "u_GroundTint": new Laya.Color(0.369, 0.349, 0.341, 1.0),
                "u_Exposure": 1.3,
            };
            let shader = Laya.Shader3D.add("SkyProcedural");
            let subShader = new Laya.SubShader(attributeMap, uniformMap, defaultValue);
            shader.addSubShader(subShader);
            let pass = subShader.addShaderPass(SkyProceduralVS, SkyProceduralFS);
            pass.renderState.depthTest = Laya.RenderState.DEPTHTEST_LEQUAL;
            pass.statefirst = true;
        }
    }

    var SkyPanoramicVS = "#define SHADER_NAME SkyPanoramicVS\r\n\r\n#include \"Camera.glsl\";\r\n#define PI 3.14159265359\r\n\r\n//attribute vec4 a_Position;\r\n\r\n//uniform float u_Rotation;\r\n\r\nvarying vec3 v_Texcoord;\r\nvarying vec2 v_Image180ScaleAndCutoff;\r\nvarying vec4 v_Layout3DScaleAndOffset;\r\n\r\nvec4 skyRemapGLPositionZ(vec4 position){\r\n\tposition.z = position.w;\r\n\treturn position;\r\n}\r\n\r\nvec4 rotateAroundYInDegrees (vec4 vertex, float degrees)\r\n{\r\n\tfloat angle = degrees * PI / 180.0;\r\n\tfloat sina=sin(angle);\r\n\tfloat cosa=cos(angle);\r\n\tmat2 m = mat2(cosa, -sina, sina, cosa);\r\n\treturn vec4(m*vertex.xz, vertex.yw).xzyw;\r\n}\r\n\t\r\nvoid main()\r\n{\r\n\tvec4 position = rotateAroundYInDegrees(a_Position, u_Rotation);\r\n\t\r\n\r\n\tv_Texcoord=vec3(-a_Position.x,-a_Position.y,a_Position.z);// NOTE: -a_Position.x convert coords system\r\n\r\n\t// Calculate constant horizontal scale and cutoff for 180 (vs 360) image type\r\n\tv_Image180ScaleAndCutoff = vec2(1.0, 1.0);// 360 degree mode\r\n\r\n\t// Calculate constant scale and offset for 3D layouts\r\n\tv_Layout3DScaleAndOffset = vec4(0,0,1,1);\r\n\tgl_Position = u_ViewProjection*position;\r\n\tgl_Position=skyRemapGLPositionZ(gl_Position);\r\n\r\n}\r\n";

    var SkyPanoramicFS = "#define SHADER_NAME SkyPanoramicVS\r\n\r\n#define PI 3.14159265359\r\n\r\nvarying vec3 v_Texcoord;\r\nvarying vec2 v_Image180ScaleAndCutoff;\r\nvarying vec4 v_Layout3DScaleAndOffset;\r\nconst vec4 c_ColorSpace = vec4(4.59479380, 4.59479380, 4.59479380, 2.0);\r\n\r\nvec2 ToRadialCoords(vec3 coords)\r\n{\r\n    vec3 normalizedCoords = normalize(coords);\r\n    float latitude = acos(normalizedCoords.y);\r\n    float longitude = atan(normalizedCoords.z, normalizedCoords.x);\r\n    vec2 sphereCoords = vec2(longitude, latitude) * vec2(0.5 / PI, 1.0 / PI);\r\n    return vec2(0.5, 1.0) - sphereCoords;\r\n}\r\n\r\nvoid main()\r\n{\r\n    vec2 tc = ToRadialCoords(v_Texcoord);\r\n    if (tc.x > v_Image180ScaleAndCutoff.y)\r\n\tgl_FragColor = vec4(0, 0, 0, 1);\r\n    tc.x = mod(tc.x * v_Image180ScaleAndCutoff.x, 1.0);\r\n    tc = (tc + v_Layout3DScaleAndOffset.xy) * v_Layout3DScaleAndOffset.zw;\r\n\r\n    mediump vec4 tex = texture2D(u_Texture, tc);\r\n    mediump vec3 c = tex.xyz;\r\n    c = c * u_TintColor.rgb * c_ColorSpace.rgb;\r\n    c *= u_Exposure;\r\n    gl_FragColor = vec4(c, 1.0);\r\n}\r\n";

    class SkyPanoramicShaderInit {
        static init() {
            let attributeMap = {
                "a_Position": [Laya.VertexMesh.MESH_POSITION0, Laya.ShaderDataType.Vector4]
            };
            let uniformMap = {
                'u_TintColor': Laya.ShaderDataType.Color,
                'u_Rotation': Laya.ShaderDataType.Float,
                'u_Texture': Laya.ShaderDataType.Texture2D,
                'u_Exposure': Laya.ShaderDataType.Float,
            };
            let defaultValue = {
                'u_TintColor': new Laya.Color(0.5, 0.5, 0.5, 1.0),
                'u_Exposure': 1.3,
                'u_Rotation': 0,
                'u_Texture': Laya.Texture2D.grayTexture,
            };
            let shader = Laya.Shader3D.add("SkyPanoramic");
            let subShader = new Laya.SubShader(attributeMap, uniformMap, defaultValue);
            shader.addSubShader(subShader);
            let pass = subShader.addShaderPass(SkyPanoramicVS, SkyPanoramicFS);
            pass.renderState.depthTest = Laya.RenderState.DEPTHTEST_LEQUAL;
            pass.statefirst = true;
        }
    }

    var UtillitiesColorGLSL = "#if !defined(UtillitiesColor_lib)\r\n#define UtillitiesColor_lib\r\n\r\n// Transformations between CIE XYZ tristimulus values and CIE x,y\r\n// chromaticity coordinates\r\nvec3 XYZ_2_xyY(vec3 XYZ)\r\n{\r\n    vec3 xyY;\r\n    float divisor = max(XYZ.x + XYZ.y + XYZ.z, 1e-10);\r\n    xyY.x = XYZ.x / divisor;\r\n    xyY.y = XYZ.y / divisor;\r\n    xyY.z = XYZ.y;\r\n    return xyY;\r\n}\r\n\r\nvec3 xyY_2_XYZ(vec3 xyY)\r\n{\r\n    vec3 XYZ;\r\n    XYZ.x = xyY.x * xyY.z / max(xyY.y, 1e-10);\r\n    XYZ.y = xyY.z;\r\n    XYZ.z = (1.0 - xyY.x - xyY.y) * xyY.z / max(xyY.y, 1e-10);\r\n    return XYZ;\r\n}\r\n\r\nfloat rgb_2_yc(vec3 rgb, float ycRadiusWeight)\r\n{\r\n    float r = rgb.r;\r\n    float g = rgb.g;\r\n    float b = rgb.b;\r\n    float k = b * (b - g) + g * (g - r) + r * (r - b);\r\n    k = max(MEDIUMP_FLT_MIN, k);\r\n    float chroma = sqrt(k);\r\n    return (b + g + r + ycRadiusWeight * chroma) / 3.0;\r\n}\r\n\r\nfloat rgb_2_yc(vec3 rgb)\r\n{\r\n    return rgb_2_yc(rgb, 1.75);\r\n}\r\n\r\n// Transformations from RGB to other color representations\r\n\r\n// Returns a geometric hue angle in degrees (0-360) based on RGB values.\r\nfloat rgb_2_hue(vec3 rgb)\r\n{\r\n    float hue;\r\n    // For neutral colors, hue is undefined and the function will return a quiet NaN value.\r\n    // if (rgb.r == rgb.g && rgb.g == rgb.b) {\r\n    //     // hue = FLT_NAN;\r\n    //     // todo FLT_NAN\r\n    //     hue = 0.0;\r\n    // } else {\r\n    //     hue = (180.0 * INVERT_PI) * atan2(sqrt(3.0) * (rgb.g - rgb.b), 2.0 * rgb.r - rgb.g - rgb.b);\r\n    // }\r\n    if (rgb.x == rgb.y && rgb.y == rgb.z)\r\n        hue = 0.0; // RGB triplets where RGB are equal have an undefined hue\r\n    else\r\n        hue = (180.0 * INVERT_PI) * atan(sqrt(3.0) * (rgb.y - rgb.z), 2.0 * rgb.x - rgb.y - rgb.z);\r\n\r\n    if (hue < 0.0) {\r\n        hue = hue + 360.0;\r\n    }\r\n\r\n    return hue;\r\n}\r\n\r\n#endif // UtillitiesColor_lib";

    var TransformCommonGLSL = "#if !defined(TransformCommon_lib)\r\n    #define TransformCommon_lib\r\n\r\nconst float TINY = 1e-10;\r\n\r\n// sRGB D65 to AP0 D60\r\n// https://www.colour-science.org:8010/apps/rgb_colourspace_transformation_matrix CAT 02\r\nconst mat3 sRGB_to_AP0_MAT = mat3(\r\n    vec3(0.4395856442, 0.0895395735, 0.0173871832),\r\n    vec3(0.3839294030, 0.8147498351, 0.1087391143),\r\n    vec3(0.1765327364, 0.0956836061, 0.8738205876));\r\n\r\n// sRGB D65 to AP1 D60\r\n// https://www.colour-science.org:8010/apps/rgb_colourspace_transformation_matrix CAT 02\r\nconst mat3 sRGB_to_AP1_MAT = mat3(\r\n    vec3(0.6131178129, 0.0699340823, 0.0204629926),\r\n    vec3(0.3411819959, 0.9181030375, 0.1067686634),\r\n    vec3(0.0457873443, 0.0119327755, 0.8727159106));\r\n\r\nconst mat3 AP1_to_XYZ_MAT = mat3(\r\n    vec3(0.6624541811, 0.2722287168, -0.0055746495),\r\n    vec3(0.1340042065, 0.6740817658, 0.0040607335),\r\n    vec3(0.1561876870, 0.0536895174, 1.0103391003));\r\n\r\nconst mat3 AP0_to_AP1_MAT = mat3(\r\n    vec3(1.4514393161, -0.0765537734, 0.0083161484),\r\n    vec3(-0.2365107469, 1.1762296998, -0.0060324498),\r\n    vec3(-0.2149285693, -0.0996759264, 0.9977163014));\r\n\r\nconst mat3 AP1_to_AP0_MAT = mat3(\r\n    vec3(0.6954522414, 0.0447945634, -0.0055258826),\r\n    vec3(0.1406786965, 0.8596711185, 0.0040252103),\r\n    vec3(0.1638690622, 0.0955343182, 1.0015006723));\r\n\r\nconst mat3 XYZ_to_AP1_MAT = mat3(\r\n    vec3(1.6410233797, -0.6636628587, 0.0117218943),\r\n    vec3(-0.3248032942, 1.6153315917, -0.0082844420),\r\n    vec3(-0.2364246952, 0.0167563477, 0.9883948585));\r\n\r\nconst vec3 AP1_RGB2Y = vec3(0.2722287168, 0.6740817658, 0.0536895174);\r\n\r\nfloat ACES_to_ACEScc(float x)\r\n{\r\n    // if (x <= 0.0)\r\n    // return -0.35828683;\r\n    // else if (x < pow(2.0, -15.0))\r\n    // return (log2(pow(2.0, -16.0) + x * 0.5) + 9.72) / 17.52;\r\n    // else\r\n    // return (log2(x) + 9.72) / 17.52;\r\n\r\n    return (x < 0.00003051757) ? (log2(0.00001525878 + x * 0.5) + 9.72) / 17.52 : (log2(x) + 9.72) / 17.52;\r\n}\r\n\r\nvec3 ACES_to_ACEScc(vec3 x)\r\n{\r\n    x = clamp(x, vec3(0.0), vec3(MEDIUMP_FLT_MAX));\r\n    x.x = ACES_to_ACEScc(x.x);\r\n    x.y = ACES_to_ACEScc(x.y);\r\n    x.z = ACES_to_ACEScc(x.z);\r\n\r\n    return x;\r\n}\r\n\r\nfloat ACEScc_to_ACES(float x)\r\n{\r\n    if (x < -0.3013698630)\r\n\treturn (pow(2.0, x * 17.52 - 9.72) - pow(2.0, -16.0)) * 2.0;\r\n    else if (x < (log2(MEDIUMP_FLT_MAX) + 9.72) / 17.52)\r\n\treturn pow(2.0, x * 17.52 - 9.72);\r\n    else\r\n\treturn MEDIUMP_FLT_MAX;\r\n}\r\n\r\nvec3 ACEScc_to_ACES(vec3 x)\r\n{\r\n    x.x = ACEScc_to_ACES(x.x);\r\n    x.y = ACEScc_to_ACES(x.y);\r\n    x.z = ACEScc_to_ACES(x.z);\r\n    return x;\r\n}\r\n\r\nfloat rgb_2_saturation(vec3 rgb)\r\n{\r\n    float rgbmax = vecmax(rgb);\r\n    float rgbmin = vecmin(rgb);\r\n    return (max(rgbmax, TINY) - max(rgbmin, TINY)) / max(rgbmax, 1e-2);\r\n}\r\n\r\n#endif // TransformCommon_lib";

    var RRTCommonGLSL = "#if !defined(RRTCommon_lib)\r\n#define RRTCommon_lib\r\n\r\n// \"Glow\" module constants\r\nconst float RRT_GLOW_GAIN = 0.05;\r\nconst float RRT_GLOW_MID = 0.08;\r\n\r\n// Red modifier constants\r\nconst float RRT_RED_SCALE = 0.82;\r\nconst float RRT_RED_PIVOT = 0.03;\r\nconst float RRT_RED_HUE = 0.;\r\nconst float RRT_RED_WIDTH = 135.;\r\n\r\n// Desaturation contants\r\nconst float RRT_SAT_FACTOR = 0.96;\r\n\r\n// ------- Glow module functions\r\n\r\nfloat glow_fwd(float ycIn, float glowGainIn, float glowMid)\r\n{\r\n    float glowGainOut;\r\n    if (ycIn <= 2.0 / 3.0 * glowMid) {\r\n        glowGainOut = glowGainIn;\r\n    } else if (ycIn >= 2.0 * glowMid) {\r\n        glowGainOut = 0.0;\r\n    } else {\r\n        glowGainOut = glowGainIn * (glowMid / ycIn - 0.5);\r\n    }\r\n    return glowGainOut;\r\n}\r\n\r\n// Sigmoid function in the range 0 to 1 spanning -2 to +2.\r\nfloat sigmoid_shaper(float x)\r\n{\r\n    float t = max(1.0 - abs(x * 0.5), 0.0);\r\n    float y = 1.0 + sign(x) * (1.0 - t * t);\r\n\r\n    return y * 0.5;\r\n}\r\n\r\n// ------- Red modifier functions\r\nfloat center_hue(float hue, float centerH)\r\n{\r\n    float hueCentered = hue - centerH;\r\n    if (hueCentered < -180.0) {\r\n        hueCentered = hueCentered + 360.0;\r\n    } else if (hueCentered > 180.0) {\r\n        hueCentered -= 360.0;\r\n    }\r\n    return hueCentered;\r\n}\r\n\r\n#endif // RRTCommon_lib";

    var ODTCommonGLSL = "#if !defined(ODTCommon_lib)\r\n#define ODTCommon_lib\r\n\r\nconst float CINEMA_WHITE = 48.0;\r\nconst float CINEMA_BLACK = 0.02; // CINEMA_WHITE / 2400.\r\n\r\n// Gamma compensation factor\r\nconst float DIM_SURROUND_GAMMA = 0.9811;\r\n\r\n// Saturation compensation factor\r\nconst float ODT_SAT_FACTOR = 0.93;\r\n\r\n// white point D60 to D65\r\n// ACES white point D60\r\nconst mat3 D60_to_D65_MAT = mat3(\r\n    vec3(0.987224, -0.00759836, 0.00307257),\r\n    vec3(-0.00611327, 1.00186, -0.00509595),\r\n    vec3(0.0159533, 0.00533002, 1.08168));\r\n\r\nfloat Y_2_linCV(float Y, float Ymax, float Ymin)\r\n{\r\n    return (Y - Ymin) / (Ymax - Ymin);\r\n}\r\n\r\nvec3 darkSurround_to_dimSurround(vec3 linearCV)\r\n{\r\n    vec3 XYZ = linearCV * AP1_to_XYZ_MAT;\r\n    vec3 xyY = XYZ_2_xyY(XYZ);\r\n    xyY.z = clamp(xyY.z, 0.0, MEDIUMP_FLT_MAX);\r\n    xyY.z = pow(xyY.z, DIM_SURROUND_GAMMA);\r\n    XYZ = xyY_2_XYZ(xyY);\r\n\r\n    return XYZ * XYZ_to_AP1_MAT;\r\n}\r\n\r\n#endif // ODTCommon_lib";

    var TonescalesGLSL = "#if !defined(Tonescales_lib)\r\n#define Tonescales_lib\r\n\r\nconst mat3 M = mat3(\r\n    vec3(0.5, -1.0, 0.5),\r\n    vec3(-1.0, 1.0, 0.5),\r\n    vec3(0.5, 0.0, 0.0));\r\n\r\nfloat segmented_spline_c5_fwd(float x)\r\n{\r\n#ifdef GRAPHICS_API_GLES3\r\n    const float coefsLow[6] = float[6](-4.0000000000, -4.0000000000, -3.1573765773, -0.4852499958, 1.8477324706, 1.8477324706);\r\n    const float coefsHigh[6] = float[6](-0.7185482425, 2.0810307172, 3.6681241237, 4.0000000000, 4.0000000000, 4.0000000000);\r\n#else\r\n    const float coefsLow_0 = -4.0000000000;\r\n    const float coefsLow_1 = -4.0000000000;\r\n    const float coefsLow_2 = -3.1573765773;\r\n    const float coefsLow_3 = -0.4852499958;\r\n    const float coefsLow_4 = 1.8477324706;\r\n    const float coefsLow_5 = 1.8477324706;\r\n\r\n    const float coefsHigh_0 = -0.7185482425;\r\n    const float coefsHigh_1 = 2.0810307172;\r\n    const float coefsHigh_2 = 3.6681241237;\r\n    const float coefsHigh_3 = 4.0000000000;\r\n    const float coefsHigh_4 = 4.0000000000;\r\n    const float coefsHigh_5 = 4.0000000000;\r\n#endif // GRAPHICS_API_GLES3\r\n\r\n    const vec2 minPoint = vec2(0.0000054931640625, 0.0001);\r\n    const vec2 midPoint = vec2(0.18, 4.8);\r\n    const vec2 maxPoint = vec2(47185.92, 10000.);\r\n    const float slopeLow = 0.0;\r\n    const float slopeHigh = 0.0;\r\n\r\n    const int N_KNOTS_LOW = 4;\r\n    const int N_KNOTS_HIGH = 4;\r\n\r\n    float logx = log10(max(x, MEDIUMP_FLT_MIN));\r\n    float logy;\r\n\r\n    if (logx <= log10(minPoint.x)) {\r\n        logy = logx * slopeLow + (log10(minPoint.y) - slopeLow * log10(minPoint.x));\r\n    } else if ((logx > log10(minPoint.x)) && (logx < log10(midPoint.x))) {\r\n        float knot_coord = float(N_KNOTS_LOW - 1) * (logx - log10(minPoint.x)) / (log10(midPoint.x) - log10(minPoint.x));\r\n        int j = int(knot_coord);\r\n        float t = knot_coord - float(j);\r\n        vec3 cf;\r\n#ifdef GRAPHICS_API_GLES3\r\n        cf = vec3(coefsLow[j], coefsLow[j + 1], coefsLow[j + 2]);\r\n#else\r\n        if (j <= 0) {\r\n            cf = vec3(coefsLow_0, coefsLow_1, coefsLow_2);\r\n        } else if (j == 1) {\r\n            cf = vec3(coefsLow_1, coefsLow_2, coefsLow_3);\r\n        } else if (j == 2) {\r\n            cf = vec3(coefsLow_2, coefsLow_3, coefsLow_4);\r\n        } else { // if (j == 3)\r\n            cf = vec3(coefsLow_3, coefsLow_4, coefsLow_5);\r\n        }\r\n#endif // GRAPHICS_API_GLES3\r\n\r\n        vec3 monomials = vec3(t * t, t, 1.);\r\n        logy = dot(monomials, M * cf);\r\n    } else if ((logx >= log10(midPoint.x)) && (logx < log10(maxPoint.x))) {\r\n        float knot_coord = float(N_KNOTS_HIGH - 1) * (logx - log10(midPoint.x)) / (log10(maxPoint.x) - log10(midPoint.x));\r\n        int j = int(knot_coord);\r\n        float t = knot_coord - float(j);\r\n        vec3 cf;\r\n#ifdef GRAPHICS_API_GLES3\r\n        cf = vec3(coefsHigh[j], coefsHigh[j + 1], coefsHigh[j + 2]);\r\n#else\r\n        if (j <= 0) {\r\n            cf = vec3(coefsHigh_0, coefsHigh_1, coefsHigh_2);\r\n        } else if (j == 1) {\r\n            cf = vec3(coefsHigh_1, coefsHigh_2, coefsHigh_3);\r\n        } else if (j == 2) {\r\n            cf = vec3(coefsHigh_2, coefsHigh_3, coefsHigh_4);\r\n        } else { // if (j == 3)\r\n            cf = vec3(coefsHigh_3, coefsHigh_4, coefsHigh_5);\r\n        }\r\n#endif // #ifdef GRAPHICS_API_GLES3\r\n        vec3 monomials = vec3(t * t, t, 1.);\r\n        logy = dot(monomials, M * cf);\r\n    } else {\r\n        logy = logx * slopeHigh + (log10(maxPoint.y) - slopeHigh * log10(maxPoint.x));\r\n    }\r\n    return pow(10.0, logy);\r\n}\r\n\r\nfloat segmented_spline_c9_fwd(float x)\r\n{\r\n// ODT_48nits\r\n#ifdef GRAPHICS_API_GLES3\r\n    const float coefsLow[10] = float[10](-1.6989700043, -1.6989700043, -1.4779000000, -1.2291000000, -0.8648000000, -0.4480000000, 0.0051800000, 0.4511080334, 0.9113744414, 0.9113744414);\r\n    const float coefsHigh[10] = float[10](0.5154386965, 0.8470437783, 1.1358000000, 1.3802000000, 1.5197000000, 1.5985000000, 1.6467000000, 1.6746091357, 1.6878733390, 1.6878733390);\r\n#else\r\n    const float coefsLow_0 = -1.6989700043;\r\n    const float coefsLow_1 = -1.6989700043;\r\n    const float coefsLow_2 = -1.4779000000;\r\n    const float coefsLow_3 = -1.2291000000;\r\n    const float coefsLow_4 = -0.8648000000;\r\n    const float coefsLow_5 = -0.4480000000;\r\n    const float coefsLow_6 = 0.0051800000;\r\n    const float coefsLow_7 = 0.4511080334;\r\n    const float coefsLow_8 = 0.9113744414;\r\n    const float coefsLow_9 = 0.9113744414;\r\n\r\n    const float coefsHigh_0 = 0.5154386965;\r\n    const float coefsHigh_1 = 0.8470437783;\r\n    const float coefsHigh_2 = 1.1358000000;\r\n    const float coefsHigh_3 = 1.3802000000;\r\n    const float coefsHigh_4 = 1.5197000000;\r\n    const float coefsHigh_5 = 1.5985000000;\r\n    const float coefsHigh_6 = 1.6467000000;\r\n    const float coefsHigh_7 = 1.6746091357;\r\n    const float coefsHigh_8 = 1.6878733390;\r\n    const float coefsHigh_9 = 1.6878733390;\r\n#endif // GRAPHICS_API_GLES3\r\n\r\n    // todo const\r\n    vec2 minPoint = vec2(segmented_spline_c5_fwd(0.18 * pow(2.0, -6.5)), 0.02);\r\n    vec2 midPoint = vec2(segmented_spline_c5_fwd(0.18), 4.8);\r\n    vec2 maxPoint = vec2(segmented_spline_c5_fwd(0.18 * pow(2., 6.5)), 48.0);\r\n\r\n    const float slopeLow = 0.0;\r\n    const float slopeHigh = 0.04;\r\n\r\n    const int N_KNOTS_LOW = 8;\r\n    const int N_KNOTS_HIGH = 8;\r\n\r\n    float logx = log10(max(x, MEDIUMP_FLT_MIN));\r\n    float logy;\r\n\r\n    if (logx <= log10(minPoint.x)) {\r\n        logy = logx * slopeLow + (log10(minPoint.y) - slopeLow * log10(minPoint.x));\r\n    } else if ((logx > log10(minPoint.x)) && (logx < log10(midPoint.x))) {\r\n        float knot_coord = float(N_KNOTS_LOW - 1) * (logx - log10(minPoint.x)) / (log10(midPoint.x) - log10(minPoint.x));\r\n        int j = int(knot_coord);\r\n        float t = knot_coord - float(j);\r\n        vec3 cf;\r\n#ifdef GRAPHICS_API_GLES3\r\n        cf = vec3(coefsLow[j], coefsLow[j + 1], coefsLow[j + 2]);\r\n#else\r\n        if (j <= 0) {\r\n            cf = vec3(coefsLow_0, coefsLow_1, coefsLow_2);\r\n        } else if (j == 1) {\r\n            cf = vec3(coefsLow_1, coefsLow_2, coefsLow_3);\r\n        } else if (j == 2) {\r\n            cf = vec3(coefsLow_2, coefsLow_3, coefsLow_4);\r\n        } else if (j == 3) {\r\n            cf = vec3(coefsLow_3, coefsLow_4, coefsLow_5);\r\n        } else if (j == 4) {\r\n            cf = vec3(coefsLow_4, coefsLow_5, coefsLow_6);\r\n        } else if (j == 5) {\r\n            cf = vec3(coefsLow_5, coefsLow_6, coefsLow_7);\r\n        } else if (j == 6) {\r\n            cf = vec3(coefsLow_6, coefsLow_7, coefsLow_8);\r\n        } else { // if (j == 7)\r\n            cf = vec3(coefsLow_7, coefsLow_8, coefsLow_9);\r\n        }\r\n#endif // GRAPHICS_API_GLES3\r\n        vec3 monomials = vec3(t * t, t, 1.0);\r\n        logy = dot(monomials, M * cf);\r\n    } else if ((logx >= log10(midPoint.x)) && (logx < log10(maxPoint.x))) {\r\n        float knot_coord = float(N_KNOTS_HIGH - 1) * (logx - log10(midPoint.x)) / (log10(maxPoint.x) - log10(midPoint.x));\r\n        int j = int(knot_coord);\r\n        float t = knot_coord - float(j);\r\n        vec3 cf;\r\n#ifdef GRAPHICS_API_GLES3\r\n        cf = vec3(coefsHigh[j], coefsHigh[j + 1], coefsHigh[j + 2]);\r\n#else\r\n        if (j <= 0) {\r\n            cf = vec3(coefsHigh_0, coefsHigh_1, coefsHigh_2);\r\n        } else if (j == 1) {\r\n            cf = vec3(coefsHigh_1, coefsHigh_2, coefsHigh_3);\r\n        } else if (j == 2) {\r\n            cf = vec3(coefsHigh_2, coefsHigh_3, coefsHigh_4);\r\n        } else if (j == 3) {\r\n            cf = vec3(coefsHigh_3, coefsHigh_4, coefsHigh_5);\r\n        } else if (j == 4) {\r\n            cf = vec3(coefsHigh_4, coefsHigh_5, coefsHigh_6);\r\n        } else if (j == 5) {\r\n            cf = vec3(coefsHigh_5, coefsHigh_6, coefsHigh_7);\r\n        } else if (j == 6) {\r\n            cf = vec3(coefsHigh_6, coefsHigh_7, coefsHigh_8);\r\n        } else { // if (j == 7)\r\n            cf = vec3(coefsHigh_7, coefsHigh_8, coefsHigh_9);\r\n        }\r\n#endif // GRAPHICS_API_GLES3\r\n        vec3 monomials = vec3(t * t, t, 1.0);\r\n        logy = dot(monomials, M * cf);\r\n    } else {\r\n        logy = logx * slopeHigh + (log10(maxPoint.y) - slopeHigh * log10(maxPoint.x));\r\n    }\r\n\r\n    return pow(10.0, logy);\r\n}\r\n\r\n#endif // Tonescales_lib";

    var RRTGLSL = "#if !defined(RRT_lib)\r\n#define RRT_lib\r\n\r\n#include \"ACES_RRTCommon.glsl\";\r\n\r\n/**\r\n * @param ACES AP0\r\n * @returns OCES\r\n */\r\nvec3 RRT(vec3 aces)\r\n{\r\n    // --- Glow module --- //\r\n    float saturation = rgb_2_saturation(aces);\r\n    float ycIn = rgb_2_yc(aces);\r\n    float s = sigmoid_shaper((saturation - 0.4) / 0.2);\r\n    float addedGlow = 1.0 + glow_fwd(ycIn, RRT_GLOW_GAIN * s, RRT_GLOW_MID);\r\n\r\n    aces *= addedGlow;\r\n\r\n    // --- Red modifier --- //\r\n    float hue = rgb_2_hue(aces);\r\n    float centeredHue = center_hue(hue, RRT_RED_HUE);\r\n\r\n    float hueWeight = smoothstep(0.0, 1.0, 1.0 - abs(2.0 * centeredHue / RRT_RED_WIDTH));\r\n    hueWeight *= hueWeight;\r\n\r\n    aces.r += hueWeight * saturation * (RRT_RED_PIVOT - aces.r) * (1. - RRT_RED_SCALE);\r\n\r\n    // --- ACES to RGB rendering space --- //\r\n    vec3 rgbPre = AP0_to_AP1_MAT * aces;\r\n    rgbPre = clamp(rgbPre, 0.0, MEDIUMP_FLT_MAX);\r\n\r\n    // --- Global desaturation --- //\r\n    rgbPre = mix(vec3(dot(rgbPre, AP1_RGB2Y)), rgbPre, RRT_SAT_FACTOR);\r\n\r\n    // --- Apply the tonescale independently in rendering-space RGB --- //\r\n    vec3 rgbPost;\r\n    rgbPost.x = segmented_spline_c5_fwd(rgbPre.x);\r\n    rgbPost.y = segmented_spline_c5_fwd(rgbPre.y);\r\n    rgbPost.z = segmented_spline_c5_fwd(rgbPre.z);\r\n\r\n    // --- RGB rendering space to OCES --- //\r\n    vec3 rgbOces = AP1_to_AP0_MAT * rgbPost;\r\n\r\n    return rgbOces;\r\n}\r\n\r\n#endif // RRT_lib";

    var ODT_sRGB_100nits_GLSL = "#if !defined(ODT_sRGB_100nits_lib)\r\n#define ODT_sRGB_100nits_lib\r\n\r\n#include \"ACES_ODTCommon.glsl\";\r\n\r\n// CIE XYZ to REC.709\r\nconst mat3 XYZ_to_REC709_MAT = mat3(\r\n    vec3(3.2409699419, -0.9692436363, 0.0556300797),\r\n    vec3(-1.5373831776, 1.8759675015, -0.2039769589),\r\n    vec3(-0.498610760, 0.0415550574, 1.0569715142));\r\n\r\nconst float DISPGAMMA = 2.4;\r\nconst float OFFSET = 0.055;\r\n\r\nvec3 ODT_sRGB_100nits(vec3 oces)\r\n{\r\n    // OCES to RGB rendering space\r\n    vec3 rgbPre = AP0_to_AP1_MAT * oces;\r\n\r\n    // Apply the tonescale independently in rendering-space RGB\r\n    vec3 rgbPost;\r\n    rgbPost.r = segmented_spline_c9_fwd(rgbPre.r);\r\n    rgbPost.g = segmented_spline_c9_fwd(rgbPre.g);\r\n    rgbPost.b = segmented_spline_c9_fwd(rgbPre.b);\r\n\r\n    // Scale luminance to linear code value\r\n    vec3 linearCV;\r\n    linearCV.r = Y_2_linCV(rgbPost.r, CINEMA_WHITE, CINEMA_BLACK);\r\n    linearCV.g = Y_2_linCV(rgbPost.g, CINEMA_WHITE, CINEMA_BLACK);\r\n    linearCV.b = Y_2_linCV(rgbPost.b, CINEMA_WHITE, CINEMA_BLACK);\r\n\r\n    // Apply gamma adjustment to compensate for dim surround\r\n    linearCV = darkSurround_to_dimSurround(linearCV);\r\n\r\n    // Convert to display primary encoding\r\n    // Rendering space RGB to XYZ\r\n    vec3 XYZ = AP1_to_XYZ_MAT * linearCV;\r\n\r\n    // Apply CAT from ACES white point to assumed observer adapted white point\r\n    XYZ = D60_to_D65_MAT * XYZ;\r\n\r\n    // CIE XYZ to display primaries\r\n    linearCV = XYZ_to_REC709_MAT * XYZ;\r\n\r\n    linearCV = clamp(linearCV, vec3(0.0), vec3(1.0));\r\n    return linearCV;\r\n}\r\n\r\n#endif // ODT_sRGB_100nits_lib";

    var ACESGLSL = "// Academy Color Encoding System (ACES) software and tools are provided by the\r\n// Academy under the following terms and conditions: A worldwide, royalty-free,\r\n// non-exclusive right to copy, modify, create derivatives, and use, in source\r\n// and binary forms, is hereby granted, subject to acceptance of this license.\r\n\r\n// Copyright 2019 Academy of Motion Picture Arts and Sciences (A.M.P.A.S.).\r\n// Portions contributed by others as indicated. All rights reserved.\r\n\r\n// Performance of any of the aforementioned acts indicates acceptance to be\r\n// bound by the following terms and conditions:\r\n\r\n// Copies of source code, in whole or in part, must retain the above copyright\r\n// notice, this list of conditions and the Disclaimer of Warranty.\r\n\r\n// Use in binary form must retain the above copyright notice, this list of\r\n// conditions and the Disclaimer of Warranty in the documentation and/or other\r\n// materials provided with the distribution.\r\n\r\n// Nothing in this license shall be deemed to grant any rights to trademarks,\r\n// copyrights, patents, trade secrets or any other intellectual property of\r\n// A.M.P.A.S. or any contributors, except as expressly stated herein.\r\n\r\n// Neither the name \"A.M.P.A.S.\" nor the name of any other contributors to this\r\n// software may be used to endorse or promote products derivative of or based on\r\n// this software without express prior written permission of A.M.P.A.S. or the\r\n// contributors, as appropriate.\r\n\r\n// This license shall be construed pursuant to the laws of the State of\r\n// California, and any disputes related thereto shall be subject to the\r\n// jurisdiction of the courts therein.\r\n\r\n// Disclaimer of Warranty: THIS SOFTWARE IS PROVIDED BY A.M.P.A.S. AND\r\n// CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT\r\n// NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\r\n// PARTICULAR PURPOSE, AND NON-INFRINGEMENT ARE DISCLAIMED. IN NO EVENT SHALL\r\n// A.M.P.A.S., OR ANY CONTRIBUTORS OR DISTRIBUTORS, BE LIABLE FOR ANY DIRECT,\r\n// INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, RESITUTIONARY, OR CONSEQUENTIAL\r\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\r\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\r\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\r\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n\r\n// WITHOUT LIMITING THE GENERALITY OF THE FOREGOING, THE ACADEMY SPECIFICALLY\r\n// DISCLAIMS ANY REPRESENTATIONS OR WARRANTIES WHATSOEVER RELATED TO PATENT OR\r\n// OTHER INTELLECTUAL PROPERTY RIGHTS IN THE ACADEMY COLOR ENCODING SYSTEM, OR\r\n// APPLICATIONS THEREOF, HELD BY PARTIES OTHER THAN A.M.P.A.S.,WHETHER DISCLOSED\r\n// OR UNDISCLOSED.\r\n\r\n#if !defined(ACES_lib)\r\n#define ACES_lib\r\n\r\n#include \"ACES_TransformCommon.glsl\";\r\n#include \"ACES_UtillitiesColor.glsl\";\r\n#include \"ACES_Tonescales.glsl\";\r\n\r\n#include \"ACES_RRT.glsl\";\r\n#include \"ACES_ODT_sRGB_100nits.glsl\";\r\n\r\n// idt\r\n\r\n// linear D65 sRGB to D60 ACES AP0\r\nvec3 sRGB_to_AP0(vec3 sRGB)\r\n{\r\n    return sRGB_to_AP0_MAT * sRGB;\r\n}\r\n\r\n// linear D65 sRGB to D60 ACES AP1\r\nvec3 sRGB_to_AP1(vec3 sRGB)\r\n{\r\n    return sRGB_to_AP1_MAT * sRGB;\r\n}\r\n\r\n// lmt\r\n// todo\r\n\r\n#endif // ACES_lib";

    class ACESShaderLib {
        static init() {
            Laya.Shader3D.addInclude("ACES_UtillitiesColor.glsl", UtillitiesColorGLSL);
            Laya.Shader3D.addInclude("ACES_TransformCommon.glsl", TransformCommonGLSL);
            Laya.Shader3D.addInclude("ACES_Tonescales.glsl", TonescalesGLSL);
            Laya.Shader3D.addInclude("ACES_RRTCommon.glsl", RRTCommonGLSL);
            Laya.Shader3D.addInclude("ACES_ODTCommon.glsl", ODTCommonGLSL);
            Laya.Shader3D.addInclude("ACES_RRT.glsl", RRTGLSL);
            Laya.Shader3D.addInclude("ACES_ODT_sRGB_100nits.glsl", ODT_sRGB_100nits_GLSL);
            Laya.Shader3D.addInclude("ACES.glsl", ACESGLSL);
        }
    }

    class ShaderInit3D {
        static __init__() {
            Laya.Shader3D.addInclude("Utils.glsl", UtilsGLSL);
            Laya.Shader3D.addInclude("Color.glsl", ColorGLSL);
            Laya.Shader3D.addInclude("Math.glsl", MathGLSL);
            Laya.Shader3D.addInclude("TBNNormal.glsl", TBNNormalGLSL);
            Laya.Shader3D.addInclude("BakedBoneMatrixSampler.glsl", BakedBoneMatrixSamplerGLSL);
            Laya.Shader3D.addInclude("VertexCommon.glsl", VertexGLSL);
            Laya.Shader3D.addInclude("Scene.glsl", SceneGLSL);
            Laya.Shader3D.addInclude("Camera.glsl", CameraGLSL);
            Laya.Shader3D.addInclude("Sprite3DCommon.glsl", Sprite3DCommonGLSL);
            Laya.Shader3D.addInclude("Sprite3DVertex.glsl", Sprite3DVertexGLSL);
            Laya.Shader3D.addInclude("Sprite3DFrag.glsl", Sprite3DFragGLSL);
            Laya.Shader3D.addInclude("DepthVertex.glsl", DepthVertexGLSL);
            Laya.Shader3D.addInclude("DepthFrag.glsl", DepthFragGLSL);
            Laya.Shader3D.addInclude("DepthNormalUtil.glsl", DepthNormalUtilGLSL);
            Laya.Shader3D.addInclude("SceneFog.glsl", SceneFogGLSL);
            Laya.Shader3D.addInclude("SceneFogInput.glsl", SceneFogInputGLSL);
            Laya.Shader3D.addInclude("ShadowSampleTent.glsl", ShadowSampleTentGLSL);
            Laya.Shader3D.addInclude("ShadowSampler.glsl", ShadowSamplerGLSL);
            Laya.Shader3D.addInclude("Lighting.glsl", LightingGLSL);
            Laya.Shader3D.addInclude("globalIllumination.glsl", GlobalIlluminationGLSL);
            Laya.Shader3D.addInclude("BlinnPhongLighting.glsl", BlinnPhongLightingGLSL);
            Laya.Shader3D.addInclude("PBRLighting.glsl", PBRLightingGLSL);
            PBRShaderLib.init();
            ACESShaderLib.init();
            BlitScreenShaderInit.init();
            UnlitShaderInit.init();
            PBRStandardShaderInit.init();
            BlinnPhongShaderInit.init();
            TrailShaderInit.init();
            ParticleShuriKenShaderInit.init();
            SkyBoxShaderInit.init();
            SkyProceduralShaderInit.init();
            SkyPanoramicShaderInit.init();
            Laya.Shader3D.SHADERDEFINE_LEGACYSINGALLIGHTING = Laya.Shader3D.getDefineByName("LEGACYSINGLELIGHTING");
            Laya.Shader3D.SHADERDEFINE_GRAPHICS_API_GLES2 = Laya.Shader3D.getDefineByName("GRAPHICS_API_GLES2");
            Laya.Shader3D.SHADERDEFINE_GRAPHICS_API_GLES3 = Laya.Shader3D.getDefineByName("GRAPHICS_API_GLES3");
            Laya.Shader3D.SHADERDEFINE_ENUNIFORMBLOCK = Laya.Shader3D.getDefineByName("ENUNIFORMBLOCK");
        }
    }

    class IndexBuffer3D extends Laya.IndexBuffer {
        constructor(indexType, indexCount, bufferUsage = Laya.BufferUsage.Static, canRead = false) {
            super(Laya.BufferTargetType.ELEMENT_ARRAY_BUFFER, bufferUsage);
            this._indexType = indexType;
            this._indexCount = indexCount;
            this._canRead = canRead;
            switch (indexType) {
                case Laya.IndexFormat.UInt32:
                    this._indexTypeByteCount = 4;
                    break;
                case Laya.IndexFormat.UInt16:
                    this._indexTypeByteCount = 2;
                    break;
                case Laya.IndexFormat.UInt8:
                    this._indexTypeByteCount = 1;
                    break;
                default:
                    throw new Error("unidentification index type.");
            }
            var byteLength = this._indexTypeByteCount * indexCount;
            this._byteLength = byteLength;
            this._setIndexData(byteLength);
            if (canRead) {
                switch (indexType) {
                    case Laya.IndexFormat.UInt32:
                        this._buffer = new Uint32Array(indexCount);
                        break;
                    case Laya.IndexFormat.UInt16:
                        this._buffer = new Uint16Array(indexCount);
                        break;
                    case Laya.IndexFormat.UInt8:
                        this._buffer = new Uint8Array(indexCount);
                        break;
                }
            }
        }
        get indexType() {
            return this._indexType;
        }
        get indexTypeByteCount() {
            return this._indexTypeByteCount;
        }
        get indexCount() {
            return this._indexCount;
        }
        get canRead() {
            return this._canRead;
        }
        setData(data, bufferOffset = 0, dataStartIndex = 0, dataCount = 4294967295) {
            var byteCount = this._indexTypeByteCount;
            if (dataStartIndex !== 0 || dataCount !== 4294967295) {
                switch (this._indexType) {
                    case Laya.IndexFormat.UInt32:
                        data = new Uint32Array(data.buffer, dataStartIndex * byteCount, dataCount);
                        break;
                    case Laya.IndexFormat.UInt16:
                        data = new Uint16Array(data.buffer, dataStartIndex * byteCount, dataCount);
                        break;
                    case Laya.IndexFormat.UInt8:
                        data = new Uint8Array(data.buffer, dataStartIndex * byteCount, dataCount);
                        break;
                }
            }
            this._setIndexData(data, bufferOffset * byteCount);
            if (this._canRead) {
                if (bufferOffset !== 0 || dataStartIndex !== 0 || dataCount !== 4294967295) {
                    var maxLength = this._buffer.length - bufferOffset;
                    if (dataCount > maxLength)
                        dataCount = maxLength;
                    if (typeof data == typeof this._buffer && data.length == dataCount)
                        this._buffer.set(data, bufferOffset);
                    else
                        for (var i = 0; i < dataCount; i++)
                            this._buffer[bufferOffset + i] = data[i];
                }
                else {
                    this._buffer = data;
                }
            }
        }
        getData() {
            if (this._canRead)
                return this._buffer;
            else
                throw new Error("Can't read data from VertexBuffer with only write flag!");
        }
        destroy() {
            super.destroy();
            this._buffer = null;
            this._byteLength = 0;
            this._indexCount = 0;
        }
    }

    class VertexBuffer3D extends Laya.VertexBuffer {
        constructor(byteLength, bufferUsage, canRead = false) {
            super(Laya.BufferTargetType.ARRAY_BUFFER, bufferUsage);
            this._float32Reader = null;
            this._canRead = canRead;
            this._byteLength = byteLength;
            this.bind();
            this._glBuffer.setDataLength(byteLength);
            if (this._canRead) {
                this._buffer = new Uint8Array(byteLength);
                this._float32Reader = new Float32Array(this._buffer.buffer);
            }
        }
        get vertexDeclaration() {
            return this._vertexDeclaration;
        }
        set vertexDeclaration(value) {
            this._vertexDeclaration = value;
        }
        get canRead() {
            return this._canRead;
        }
        orphanStorage() {
            this.bind();
            this._glBuffer.setDataLength(this._byteLength);
        }
        setData(buffer, bufferOffset = 0, dataStartIndex = 0, dataCount = Number.MAX_SAFE_INTEGER) {
            this.bind();
            var needSubData = dataStartIndex !== 0 || dataCount !== Number.MAX_SAFE_INTEGER;
            if (needSubData) {
                var subData = new Uint8Array(buffer, dataStartIndex, dataCount);
                this._glBuffer.setData(subData, bufferOffset);
                if (this._canRead)
                    this._buffer.set(subData, bufferOffset);
            }
            else {
                this._glBuffer.setData(buffer, bufferOffset);
                if (this._canRead)
                    this._buffer.set(new Uint8Array(buffer), bufferOffset);
            }
        }
        getUint8Data() {
            if (this._canRead)
                return this._buffer;
            else
                throw new Error("Can't read data from VertexBuffer with only write flag!");
        }
        getFloat32Data() {
            if (this._canRead)
                return this._float32Reader;
            else
                throw new Error("Can't read data from VertexBuffer with only write flag!");
        }
        markAsUnreadbale() {
            this._canRead = false;
            this._buffer = null;
            this._float32Reader = null;
        }
        destroy() {
            super.destroy();
            this._buffer = null;
            this._float32Reader = null;
            this._vertexDeclaration = null;
            this._byteLength = 0;
        }
    }

    class BoundsImpl {
        constructor(min, max) {
            this._updateFlag = 0;
            this._center = new Laya.Vector3();
            this._extent = new Laya.Vector3();
            this._boundBox = new BoundBox(new Laya.Vector3(), new Laya.Vector3());
            min && min.cloneTo(this._boundBox.min);
            max && max.cloneTo(this._boundBox.max);
            this._setUpdateFlag(BoundsImpl._UPDATE_CENTER | BoundsImpl._UPDATE_EXTENT, true);
        }
        get min() {
            return this.getMin();
        }
        set min(value) {
            this.setMin(value);
        }
        get max() {
            return this.getMax();
        }
        set max(value) {
            this.setMax(value);
        }
        setMin(value) {
            var min = this._boundBox.min;
            if (value !== min)
                value.cloneTo(min);
            this._setUpdateFlag(BoundsImpl._UPDATE_CENTER | BoundsImpl._UPDATE_EXTENT, true);
            this._setUpdateFlag(BoundsImpl._UPDATE_MIN, false);
        }
        getMin() {
            var min = this._boundBox.min;
            if (this._getUpdateFlag(BoundsImpl._UPDATE_MIN)) {
                this._getMin(this.getCenter(), this.getExtent(), min);
                this._setUpdateFlag(BoundsImpl._UPDATE_MIN, false);
            }
            return min;
        }
        setMax(value) {
            var max = this._boundBox.max;
            if (value !== max)
                value.cloneTo(max);
            this._setUpdateFlag(BoundsImpl._UPDATE_CENTER | BoundsImpl._UPDATE_EXTENT, true);
            this._setUpdateFlag(BoundsImpl._UPDATE_MAX, false);
        }
        getMax() {
            var max = this._boundBox.max;
            if (this._getUpdateFlag(BoundsImpl._UPDATE_MAX)) {
                this._getMax(this.getCenter(), this.getExtent(), max);
                this._setUpdateFlag(BoundsImpl._UPDATE_MAX, false);
            }
            return max;
        }
        setCenter(value) {
            if (value !== this._center)
                value.cloneTo(this._center);
            this._setUpdateFlag(BoundsImpl._UPDATE_MIN | BoundsImpl._UPDATE_MAX, true);
            this._setUpdateFlag(BoundsImpl._UPDATE_CENTER, false);
        }
        getCenter() {
            if (this._getUpdateFlag(BoundsImpl._UPDATE_CENTER)) {
                this._getCenter(this.getMin(), this.getMax(), this._center);
                this._setUpdateFlag(BoundsImpl._UPDATE_CENTER, false);
            }
            return this._center;
        }
        setExtent(value) {
            if (value !== this._extent)
                value.cloneTo(this._extent);
            this._setUpdateFlag(BoundsImpl._UPDATE_MIN | BoundsImpl._UPDATE_MAX, true);
            this._setUpdateFlag(BoundsImpl._UPDATE_EXTENT, false);
        }
        getExtent() {
            if (this._getUpdateFlag(BoundsImpl._UPDATE_EXTENT)) {
                this._getExtent(this.getMin(), this.getMax(), this._extent);
                this._setUpdateFlag(BoundsImpl._UPDATE_EXTENT, false);
            }
            return this._extent;
        }
        _getUpdateFlag(type) {
            return (this._updateFlag & type) != 0;
        }
        _setUpdateFlag(type, value) {
            if (value)
                this._updateFlag |= type;
            else
                this._updateFlag &= ~type;
        }
        _getCenter(min, max, out) {
            Laya.Vector3.add(min, max, out);
            Laya.Vector3.scale(out, 0.5, out);
        }
        _getExtent(min, max, out) {
            Laya.Vector3.subtract(max, min, out);
            Laya.Vector3.scale(out, 0.5, out);
        }
        _getMin(center, extent, out) {
            Laya.Vector3.subtract(center, extent, out);
        }
        _getMax(center, extent, out) {
            Laya.Vector3.add(center, extent, out);
        }
        _rotateExtents(extents, rotation, out) {
            var extentsX = extents.x;
            var extentsY = extents.y;
            var extentsZ = extents.z;
            var matE = rotation.elements;
            out.x = Math.abs(matE[0] * extentsX) + Math.abs(matE[4] * extentsY) + Math.abs(matE[8] * extentsZ);
            out.y = Math.abs(matE[1] * extentsX) + Math.abs(matE[5] * extentsY) + Math.abs(matE[9] * extentsZ);
            out.z = Math.abs(matE[2] * extentsX) + Math.abs(matE[6] * extentsY) + Math.abs(matE[10] * extentsZ);
        }
        _tranform(matrix, out) {
            var outCen = out._center;
            var outExt = out._extent;
            Laya.Vector3.transformCoordinate(this.getCenter(), matrix, outCen);
            this._rotateExtents(this.getExtent(), matrix, outExt);
            out._boundBox.setCenterAndExtent(outCen, outExt);
            out._updateFlag = 0;
        }
        _getBoundBox() {
            if (this._updateFlag & BoundsImpl._UPDATE_MIN) {
                var min = this._boundBox.min;
                this._getMin(this.getCenter(), this.getExtent(), min);
                this._setUpdateFlag(BoundsImpl._UPDATE_MIN, false);
            }
            if (this._updateFlag & BoundsImpl._UPDATE_MAX) {
                var max = this._boundBox.max;
                this._getMax(this.getCenter(), this.getExtent(), max);
                this._setUpdateFlag(BoundsImpl._UPDATE_MAX, false);
            }
            return this._boundBox;
        }
        calculateBoundsintersection(bounds) {
            var ownMax = this.getMax();
            var ownMin = this.getMin();
            var calMax = bounds.getMax();
            var calMin = bounds.getMin();
            var tempV0 = TEMP_VECTOR3_MAX0$1;
            var tempV1 = TEMP_VECTOR3_MAX1$1;
            var thisExtends = this.getExtent();
            var boundExtends = bounds.getExtent();
            tempV0.setValue(Math.max(ownMax.x, calMax.x) - Math.min(ownMin.x, calMin.x), Math.max(ownMax.y, calMax.y) - Math.min(ownMin.y, calMin.y), Math.max(ownMax.z, calMax.z) - Math.min(ownMin.z, calMin.z));
            tempV1.setValue((thisExtends.x + boundExtends.x) * 2.0, (thisExtends.y + boundExtends.y) * 2.0, (thisExtends.z + boundExtends.z) * 2.0);
            if ((tempV0.x) > (tempV1.x))
                return -1;
            if ((tempV0.y) > (tempV1.y))
                return -1;
            if ((tempV0.z) > (tempV1.z))
                return -1;
            return (tempV1.x - tempV0.x) * (tempV1.y - tempV0.y) * (tempV1.z - tempV0.z);
        }
        cloneTo(destObject) {
            var destBounds = destObject;
            this.getMin().cloneTo(destBounds._boundBox.min);
            this.getMax().cloneTo(destBounds._boundBox.max);
            this.getCenter().cloneTo(destBounds._center);
            this.getExtent().cloneTo(destBounds._extent);
            destBounds._updateFlag = 0;
        }
        clone() {
            var dest = new BoundsImpl(new Laya.Vector3(), new Laya.Vector3());
            this.cloneTo(dest);
            return dest;
        }
    }
    BoundsImpl._UPDATE_MIN = 0x01;
    BoundsImpl._UPDATE_MAX = 0x02;
    BoundsImpl._UPDATE_CENTER = 0x04;
    BoundsImpl._UPDATE_EXTENT = 0x08;
    const TEMP_VECTOR3_MAX0$1 = new Laya.Vector3();
    const TEMP_VECTOR3_MAX1$1 = new Laya.Vector3();

    class BaseRenderNode {
    }

    class RenderElementBatch {
        constructor() {
            RenderElementBatch.instance = this;
            this._instanceBatchManager = InstanceBatchManager.instance;
            this._recoverList = new Laya.SingletonList();
        }
        recoverData() {
            let elements = this._recoverList.elements;
            for (let i = 0, n = this._recoverList.length; i < n; i++) {
                let element = elements[i];
                element.recover();
            }
            this._recoverList.length = 0;
        }
        batch(elements) {
            let len = elements.length;
            elements.length = 0;
            this._instanceBatchManager.updateCountMark++;
            let elementArray = elements.elements;
            for (var i = 0; i < len; i++) {
                let element = elements.elements[i];
                if (!element._canBatch) {
                    elements.add(element);
                    continue;
                }
                if (element.staticBatch && (!element.render._probReflection || element.render._probReflection._isScene) && Laya.Config3D.enableStaticBatch) {
                    elements.add(element);
                }
                else if (Laya.Config3D.enableDynamicBatch && Laya.LayaGL.renderEngine.getCapable(Laya.RenderCapable.DrawElement_Instance)) {
                    if (element.renderSubShader._owner._enableInstancing && element.render.lightmapIndex < 0) {
                        var insManager = this._instanceBatchManager;
                        var insBatchMarks = insManager.getInstanceBatchOpaquaMark(element.render.receiveShadow, element.material.id, element._geometry._id, element.transform ? element.transform._isFrontFaceInvert : false, element.render._probReflection ? element.render._probReflection.id : -1);
                        if (insManager.updateCountMark === insBatchMarks.updateMark) {
                            var insBatchIndex = insBatchMarks.indexInList;
                            var insOriElement = elementArray[insBatchIndex];
                            if (insBatchMarks.batched) {
                                var instanceelements = insOriElement._instanceBatchElementList;
                                if (instanceelements.length === SubMeshInstanceBatch.maxInstanceCount) {
                                    insBatchMarks.updateMark = insManager.updateCountMark;
                                    insBatchMarks.indexInList = elements.length;
                                    insBatchMarks.batched = false;
                                    elements.add(element);
                                }
                                else {
                                    instanceelements.add(element);
                                }
                            }
                            else {
                                let instanceRenderElement = InstanceRenderElement.create();
                                this._recoverList.add(instanceRenderElement);
                                instanceRenderElement.render = insOriElement.render;
                                instanceRenderElement.renderType = RenderElement.RENDERTYPE_INSTANCEBATCH;
                                instanceRenderElement._geometry.subMesh = insOriElement._geometry;
                                instanceRenderElement.material = insOriElement.material;
                                instanceRenderElement.setTransform(null);
                                instanceRenderElement.renderSubShader = insOriElement.renderSubShader;
                                let list = instanceRenderElement._instanceBatchElementList;
                                list.length = 0;
                                list.add(insOriElement);
                                list.add(element);
                                elementArray[insBatchIndex] = instanceRenderElement;
                                insBatchMarks.batched = true;
                                instanceRenderElement._isUpdataData = true;
                            }
                        }
                        else {
                            insBatchMarks.updateMark = insManager.updateCountMark;
                            insBatchMarks.indexInList = elements.length;
                            insBatchMarks.batched = false;
                            elements.add(element);
                        }
                    }
                    else
                        elements.add(element);
                }
                else
                    elements.add(element);
            }
        }
    }

    class BaseRenderQueue {
        constructor(isTransparent) {
            this._isTransparent = false;
            this.elements = new Laya.SingletonList();
            this._isTransparent = isTransparent;
            this._batch = RenderElementBatch.instance ? RenderElementBatch.instance : new RenderElementBatch();
        }
        set sortPass(value) {
            this._sortPass = value;
        }
        set context(value) {
            this._context = value._contextOBJ;
        }
        addRenderElement(renderelement) {
            this.elements.add(renderelement);
        }
        clear() {
            this.elements.length = 0;
        }
        renderQueue(context) {
            this.context = context;
            this._context.applyContext(Camera._updateMark);
            var elements = this.elements.elements;
            this._batchQueue();
            for (var i = 0, n = this.elements.length; i < n; i++) {
                elements[i]._renderUpdatePre(context);
            }
            this._sort();
            for (var i = 0, n = this.elements.length; i < n; i++)
                elements[i]._render(this._context);
            Laya.BufferState._curBindedBufferState && Laya.BufferState._curBindedBufferState.unBind();
            this._batch.recoverData();
            return n;
        }
        _batchQueue() {
            this._isTransparent || this._batch.batch(this.elements);
        }
        _sort() {
            var count = this.elements.length;
            this._sortPass.sort(this.elements, this._isTransparent, 0, count - 1);
        }
        destroy() {
            this.elements.destroy();
        }
    }

    class CameraCullInfo {
    }

    class RenderElementOBJ {
        constructor() {
            this._shaderInstances = new Laya.SingletonList();
        }
        _addShaderInstance(shader) {
            this._shaderInstances.add(shader);
        }
        _clearShaderInstance() {
            this._shaderInstances.length = 0;
        }
        _render(context) {
            var forceInvertFace = context.invertY;
            var updateMark = context.cameraUpdateMark;
            var sceneID = context.sceneID;
            var sceneShaderData = context.sceneShaderData;
            var cameraShaderData = context.cameraShaderData;
            if (this._isRender) {
                var passes = this._shaderInstances.elements;
                for (var j = 0, m = this._shaderInstances.length; j < m; j++) {
                    const shaderIns = passes[j];
                    if (!shaderIns.complete)
                        continue;
                    var switchShader = shaderIns.bind();
                    var switchUpdateMark = (updateMark !== shaderIns._uploadMark);
                    var uploadScene = (shaderIns._uploadScene !== sceneID) || switchUpdateMark;
                    if (uploadScene || switchShader) {
                        sceneShaderData && shaderIns.uploadUniforms(shaderIns._sceneUniformParamsMap, sceneShaderData, uploadScene);
                        shaderIns._uploadScene = sceneID;
                    }
                    if (this._renderShaderData) {
                        var uploadSprite3D = (shaderIns._uploadRender !== this._renderShaderData) || switchUpdateMark;
                        if (uploadSprite3D || switchShader) {
                            shaderIns.uploadUniforms(shaderIns._spriteUniformParamsMap, this._renderShaderData, uploadSprite3D);
                            shaderIns._uploadRender = this._renderShaderData;
                        }
                    }
                    var uploadCamera = shaderIns._uploadCameraShaderValue !== cameraShaderData || switchUpdateMark;
                    if (uploadCamera || switchShader) {
                        cameraShaderData && shaderIns.uploadUniforms(shaderIns._cameraUniformParamsMap, cameraShaderData, uploadCamera);
                        shaderIns._uploadCameraShaderValue = cameraShaderData;
                    }
                    var uploadMaterial = (shaderIns._uploadMaterial !== this._materialShaderData) || switchUpdateMark;
                    if (uploadMaterial || switchShader) {
                        shaderIns.uploadUniforms(shaderIns._materialUniformParamsMap, this._materialShaderData, uploadMaterial);
                        shaderIns._uploadMaterial = this._materialShaderData;
                        context.globalShaderData && shaderIns.uploadUniforms(shaderIns._materialUniformParamsMap, context.globalShaderData, uploadMaterial);
                    }
                    shaderIns.uploadRenderStateBlendDepth(this._materialShaderData);
                    shaderIns.uploadRenderStateFrontFace(this._materialShaderData, forceInvertFace, this._invertFront);
                    this.drawGeometry(shaderIns);
                }
            }
        }
        drawGeometry(shaderIns) {
            Laya.LayaGL.renderDrawContext.drawGeometryElement(this._geometry);
        }
        _destroy() {
            this._geometry = null;
            this._shaderInstances = null;
            this._materialShaderData = null;
            this._renderShaderData = null;
            this._transform = null;
            this._isRender = null;
        }
    }

    class InstanceRenderElementOBJ extends RenderElementOBJ {
        constructor() {
            super();
            this._vertexBuffer3D = [];
            this._updateData = [];
            this._updateDataNum = [];
        }
        addUpdateBuffer(vb, length) {
            this._vertexBuffer3D[this.updateNums] = vb;
            this._updateDataNum[this.updateNums++] = length;
        }
        getUpdateData(index, length) {
            let data = this._updateData[index];
            if (!data || data.length < length) {
                data = this._updateData[index] = new Float32Array(length);
            }
            return data;
        }
        drawGeometry(shaderIns) {
            let data;
            let buffer;
            for (let i = 0; i < this.updateNums; i++) {
                buffer = this._vertexBuffer3D[i];
                if (!buffer)
                    break;
                data = this._updateData[i];
                buffer.orphanStorage();
                buffer.setData(data.buffer, 0, 0, this.drawCount * this._updateDataNum[i] * 4);
            }
            Laya.LayaGL.renderDrawContext.drawGeometryElement(this._geometry);
        }
        clear() {
            this.updateNums = 0;
        }
    }

    class QuickSort {
        sort(elements, isTransparent, left, right) {
            this.elementArray = elements;
            this.isTransparent = isTransparent;
            this._quickSort(left, right);
        }
        _quickSort(left, right) {
            if (this.elementArray.length > 1) {
                var index = this._partitionRenderObject(left, right);
                var leftIndex = index - 1;
                if (left < leftIndex)
                    this._quickSort(left, leftIndex);
                if (index < right)
                    this._quickSort(index, right);
            }
        }
        _partitionRenderObject(left, right) {
            var elements = this.elementArray.elements;
            var pivot = elements[Math.floor((right + left) / 2)];
            while (left <= right) {
                while (this._compare(elements[left], pivot) < 0)
                    left++;
                while (this._compare(elements[right], pivot) > 0)
                    right--;
                if (left < right) {
                    var temp = elements[left];
                    elements[left] = elements[right];
                    elements[right] = temp;
                    left++;
                    right--;
                }
                else if (left === right) {
                    left++;
                    break;
                }
            }
            return left;
        }
        _compare(left, right) {
            var renderQueue = left.material.renderQueue - right.material.renderQueue;
            if (renderQueue === 0) {
                var sort = this.isTransparent ? right.render.distanceForSort - left.render.distanceForSort : left.render.distanceForSort - right.render.distanceForSort;
                return sort + right.render.sortingFudge - left.render.sortingFudge;
            }
            else {
                return renderQueue;
            }
        }
    }

    class RenderContext3DOBJ {
        constructor() {
            this.invertY = false;
            this.viewPort = new Viewport(0, 0, 0, 0);
            this.scissor = new Laya.Vector4();
            this.pipelineMode = "Forward";
        }
        applyContext(cameraUpdateMark) {
            this.destTarget && this.destTarget._start();
            this.cameraUpdateMark = cameraUpdateMark;
            Laya.LayaGL.renderEngine.viewport(this.viewPort.x, this.viewPort.y, this.viewPort.width, this.viewPort.height);
            Laya.LayaGL.renderEngine.scissor(this.scissor.x, this.scissor.y, this.scissor.z, this.scissor.w);
        }
        drawRenderElement(renderelemt) {
            renderelemt._render(this);
        }
    }

    class RenderGeometryElementOBJ {
        constructor(mode, drawType) {
            this.mode = mode;
            this.drawParams = new Laya.SingletonList();
            this.drawType = drawType;
        }
        setDrawArrayParams(first, count) {
            this.drawParams.add(first);
            this.drawParams.add(count);
        }
        setDrawElemenParams(count, offset) {
            this.drawParams.add(offset);
            this.drawParams.add(count);
        }
        destroy() {
        }
        clearRenderParams() {
            this.drawParams.length = 0;
        }
    }

    class SceneRenderManagerOBJ {
        constructor() {
            this._renders = new Laya.SingletonList();
            this._motionRenders = new Laya.SingletonList();
        }
        get list() {
            return this._renders;
        }
        set list(value) {
            this._renders = value;
        }
        addRenderObject(object) {
            this._renders.add(object);
        }
        removeRenderObject(object) {
            this._renders.remove(object);
            this.removeMotionObject(object);
        }
        removeMotionObject(object) {
            let index = object._motionIndexList;
            if (index != -1) {
                let elements = this._motionRenders.elements;
                this._motionRenders.length -= 1;
                elements[length]._motionIndexList = index;
                elements[index] = elements[length];
            }
        }
        updateMotionObjects() {
            for (let i = 0; i < this._motionRenders.length; i++) {
                this._motionRenders.elements[i].bounds;
                this._motionRenders.elements[i]._motionIndexList = -1;
            }
            this._motionRenders.length = 0;
        }
        addMotionObject(object) {
            if (object._motionIndexList == -1) {
                object._motionIndexList = this._motionRenders.length;
                this._motionRenders.add(object);
            }
        }
        destroy() {
            this._renders.destroy();
        }
    }

    class ShadowCullInfo {
    }

    class SkinRenderElementOBJ extends RenderElementOBJ {
        constructor() {
            super();
        }
        drawGeometry(shaderIns) {
            let length = this._shaderInstances.length;
            let element = this._geometry.drawParams.elements;
            if (!this.skinnedData)
                return;
            this._geometry.bufferState.bind();
            for (var i = 0, n = length; i < n; i++) {
                for (var j = 0, m = this._geometry.drawParams.length / 2; j < m; j++) {
                    var subSkinnedDatas = this.skinnedData[j];
                    shaderIns.uploadCustomUniform(SkinnedMeshSprite3D.BONES, subSkinnedDatas);
                    var offset = j * 2;
                    Laya.LayaGL.renderDrawContext.drawElements(this._geometry.mode, element[offset + 1], this._geometry.indexFormat, element[offset]);
                }
            }
        }
    }

    class RenderOBJCreateUtil {
        constructor() {
            this.globalBlockMap = {};
        }
        createTransform(owner) {
            return new Transform3D(owner);
        }
        createBounds(min, max) {
            return new BoundsImpl(min, max);
        }
        createShaderData() {
            return new Laya.ShaderData();
        }
        createRenderElement() {
            return new RenderElementOBJ();
        }
        createSkinRenderElement() {
            return new SkinRenderElementOBJ();
        }
        createInstanceRenderElement() {
            return new InstanceRenderElementOBJ();
        }
        createBaseRenderQueue(isTransparent) {
            var queue = new BaseRenderQueue(isTransparent);
            queue.sortPass = this.createSortPass();
            return queue;
        }
        createRenderGeometry(mode, drayType) {
            return new RenderGeometryElementOBJ(mode, drayType);
        }
        createVertexBuffer3D(byteLength, bufferUsage, canRead = false) {
            return new VertexBuffer3D(byteLength, bufferUsage, canRead);
        }
        createIndexBuffer3D(indexType, indexCount, bufferUsage = Laya.BufferUsage.Static, canRead = false) {
            return new IndexBuffer3D(indexType, indexCount, bufferUsage, canRead);
        }
        createShaderInstance(vs, ps, attributeMap, shaderPass) {
            return new Laya.ShaderInstance(vs, ps, attributeMap, shaderPass);
        }
        createBaseRenderNode() {
            return new BaseRenderNode();
        }
        createRenderContext3D() {
            return new RenderContext3DOBJ();
        }
        createSceneRenderManager() {
            return new SceneRenderManagerOBJ();
        }
        createCullPass() {
            return new CullPassBase();
        }
        createSortPass() {
            return new QuickSort();
        }
        createShadowCullInfo() {
            return new ShadowCullInfo();
        }
        createCameraCullInfo() {
            return new CameraCullInfo();
        }
        createRenderStateComand() {
            return new Laya.RenderStateCommand();
        }
        createRenderState() {
            return new Laya.RenderState();
        }
        createUniformBufferObject(glPointer, name, bufferUsage, byteLength, isSingle) {
            return new Laya.UniformBufferObject(glPointer, name, bufferUsage, byteLength, isSingle);
        }
        createGlobalUniformMap(blockName) {
            let comMap = this.globalBlockMap[blockName];
            if (!comMap)
                comMap = this.globalBlockMap[blockName] = new Laya.CommandUniformMap(blockName);
            return comMap;
        }
    }

    class NativeBaseRenderNode {
        constructor() {
            this._bounds = null;
            this._geometryBounds = null;
            this._transform = null;
            this._nativeObj = new window.conchRenderNode();
        }
        set boundsChange(value) {
            this._nativeObj.boundsChange = value;
        }
        get boundsChange() {
            return this._nativeObj.boundsChange;
        }
        set layer(value) {
            this._nativeObj.layer = value;
        }
        get layer() {
            return this._nativeObj.layer;
        }
        get renderId() {
            return this._nativeObj.renderId;
        }
        set renderId(value) {
            this._nativeObj.renderId = value;
        }
        get receiveShadow() {
            return this._nativeObj.receiveShadow;
        }
        set receiveShadow(value) {
            this._nativeObj.receiveShadow = value;
        }
        get castShadow() {
            return this._nativeObj.castShadow;
        }
        set castShadow(value) {
            this._nativeObj.castShadow = value;
        }
        get bounds() {
            return this._bounds;
        }
        set bounds(value) {
            this._bounds = value;
            this._nativeObj.bounds = value._imp._nativeObj;
        }
        get distanceForSort() {
            return this._nativeObj.distanceForSort;
        }
        set distanceForSort(value) {
            this._nativeObj.distanceForSort = value;
        }
        get transform() {
            return this._transform;
        }
        set transform(value) {
            this._transform = value;
            this._nativeObj.transform = value ? value._nativeObj : null;
        }
        get owner() {
            return this._nativeObj.owner;
        }
        set owner(value) {
            this._nativeObj.owner = value;
        }
        get geometryBounds() {
            return this._geometryBounds;
        }
        set geometryBounds(value) {
            this._geometryBounds = value;
            this._nativeObj.geometryBounds = value._imp._nativeObj;
        }
        get renderbitFlag() {
            return this._nativeObj.renderbitFlag;
        }
        set renderbitFlag(value) {
            this._nativeObj.renderbitFlag = value;
        }
        get staticMask() {
            return this._nativeObj.staticMask;
        }
        set staticMask(value) {
            this._nativeObj.staticMask = value;
        }
    }

    class NativeBaseRenderQueue {
        constructor(isTransparent) {
            this._isTransparent = false;
            this.elements = new Laya.SingletonList();
            this._isTransparent = isTransparent;
            this._nativeObj = new window.conchRenderQueue(isTransparent);
            this._batch = RenderElementBatch.instance ? RenderElementBatch.instance : new RenderElementBatch();
        }
        set sortPass(value) {
            this._nativeObj.sortPass = value;
        }
        destroy() {
            this._nativeObj.destroy();
        }
        set context(value) {
            this._context = value._contextOBJ;
        }
        addRenderElement(renderelement) {
            this.elements.add(renderelement);
        }
        clear() {
            this._nativeObj.clear();
            this.elements.length = 0;
        }
        renderQueue(context) {
            this.context = context;
            this._context.applyContext(Camera._updateMark);
            var elements = this.elements.elements;
            this._batchQueue();
            this._nativeObj.clear();
            for (var i = 0, n = this.elements.length; i < n; i++) {
                var render_element = elements[i];
                this._nativeObj.addRenderElement(render_element._renderElementOBJ._nativeObj, render_element.render.renderNode._nativeObj, render_element.material.renderQueue, render_element.render.sortingFudge);
                render_element._renderUpdatePre(context);
            }
            Laya.UploadMemoryManager.syncRenderMemory();
            Laya.BufferState._curBindedBufferState && Laya.BufferState._curBindedBufferState.unBind();
            this._nativeObj.renderQueue(this._context._nativeObj);
            this._batch.recoverData();
            return n;
        }
        _batchQueue() {
            this._isTransparent || this._batch.batch(this.elements);
        }
    }

    class NativeBounds {
        constructor(min, max) {
            this._center = new Laya.Vector3();
            this._extent = new Laya.Vector3();
            this._boundBox = new BoundBox(new Laya.Vector3(), new Laya.Vector3());
            this.nativeMemory = new Laya.NativeMemory(NativeBounds.MemoryBlock_size, true);
            this.float32Array = this.nativeMemory.float32Array;
            this.float64Array = this.nativeMemory.float64Array;
            this._nativeObj = new window.conchBounds(this.nativeMemory._buffer);
            min && this.setMin(min);
            max && this.setMax(max);
        }
        get min() {
            return this.getMin();
        }
        set min(value) {
            this.setMin(value);
        }
        get max() {
            return this.getMax();
        }
        set max(value) {
            this.setMax(value);
        }
        setMin(value) {
            this.float64Array[0] = value.x;
            this.float64Array[1] = value.y;
            this.float64Array[2] = value.z;
            this._nativeObj.setMin();
        }
        getMin() {
            var min = this._boundBox.min;
            this._nativeObj.getMin();
            min.x = this.float64Array[0];
            min.y = this.float64Array[1];
            min.z = this.float64Array[2];
            return min;
        }
        setMax(value) {
            this.float64Array[0] = value.x;
            this.float64Array[1] = value.y;
            this.float64Array[2] = value.z;
            this._nativeObj.setMax();
        }
        getMax() {
            var max = this._boundBox.max;
            this._nativeObj.getMax();
            max.x = this.float64Array[0];
            max.y = this.float64Array[1];
            max.z = this.float64Array[2];
            return max;
        }
        setCenter(value) {
            this.float64Array[0] = value.x;
            this.float64Array[1] = value.y;
            this.float64Array[2] = value.z;
            this._nativeObj.setCenter();
        }
        getCenter() {
            var center = this._center;
            this._nativeObj.getCenter();
            center.x = this.float64Array[0];
            center.y = this.float64Array[1];
            center.z = this.float64Array[2];
            return center;
        }
        setExtent(value) {
            this.float64Array[0] = value.x;
            this.float64Array[1] = value.y;
            this.float64Array[2] = value.z;
            this._nativeObj.setExtent();
        }
        getExtent() {
            var extent = this._extent;
            this._nativeObj.getExtent();
            extent.x = this.float64Array[0];
            extent.y = this.float64Array[1];
            extent.z = this.float64Array[2];
            return extent;
        }
        _tranform(matrix, out) {
            this.float32Array.set(matrix.elements);
            this._nativeObj._tranform(out._nativeObj);
        }
        _getBoundBox() {
            this._nativeObj._getBoundBox();
            this._boundBox.min.x = this.float64Array[0];
            this._boundBox.min.y = this.float64Array[1];
            this._boundBox.min.z = this.float64Array[2];
            this._boundBox.max.x = this.float64Array[3];
            this._boundBox.max.y = this.float64Array[4];
            this._boundBox.max.z = this.float64Array[5];
            return this._boundBox;
        }
        calculateBoundsintersection(bounds) {
            var ownMax = this.getMax();
            var ownMin = this.getMin();
            var calMax = bounds.getMax();
            var calMin = bounds.getMin();
            var tempV0 = TEMP_VECTOR3_MAX0;
            var tempV1 = TEMP_VECTOR3_MAX1;
            var thisExtends = this.getExtent();
            var boundExtends = bounds.getExtent();
            tempV0.setValue(Math.max(ownMax.x, calMax.x) - Math.min(ownMin.x, calMin.x), Math.max(ownMax.y, calMax.y) - Math.min(ownMin.y, calMin.y), Math.max(ownMax.z, calMax.z) - Math.min(ownMin.z, calMin.z));
            tempV1.setValue((thisExtends.x + boundExtends.x) * 2.0, (thisExtends.y + boundExtends.y) * 2.0, (thisExtends.z + boundExtends.z) * 2.0);
            if ((tempV0.x) > (tempV1.x))
                return -1;
            if ((tempV0.y) > (tempV1.y))
                return -1;
            if ((tempV0.z) > (tempV1.z))
                return -1;
            return (tempV1.x - tempV0.x) * (tempV1.y - tempV0.y) * (tempV1.z - tempV0.z);
        }
        cloneTo(destObject) {
            var destBounds = destObject;
            this._nativeObj.cloneTo(destBounds._nativeObj);
        }
        clone() {
            var dest = new NativeBounds(new Laya.Vector3(), new Laya.Vector3());
            this.cloneTo(dest);
            return dest;
        }
    }
    NativeBounds.MemoryBlock_size = Math.max(6 * 8, 16 * 4);
    const TEMP_VECTOR3_MAX0 = new Laya.Vector3();
    const TEMP_VECTOR3_MAX1 = new Laya.Vector3();

    class NativeCameraCullInfo {
        constructor() {
            this.nativeMemory = new Laya.NativeMemory(NativeCameraCullInfo.MemoryBlock_size, true);
            this.float64Array = this.nativeMemory.float64Array;
            this._nativeObj = new window.conchCameraCullInfo(this.nativeMemory._buffer);
        }
        set position(position) {
            this._position = position;
            this._nativeObj.setPosition(position.x, position.y, position.z);
        }
        get position() {
            return this._position;
        }
        set useOcclusionCulling(useOcclusionCulling) {
            this._useOcclusionCulling = useOcclusionCulling;
            this._nativeObj.useOcclusionCulling = useOcclusionCulling;
        }
        get useOcclusionCulling() {
            return this._useOcclusionCulling;
        }
        set cullingMask(cullingMask) {
            this._cullingMask = cullingMask;
            this._nativeObj.cullingMask = cullingMask;
        }
        get cullingMask() {
            return this._cullingMask;
        }
        set staticMask(value) {
            this._staticMask = value;
            this._nativeObj.staticMask = value;
        }
        get staticMask() {
            return this._staticMask;
        }
        serialize() {
            if (this.boundFrustum) {
                this.setPlane(0, this.boundFrustum.near);
                this.setPlane(4, this.boundFrustum.far);
                this.setPlane(8, this.boundFrustum.left);
                this.setPlane(12, this.boundFrustum.right);
                this.setPlane(16, this.boundFrustum.top);
                this.setPlane(20, this.boundFrustum.bottom);
                this._nativeObj.setBoundFrustum();
            }
        }
        setPlane(index, value) {
            this.float64Array[index] = value.normal.x;
            this.float64Array[index + 1] = value.normal.y;
            this.float64Array[index + 2] = value.normal.z;
            this.float64Array[index + 3] = value.distance;
        }
    }
    NativeCameraCullInfo.MemoryBlock_size = 192;

    class NativeCommandUniformMap extends Laya.CommandUniformMap {
        constructor(_nativeObj, stateName) {
            super(stateName);
            this._nativeObj = _nativeObj;
        }
        hasPtrID(propertyID) {
            return this._nativeObj.hasPtrID(propertyID);
        }
        getMap() {
            return this._idata;
        }
        addShaderUniform(propertyID, propertyKey) {
            this._idata[propertyID] = propertyKey;
            this._nativeObj.addShaderUniform(propertyID, propertyKey);
        }
    }

    class NativeCullPassBase {
        constructor() {
            this._nativeObj = new window.conchCullPass();
            this._tempRenderList = new Laya.SingletonList();
        }
        get cullList() {
            this._tempRenderList.elements = this._nativeObj.cullList;
            this._tempRenderList.length = this._nativeObj.cullList.length;
            return this._tempRenderList;
        }
        cullByCameraCullInfo(cameraCullInfo, renderManager) {
            cameraCullInfo.serialize();
            Laya.Stat.frustumCulling += this._nativeObj.cullByCameraCullInfo(cameraCullInfo._nativeObj, renderManager._sceneManagerOBJ._nativeObj);
            var customRenderList = renderManager._sceneManagerOBJ._customCullList;
            var boundFrustum = cameraCullInfo.boundFrustum;
            var cullMask = cameraCullInfo.cullingMask;
            let staticMask = cameraCullInfo.staticMask;
            var renders = customRenderList.elements;
            let context = RenderContext3D._instance;
            for (var i = 0, n = customRenderList.length; i < n; i++) {
                var render = renders[i];
                var canPass;
                canPass = (Math.pow(2, render.renderNode.layer & cullMask) != 0) && render._enabled && (render.renderbitFlag == 0);
                canPass = canPass && ((render.renderNode.staticMask & staticMask) != 0);
                if (canPass) {
                    Laya.Stat.frustumCulling++;
                    if (!cameraCullInfo.useOcclusionCulling || render._needRender(boundFrustum, context)) {
                        this._nativeObj.cullList.push(render);
                    }
                }
            }
        }
        cullByShadowCullInfo(cullInfo, renderManager) {
            Laya.Stat.frustumCulling += this._nativeObj.cullByShadowCullInfo(cullInfo._nativeObj, renderManager._sceneManagerOBJ._nativeObj);
            var customRenderList = renderManager._sceneManagerOBJ._customCullList;
            var renders = customRenderList.elements;
            for (var i = 0, n = customRenderList.length; i < n; i++) {
                var render = renders[i];
                var canPass = render.castShadow && render._enabled && (render.renderbitFlag == 0);
                if (canPass) {
                    Laya.Stat.frustumCulling++;
                    let pass = FrustumCulling.cullingRenderBounds(render.bounds, cullInfo);
                    pass && this._nativeObj.cullList.push(render);
                }
            }
        }
        cullingSpotShadow(cameraCullInfo, renderManager) {
            cameraCullInfo.serialize();
            Laya.Stat.frustumCulling += this._nativeObj.cullingSpotShadow(cameraCullInfo._nativeObj, renderManager._sceneManagerOBJ._nativeObj);
            var customRenderList = renderManager._sceneManagerOBJ._customCullList;
            var renders = customRenderList.elements;
            let context = RenderContext3D._instance;
            for (var i = 0, n = customRenderList.length; i < n; i++) {
                var render = renders[i];
                var canPass = render.castShadow && render._enabled && (render.renderbitFlag == 0);
                if (canPass) {
                    Laya.Stat.frustumCulling++;
                    var render = renders[i];
                    if (render._needRender(cameraCullInfo.boundFrustum, context))
                        this._nativeObj.cullList.push(render);
                }
            }
        }
    }

    class NativeIndexBuffer3D extends IndexBuffer3D {
        constructor(indexType, indexCount, bufferUsage = Laya.BufferUsage.Static, canRead = false) {
            super(indexType, indexCount, bufferUsage, canRead);
            this._conchIndexBuffer3D = null;
            this._conchIndexBuffer3D = new window.conchIndexBuffer3D(Laya.LayaGL.renderEngine._nativeObj, indexType, indexCount, bufferUsage, false);
            this._conchIndexBuffer3D.setGLBuffer(this._glBuffer);
        }
    }

    exports.RenderElementType = void 0;
    (function (RenderElementType) {
        RenderElementType[RenderElementType["Base"] = 0] = "Base";
        RenderElementType[RenderElementType["Skin"] = 1] = "Skin";
        RenderElementType[RenderElementType["Instance"] = 2] = "Instance";
    })(exports.RenderElementType || (exports.RenderElementType = {}));
    class NativeRenderElementOBJ {
        constructor() {
            this._shaderInstances = new Laya.SingletonList();
            this.init();
        }
        set _geometry(data) {
            this.geometry = data;
            this._nativeObj._geometry = data._nativeObj;
        }
        get _geometry() {
            return this.geometry;
        }
        set _materialShaderData(data) {
            this.materialShaderData = data;
            this._nativeObj._materialShaderData = data ? data._nativeObj : null;
        }
        get _materialShaderData() {
            return this.materialShaderData;
        }
        set _renderShaderData(data) {
            this.renderShaderData = data;
            this._nativeObj._renderShaderData = data ? data._nativeObj : null;
        }
        get _renderShaderData() {
            return this.renderShaderData;
        }
        set _transform(data) {
            this.transform = data;
            this._nativeObj._transform = data ? data._nativeObj : null;
        }
        get _transform() {
            return this.transform;
        }
        get _isRender() {
            return this._nativeObj._isRender;
        }
        set _isRender(data) {
            this._nativeObj._isRender = data;
        }
        get _invertFront() {
            return this._nativeObj._invertFront;
        }
        set _invertFront(data) {
            this._nativeObj._invertFront = data;
        }
        init() {
            this._nativeObj = new window.conchRenderElement(exports.RenderElementType.Base, Laya.LayaGL.renderEngine._nativeObj);
        }
        _addShaderInstance(shader) {
            this._shaderInstances.add(shader);
            this._nativeObj._addShaderInstance(shader._nativeObj);
        }
        _clearShaderInstance() {
            this._shaderInstances.length = 0;
            this._nativeObj._clearShaderInstance();
        }
        _render(context) {
            this._nativeObj._render(context._nativeObj);
        }
        _destroy() {
            this._nativeObj._destroy();
            this._shaderInstances = null;
            this.transform = null;
        }
    }

    class NativeInstanceRenderElementOBJ extends NativeRenderElementOBJ {
        constructor() {
            super();
            this._vertexBuffer3D = [];
            this._updateData = [];
        }
        addUpdateBuffer(vb, length) {
            this._vertexBuffer3D[this._updateNums++] = vb;
            this._nativeObj.addUpdateBuffer(vb._conchVertexBuffer3D, length);
        }
        getUpdateData(index, length) {
            let data = this._updateData[index];
            if (!data || data.length < length) {
                data = this._updateData[index] = new Float32Array(length);
                this._nativeObj.getUpdateData(index, data);
            }
            return data;
        }
        clear() {
            this._updateNums = 0;
            this._nativeObj.clear();
        }
        init() {
            this._nativeObj = new window.conchRenderElement(exports.RenderElementType.Instance, Laya.LayaGL.renderEngine._nativeObj);
        }
        set drawCount(drawCount) {
            this._nativeObj.drawCount = drawCount;
        }
        get drawCount() {
            return this._nativeObj.drawCount;
        }
    }

    class NativeRenderContext3DOBJ {
        constructor() {
            this._viewPort = new Viewport(0, 0, 0, 0);
            this._scissor = new Laya.Vector4();
            this._nativeObj = new window.conchRenderContext3D(Laya.LayaGL.renderEngine._nativeObj);
        }
        drawRenderElement(renderelemt) {
            Laya.UploadMemoryManager.syncRenderMemory();
            renderelemt._render(this);
        }
        applyContext(cameraUpdateMark) {
            this._nativeObj.changeViewport(this._viewPort.x, this._viewPort.y, this._viewPort.width, this._viewPort.height);
            this._nativeObj.changeScissor(this._scissor.x, this._scissor.y, this._scissor.z, this._scissor.w);
            this.destTarget && this.destTarget._start();
            this._nativeObj.applyContext(cameraUpdateMark);
        }
        set destTarget(destTarget) {
            this._destTarget = destTarget;
            this._nativeObj.destTarget = destTarget ? destTarget._renderTarget : null;
        }
        get destTarget() {
            return this._destTarget;
        }
        set viewPort(viewPort) {
            this._viewPort = viewPort;
            this._nativeObj.changeViewport(viewPort.x, viewPort.y, viewPort.width, viewPort.height);
        }
        get viewPort() {
            return this._viewPort;
        }
        set scissor(scissor) {
            this._scissor = scissor;
            this._nativeObj.changeScissor(scissor.x, scissor.y, scissor.z, scissor.w);
        }
        get scissor() {
            return this._scissor;
        }
        set invertY(invertY) {
            this._nativeObj.invertY = invertY;
        }
        get invertY() {
            return this._nativeObj.invertY;
        }
        set pipelineMode(pipelineMode) {
            this._nativeObj.pipelineMode = pipelineMode;
        }
        get pipelineMode() {
            return this._nativeObj.pipelineMode;
        }
        set globalShaderData(globalShaderData) {
            this._globalShaderData = globalShaderData;
            this._nativeObj.globalShaderData = globalShaderData ? globalShaderData._nativeObj : null;
        }
        get globalShaderData() {
            return this._globalShaderData;
        }
        set sceneShaderData(sceneShaderData) {
            this._sceneShaderData = sceneShaderData;
            this._nativeObj.sceneShaderData = sceneShaderData ? sceneShaderData._nativeObj : null;
        }
        get sceneShaderData() {
            return this._sceneShaderData;
        }
        set cameraShaderData(cameraShaderData) {
            this._cameraShaderData = cameraShaderData;
            this._nativeObj.cameraShaderData = cameraShaderData ? cameraShaderData._nativeObj : null;
        }
        get cameraShaderData() {
            return this._cameraShaderData;
        }
        set sceneID(sceneID) {
            this._nativeObj.sceneID = sceneID;
        }
        get sceneID() {
            return this._nativeObj.sceneID;
        }
        set cameraUpdateMark(cameraUpdateMark) {
            this._nativeObj.cameraUpdateMark = cameraUpdateMark;
        }
        get cameraUpdateMark() {
            return this._nativeObj.cameraUpdateMark;
        }
    }

    class NativeRenderGeometryElementOBJ {
        constructor(mode, drawType) {
            this._nativeObj = new window.conchRenderGeometryElement(mode, drawType);
            this.drawParams = new Laya.SingletonList();
        }
        setDrawArrayParams(first, count) {
            this.drawParams.add(first);
            this.drawParams.add(count);
            this._nativeObj.setDrawArrayParams(first, count);
        }
        setDrawElemenParams(count, offset) {
            this.drawParams.add(offset);
            this.drawParams.add(count);
            this._nativeObj.setDrawElemenParams(count, offset);
        }
        destroy() {
            this._nativeObj.destroy();
        }
        clearRenderParams() {
            this.drawParams.length = 0;
            this._nativeObj.clearRenderParams();
        }
        set bufferState(value) {
            this._bufferState = value;
            if (value) {
                this._nativeObj.bufferState = value._nativeVertexArrayObject._nativeObj;
            }
            else {
                this._nativeObj.bufferState = null;
            }
        }
        get bufferState() {
            return this._bufferState;
        }
        set mode(value) {
            this._nativeObj.mode = value;
        }
        get mode() {
            return this._nativeObj.mode;
        }
        set drawType(value) {
            this._nativeObj.drawType = value;
        }
        get drawType() {
            return this._nativeObj.drawType;
        }
        set instanceCount(value) {
            this._nativeObj.instanceCount = value;
        }
        get instanceCount() {
            return this._nativeObj.instanceCount;
        }
        set indexFormat(value) {
            this._nativeObj.indexFormat = value;
        }
        get indexFormat() {
            return this._nativeObj.indexFormat;
        }
    }

    class NativeRenderState {
        constructor() {
            this._nativeObj = new window.conchRenderState();
        }
        set cull(value) {
            this._nativeObj.cull = value;
        }
        get cull() {
            return this._nativeObj.cull;
        }
        set blend(value) {
            this._nativeObj.blend = value;
        }
        get blend() {
            return this._nativeObj.blend;
        }
        set srcBlend(value) {
            this._nativeObj.srcBlend = value;
        }
        get srcBlend() {
            return this._nativeObj.srcBlend;
        }
        set dstBlend(value) {
            this._nativeObj.dstBlend = value;
        }
        get dstBlend() {
            return this._nativeObj.dstBlend;
        }
        set srcBlendRGB(value) {
            this._nativeObj.srcBlendRGB = value;
        }
        get srcBlendRGB() {
            return this._nativeObj.srcBlendRGB;
        }
        set dstBlendRGB(value) {
            this._nativeObj.dstBlendRGB = value;
        }
        get dstBlendRGB() {
            return this._nativeObj.dstBlendRGB;
        }
        set srcBlendAlpha(value) {
            this._nativeObj.srcBlendAlpha = value;
        }
        get srcBlendAlpha() {
            return this._nativeObj.srcBlendAlpha;
        }
        set dstBlendAlpha(value) {
            this._nativeObj.dstBlendAlpha = value;
        }
        get dstBlendAlpha() {
            return this._nativeObj.dstBlendAlpha;
        }
        set blendEquation(value) {
            this._nativeObj.blendEquation = value;
        }
        get blendEquation() {
            return this._nativeObj.blendEquation;
        }
        set blendEquationRGB(value) {
            this._nativeObj.blendEquationRGB = value;
        }
        get blendEquationRGB() {
            return this._nativeObj.blendEquationRGB;
        }
        set blendEquationAlpha(value) {
            this._nativeObj.blendEquationAlpha = value;
        }
        get blendEquationAlpha() {
            return this._nativeObj.blendEquationAlpha;
        }
        set depthTest(value) {
            this._nativeObj.depthTest = value;
        }
        get depthTest() {
            return this._nativeObj.depthTest;
        }
        set depthWrite(value) {
            this._nativeObj.depthWrite = value;
        }
        get depthWrite() {
            return this._nativeObj.depthWrite;
        }
        set stencilWrite(value) {
            this._nativeObj.stencilWrite = value;
        }
        get stencilWrite() {
            return this._nativeObj.stencilWrite;
        }
        set stencilTest(value) {
            this._nativeObj.stencilTest = value;
        }
        get stencilTest() {
            return this._nativeObj.stencilTest;
        }
        set stencilRef(value) {
            this._nativeObj.stencilRef = value;
        }
        get stencilRef() {
            return this._nativeObj.stencilRef;
        }
        set stencilOp(value) {
            this._nativeObj.setStencilOp(value.x, value.y, value.z);
        }
        setNull() {
        }
    }

    class NativeSceneRenderManager {
        constructor() {
            this._renders = new Laya.SingletonList();
            this._customUpdateList = new Laya.SingletonList();
            this._customCullList = new Laya.SingletonList();
            this._nativeObj = new window.conchSceneCullManger();
        }
        get list() {
            return this._renders;
        }
        set list(value) {
            this._customCullList.elements = [];
            this._customCullList.length = 0;
            this._nativeObj.clear();
            this._renders.clear();
            for (let i = 0, len = value.length; i < len; i++) {
                this.addRenderObject(value.elements[i]);
            }
        }
        addRenderObject(object) {
            this._renders.add(object);
            if (!object._customCull && object.renderNode.geometryBounds) {
                this._nativeObj.addRenderObject(object.renderNode._nativeObj);
            }
            else {
                this._customCullList.add(object);
            }
        }
        removeRenderObject(object) {
            if (!object._customCull && object.renderNode.geometryBounds) {
                this._nativeObj.removeRenderObject(object.renderNode._nativeObj);
            }
            else {
                let elements = this._customCullList.elements;
                let index = elements.indexOf(object);
                if (index < this._customCullList.length) {
                    this._customCullList.length -= 1;
                    elements[index] = elements[this._customCullList.length];
                }
            }
            this._renders.remove(object);
            this.removeMotionObject(object);
        }
        removeMotionObject(object) {
            if (object.renderNode.geometryBounds) {
                this._nativeObj.removeMotionObject(object.renderNode._nativeObj);
            }
            else {
                let index = object._motionIndexList;
                if (index != -1) {
                    let elements = this._customUpdateList.elements;
                    this._customUpdateList.length -= 1;
                    elements[length]._motionIndexList = index;
                    elements[index] = elements[length];
                }
            }
        }
        updateMotionObjects() {
            this._nativeObj.updateMotionObjects();
            for (let i = 0; i < this._customUpdateList.length; i++) {
                this._customUpdateList.elements[i].bounds;
                this._customUpdateList.elements[i]._motionIndexList = -1;
            }
            this._customUpdateList.length = 0;
        }
        addMotionObject(object) {
            if (object.renderNode.geometryBounds) {
                this._nativeObj.addMotionObject(object.renderNode._nativeObj);
            }
            else {
                if (object._motionIndexList == -1) {
                    object._motionIndexList = this._customUpdateList.length;
                    this._customUpdateList.add(object);
                }
            }
        }
        destroy() {
            this._nativeObj.destroy();
            this._renders.destroy();
            this._customUpdateList.destroy();
            this._customCullList.destroy();
        }
    }

    exports.NativeShaderDataType = void 0;
    (function (NativeShaderDataType) {
        NativeShaderDataType[NativeShaderDataType["Number32"] = 0] = "Number32";
        NativeShaderDataType[NativeShaderDataType["Vector2"] = 1] = "Vector2";
        NativeShaderDataType[NativeShaderDataType["Vector3"] = 2] = "Vector3";
        NativeShaderDataType[NativeShaderDataType["Vector4"] = 3] = "Vector4";
        NativeShaderDataType[NativeShaderDataType["Matrix4x4"] = 4] = "Matrix4x4";
        NativeShaderDataType[NativeShaderDataType["Number32Array"] = 5] = "Number32Array";
        NativeShaderDataType[NativeShaderDataType["Texture"] = 6] = "Texture";
        NativeShaderDataType[NativeShaderDataType["ShaderDefine"] = 7] = "ShaderDefine";
        NativeShaderDataType[NativeShaderDataType["UBO"] = 8] = "UBO";
    })(exports.NativeShaderDataType || (exports.NativeShaderDataType = {}));
    class NativeShaderData extends Laya.ShaderData {
        constructor(ownerResource = null) {
            super(ownerResource);
            this.inUploadList = false;
            this.payload32bitNum = 0;
            this._initData();
            this._nativeObj = new window.conchShaderData();
            this.nativeObjID = this._nativeObj.nativeID;
            this._dataType = Laya.MemoryDataType.ShaderData;
            this.updateMap = new Map();
            this.updataSizeMap = new Map();
        }
        getUploadMemoryLength() {
            let head = 4;
            this.updataSizeMap.forEach((value) => {
                this.payload32bitNum += value;
            });
            return (this.payload32bitNum + head) * 4;
        }
        uploadDataTOShareMemory(memoryBlock, strideInByte) {
            if (!this._data) {
                return false;
            }
            let array = memoryBlock.int32Array;
            let strideFloat = strideInByte / 4;
            array[strideFloat++] = Laya.MemoryDataType.ShaderData;
            array[strideFloat++] = this.nativeObjID;
            array[strideFloat++] = this.payload32bitNum;
            array[strideFloat++] = this.updateMap.size;
            this.updateMap.forEach((value, key) => {
                strideFloat += value.call(this, key, memoryBlock, strideFloat);
            });
            this.clearUpload();
            this.inUploadList = false;
            return true;
        }
        clearUpload() {
            this.payload32bitNum = 0;
            this.updataSizeMap.clear();
            this.updateMap.clear();
        }
        compressNumber(index, memoryBlock, stride) {
            var length = 3;
            memoryBlock.int32Array[stride] = index;
            memoryBlock.int32Array[stride + 1] = exports.NativeShaderDataType.Number32;
            memoryBlock.float32Array[stride + 2] = this._data[index];
            return length;
        }
        compressVector2(index, memoryBlock, stride) {
            var length = 4;
            memoryBlock.int32Array[stride] = index;
            memoryBlock.int32Array[stride + 1] = exports.NativeShaderDataType.Vector2;
            var value = this._data[index];
            memoryBlock.float32Array[stride + 2] = value.x;
            memoryBlock.float32Array[stride + 3] = value.y;
            return length;
        }
        compressVector3(index, memoryBlock, stride) {
            var length = 5;
            memoryBlock.int32Array[stride] = index;
            memoryBlock.int32Array[stride + 1] = exports.NativeShaderDataType.Vector3;
            var value = this._data[index];
            memoryBlock.float32Array[stride + 2] = value.x;
            memoryBlock.float32Array[stride + 3] = value.y;
            memoryBlock.float32Array[stride + 4] = value.z;
            return length;
        }
        compressVector4(index, memoryBlock, stride) {
            var length = 6;
            memoryBlock.int32Array[stride] = index;
            memoryBlock.int32Array[stride + 1] = exports.NativeShaderDataType.Vector4;
            var value = this._data[index];
            memoryBlock.float32Array[stride + 2] = value.x;
            memoryBlock.float32Array[stride + 3] = value.y;
            memoryBlock.float32Array[stride + 4] = value.z;
            memoryBlock.float32Array[stride + 5] = value.w;
            return length;
        }
        compressMatrix4x4(index, memoryBlock, stride) {
            var length = 18;
            memoryBlock.int32Array[stride] = index;
            memoryBlock.int32Array[stride + 1] = exports.NativeShaderDataType.Matrix4x4;
            var value = this._data[index];
            memoryBlock.float32Array.set(value.elements, stride + 2);
            return length;
        }
        compressNumberArray(index, memoryBlock, stride) {
            memoryBlock.int32Array[stride] = index;
            memoryBlock.int32Array[stride + 1] = exports.NativeShaderDataType.Number32Array;
            var value = this._data[index];
            memoryBlock.int32Array[stride + 2] = value.length;
            memoryBlock.float32Array.set(value, stride + 3);
            return value.length + 3;
        }
        compressTexture(index, memoryBlock, stride) {
            var value = this._data[index];
            memoryBlock.int32Array[stride] = index;
            memoryBlock.int32Array[stride + 1] = exports.NativeShaderDataType.Texture;
            if (value && value instanceof Laya.Texture) {
                memoryBlock.int32Array[stride + 2] = value.bitmap._texture.id;
            }
            else if (value && value._texture) {
                memoryBlock.int32Array[stride + 2] = value._texture.id;
            }
            else {
                memoryBlock.int32Array[stride + 2] = Laya.Texture2D.erroTextur._texture.id;
            }
            return 3;
        }
        compressUBO(index, memoryBlock, stride) {
            var value = this._data[index];
            memoryBlock.int32Array[stride] = index;
            memoryBlock.int32Array[stride + 1] = exports.NativeShaderDataType.UBO;
            memoryBlock.int32Array[stride + 2] = value._conchUniformBufferObject.nativeID;
            return 3;
        }
        configMotionProperty(key, length, callBack) {
            this.updateMap.set(key, callBack);
            this.updataSizeMap.set(key, length);
            if (!this.inUploadList) {
                this.inUploadList = true;
                Laya.UploadMemoryManager.getInstance()._dataNodeList.add(this);
            }
        }
        setBool(index, value) {
            super.setBool(index, value);
            this.configMotionProperty(index, 3, this.compressNumber);
        }
        setInt(index, value) {
            super.setInt(index, value);
            this.configMotionProperty(index, 3, this.compressNumber);
        }
        setNumber(index, value) {
            super.setNumber(index, value);
            this.configMotionProperty(index, 3, this.compressNumber);
        }
        setVector2(index, value) {
            super.setVector2(index, value);
            this.configMotionProperty(index, 4, this.compressVector2);
        }
        setVector3(index, value) {
            super.setVector3(index, value);
            this.configMotionProperty(index, 5, this.compressVector3);
        }
        setVector(index, value) {
            super.setVector(index, value);
            this.configMotionProperty(index, 6, this.compressVector4);
        }
        setColor(index, value) {
            super.setColor(index, value);
            this.configMotionProperty(index, 6, this.compressVector4);
        }
        setMatrix4x4(index, value) {
            super.setMatrix4x4(index, value);
            this.configMotionProperty(index, 18, this.compressMatrix4x4);
        }
        setBuffer(index, value) {
            super.setBuffer(index, value);
            this.configMotionProperty(index, 3 + value.length, this.compressNumberArray);
        }
        setTexture(index, value) {
            super.setTexture(index, value);
            this.configMotionProperty(index, 3, this.compressTexture);
        }
        setUniformBuffer(index, value) {
            this._data[index] = value;
            this.configMotionProperty(index, 3, this.compressUBO);
        }
        setValueData(index, value) {
            if (typeof value == "boolean") {
                this.setBool(index, value);
            }
            else if (typeof value == "number") {
                this.setNumber(index, value);
            }
            else if (value instanceof Laya.Color) {
                this.setColor(index, value);
            }
            else if (value instanceof Laya.Vector2) {
                this.setVector2(index, value);
            }
            else if (value instanceof Laya.Vector3) {
                this.setVector3(index, value);
            }
            else if (value instanceof Laya.Vector4 || value instanceof Laya.Quaternion) {
                this.setVector(index, value);
            }
            else if (value instanceof Laya.Matrix4x4) {
                this.setMatrix4x4(index, value);
            }
            else if (value.ArrayBuffer != null) {
                this.setBuffer(index, value);
            }
            else if (value._texture != null) {
                this.setTexture(index, value);
            }
        }
        cloneTo(destObject) {
            var dest = destObject;
            for (var k in this._data) {
                var value = this._data[k];
                if (value != null) {
                    if (typeof (value) == 'boolean') {
                        destObject.setBool(k, value);
                    }
                    else if (typeof (value) == 'number') {
                        destObject.setNumber(k, value);
                    }
                    else if (value instanceof Laya.Vector2) {
                        destObject.setVector2(k, value);
                    }
                    else if (value instanceof Laya.Vector3) {
                        destObject.setVector3(k, value);
                    }
                    else if (value instanceof Laya.Vector4) {
                        destObject.setVector(k, value);
                    }
                    else if (value instanceof Laya.Matrix4x4) {
                        destObject.setMatrix4x4(k, value);
                    }
                    else if (value instanceof Laya.BaseTexture) {
                        destObject.setTexture(k, value);
                    }
                }
            }
            this._defineDatas.cloneTo(dest._defineDatas);
            this._gammaColorMap.forEach((color, index) => {
                destObject._gammaColorMap.set(index, color.clone());
            });
        }
        clone() {
            var dest = new NativeShaderData();
            this.cloneTo(dest);
            return dest;
        }
    }

    var UniformParamsMapType;
    (function (UniformParamsMapType) {
        UniformParamsMapType[UniformParamsMapType["Scene"] = 0] = "Scene";
        UniformParamsMapType[UniformParamsMapType["Camera"] = 1] = "Camera";
        UniformParamsMapType[UniformParamsMapType["Sprite"] = 2] = "Sprite";
        UniformParamsMapType[UniformParamsMapType["Material"] = 3] = "Material";
    })(UniformParamsMapType || (UniformParamsMapType = {}));
    class NativeShaderInstance {
        constructor(vs, ps, attributeMap, shaderPass) {
            this._shaderPass = shaderPass;
            var pConchAttributeMap = new window.conchAttributeMap();
            for (var k in attributeMap) {
                pConchAttributeMap.setAttributeValue(k, attributeMap[k][0]);
            }
            var stateMap = Laya.SubShader.StateParamsMap;
            for (var s in stateMap) {
                pConchAttributeMap.setStateValue(parseInt(s), stateMap[s]);
            }
            pConchAttributeMap.statefirst = this._shaderPass.statefirst;
            var renderState = shaderPass.renderState;
            this._nativeObj = new window.conchShaderInstance(Laya.LayaGL.renderEngine._nativeObj, vs, ps, pConchAttributeMap, renderState._nativeObj);
        }
        _disposeResource() {
            this._nativeObj.destroy();
        }
        bind() {
            return this._nativeObj.bind();
        }
        uploadUniforms(shaderUniform, shaderDatas, uploadUnTexture) {
            this._nativeObj.uploadUniforms(shaderUniform, shaderDatas._nativeObj, uploadUnTexture);
        }
        uploadCustomUniform(index, data) {
            this._nativeObj.uploadCustomUniforms(index, data);
        }
        get _sceneUniformParamsMap() {
            return UniformParamsMapType.Scene;
        }
        get _cameraUniformParamsMap() {
            return UniformParamsMapType.Camera;
        }
        get _spriteUniformParamsMap() {
            return UniformParamsMapType.Sprite;
        }
        get _materialUniformParamsMap() {
            return UniformParamsMapType.Material;
        }
        uploadRenderStateBlendDepth(shaderDatas) {
            this._nativeObj.uploadRenderStateBlendDepth(shaderDatas._nativeObj);
        }
        uploadRenderStateFrontFace(shaderDatas, isTarget, invertFront) {
            this._nativeObj.uploadRenderStateFrontFace(shaderDatas._nativeObj, isTarget, invertFront);
        }
    }

    class NativeShadowCullInfo {
        constructor() {
            this.nativeMemory = new Laya.NativeMemory(NativeShadowCullInfo.MemoryBlock_size, true);
            this.float64Array = this.nativeMemory.float64Array;
            this._nativeObj = new window.conchShadowCullInfo(this.nativeMemory._buffer);
        }
        set cullPlanes(cullPlanes) {
            this._cullPlanes = cullPlanes;
            this._nativeObj.clearCullPlanes();
            cullPlanes.forEach((element) => {
                this.float64Array[0] = element.normal.x;
                this.float64Array[1] = element.normal.y;
                this.float64Array[2] = element.normal.z;
                this.float64Array[3] = element.distance;
                this._nativeObj.addCullPlane();
            });
        }
        get cullPlanes() {
            return this._cullPlanes;
        }
        set cullSphere(cullSphere) {
            this._cullSphere = cullSphere;
            this.float64Array[0] = cullSphere.center.x;
            this.float64Array[1] = cullSphere.center.y;
            this.float64Array[2] = cullSphere.center.z;
            this.float64Array[3] = cullSphere.radius;
            this._nativeObj.setCullSphere();
        }
        get cullSphere() {
            return this._cullSphere;
        }
        set position(position) {
            this._position = position;
            this.float64Array[0] = position.x;
            this.float64Array[1] = position.y;
            this.float64Array[2] = position.z;
            this._nativeObj.setPosition();
        }
        get position() {
            return this._position;
        }
        set direction(direction) {
            this._direction = direction;
            this.float64Array[0] = direction.x;
            this.float64Array[1] = direction.y;
            this.float64Array[2] = direction.z;
            this._nativeObj.setDirection();
        }
        get direction() {
            return this._direction;
        }
        set cullPlaneCount(cullPlaneCount) {
            this._cullPlaneCount = cullPlaneCount;
            this._nativeObj.cullPlaneCount = cullPlaneCount;
        }
        get cullPlaneCount() {
            return this._cullPlaneCount;
        }
    }
    NativeShadowCullInfo.MemoryBlock_size = 4 * 8;

    class NativeSkinRenderElementOBJ extends NativeRenderElementOBJ {
        constructor() {
            super();
        }
        get skinnedData() {
            return this._skinnedData;
        }
        set skinnedData(data) {
            this._skinnedData = data;
            this._nativeObj._skinnedData = data;
        }
        init() {
            this._nativeObj = new window.conchRenderElement(exports.RenderElementType.Skin, Laya.LayaGL.renderEngine._nativeObj);
        }
    }

    class NativeTransform3D extends Transform3D {
        constructor(owner) {
            super(owner);
            this.nativeMemory = new Laya.NativeMemory(NativeTransform3D.MemoryBlock_size, true);
            this.float32Array = this.nativeMemory.float32Array;
            this.float64Array = this.nativeMemory.float64Array;
            this.int32Array = this.nativeMemory.int32Array;
            this.eventDispatcher = new Laya.EventDispatcher();
            this._nativeObj = new window.conchTransform(this.nativeMemory._buffer, this.eventDispatcher.event.bind(this.eventDispatcher));
        }
        get _isFrontFaceInvert() {
            return this._nativeObj._isFrontFaceInvert;
        }
        get owner() {
            return this._owner;
        }
        get localPositionX() {
            return this.localPosition.x;
        }
        set localPositionX(x) {
            this._localPosition.x = x;
            this.localPosition = this._localPosition;
        }
        get localPositionY() {
            return this.localPosition.y;
        }
        set localPositionY(y) {
            this._localPosition.y = y;
            this.localPosition = this._localPosition;
        }
        get localPositionZ() {
            return this.localPosition.z;
        }
        set localPositionZ(z) {
            this._localPosition.z = z;
            this.localPosition = this._localPosition;
        }
        get localPosition() {
            if (this._nativeObj.getLocalPosition()) {
                this._localPosition.x = this.float64Array[0];
                this._localPosition.y = this.float64Array[1];
                this._localPosition.z = this.float64Array[2];
            }
            return this._localPosition;
        }
        set localPosition(value) {
            this._localPosition.x = this.float64Array[0] = value.x;
            this._localPosition.y = this.float64Array[1] = value.y;
            this._localPosition.z = this.float64Array[2] = value.z;
            this._nativeObj.setLocalPosition();
        }
        get localRotationX() {
            return this.localRotation.x;
        }
        set localRotationX(x) {
            let rot = this.localRotation;
            rot.x = x;
            this.localRotation = rot;
        }
        get localRotationY() {
            return this.localRotation.y;
        }
        set localRotationY(y) {
            let rot = this.localRotation;
            rot.y = y;
            this.localRotation = rot;
        }
        get localRotationZ() {
            return this.localRotation.z;
        }
        set localRotationZ(z) {
            let rot = this.localRotation;
            rot.z = z;
            this.localRotation = rot;
        }
        get localRotationW() {
            return this.localRotation.w;
        }
        set localRotationW(w) {
            let rot = this.localRotation;
            rot.w = w;
            this.localRotation = rot;
        }
        get localRotation() {
            if (this._nativeObj.getLocalRotation()) {
                this._localRotation.x = this.float64Array[0];
                this._localRotation.y = this.float64Array[1];
                this._localRotation.z = this.float64Array[2];
                this._localRotation.w = this.float64Array[3];
            }
            return this._localRotation;
        }
        set localRotation(value) {
            this._localRotation.x = this.float64Array[0] = value.x;
            this._localRotation.y = this.float64Array[1] = value.y;
            this._localRotation.z = this.float64Array[2] = value.z;
            this._localRotation.w = this.float64Array[3] = value.w;
            this._nativeObj.setLocalRotation();
        }
        get localScaleX() {
            return this.localScale.x;
        }
        set localScaleX(value) {
            this._localScale.x = value;
            this.localScale = this._localScale;
        }
        get localScaleY() {
            return this.localScale.y;
        }
        set localScaleY(value) {
            this._localScale.y = value;
            this.localScale = this._localScale;
        }
        get localScaleZ() {
            return this.localScale.z;
        }
        set localScaleZ(value) {
            this._localScale.z = value;
            this.localScale = this._localScale;
        }
        get localScale() {
            if (this._nativeObj.getLocalScale()) {
                this._localScale.x = this.float64Array[0];
                this._localScale.y = this.float64Array[1];
                this._localScale.z = this.float64Array[2];
            }
            return this._localScale;
        }
        set localScale(value) {
            this._localScale.x = this.float64Array[0] = value.x;
            this._localScale.y = this.float64Array[1] = value.y;
            this._localScale.z = this.float64Array[2] = value.z;
            this._nativeObj.setLocalScale();
        }
        get localRotationEulerX() {
            return this.localRotationEuler.x;
        }
        set localRotationEulerX(value) {
            let rot = this.localRotationEuler;
            rot.x = value;
            this.localRotationEuler = rot;
        }
        get localRotationEulerY() {
            return this.localRotationEuler.y;
        }
        set localRotationEulerY(value) {
            let rot = this.localRotationEuler;
            rot.y = value;
            this.localRotationEuler = rot;
        }
        get localRotationEulerZ() {
            return this.localRotationEuler.z;
        }
        set localRotationEulerZ(value) {
            let rot = this.localRotationEuler;
            rot.z = value;
            this.localRotationEuler = rot;
        }
        get localRotationEuler() {
            if (this._nativeObj.getLocalRotationEuler()) {
                this._localRotationEuler.x = this.float64Array[0];
                this._localRotationEuler.y = this.float64Array[1];
                this._localRotationEuler.z = this.float64Array[2];
            }
            return this._localRotationEuler;
        }
        set localRotationEuler(value) {
            this._localRotationEuler.x = this.float64Array[0] = value.x;
            this._localRotationEuler.y = this.float64Array[1] = value.y;
            this._localRotationEuler.z = this.float64Array[2] = value.z;
            this._nativeObj.setLocalRotationEuler();
        }
        get localMatrix() {
            if (this._nativeObj.getLocalMatrix()) {
                for (var i = 0; i < 16; ++i) {
                    this._localMatrix.elements[i] = this.float32Array[i];
                }
            }
            return this._localMatrix;
        }
        set localMatrix(value) {
            if (this._localMatrix !== value)
                value.cloneTo(this._localMatrix);
            this.float32Array.set(value.elements);
            this._nativeObj.setLocalMatrix();
        }
        get position() {
            if (this._nativeObj.getPosition()) {
                this._position.x = this.float64Array[0];
                this._position.y = this.float64Array[1];
                this._position.z = this.float64Array[2];
            }
            return this._position;
        }
        set position(value) {
            this._position.x = this.float64Array[0] = value.x;
            this._position.y = this.float64Array[1] = value.y;
            this._position.z = this.float64Array[2] = value.z;
            this._nativeObj.setPosition();
        }
        get rotation() {
            if (this._nativeObj.getRotation()) {
                this._rotation.x = this.float64Array[0];
                this._rotation.y = this.float64Array[1];
                this._rotation.z = this.float64Array[2];
                this._rotation.w = this.float64Array[3];
            }
            return this._rotation;
        }
        set rotation(value) {
            this._rotation.x = this.float64Array[0] = value.x;
            this._rotation.y = this.float64Array[1] = value.y;
            this._rotation.z = this.float64Array[2] = value.z;
            this._rotation.w = this.float64Array[3] = value.w;
            this._nativeObj.setRotation();
        }
        get rotationEuler() {
            if (this._nativeObj.getRotationEuler()) {
                this._rotationEuler.x = this.float64Array[0];
                this._rotationEuler.y = this.float64Array[1];
                this._rotationEuler.z = this.float64Array[2];
            }
            return this._rotationEuler;
        }
        set rotationEuler(value) {
            this._rotationEuler.x = this.float64Array[0] = value.x;
            this._rotationEuler.y = this.float64Array[1] = value.y;
            this._rotationEuler.z = this.float64Array[2] = value.z;
            this._nativeObj.setRotationEuler();
        }
        get worldMatrix() {
            if (this._nativeObj.getWorldMatrix()) {
                for (var i = 0; i < 16; i++) {
                    this._worldMatrix.elements[i] = this.float32Array[i];
                }
            }
            return this._worldMatrix;
        }
        set worldMatrix(value) {
            if (this._worldMatrix !== value)
                value.cloneTo(this._worldMatrix);
            this.float32Array.set(value.elements);
            this._nativeObj.setWorldMatrix();
        }
        _setTransformFlag(type, value) {
            this._nativeObj && this._nativeObj._setTransformFlag(type, value);
        }
        _getTransformFlag(type) {
            return this._nativeObj._getTransformFlag(type);
        }
        _setParent(value) {
            this._nativeObj.setParent(value ? value._nativeObj : null);
        }
        translate(translation, isLocal = true) {
            this.float64Array[0] = translation.x;
            this.float64Array[1] = translation.y;
            this.float64Array[2] = translation.z;
            this.int32Array[6] = isLocal ? 1 : 0;
            this._nativeObj.translate();
        }
        rotate(rotation, isLocal = true, isRadian = true) {
            this.float64Array[0] = rotation.x;
            this.float64Array[1] = rotation.y;
            this.float64Array[2] = rotation.z;
            this.int32Array[6] = isLocal ? 1 : 0;
            this.int32Array[7] = isRadian ? 1 : 0;
            this._nativeObj.rotate();
        }
        getForward(forward) {
            var worldMatElem = this.worldMatrix.elements;
            forward.x = -worldMatElem[8];
            forward.y = -worldMatElem[9];
            forward.z = -worldMatElem[10];
        }
        getUp(up) {
            var worldMatElem = this.worldMatrix.elements;
            up.x = worldMatElem[4];
            up.y = worldMatElem[5];
            up.z = worldMatElem[6];
        }
        getRight(right) {
            var worldMatElem = this.worldMatrix.elements;
            right.x = worldMatElem[0];
            right.y = worldMatElem[1];
            right.z = worldMatElem[2];
        }
        lookAt(target, up, isLocal = false, isCamera = true) {
            this.float64Array[0] = target.x;
            this.float64Array[1] = target.y;
            this.float64Array[2] = target.z;
            this.float64Array[3] = up.x;
            this.float64Array[4] = up.y;
            this.float64Array[5] = up.z;
            this.int32Array[12] = isLocal ? 1 : 0;
            this.int32Array[13] = isCamera ? 1 : 0;
            this._nativeObj.lookAt();
        }
        objLookat(target, up, isLocal = false) {
        }
        getWorldLossyScale() {
            if (this._nativeObj.getWorldLossyScale()) {
                this._scale.x = this.float64Array[0];
                this._scale.y = this.float64Array[1];
                this._scale.z = this.float64Array[2];
            }
            return this._scale;
        }
        setWorldLossyScale(value) {
            this._scale.x = this.float64Array[0] = value.x;
            this._scale.y = this.float64Array[1] = value.y;
            this._scale.z = this.float64Array[2] = value.z;
            this._nativeObj.setWorldLossyScale();
        }
        hasListener(type) {
            return this.eventDispatcher.hasListener(type);
        }
        event(type, data) {
            return this.eventDispatcher.event(type, data);
        }
        on(type, caller, listener, args) {
            if (arguments.length == 2) {
                listener = caller;
                caller = null;
            }
            return this.eventDispatcher.on(type, caller, listener, args);
        }
        once(type, caller, listener, args) {
            if (arguments.length == 2) {
                listener = caller;
                caller = null;
            }
            return this.eventDispatcher.once(type, caller, listener, args);
        }
        off(type, caller, listener) {
            if (arguments.length == 2) {
                listener = caller;
                caller = null;
            }
            return this.eventDispatcher.off(type, caller, listener);
        }
        offAll(type) {
            return this.eventDispatcher.offAll(type);
        }
        offAllCaller(caller) {
            return this.eventDispatcher.offAllCaller(caller);
        }
    }
    NativeTransform3D.MemoryBlock_size = 16 * 4;

    class NativeUniformBufferObject extends Laya.UniformBufferObject {
        constructor(glPointer, name, bufferUsage, byteLength, isSingle) {
            super(glPointer, name, bufferUsage, byteLength, isSingle);
            this._conchUniformBufferObject = null;
            this._conchUniformBufferObject = new window.conchUniformBufferObject(Laya.LayaGL.renderEngine._nativeObj, glPointer);
            this._conchUniformBufferObject.setGLBuffer(this._glBuffer);
        }
    }

    class NativeVertexBuffer3D extends VertexBuffer3D {
        constructor(byteLength, bufferUsage, canRead = false) {
            super(byteLength, bufferUsage, canRead);
            this._conchVertexBuffer3D = null;
            this._conchVertexBuffer3D = new window.conchVertexBuffer3D(Laya.LayaGL.renderEngine._nativeObj, byteLength, bufferUsage, false);
            this._conchVertexBuffer3D.setGLBuffer(this._glBuffer);
        }
        get vertexDeclaration() {
            return this._vertexDeclaration;
        }
        set vertexDeclaration(value) {
            this._vertexDeclaration = value;
            this._conchVertexBuffer3D.setVertexDeclaration(this.serilizeVertexDeclaration(value));
        }
        serilizeVertexDeclaration(value) {
            let array = new Int32Array(value._vertexElements.length * 6);
            let offset = 0;
            var valueData = value._shaderValues;
            for (var k in valueData) {
                var loc = parseInt(k);
                var attribute = valueData[k];
                array[offset++] = loc;
                array.set(attribute, offset);
                offset += 5;
            }
            return array;
        }
        get instanceBuffer() {
            return this._conchVertexBuffer3D._instanceBuffer;
        }
        set instanceBuffer(value) {
            this._conchVertexBuffer3D._instanceBuffer = value;
        }
    }

    class NativeRenderOBJCreateUtil {
        createTransform(owner) {
            return new NativeTransform3D(owner);
        }
        createBounds(min, max) {
            return new NativeBounds(min, max);
        }
        createShaderData() {
            return new NativeShaderData();
        }
        createRenderElement() {
            return new NativeRenderElementOBJ();
        }
        createSkinRenderElement() {
            return new NativeSkinRenderElementOBJ();
        }
        createInstanceRenderElement() {
            return new NativeInstanceRenderElementOBJ();
        }
        createBaseRenderQueue(isTransparent) {
            var queue = new NativeBaseRenderQueue(isTransparent);
            queue.sortPass = this.createSortPass();
            return queue;
        }
        createRenderGeometry(mode, drayType) {
            return new NativeRenderGeometryElementOBJ(mode, drayType);
        }
        createVertexBuffer3D(byteLength, bufferUsage, canRead = false) {
            return new NativeVertexBuffer3D(byteLength, bufferUsage, canRead);
        }
        createIndexBuffer3D(indexType, indexCount, bufferUsage = Laya.BufferUsage.Static, canRead = false) {
            return new NativeIndexBuffer3D(indexType, indexCount, bufferUsage, canRead);
        }
        createShaderInstance(vs, ps, attributeMap, shaderPass) {
            return new NativeShaderInstance(vs, ps, attributeMap, shaderPass);
        }
        createBaseRenderNode() {
            return new NativeBaseRenderNode();
        }
        createRenderContext3D() {
            return new NativeRenderContext3DOBJ();
        }
        createSceneRenderManager() {
            return new NativeSceneRenderManager();
        }
        createCullPass() {
            return new NativeCullPassBase();
        }
        createSortPass() {
            return new window.conchQuickSort();
        }
        createShadowCullInfo() {
            return new NativeShadowCullInfo();
        }
        createCameraCullInfo() {
            return new NativeCameraCullInfo();
        }
        createRenderStateComand() {
            return new Laya.NativeRenderStateCommand();
        }
        createRenderState() {
            return new NativeRenderState();
        }
        createUniformBufferObject(glPointer, name, bufferUsage, byteLength, isSingle) {
            return new NativeUniformBufferObject(glPointer, name, bufferUsage, byteLength, isSingle);
        }
        createGlobalUniformMap(blockName) {
            return new NativeCommandUniformMap(window.conchCommandUniformMap.createGlobalUniformMap(blockName), blockName);
        }
    }

    class Laya3D {
        static get enablePhysics() {
            return Physics3D._enablePhysics;
        }
        static _changeWebGLSize(width, height) {
            Laya.WebGL.onStageResize(width, height);
            RenderContext3D.clientWidth = width;
            RenderContext3D.clientHeight = height;
        }
        static __init__(checkPhysics) {
            if (checkPhysics !== false) {
                let physics3D = window.Physics3D;
                if (physics3D == null)
                    Physics3D._enablePhysics = false;
                else {
                    Physics3D._enablePhysics = true;
                    return new Promise(resolve => {
                        physics3D(Math.max(16, Laya.Config3D.defaultPhysicsMemory) * 16, new BulletInteractive(null, null)).then(() => {
                            Laya3D.__init__(false).then(resolve);
                        });
                    });
                }
            }
            Laya3D.createRenderObjInit();
            if (Laya.LayaEnv.isConch && !window.conchConfig.conchWebGL) {
                var skinnedMeshRender = SkinnedMeshRenderer;
                skinnedMeshRender.prototype._computeSkinnedData = skinnedMeshRender.prototype._computeSkinnedDataForNative;
            }
            Laya.Config3D._multiLighting = Laya.Config3D.enableMultiLight && Laya.LayaGL.renderEngine.getCapable(Laya.RenderCapable.TextureFormat_R32G32B32A32);
            Laya.Config3D._uniformBlock = Laya.Config3D.enableUniformBufferObject && Laya.LayaGL.renderEngine.getCapable(Laya.RenderCapable.UnifromBufferObject);
            if (Laya.Config3D.maxLightCount > 2048) {
                Laya.Config3D.maxLightCount = 2048;
                console.warn("Config3D: maxLightCount must less equal 2048.");
            }
            let lcc = Laya.Config3D.lightClusterCount;
            if (lcc.x > 128 || lcc.y > 128 || lcc.z > 128) {
                lcc.setValue(Math.min(lcc.x, 128), Math.min(lcc.y, 128), Math.min(lcc.z, 128));
                console.warn("Config3D: lightClusterCount X and Y、Z must less equal 128.");
            }
            let maxAreaLightCountWithZ = Math.floor(2048 / Laya.Config3D.lightClusterCount.z - 1) * 4;
            if (maxAreaLightCountWithZ < Laya.Config3D.maxLightCount)
                console.warn("Config3D: if the area light(PointLight、SpotLight) count is large than " + maxAreaLightCountWithZ + ",maybe the far away culster will ingonre some light.");
            Laya.Config3D._maxAreaLightCountPerClusterAverage = Math.min(maxAreaLightCountWithZ, Laya.Config3D.maxLightCount);
            ILaya3D.Scene3D = Scene3D;
            ILaya3D.Laya3D = Laya3D;
            ILaya3D.Physics3D = Physics3D;
            Physics3D.__bulletinit__();
            Laya.SubShader.__init__();
            Laya.VertexMesh.__init__();
            VertexShurikenParticleBillboard.__init__();
            VertexShurikenParticleMesh.__init__();
            VertexPositionTexture0.__init__();
            VertexTrail.__init__();
            VertexPositionTerrain.__init__();
            PixelLineVertex.__init__();
            SubMeshInstanceBatch.__init__();
            ShaderInit3D.__init__();
            ShuriKenParticle3DShaderDeclaration.__init__();
            SimpleSkinnedMeshSprite3D.__init__();
            PBRMaterial.__init__();
            PBRStandardMaterial.__init__();
            SkyPanoramicMaterial.__init__();
            BloomEffect.init();
            ScalableAO.init();
            GaussianDoF.init();
            ColorGradEffect.init();
            Mesh.__init__();
            PrimitiveMesh.__init__();
            Sprite3D.__init__();
            RenderableSprite3D.__init__();
            MeshSprite3D.__init__();
            DepthPass.__init__();
            SkinnedMeshSprite3D.__init__();
            SimpleSkinnedMeshSprite3D.__init__();
            TrailFilter.__init__();
            ShuriKenParticle3D.__init__();
            TrailSprite3D.__init__();
            PostProcess.__init__();
            Scene3D.__init__();
            ShadowCasterPass.__init__();
            BaseCamera.__init__();
            BaseRender.__init__();
            MeshRenderer.__init__();
            SkyRenderer.__init__();
            Camera.__init__();
            ShadowUtils.init();
            RenderContext3D.__init__();
            Laya.RenderTexture.configRenderContextInstance(RenderContext3D._instance);
            Material.__initDefine__();
            BlinnPhongMaterial.__initDefine__();
            SkyProceduralMaterial.__initDefine__();
            UnlitMaterial.__initDefine__();
            TrailMaterial.__initDefine__();
            ShurikenParticleMaterial.__initDefine__();
            SkyBoxMaterial.__initDefine__();
            Command.__init__();
            BlitFrameBufferCMD.__init__();
            BlinnPhongMaterial.defaultMaterial = new BlinnPhongMaterial();
            BlinnPhongMaterial.defaultMaterial.lock = true;
            Laya.Texture2D.__init__();
            TextureCube.__init__();
            SkyBox.__init__();
            SkyDome.__init__();
            ScreenQuad.__init__();
            FrustumCulling.__init__();
            Laya.HalfFloatUtils.__init__();
            return Promise.resolve();
        }
        static init(width, height, config = null, complete = null) {
            Laya.Laya.init(width, height).then(() => {
                complete && complete.run();
            });
        }
        static createRenderObjInit() {
            if (Laya.LayaEnv.isConch && !window.conchConfig.conchWebGL) {
                Laya.LayaGL.renderEngine._renderOBJCreateContext = new NativeRenderOBJCreateUtil();
                Laya.LayaGL.renderOBJCreate = Laya.LayaGL.renderEngine.getCreateRenderOBJContext();
            }
            else {
                Laya.LayaGL.renderEngine._renderOBJCreateContext = new RenderOBJCreateUtil();
                Laya.LayaGL.renderOBJCreate = Laya.LayaGL.renderEngine.getCreateRenderOBJContext();
            }
        }
    }
    window.Laya3D = Laya3D;

    class AnimatorStateScript {
        constructor() {
        }
        onStateEnter() {
        }
        onStateUpdate(normalizeTime) {
        }
        onStateExit() {
        }
    }

    class RandX {
        constructor(seed) {
            if (!(seed instanceof Array) || seed.length !== 4)
                throw new Error('Rand:Seed must be an array with 4 numbers');
            this._state0U = seed[0] | 0;
            this._state0L = seed[1] | 0;
            this._state1U = seed[2] | 0;
            this._state1L = seed[3] | 0;
        }
        randomint() {
            var s1U = this._state0U, s1L = this._state0L;
            var s0U = this._state1U, s0L = this._state1L;
            var sumL = (s0L >>> 0) + (s1L >>> 0);
            var resU = (s0U + s1U + (sumL / 2 >>> 31)) >>> 0;
            var resL = sumL >>> 0;
            this._state0U = s0U;
            this._state0L = s0L;
            var t1U = 0, t1L = 0;
            var t2U = 0, t2L = 0;
            var a1 = 23;
            var m1 = 0xFFFFFFFF << (32 - a1);
            t1U = (s1U << a1) | ((s1L & m1) >>> (32 - a1));
            t1L = s1L << a1;
            s1U = s1U ^ t1U;
            s1L = s1L ^ t1L;
            t1U = s1U ^ s0U;
            t1L = s1L ^ s0L;
            var a2 = 18;
            var m2 = 0xFFFFFFFF >>> (32 - a2);
            t2U = s1U >>> a2;
            t2L = (s1L >>> a2) | ((s1U & m2) << (32 - a2));
            t1U = t1U ^ t2U;
            t1L = t1L ^ t2L;
            var a3 = 5;
            var m3 = 0xFFFFFFFF >>> (32 - a3);
            t2U = s0U >>> a3;
            t2L = (s0L >>> a3) | ((s0U & m3) << (32 - a3));
            t1U = t1U ^ t2U;
            t1L = t1L ^ t2L;
            this._state1U = t1U;
            this._state1L = t1L;
            return [resU, resL];
        }
        random() {
            var t2 = this.randomint();
            var t2U = t2[0];
            var t2L = t2[1];
            var eU = 0x3FF << (52 - 32);
            var eL = 0;
            var a1 = 12;
            var m1 = 0xFFFFFFFF >>> (32 - a1);
            var sU = t2U >>> a1;
            var sL = (t2L >>> a1) | ((t2U & m1) << (32 - a1));
            var xU = eU | sU;
            var xL = eL | sL;
            RandX._CONVERTION_BUFFER.setUint32(0, xU, false);
            RandX._CONVERTION_BUFFER.setUint32(4, xL, false);
            var d = RandX._CONVERTION_BUFFER.getFloat64(0, false);
            return d - 1;
        }
    }
    RandX._CONVERTION_BUFFER = new DataView(new ArrayBuffer(8));
    RandX.defaultRand = new RandX([0, Date.now() / 65536, 0, Date.now() % 65536]);

    class TextMesh {
        constructor() {
        }
        get text() {
            return this._text;
        }
        set text(value) {
            this._text = value;
        }
        get fontSize() {
            return this._fontSize;
        }
        set fontSize(value) {
            this._fontSize = value;
        }
        get color() {
            return this._color;
        }
        set color(value) {
            this._color = value;
        }
    }

    class Size {
        constructor(width, height) {
            this._width = 0;
            this._height = 0;
            this._width = width;
            this._height = height;
        }
        static get fullScreen() {
            return new Size(-1, -1);
        }
        get width() {
            if (this._width === -1)
                return RenderContext3D.clientWidth;
            return this._width;
        }
        get height() {
            if (this._height === -1)
                return RenderContext3D.clientHeight;
            return this._height;
        }
    }

    class RenderTextureCube extends Laya.RenderTexture {
        constructor(size, colorFormat, depthFormat, generateMipmap, multiSamples) {
            super(size, size, colorFormat, depthFormat, generateMipmap, multiSamples);
            this.faceIndex = 0;
        }
        _createRenderTarget() {
            this._dimension = Laya.TextureDimension.Cube;
            this._renderTarget = Laya.LayaGL.textureContext.createRenderTargetCubeInternal(this.width, this._format, this._depthStencilFormat, this._generateMipmap, this._gammaSpace, this._multiSamples);
            this._texture = this._renderTarget._textures[0];
        }
        _start() {
            Laya.RenderTexture._configInstance.invertY = this._isCameraTarget;
            if (Laya.RenderTexture._currentActive != this) {
                Laya.RenderTexture._currentActive && Laya.RenderTexture._currentActive._end();
                Laya.RenderTexture._currentActive = this;
                Laya.LayaGL.textureContext.bindRenderTarget(this._renderTarget, this.faceIndex);
            }
        }
    }

    class WebXRRenderTexture extends Laya.RenderTexture {
        constructor() {
            super(1, 1, 1, Laya.RenderTargetFormat.STENCIL_8, false, 1);
            this.frameLoop = -1;
        }
        set frameBuffer(value) {
            this._frameBuffer = value;
        }
        _create(width, height) {
        }
        _start() {
            var gl = WebXRExperienceHelper.glInstance;
            gl.bindFramebuffer(gl.FRAMEBUFFER, this._frameBuffer);
            Laya.RenderTexture._currentActive = this;
        }
        _end() {
            var gl = WebXRExperienceHelper.glInstance;
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            Laya.RenderTexture._currentActive = null;
        }
    }

    class WebXRSessionManager extends Laya.EventDispatcher {
        constructor() {
            super();
            this.currentTimestamp = -1;
            this.defaultHeightCompensation = 1.7;
            this._sessionEnded = false;
        }
        get referenceSpace() {
            return this._referenceSpace;
        }
        set referenceSpace(newReferenceSpace) {
            this._referenceSpace = newReferenceSpace;
        }
        get sessionMode() {
            return this._sessionMode;
        }
        exitXR() {
            this.endXRRenderLoop();
            this.event(WebXRSessionManager.EVENT_MANAGER_END);
        }
        initializeXRGL(xrSession, gl) {
            return gl.makeXRCompatible().then(() => {
                return true;
            });
        }
        ;
        initializeAsync() {
            this._xrNavigator = navigator;
            if (!this._xrNavigator.xr) {
                return Promise.reject("WebXR not available");
            }
            return Promise.resolve();
        }
        isSessionSupportedAsync(sessionMode) {
            if (!navigator.xr) {
                return Promise.resolve(false);
            }
            else {
                this._xrNavigator = navigator;
            }
            const functionToUse = navigator.xr.isSessionSupported || navigator.xr.supportsSession;
            if (!functionToUse)
                return Promise.resolve(false);
            else {
                return navigator.xr.isSessionSupported(sessionMode);
            }
        }
        initializeSessionAsync(xrSessionMode = 'immersive-vr', xrSessionInit = {}) {
            return this._xrNavigator.xr.requestSession('immersive-vr').then((session) => {
                this.session = session;
                this._sessionMode = xrSessionMode;
                this._sessionEnded = false;
                this.session.addEventListener("end", () => {
                    this._sessionEnded = true;
                    this.exitXR();
                }, { once: true });
                return this.session;
            });
        }
        resetReferenceSpace() {
            this.referenceSpace = this.baseReferenceSpace;
        }
        runXRRenderLoop() {
            this.session.requestAnimationFrame.bind(this.session);
            let fn = (timestamp, xrFrame) => {
                this._updateByXrFrame(xrFrame, timestamp);
                this.event(WebXRSessionManager.EVENT_FRAME_LOOP, [xrFrame]);
                Laya.ILaya.stage._loop();
                this.session.requestAnimationFrame(fn);
            };
            this.session.requestAnimationFrame(fn);
        }
        endXRRenderLoop() {
        }
        _updateByXrFrame(xrFrame, timestamp) {
            this.currentFrame = xrFrame;
            this.currentTimestamp = timestamp;
        }
        setReferenceSpaceTypeAsync(referenceSpaceType = "local-floor") {
            return this.session
                .requestReferenceSpace(referenceSpaceType)
                .then((referenceSpace) => {
                return referenceSpace;
            }, (rejectionReason) => {
                return this.session.requestReferenceSpace("viewer").then((referenceSpace) => {
                    const heightCompensation = new XRRigidTransform({ x: 0, y: -this.defaultHeightCompensation, z: 0 });
                    return (referenceSpace).getOffsetReferenceSpace(heightCompensation);
                }, (rejectionReason) => {
                    throw 'XR initialization failed: required "viewer" reference space type not supported.';
                });
            }).then((referenceSpace) => {
                this.referenceSpace = this.baseReferenceSpace = referenceSpace;
                return this.referenceSpace;
            });
        }
        updateRenderStateAsync(state) {
            if (state.baseLayer) {
                this._baseLayer = state.baseLayer;
            }
            return this.session.updateRenderState(state);
        }
        get currentFrameRate() {
            var _a;
            return (_a = this.session) === null || _a === void 0 ? void 0 : _a.frameRate;
        }
        get supportedFrameRates() {
            var _a;
            return (_a = this.session) === null || _a === void 0 ? void 0 : _a.supportedFrameRates;
        }
        updateTargetFrameRate(rate) {
            return this.session.updateTargetFrameRate(rate);
        }
        destroy() {
            if (!this._sessionEnded) {
                this.exitXR();
            }
        }
    }
    WebXRSessionManager.EVENT_MANAGER_END = "xrManagerDestory";
    WebXRSessionManager.EVENT_FRAME_LOOP = "xrFrameLoop";

    class WebXRCameraManager {
        constructor(camera, manager = null) {
            this._referenceQuaternion = new Laya.Quaternion();
            this._referencedPosition = new Laya.Vector3();
            this._firstFrame = true;
            this._XRRenderTexture = new WebXRRenderTexture();
            this._rigCameras = new Array();
            this._position = new Laya.Vector3();
            this.owner = camera;
            this.owner.enableRender = false;
            if (!this.owner.aspectRatio) {
                console.warn("owner is not Camera");
            }
            this._webXRSessionManager = manager;
            this._webXRSessionManager.on(WebXRSessionManager.EVENT_FRAME_LOOP, this, this._updateFromXRSession);
            this._webXRSessionManager.on(WebXRSessionManager.EVENT_FRAME_LOOP, this, this._updateReferenceSpace);
            this._webXRSessionManager.on(WebXRSessionManager.EVENT_MANAGER_END, this, this.destroy);
        }
        get position() {
            return this._position;
        }
        set position(newPosition) {
            newPosition.cloneTo(this._position);
        }
        set rotationQuaternion(value) {
            value.cloneTo(this._referenceQuaternion);
        }
        get rotationQuaternion() {
            return this._referenceQuaternion;
        }
        get rigCameras() {
            return this._rigCameras;
        }
        _updateFromXRSession() {
            let pose = this._webXRSessionManager.currentFrame && this._webXRSessionManager.currentFrame.getViewerPose(this._webXRSessionManager.referenceSpace);
            const pos = pose.transform.position;
            const orientation = pose.transform.orientation;
            this._referenceQuaternion.setValue(orientation.x, orientation.y, orientation.z, orientation.w);
            this._referencedPosition.setValue(pos.x, pos.y, pos.z);
            if (this._firstFrame) {
                this._firstFrame = false;
                this.position.y += this._referencedPosition.y;
                this._referenceQuaternion.setValue(0, 0, 0, 1);
            }
            else {
                this.rotationQuaternion = this._referenceQuaternion;
                this.position = this._referencedPosition;
            }
            if (this.rigCameras.length !== pose.views.length) {
                this._updateNumberOfRigCameras(pose.views.length);
            }
            pose.views.forEach((view, i) => {
                const currentRig = this.rigCameras[i];
                if (view.eye === "right")
                    currentRig.name = "right";
                else if (view.eye === "left")
                    currentRig.name = "left";
                const pos = view.transform.position;
                const orientation = view.transform.orientation;
                currentRig.transform.position.setValue(pos.x, pos.y, pos.z);
                currentRig.transform.rotation.setValue(orientation.x, orientation.y, orientation.z, orientation.w);
                currentRig.transform.position = currentRig.transform.position;
                currentRig.transform.rotation = currentRig.transform.rotation;
                if (this._webXRSessionManager.session.renderState.baseLayer) {
                    var viewport = this._webXRSessionManager.session.renderState.baseLayer.getViewport(view);
                    var width = this._webXRSessionManager.session.renderState.baseLayer.framebufferWidth;
                    var height = this._webXRSessionManager.session.renderState.baseLayer.framebufferHeight;
                    this._XRRenderTexture.frameBuffer = this._webXRSessionManager.session.renderState.baseLayer.framebuffer;
                    currentRig.renderTarget = this._XRRenderTexture;
                    currentRig.clientWidth = width;
                    currentRig.clientHeight = height;
                    var cameraViewPort = currentRig.viewport;
                    cameraViewPort.x = viewport.x;
                    cameraViewPort.y = viewport.y;
                    cameraViewPort.width = viewport.width;
                    cameraViewPort.height = viewport.height;
                    currentRig.viewport = cameraViewPort;
                    currentRig.projectionMatrix.cloneByArray(view.projectionMatrix);
                }
            });
        }
        _updateNumberOfRigCameras(viewCount = 1) {
            while (this.rigCameras.length < viewCount) {
                var xrcamera = new WebXRCamera(this.owner.aspectRatio, this.owner.nearPlane, this.owner.farPlane);
                xrcamera.clearFlag = this.owner.clearFlag;
                xrcamera.clearColor = this.owner.clearColor;
                this.owner.addChild(xrcamera);
                this.rigCameras.push(xrcamera);
            }
            while (this.rigCameras.length > viewCount) {
                let xrcamera = this.rigCameras.pop();
                this.owner.removeChild(xrcamera);
            }
        }
        _updateReferenceSpace() {
        }
        destroy() {
            this.owner.enableRender = true;
            this._webXRSessionManager.off(WebXRSessionManager.EVENT_FRAME_LOOP, this, this._updateFromXRSession);
            this._webXRSessionManager.off(WebXRSessionManager.EVENT_FRAME_LOOP, this, this._updateReferenceSpace);
            this._webXRSessionManager.off(WebXRSessionManager.EVENT_MANAGER_END, this, this.destroy);
            this._rigCameras.forEach(element => {
                element.destroy();
            });
            this._rigCameras = null;
            this._XRRenderTexture.destroy();
        }
    }

    class AxiGamepad extends Laya.EventDispatcher {
        constructor(handness, length) {
            super();
            this.axisData = new Array();
            this.handness = handness;
            this.axisData.length = length;
            this.axisLength = length;
        }
        update(padGameAxi) {
            for (let i = 0, j = 0; i < padGameAxi.axes.length; i += 2, ++j) {
                if (!this.axisData[j])
                    this.axisData[j] = new Laya.Vector2();
                this.axisData[j].setValue(padGameAxi.axes[i], padGameAxi.axes[i + 1]);
                this.outPutStickValue(this.axisData[j], j);
            }
        }
        outPutStickValue(value, index) {
            const eventnam = AxiGamepad.EVENT_OUTPUT + index.toString();
            this.event(eventnam, [value]);
        }
        destroy() {
            for (let i = 0; i < this.axisLength; i++) {
                let eventname = AxiGamepad.EVENT_OUTPUT + i.toString();
                this.offAll(eventname);
            }
        }
    }
    AxiGamepad.EVENT_OUTPUT = "outputAxi_id";
    class ButtonGamepad extends Laya.EventDispatcher {
        constructor(handness, index) {
            super();
            this.lastTouch = false;
            this.lastPress = false;
            this.lastPressValue = 0;
            this.touch = false;
            this.press = false;
            this.pressValue = 0;
            this.handness = handness;
            this.index = index;
        }
        update(padButton) {
            this.lastTouch = this.touch;
            this.lastPress = this.press;
            this.lastPressValue = this.pressValue;
            this.touch = padButton.touched;
            this.press = padButton.pressed;
            this.pressValue = padButton.value;
            if (!this.lastTouch && !this.touch) {
                return;
            }
            if (this.lastTouch != this.touch && this.touch) {
                this.touchEnter();
            }
            else if (this.lastTouch == this.touch && this.touch) {
                this.touchStay();
            }
            else if (this.lastTouch != this.touch && !this.touch) {
                this.touchOut();
            }
            if (this.lastPress != this.press && this.press) {
                this.pressEnter();
            }
            else if (this.lastPress == this.press && this.press) {
                this.pressStay();
            }
            else if (this.lastPress != this.press && !this.press) {
                this.pressOut();
            }
            if (this.touch) {
                this.outpressed();
            }
        }
        touchEnter() {
            this.event(ButtonGamepad.EVENT_TOUCH_ENTER);
        }
        touchStay() {
            this.event(ButtonGamepad.EVENT_TOUCH_STAY);
        }
        touchOut() {
            this.event(ButtonGamepad.EVENT_TOUCH_OUT);
        }
        pressEnter() {
            this.event(ButtonGamepad.EVENT_PRESS_ENTER);
        }
        pressStay() {
            this.event(ButtonGamepad.EVENT_PRESS_STAY);
        }
        pressOut() {
            this.event(ButtonGamepad.EVENT_PRESS_OUT);
        }
        outpressed() {
            this.event(ButtonGamepad.EVENT_PRESS_VALUE, [this.pressValue]);
        }
        destroy() {
            this.offAll(ButtonGamepad.EVENT_PRESS_ENTER);
            this.offAll(ButtonGamepad.EVENT_PRESS_STAY);
            this.offAll(ButtonGamepad.EVENT_PRESS_OUT);
            this.offAll(ButtonGamepad.EVENT_PRESS_ENTER);
            this.offAll(ButtonGamepad.EVENT_PRESS_STAY);
            this.offAll(ButtonGamepad.EVENT_PRESS_OUT);
            this.offAll(ButtonGamepad.EVENT_PRESS_VALUE);
        }
    }
    ButtonGamepad.EVENT_TOUCH_ENTER = "touchEnter";
    ButtonGamepad.EVENT_TOUCH_STAY = "touchStay";
    ButtonGamepad.EVENT_TOUCH_OUT = "touchOut";
    ButtonGamepad.EVENT_PRESS_ENTER = "pressEnter";
    ButtonGamepad.EVENT_PRESS_STAY = "pressStay";
    ButtonGamepad.EVENT_PRESS_OUT = "pressOut";
    ButtonGamepad.EVENT_PRESS_VALUE = "outpressed";

    class WebXRInput extends Laya.EventDispatcher {
        constructor(handness) {
            super();
            this.preButtonEventList = [];
            this.preAxisEventList = [];
            this.handness = handness;
            this.position = new Laya.Vector3();
            this.rotation = new Laya.Quaternion();
            this.ray = new Ray(new Laya.Vector3(), new Laya.Vector3());
        }
        _updateByXRPose(xrFrame, referenceSpace) {
            const rayPose = xrFrame.getPose(this._inputSource.targetRaySpace, referenceSpace);
            this._lastXRPose = rayPose;
            if (rayPose) {
                const pos = rayPose.transform.position;
                const orientation = rayPose.transform.orientation;
                WebXRInput.tempQua.setValue(orientation.x, orientation.y, orientation.z, orientation.w);
                this.ray.origin.setValue(pos.x, pos.y, pos.z);
                Laya.Vector3.transformQuat(Laya.Vector3.UnitZ, WebXRInput.tempQua, this.ray.direction);
                Laya.Vector3.scale(this.ray.direction, -1, this.ray.direction);
            }
            if (this._inputSource.gripSpace) {
                let meshPose = xrFrame.getPose(this._inputSource.gripSpace, referenceSpace);
                if (meshPose) {
                    const pos = meshPose.transform.position;
                    const orientation = meshPose.transform.orientation;
                    this.position.setValue(pos.x, pos.y, pos.z);
                    this.rotation.setValue(orientation.x, orientation.y, orientation.z, orientation.w);
                }
            }
            this.event(WebXRInput.EVENT_FRAMEUPDATA_WEBXRINPUT, [this]);
            this._handleProcessGamepad();
        }
        _handleProcessGamepad() {
            const gamepad = this._inputSource.gamepad;
            if (!this.gamepadAxis) {
                this.gamepadAxis = new AxiGamepad(this.handness, gamepad.axes.length);
                this.preAxisEventList.forEach(element => {
                    this.gamepadAxis.on(element.eventnam, element.caller, element.listener);
                });
            }
            if (!this.gamepadButton) {
                this.gamepadButton = [];
                for (let i = 0; i < gamepad.buttons.length; ++i) {
                    this.gamepadButton.push(new ButtonGamepad(this.handness, i));
                }
                this.preButtonEventList.forEach(element => {
                    this.addButtonEvent(element.index, element.type, element.caller, element.listener);
                });
            }
            this.gamepadAxis.update(gamepad);
            for (let i = 0; i < gamepad.buttons.length; ++i) {
                let button = this.gamepadButton[i];
                button.update(gamepad.buttons[i]);
            }
        }
        addButtonEvent(index, type, caller, listener) {
            if (!this.gamepadButton) {
                this.preButtonEventList.push({
                    "index": index,
                    "type": type,
                    "caller": caller,
                    "listener": listener
                });
            }
            else {
                let button = this.gamepadButton[index];
                button.on(type, caller, listener);
            }
        }
        addAxisEvent(index, type, caller, listener) {
            if (!this.gamepadAxis) {
                this.preAxisEventList.push({
                    "eventnam": type + index.toString(),
                    "caller": caller,
                    "listener": listener
                });
            }
            else {
                const eventnam = type + index.toString();
                this.gamepadAxis.on(eventnam, caller, listener);
            }
        }
        offAxisEvent(index, type, caller, listener) {
            if (this.gamepadAxis) {
                const eventnam = type + index.toString();
                this.gamepadAxis.off(eventnam, caller, listener);
            }
        }
        offButtonEvent(index, type, caller, listener) {
            if (this.gamepadButton) {
                let button = this.gamepadButton[index];
                button.off(type, caller, listener);
            }
        }
        destroy() {
            this.preButtonEventList = null;
            this.ray = null;
            this.position = null;
            this.rotation = null;
            this.gamepadAxis.destroy();
            this.gamepadButton.forEach(element => {
                element.destroy();
            });
        }
    }
    WebXRInput.HANDNESS_LEFT = "left";
    WebXRInput.HANDNESS_RIGHT = "right";
    WebXRInput.EVENT_FRAMEUPDATA_WEBXRINPUT = "frameXRInputUpdate";
    WebXRInput.tempQua = new Laya.Quaternion();

    class WebXRInputManager {
        constructor(webxrManager, webXRCamera) {
            this.controllers = new Map();
            this.controllerHandMesh = new Map();
            this.controllerLineRender = new Map();
            this.lineColor = Laya.Color.RED;
            this.rayLength = 2;
            this.webXRSessionManager = webxrManager;
            this.webXRCameraManager = webXRCamera;
            this.webXRSessionManager.on(WebXRSessionManager.EVENT_MANAGER_END, this, this.destory);
            this.webXRSessionManager.on(WebXRSessionManager.EVENT_FRAME_LOOP, this, this._updateFromXRFrame);
        }
        _updataMeshRender(xrInput) {
            const handness = xrInput.handness;
            if (this.controllerHandMesh.has(handness)) {
                let meshNode = this.controllerHandMesh.get(handness);
                meshNode.transform.position = xrInput.position;
                meshNode.transform.rotation = xrInput.rotation;
            }
            if (this.controllerLineRender.has(handness)) {
                let line = this.controllerLineRender.get(handness);
                line.clear();
                let ray = xrInput.ray;
                WebXRInputManager.tempVec.setValue(ray.origin.x, ray.origin.y, ray.origin.z);
                Laya.Vector3.scale(ray.direction, this.rayLength, WebXRInputManager.tempVec1);
                Laya.Vector3.add(WebXRInputManager.tempVec, WebXRInputManager.tempVec1, WebXRInputManager.tempVec1);
                line.addLine(WebXRInputManager.tempVec, WebXRInputManager.tempVec1, this.lineColor, this.lineColor);
            }
        }
        _updateFromXRFrame(xrFrame) {
            const session = this.webXRSessionManager.session;
            const refSpace = this.webXRSessionManager.referenceSpace;
            for (let inputSource of session.inputSources) {
                const key = inputSource.handedness;
                let xrInput;
                if (!this.controllers.has(key)) {
                    xrInput = this.getController(key);
                }
                else
                    xrInput = this.controllers.get(key);
                if (xrInput) {
                    xrInput = this.controllers.get(key);
                    xrInput._inputSource = inputSource;
                    xrInput._updateByXRPose(xrFrame, refSpace);
                }
            }
        }
        bindMeshNode(meshSprite, handness) {
            this.controllerHandMesh.set(handness, meshSprite);
        }
        bindRayNode(lineSprite, handness) {
            this.controllerLineRender.set(handness, lineSprite);
        }
        getController(handness) {
            if (handness != "left" && handness != "right")
                return null;
            if (!this.controllers.has(handness)) {
                let value = new WebXRInput(handness);
                this.controllers.set(handness, value);
                value.on(WebXRInput.EVENT_FRAMEUPDATA_WEBXRINPUT, this, this._updataMeshRender);
            }
            return this.controllers.get(handness);
        }
        destory() {
            this.webXRSessionManager.off(WebXRSessionManager.EVENT_FRAME_LOOP, this, this._updateFromXRFrame);
            for (let key in this.controllers) {
                this.controllers.get(key).off("frameXRInputUpdate", this, this._updataMeshRender);
                this.controllers.get(key).destroy();
            }
            this.controllers = null;
            this.controllerHandMesh = null;
            this.controllerLineRender = null;
        }
    }
    WebXRInputManager.tempVec = new Laya.Vector3();
    WebXRInputManager.tempVec1 = new Laya.Vector3();

    class WebXRCameraInfo {
    }
    class WebXRExperienceHelper {
        static supportXR(sessionMode) {
            return WebXRExperienceHelper.xr_Manager.isSessionSupportedAsync(sessionMode).then(value => {
                WebXRExperienceHelper.supported = value;
                return value;
            });
        }
        static enterXRAsync(sessionMode, referenceSpaceType, cameraInfo) {
            if (sessionMode === "immersive-ar" && referenceSpaceType !== "unbounded") {
                console.warn("We recommend using 'unbounded' reference space type when using 'immersive-ar' session mode");
            }
            return WebXRExperienceHelper.xr_Manager.initializeSessionAsync(sessionMode).then(() => {
                return WebXRExperienceHelper.xr_Manager.setReferenceSpaceTypeAsync(referenceSpaceType);
            }).then(() => {
                return WebXRExperienceHelper.xr_Manager.initializeXRGL(sessionMode, Laya.LayaGL.renderEngine._gl);
            }).then(() => {
                WebXRExperienceHelper.glInstance = Laya.LayaGL.renderEngine._gl;
                return WebXRExperienceHelper.xr_Manager.updateRenderStateAsync({
                    depthFar: cameraInfo.depthFar,
                    depthNear: cameraInfo.depthNear,
                    baseLayer: new XRWebGLLayer(WebXRExperienceHelper.xr_Manager.session, Laya.LayaGL.instance),
                });
            }).then(() => {
                WebXRExperienceHelper.xr_Manager.runXRRenderLoop();
                return WebXRExperienceHelper.xr_Manager;
            });
        }
        static setWebXRCamera(camera, manager) {
            return new WebXRCameraManager(camera, manager);
        }
        static setWebXRInput(sessionManager, cameraManager) {
            return new WebXRInputManager(sessionManager, cameraManager);
        }
    }
    WebXRExperienceHelper.xr_Manager = new WebXRSessionManager();
    WebXRExperienceHelper.supported = false;
    WebXRExperienceHelper.canvasOptions = {
        antialias: true,
        depth: true,
        stencil: false,
        alpha: true,
        multiview: false,
        framebufferScaleFactor: 1,
    };

    class WebXRCamera extends Camera {
        constructor() {
            super(...arguments);
            this.isWebXR = true;
        }
        get renderTarget() {
            return this._internalRenderTexture;
        }
        set renderTarget(value) {
            this._internalRenderTexture = value;
        }
        set clientWidth(value) {
            this._clientWidth = value;
        }
        set clientHeight(value) {
            this._clientHeight = value;
        }
        get clientWidth() {
            return this._clientWidth;
        }
        get clientHeight() {
            return this._clientHeight;
        }
        _restoreView(gl) {
            var viewport = this.viewport;
            var vpX, vpY;
            var vpW = viewport.width;
            var vpH = viewport.height;
            if (this._needInternalRenderTexture()) {
                vpX = 0;
                vpY = 0;
            }
            else {
                vpX = viewport.x;
                vpY = this._getCanvasHeight() - viewport.y - vpH;
            }
            gl.viewport(vpX, vpY, vpW, vpH);
        }
        render(shader = null, replacementTag = null) {
            if (!this.activeInHierarchy)
                return;
            var viewport = this.viewport;
            var needInternalRT = true;
            var context = RenderContext3D._instance;
            var scene = context.scene = this._scene;
            context.pipelineMode = context.configPipeLineMode;
            context.replaceTag = replacementTag;
            context.customShader = shader;
            var needShadowCasterPass = this._renderShadowMap(scene, context);
            this._preRenderMainPass(context, scene, needInternalRT, viewport);
            this._renderMainPass(context, viewport, scene, shader, replacementTag, needInternalRT);
            this._aftRenderMainPass(needShadowCasterPass);
        }
        _renderMainPass(context, viewport, scene, shader, replacementTag, needInternalRT) {
            var gl = WebXRExperienceHelper.glInstance;
            var renderTex = this._internalRenderTexture;
            context.viewport = viewport;
            this._prepareCameraToRender();
            var multiLighting = Laya.Config3D._multiLighting;
            (multiLighting) && (Cluster.instance.update(this, (scene)));
            scene._preCulling(context, this);
            if (renderTex && renderTex._isCameraTarget)
                context.invertY = true;
            this._applyViewProject(context, this.viewMatrix, this._projectionMatrix);
            if (this.depthTextureMode != 0) {
                this._renderDepthMode(context);
            }
            (renderTex) && (renderTex._start());
            if (renderTex.frameLoop != Scene3D._updateMark) {
                renderTex.frameLoop = Scene3D._updateMark;
                this.clear(gl);
            }
            this._restoreView(gl);
            this._prepareCameraToRender();
            this._applyCommandBuffer(exports.CameraEventFlags.BeforeForwardOpaque, context);
            scene._renderScene(context, ILaya3D.Scene3D.SCENERENDERFLAG_RENDERQPAQUE);
            this._applyCommandBuffer(exports.CameraEventFlags.BeforeSkyBox, context);
            scene._renderScene(context, ILaya3D.Scene3D.SCENERENDERFLAG_SKYBOX);
            this._applyCommandBuffer(exports.CameraEventFlags.BeforeTransparent, context);
            scene._renderScene(context, ILaya3D.Scene3D.SCENERENDERFLAG_RENDERTRANSPARENT);
            scene._componentDriver.callPostRender();
            this._applyCommandBuffer(exports.CameraEventFlags.BeforeImageEffect, context);
            (renderTex) && (renderTex._end());
            this._applyCommandBuffer(exports.CameraEventFlags.AfterEveryThing, context);
        }
        _calculateProjectionMatrix() {
        }
        clear(gl) {
            gl.viewport(0, 0, this._clientWidth, this._clientHeight);
            gl.scissor(0, 0, this._clientWidth, this._clientHeight);
            gl.clearColor(this.clearColor.r, this.clearColor.g, this.clearColor.b, this.clearColor.a);
            Laya.RenderStateContext.setDepthMask(true);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        }
        destroy() {
            super.destroy(true);
        }
    }

    class Constraint3D {
        constructor() {
        }
    }

    class ConstraintComponent extends Laya.Component {
        constructor(constraintType) {
            super();
            this._anchor = new Laya.Vector3();
            this._connectAnchor = new Laya.Vector3();
            this._feedbackEnabled = false;
            this._getJointFeedBack = false;
            this._currentForce = new Laya.Vector3();
            this._currentTorque = new Laya.Vector3();
            this.disableCollisionsBetweenLinkedBodies = true;
            this._constraintType = constraintType;
            var bt = Physics3D._bullet;
            this._btframATrans = bt.btTransform_create();
            this._btframBTrans = bt.btTransform_create();
            bt.btTransform_setIdentity(this._btframATrans);
            bt.btTransform_setIdentity(this._btframBTrans);
            this._btframAPos = bt.btVector3_create(0, 0, 0);
            this._btframBPos = bt.btVector3_create(0, 0, 0);
            bt.btTransform_setOrigin(this._btframATrans, this._btframAPos);
            bt.btTransform_setOrigin(this._btframBTrans, this._btframBPos);
            this._breakForce = -1;
            this._breakTorque = -1;
        }
        get appliedImpulse() {
            if (!this._feedbackEnabled) {
                this._btConstraint.EnableFeedback(true);
                this._feedbackEnabled = true;
            }
            return this._btConstraint.AppliedImpulse;
        }
        set connectedBody(value) {
            this._connectedBody = value;
        }
        get connectedBody() {
            return this._connectedBody;
        }
        get ownBody() {
            return this._ownBody;
        }
        set ownBody(value) {
            this._ownBody = value;
        }
        get currentForce() {
            if (!this._getJointFeedBack)
                this._getFeedBackInfo();
            return this._currentForce;
        }
        get currentTorque() {
            if (!this._getJointFeedBack)
                this._getFeedBackInfo();
            return this._currentTorque;
        }
        get breakForce() {
            return this._breakForce;
        }
        set breakForce(value) {
            this._breakForce = value;
        }
        get breakTorque() {
            return this._breakTorque;
        }
        set breakTorque(value) {
            this._breakTorque = value;
        }
        set anchor(value) {
            value.cloneTo(this._anchor);
            this.setFrames();
        }
        get anchor() {
            return this._anchor;
        }
        set connectAnchor(value) {
            value.cloneTo(this._connectAnchor);
            this.setFrames();
        }
        get connectAnchor() {
            return this._connectAnchor;
        }
        setOverrideNumSolverIterations(overideNumIterations) {
            var bt = Physics3D._bullet;
            bt.btTypedConstraint_setOverrideNumSolverIterations(this._btConstraint, overideNumIterations);
        }
        setConstraintEnabled(enable) {
            var bt = Physics3D._bullet;
            bt.btTypedConstraint_setEnabled(this._btConstraint, enable);
        }
        setFrames() {
            var bt = Physics3D._bullet;
            bt.btVector3_setValue(this._btframAPos, this._anchor.x, this.anchor.y, this.anchor.z);
            bt.btVector3_setValue(this._btframBPos, this._connectAnchor.x, this._connectAnchor.y, this._connectAnchor.z);
            bt.btTransform_setOrigin(this._btframATrans, this._btframAPos);
            bt.btTransform_setOrigin(this._btframBTrans, this._btframBPos);
        }
        _addToSimulation() {
        }
        _removeFromSimulation() {
        }
        _createConstraint() {
        }
        setConnectRigidBody(ownerRigid, connectRigidBody) {
            var ownerCanInSimulation = ownerRigid && !!(ownerRigid._simulation && ownerRigid._enabled && ownerRigid.colliderShape);
            var connectCanInSimulation = connectRigidBody && !!(connectRigidBody._simulation && connectRigidBody._enabled && connectRigidBody.colliderShape);
            if (!(ownerCanInSimulation && connectCanInSimulation))
                throw "ownerRigid or connectRigidBody is not in Simulation";
            if (ownerRigid != this._ownBody || connectRigidBody != this._connectedBody) {
                var canInSimulation = !!(this.enabled && this._simulation);
                canInSimulation && this._removeFromSimulation();
                this._ownBody = ownerRigid;
                this._connectedBody = connectRigidBody;
                this._createConstraint();
            }
        }
        _setConnectRigidBody(A, B) {
            this.ownBody = A;
            this.connectedBody = B;
            this._createConstraint();
        }
        getcurrentForce(out) {
            if (!this._btJointFeedBackObj)
                throw "this Constraint is not simulation";
            var bt = Physics3D._bullet;
            var applyForce = bt.btJointFeedback_getAppliedForceBodyA(this._btJointFeedBackObj);
            out.setValue(bt.btVector3_x(applyForce), bt.btVector3_y(applyForce), bt.btVector3_z(applyForce));
            return;
        }
        getPhysicsSimulation() {
            return this.owner._scene.physicsSimulation;
        }
        getcurrentTorque(out) {
            if (!this._btJointFeedBackObj)
                throw "this Constraint is not simulation";
            var bt = Physics3D._bullet;
            var applyTorque = bt.btJointFeedback_getAppliedTorqueBodyA(this._btJointFeedBackObj);
            out.setValue(bt.btVector3_x(applyTorque), bt.btVector3_y(applyTorque), bt.btVector3_z(applyTorque));
            return;
        }
        _onDestroy() {
            var physics3D = Physics3D._bullet;
            this._simulation && this._removeFromSimulation();
            if (this._btConstraint && this._btJointFeedBackObj && this._simulation) {
                physics3D.btTypedConstraint_destroy(this._btConstraint);
                physics3D.btJointFeedback_destroy(this._btJointFeedBackObj);
                this._btJointFeedBackObj = null;
                this._btConstraint = null;
            }
        }
        _isBreakConstrained() {
            this._getJointFeedBack = false;
            if (this.breakForce == -1 && this.breakTorque == -1)
                return false;
            this._getFeedBackInfo();
            var isBreakForce = this._breakForce != -1 && (Laya.Vector3.scalarLength(this._currentForce) > this._breakForce);
            var isBreakTorque = this._breakTorque != -1 && (Laya.Vector3.scalarLength(this._currentTorque) > this._breakTorque);
            if (isBreakForce || isBreakTorque) {
                this._breakConstrained();
                return true;
            }
            return false;
        }
        _parse(data) {
            this._anchor.fromArray(data.anchor);
            this._connectAnchor.fromArray(data.connectAnchor);
            this.setFrames();
        }
        _getFeedBackInfo() {
            var bt = Physics3D._bullet;
            var applyForce = bt.btJointFeedback_getAppliedForceBodyA(this._btJointFeedBackObj);
            var applyTorque = bt.btJointFeedback_getAppliedTorqueBodyA(this._btJointFeedBackObj);
            this._currentTorque.setValue(bt.btVector3_x(applyTorque), bt.btVector3_y(applyTorque), bt.btVector3_z(applyTorque));
            this._currentForce.setValue(bt.btVector3_x(applyForce), bt.btVector3_y(applyForce), bt.btVector3_z(applyForce));
            this._getJointFeedBack = true;
        }
        _breakConstrained() {
            this.destroy();
        }
    }
    ConstraintComponent.CONSTRAINT_POINT2POINT_CONSTRAINT_TYPE = 3;
    ConstraintComponent.CONSTRAINT_HINGE_CONSTRAINT_TYPE = 4;
    ConstraintComponent.CONSTRAINT_CONETWIST_CONSTRAINT_TYPE = 5;
    ConstraintComponent.CONSTRAINT_D6_CONSTRAINT_TYPE = 6;
    ConstraintComponent.CONSTRAINT_SLIDER_CONSTRAINT_TYPE = 7;
    ConstraintComponent.CONSTRAINT_CONTACT_CONSTRAINT_TYPE = 8;
    ConstraintComponent.CONSTRAINT_D6_SPRING_CONSTRAINT_TYPE = 9;
    ConstraintComponent.CONSTRAINT_GEAR_CONSTRAINT_TYPE = 10;
    ConstraintComponent.CONSTRAINT_FIXED_CONSTRAINT_TYPE = 11;
    ConstraintComponent.CONSTRAINT_MAX_CONSTRAINT_TYPE = 12;
    ConstraintComponent.CONSTRAINT_CONSTRAINT_ERP = 1;
    ConstraintComponent.CONSTRAINT_CONSTRAINT_STOP_ERP = 2;
    ConstraintComponent.CONSTRAINT_CONSTRAINT_CFM = 3;
    ConstraintComponent.CONSTRAINT_CONSTRAINT_STOP_CFM = 4;
    ConstraintComponent.tempForceV3 = new Laya.Vector3();

    class ConfigurableConstraint extends ConstraintComponent {
        constructor() {
            super(ConstraintComponent.CONSTRAINT_D6_SPRING_CONSTRAINT_TYPE);
            this._axis = new Laya.Vector3();
            this._secondaryAxis = new Laya.Vector3();
            this._minLinearLimit = new Laya.Vector3();
            this._maxLinearLimit = new Laya.Vector3();
            this._minAngularLimit = new Laya.Vector3();
            this._maxAngularLimit = new Laya.Vector3();
            this._linearLimitSpring = new Laya.Vector3();
            this._angularLimitSpring = new Laya.Vector3();
            this._linearBounce = new Laya.Vector3();
            this._angularBounce = new Laya.Vector3();
            this._linearDamp = new Laya.Vector3();
            this._angularDamp = new Laya.Vector3();
            this._xMotion = 0;
            this._yMotion = 0;
            this._zMotion = 0;
            this._angularXMotion = 0;
            this._angularYMotion = 0;
            this._angularZMotion = 0;
            var bt = Physics3D._bullet;
            this._btAxis = bt.btVector3_create(0, 0.0, 1);
            this._btSecondaryAxis = bt.btVector3_create(0.0, 1.0, 0.0);
        }
        get axis() {
            return this._axis;
        }
        get secondaryAxis() {
            return this._secondaryAxis;
        }
        set maxAngularLimit(value) {
            value.cloneTo(this._maxAngularLimit);
        }
        set minAngularLimit(value) {
            value.cloneTo(this._minAngularLimit);
        }
        get maxAngularLimit() {
            return this._maxAngularLimit;
        }
        get minAngularLimit() {
            return this._minAngularLimit;
        }
        set maxLinearLimit(value) {
            value.cloneTo(this._maxLinearLimit);
        }
        set minLinearLimit(value) {
            value.cloneTo(this._minLinearLimit);
        }
        get maxLinearLimit() {
            return this._maxLinearLimit;
        }
        get minLinearLimit() {
            return this._minLinearLimit;
        }
        set XMotion(value) {
            if (this._xMotion != value) {
                this._xMotion = value;
                this.setLimit(ConfigurableConstraint.MOTION_LINEAR_INDEX_X, value, this._minLinearLimit.x, this._maxLinearLimit.x);
            }
        }
        get XMotion() {
            return this._xMotion;
        }
        set YMotion(value) {
            if (this._yMotion != value) {
                this._yMotion = value;
                this.setLimit(ConfigurableConstraint.MOTION_LINEAR_INDEX_Y, value, this._minLinearLimit.y, this._maxLinearLimit.y);
            }
        }
        get YMotion() {
            return this._yMotion;
        }
        set ZMotion(value) {
            if (this._zMotion != value) {
                this._zMotion = value;
                this.setLimit(ConfigurableConstraint.MOTION_LINEAR_INDEX_Z, value, this._minLinearLimit.z, this._maxLinearLimit.z);
            }
        }
        get ZMotion() {
            return this._zMotion;
        }
        set angularXMotion(value) {
            if (this._angularXMotion != value) {
                this._angularXMotion = value;
                this.setLimit(ConfigurableConstraint.MOTION_ANGULAR_INDEX_X, value, this._minAngularLimit.x, this._maxAngularLimit.x);
            }
        }
        get angularXMotion() {
            return this._angularXMotion;
        }
        set angularYMotion(value) {
            if (this._angularYMotion != value) {
                this._angularYMotion = value;
                this.setLimit(ConfigurableConstraint.MOTION_ANGULAR_INDEX_Y, value, this._minAngularLimit.y, this._maxAngularLimit.y);
            }
        }
        get angularYMotion() {
            return this._angularYMotion;
        }
        set angularZMotion(value) {
            if (this._angularZMotion != value) {
                this._angularZMotion = value;
                this.setLimit(ConfigurableConstraint.MOTION_ANGULAR_INDEX_Z, value, this._minAngularLimit.z, this._maxAngularLimit.z);
            }
        }
        get angularZMotion() {
            return this._angularZMotion;
        }
        set linearLimitSpring(value) {
            if (!Laya.Vector3.equals(this._linearLimitSpring, value)) {
                value.cloneTo(this._linearLimitSpring);
                this.setSpring(ConfigurableConstraint.MOTION_LINEAR_INDEX_X, value.x);
                this.setSpring(ConfigurableConstraint.MOTION_LINEAR_INDEX_Y, value.y);
                this.setSpring(ConfigurableConstraint.MOTION_LINEAR_INDEX_Z, value.z);
            }
        }
        get linearLimitSpring() {
            return this._linearLimitSpring;
        }
        set angularLimitSpring(value) {
            if (!Laya.Vector3.equals(this._angularLimitSpring, value)) {
                value.cloneTo(this._angularLimitSpring);
                this.setSpring(ConfigurableConstraint.MOTION_ANGULAR_INDEX_X, value.x);
                this.setSpring(ConfigurableConstraint.MOTION_ANGULAR_INDEX_Y, value.y);
                this.setSpring(ConfigurableConstraint.MOTION_ANGULAR_INDEX_Z, value.z);
            }
        }
        get angularLimitSpring() {
            return this._angularLimitSpring;
        }
        set linearBounce(value) {
            if (!Laya.Vector3.equals(this._linearBounce, value)) {
                value.cloneTo(this._linearBounce);
                this.setBounce(ConfigurableConstraint.MOTION_LINEAR_INDEX_X, value.x);
                this.setBounce(ConfigurableConstraint.MOTION_LINEAR_INDEX_Y, value.y);
                this.setBounce(ConfigurableConstraint.MOTION_LINEAR_INDEX_Z, value.z);
            }
        }
        get linearBounce() {
            return this._linearBounce;
        }
        set angularBounce(value) {
            if (!Laya.Vector3.equals(this._angularBounce, value)) {
                value.cloneTo(this._angularBounce);
                this.setBounce(ConfigurableConstraint.MOTION_ANGULAR_INDEX_X, value.x);
                this.setBounce(ConfigurableConstraint.MOTION_ANGULAR_INDEX_Y, value.y);
                this.setBounce(ConfigurableConstraint.MOTION_ANGULAR_INDEX_Z, value.z);
            }
        }
        get angularBounce() {
            return this._angularBounce;
        }
        set linearDamp(value) {
            if (!Laya.Vector3.equals(this._linearDamp, value)) {
                value.cloneTo(this._linearDamp);
                this.setDamping(ConfigurableConstraint.MOTION_LINEAR_INDEX_X, value.x);
                this.setDamping(ConfigurableConstraint.MOTION_LINEAR_INDEX_Y, value.y);
                this.setDamping(ConfigurableConstraint.MOTION_LINEAR_INDEX_Z, value.z);
            }
        }
        get linearDamp() {
            return this._linearDamp;
        }
        set angularDamp(value) {
            if (!Laya.Vector3.equals(this._angularDamp, value)) {
                value.cloneTo(this._angularDamp);
                this.setDamping(ConfigurableConstraint.MOTION_ANGULAR_INDEX_X, value.x);
                this.setDamping(ConfigurableConstraint.MOTION_ANGULAR_INDEX_Y, value.y);
                this.setDamping(ConfigurableConstraint.MOTION_ANGULAR_INDEX_Z, value.z);
            }
        }
        get angularDamp() {
            return this._angularDamp;
        }
        set anchor(value) {
            value.cloneTo(this._anchor);
            this.setFrames();
        }
        get anchor() {
            return this._anchor;
        }
        set connectAnchor(value) {
            value.cloneTo(this._connectAnchor);
            this.setFrames();
        }
        get connectAnchor() {
            return this._connectAnchor;
        }
        setAxis(axis, secondaryAxis) {
            if (!this._btConstraint)
                return;
            var bt = Physics3D._bullet;
            this._axis.setValue(axis.x, axis.y, axis.y);
            this._secondaryAxis.setValue(secondaryAxis.x, secondaryAxis.y, secondaryAxis.z);
            bt.btVector3_setValue(this._btAxis, axis.x, axis.y, axis.z);
            bt.btVector3_setValue(this._btSecondaryAxis, secondaryAxis.x, secondaryAxis.y, secondaryAxis.z);
            bt.btGeneric6DofSpring2Constraint_setAxis(this._btConstraint, this._btAxis, this._btSecondaryAxis);
        }
        setLimit(axis, motionType, low, high) {
            if (!this._btConstraint)
                return;
            var bt = Physics3D._bullet;
            switch (motionType) {
                case ConfigurableConstraint.CONFIG_MOTION_TYPE_LOCKED:
                    bt.btGeneric6DofSpring2Constraint_setLimit(this._btConstraint, axis, 0, 0);
                    break;
                case ConfigurableConstraint.CONFIG_MOTION_TYPE_LIMITED:
                    if (low < high)
                        bt.btGeneric6DofSpring2Constraint_setLimit(this._btConstraint, axis, low, high);
                    break;
                case ConfigurableConstraint.CONFIG_MOTION_TYPE_FREE:
                    bt.btGeneric6DofSpring2Constraint_setLimit(this._btConstraint, axis, 1, 0);
                    break;
                default:
                    throw "No Type of Axis Motion";
            }
        }
        setSpring(axis, springValue, limitIfNeeded = true) {
            if (!this._btConstraint)
                return;
            var bt = Physics3D._bullet;
            var enableSpring = springValue > 0;
            bt.btGeneric6DofSpring2Constraint_enableSpring(this._btConstraint, axis, enableSpring);
            if (enableSpring)
                bt.btGeneric6DofSpring2Constraint_setStiffness(this._btConstraint, axis, springValue, limitIfNeeded);
        }
        setBounce(axis, bounce) {
            if (!this._btConstraint)
                return;
            var bt = Physics3D._bullet;
            bounce = bounce <= 0 ? 0 : bounce;
            bt.btGeneric6DofSpring2Constraint_setBounce(this._btConstraint, axis, bounce);
        }
        setDamping(axis, damp, limitIfNeeded = true) {
            if (!this._btConstraint)
                return;
            var bt = Physics3D._bullet;
            damp = damp <= 0 ? 0 : damp;
            bt.btGeneric6DofSpring2Constraint_setDamping(this._btConstraint, axis, damp, limitIfNeeded);
        }
        setEquilibriumPoint(axis, equilibriumPoint) {
            var bt = Physics3D._bullet;
            bt.btGeneric6DofSpring2Constraint_setEquilibriumPoint(this._btConstraint, axis, equilibriumPoint);
        }
        enableMotor(axis, isEnableMotor) {
            var bt = Physics3D._bullet;
            bt.btGeneric6DofSpring2Constraint_enableMotor(this._btConstraint, axis, isEnableMotor);
        }
        setServo(axis, onOff) {
            var bt = Physics3D._bullet;
            bt.btGeneric6DofSpring2Constraint_setServo(this._btConstraint, axis, onOff);
        }
        setTargetVelocity(axis, velocity) {
            var bt = Physics3D._bullet;
            bt.btGeneric6DofSpring2Constraint_setTargetVelocity(this._btConstraint, axis, velocity);
        }
        setTargetPosition(axis, target) {
            var bt = Physics3D._bullet;
            bt.btGeneric6DofSpring2Constraint_setServoTarget(this._btConstraint, axis, target);
        }
        setMaxMotorForce(axis, force) {
            var bt = Physics3D._bullet;
            bt.btGeneric6DofSpring2Constraint_setMaxMotorForce(this._btConstraint, axis, force);
        }
        setParam(axis, constraintParams, value) {
            var bt = Physics3D._bullet;
            bt.btTypedConstraint_setParam(this._btConstraint, axis, constraintParams, value);
        }
        setFrames() {
            super.setFrames();
            var bt = Physics3D._bullet;
            if (!this._btConstraint)
                return;
            bt.btGeneric6DofSpring2Constraint_setFrames(this._btConstraint, this._btframATrans, this._btframBTrans);
        }
        _addToSimulation() {
            this._simulation && this._simulation.addConstraint(this, this.disableCollisionsBetweenLinkedBodies);
        }
        _removeFromSimulation() {
            this._simulation.removeConstraint(this);
            this._simulation = null;
        }
        _createConstraint() {
            var bt = Physics3D._bullet;
            this._btConstraint = bt.btGeneric6DofSpring2Constraint_create(this.ownBody.btColliderObject, this._btframATrans, this.connectedBody.btColliderObject, this._btframBTrans, ConfigurableConstraint.RO_XYZ);
            this._btJointFeedBackObj = bt.btJointFeedback_create(this._btConstraint);
            bt.btTypedConstraint_setJointFeedback(this._btConstraint, this._btJointFeedBackObj);
            this._initAllConstraintInfo();
            bt.btTypedConstraint_setEnabled(this._btConstraint, true);
            this._simulation = this.getPhysicsSimulation();
            this._addToSimulation();
        }
        _initAllConstraintInfo() {
            this.setLimit(ConfigurableConstraint.MOTION_LINEAR_INDEX_X, this._xMotion, this._minLinearLimit.x, this._maxLinearLimit.x);
            this.setLimit(ConfigurableConstraint.MOTION_LINEAR_INDEX_Y, this._yMotion, this._minLinearLimit.y, this._maxLinearLimit.y);
            this.setLimit(ConfigurableConstraint.MOTION_LINEAR_INDEX_Z, this._zMotion, this._minLinearLimit.z, this._maxLinearLimit.z);
            this.setLimit(ConfigurableConstraint.MOTION_ANGULAR_INDEX_X, this._angularXMotion, this._minAngularLimit.x, this._maxAngularLimit.x);
            this.setLimit(ConfigurableConstraint.MOTION_ANGULAR_INDEX_Y, this._angularYMotion, this._minAngularLimit.y, this._maxAngularLimit.y);
            this.setLimit(ConfigurableConstraint.MOTION_ANGULAR_INDEX_Z, this._angularZMotion, this._minAngularLimit.z, this._maxAngularLimit.z);
            this.setSpring(ConfigurableConstraint.MOTION_LINEAR_INDEX_X, this._linearLimitSpring.x);
            this.setSpring(ConfigurableConstraint.MOTION_LINEAR_INDEX_Y, this._linearLimitSpring.y);
            this.setSpring(ConfigurableConstraint.MOTION_LINEAR_INDEX_Z, this._linearLimitSpring.z);
            this.setSpring(ConfigurableConstraint.MOTION_ANGULAR_INDEX_X, this._angularLimitSpring.x);
            this.setSpring(ConfigurableConstraint.MOTION_ANGULAR_INDEX_Y, this._angularLimitSpring.y);
            this.setSpring(ConfigurableConstraint.MOTION_ANGULAR_INDEX_Z, this._angularLimitSpring.z);
            this.setBounce(ConfigurableConstraint.MOTION_LINEAR_INDEX_X, this._linearBounce.x);
            this.setBounce(ConfigurableConstraint.MOTION_LINEAR_INDEX_Y, this._linearBounce.y);
            this.setBounce(ConfigurableConstraint.MOTION_LINEAR_INDEX_Z, this._linearBounce.z);
            this.setBounce(ConfigurableConstraint.MOTION_ANGULAR_INDEX_X, this._angularBounce.x);
            this.setBounce(ConfigurableConstraint.MOTION_ANGULAR_INDEX_Y, this._angularBounce.y);
            this.setBounce(ConfigurableConstraint.MOTION_ANGULAR_INDEX_Z, this._angularBounce.z);
            this.setDamping(ConfigurableConstraint.MOTION_LINEAR_INDEX_X, this._linearDamp.x);
            this.setDamping(ConfigurableConstraint.MOTION_LINEAR_INDEX_Y, this._linearDamp.y);
            this.setDamping(ConfigurableConstraint.MOTION_LINEAR_INDEX_Z, this._linearDamp.z);
            this.setDamping(ConfigurableConstraint.MOTION_ANGULAR_INDEX_X, this._angularDamp.x);
            this.setDamping(ConfigurableConstraint.MOTION_ANGULAR_INDEX_Y, this._angularDamp.y);
            this.setDamping(ConfigurableConstraint.MOTION_ANGULAR_INDEX_Z, this._angularDamp.z);
            this.setFrames();
            this.setEquilibriumPoint(0, 0);
        }
        _onEnable() {
            if (this._btConstraint)
                Physics3D._bullet.btTypedConstraint_setEnabled(this._btConstraint, true);
        }
        _onDisable() {
            if (!this.connectedBody && this._simulation)
                this._removeFromSimulation();
            if (this._btConstraint)
                Physics3D._bullet.btTypedConstraint_setEnabled(this._btConstraint, false);
        }
        _parse(data, interactMap = null) {
            super._parse(data);
            this._axis.fromArray(data.axis);
            this._secondaryAxis.fromArray(data.secondaryAxis);
            var limitlimit = data.linearLimit;
            this._minLinearLimit.setValue(-limitlimit, -limitlimit, -limitlimit);
            this._maxLinearLimit.setValue(limitlimit, limitlimit, limitlimit);
            var limitSpring = data.linearLimitSpring;
            this._linearLimitSpring.setValue(limitSpring, limitSpring, limitSpring);
            var limitDamp = data.linearLimitDamper;
            this._linearDamp.setValue(limitDamp, limitDamp, limitDamp);
            var limitBounciness = data.linearLimitBounciness;
            this._linearBounce.setValue(limitBounciness, limitBounciness, limitBounciness);
            var xlowAngularLimit = data.lowAngularXLimit;
            var xhighAngularLimit = data.highAngularXLimit;
            var yAngularLimit = data.angularYLimit;
            var zAngularLimit = data.angularZLimit;
            this._minAngularLimit.setValue(xlowAngularLimit, -yAngularLimit, -zAngularLimit);
            this._maxAngularLimit.setValue(xhighAngularLimit, yAngularLimit, zAngularLimit);
            var xhighAngularBounciness = data.highAngularXLimitBounciness;
            var ybounciness = data.angularYLimitBounciness;
            var zbounciness = data.angularZLimitBounciness;
            this._angularBounce.setValue(xhighAngularBounciness, ybounciness, zbounciness);
            var xAngularSpring = data.angularXLimitSpring;
            var yzAngularSpriny = data.angularYZLimitSpring;
            this._angularLimitSpring.setValue(xAngularSpring, yzAngularSpriny, yzAngularSpriny);
            var xAngularDamper = data.angularXLimitDamper;
            var yzAngularDamper = data.angularYZLimitDamper;
            this._angularDamp.setValue(xAngularDamper, yzAngularDamper, yzAngularDamper);
            this.XMotion = data.xMotion;
            this.YMotion = data.yMotion;
            this.ZMotion = data.zMotion;
            this.angularXMotion = data.angularXMotion;
            this.angularYMotion = data.angularYMotion;
            this.angularZMotion = data.angularZMotion;
            if (data.rigidbodyID != -1 && data.connectRigidbodyID != -1) {
                interactMap.component.push(this);
                interactMap.data.push(data);
            }
            (data.breakForce != undefined) && (this.breakForce = data.breakForce);
            (data.breakTorque != undefined) && (this.breakTorque = data.breakTorque);
        }
        _parseInteractive(data = null, spriteMap = null) {
            var rigidBodySprite = spriteMap[data.rigidbodyID];
            var rigidBody = rigidBodySprite.getComponent(Rigidbody3D);
            var connectSprite = spriteMap[data.connectRigidbodyID];
            var connectRigidbody = connectSprite.getComponent(Rigidbody3D);
            this.ownBody = rigidBody;
            this.connectedBody = connectRigidbody;
        }
    }
    ConfigurableConstraint.CONFIG_MOTION_TYPE_LOCKED = 0;
    ConfigurableConstraint.CONFIG_MOTION_TYPE_LIMITED = 1;
    ConfigurableConstraint.CONFIG_MOTION_TYPE_FREE = 2;
    ConfigurableConstraint.MOTION_LINEAR_INDEX_X = 0;
    ConfigurableConstraint.MOTION_LINEAR_INDEX_Y = 1;
    ConfigurableConstraint.MOTION_LINEAR_INDEX_Z = 2;
    ConfigurableConstraint.MOTION_ANGULAR_INDEX_X = 3;
    ConfigurableConstraint.MOTION_ANGULAR_INDEX_Y = 4;
    ConfigurableConstraint.MOTION_ANGULAR_INDEX_Z = 5;
    ConfigurableConstraint.RO_XYZ = 0;
    ConfigurableConstraint.RO_XZY = 1;
    ConfigurableConstraint.RO_YXZ = 2;
    ConfigurableConstraint.RO_YZX = 3;
    ConfigurableConstraint.RO_ZXY = 4;
    ConfigurableConstraint.RO_ZYX = 5;

    class FixedConstraint extends ConstraintComponent {
        constructor() {
            super(ConstraintComponent.CONSTRAINT_FIXED_CONSTRAINT_TYPE);
            this.breakForce = -1;
            this.breakTorque = -1;
        }
        _addToSimulation() {
            this._simulation && this._simulation.addConstraint(this, this.disableCollisionsBetweenLinkedBodies);
        }
        _removeFromSimulation() {
            this._simulation.removeConstraint(this);
            this._simulation = null;
        }
        _createConstraint() {
            if (this.ownBody && this.ownBody._simulation && this.connectedBody && this.connectedBody._simulation) {
                var bt = Physics3D._bullet;
                this._btConstraint = bt.btFixedConstraint_create(this.ownBody.btColliderObject, this._btframATrans, this.connectedBody.btColliderObject, this._btframBTrans);
                this._btJointFeedBackObj = bt.btJointFeedback_create(this._btConstraint);
                bt.btTypedConstraint_setJointFeedback(this._btConstraint, this._btJointFeedBackObj);
                bt.btTypedConstraint_setEnabled(this._btConstraint, true);
                this._simulation = this.getPhysicsSimulation();
                this._addToSimulation();
            }
        }
        _onEnable() {
            if (this._btConstraint)
                Physics3D._bullet.btTypedConstraint_setEnabled(this._btConstraint, true);
        }
        _onDisable() {
            if (!this.connectedBody)
                this._removeFromSimulation();
            if (this._btConstraint)
                Physics3D._bullet.btTypedConstraint_setEnabled(this._btConstraint, false);
        }
        _parse(data, interactMap = null) {
            super._parse(data);
            if (data.rigidbodyID != -1 && data.connectRigidbodyID != -1) {
                interactMap.component.push(this);
                interactMap.data.push(data);
            }
            (data.breakForce != undefined) && (this.breakForce = data.breakForce);
            (data.breakTorque != undefined) && (this.breakTorque = data.breakTorque);
        }
        _parseInteractive(data = null, spriteMap = null) {
            var rigidBodySprite = spriteMap[data.rigidbodyID];
            var rigidBody = rigidBodySprite.getComponent(Rigidbody3D);
            var connectSprite = spriteMap[data.connectRigidbodyID];
            var connectRigidbody = connectSprite.getComponent(Rigidbody3D);
            this.ownBody = rigidBody;
            this.connectedBody = connectRigidbody;
        }
    }

    class PhysicsCollider extends PhysicsTriggerComponent {
        constructor(collisionGroup = Physics3DUtils.COLLISIONFILTERGROUP_DEFAULTFILTER, canCollideWith = Physics3DUtils.COLLISIONFILTERGROUP_ALLFILTER) {
            super(collisionGroup, canCollideWith);
            this._enableProcessCollisions = false;
        }
        _addToSimulation() {
            this._simulation._addPhysicsCollider(this, this._collisionGroup, this._canCollideWith);
        }
        _removeFromSimulation() {
            this._simulation._removePhysicsCollider(this);
        }
        _parse(data) {
            (data.friction != null) && (this.friction = data.friction);
            (data.rollingFriction != null) && (this.rollingFriction = data.rollingFriction);
            (data.restitution != null) && (this.restitution = data.restitution);
            (data.isTrigger != null) && (this.isTrigger = data.isTrigger);
            super._parse(data);
            this._parseShape(data.shapes);
        }
        _onAdded() {
            var bt = Physics3D._bullet;
            var btColObj = bt.btCollisionObject_create();
            bt.btCollisionObject_setUserIndex(btColObj, this.id);
            bt.btCollisionObject_forceActivationState(btColObj, PhysicsComponent.ACTIVATIONSTATE_DISABLE_SIMULATION);
            var flags = bt.btCollisionObject_getCollisionFlags(btColObj);
            if (this.owner.isStatic) {
                if ((flags & PhysicsComponent.COLLISIONFLAGS_KINEMATIC_OBJECT) > 0)
                    flags = flags ^ PhysicsComponent.COLLISIONFLAGS_KINEMATIC_OBJECT;
                flags = flags | PhysicsComponent.COLLISIONFLAGS_STATIC_OBJECT;
            }
            else {
                if ((flags & PhysicsComponent.COLLISIONFLAGS_STATIC_OBJECT) > 0)
                    flags = flags ^ PhysicsComponent.COLLISIONFLAGS_STATIC_OBJECT;
                flags = flags | PhysicsComponent.COLLISIONFLAGS_KINEMATIC_OBJECT;
            }
            bt.btCollisionObject_setCollisionFlags(btColObj, flags);
            this._btColliderObject = btColObj;
            super._onAdded();
        }
    }

    let c = Laya.ClassUtils.regClass;
    c("CharacterController", CharacterController);
    c("Rigidbody3D", Rigidbody3D);
    c("PhysicsCollider", PhysicsCollider);
    c("ConfigurableConstraint", ConfigurableConstraint);
    c("FixedConstraint", FixedConstraint);

    class HeightfieldTerrainShape extends ColliderShape {
        constructor(heightfieldData, heightStickWidth, heightStickLength, minHeight, maxHeight, heightScale) {
            super();
            this.dataPtr = 0;
            this.initSize = new Laya.Vector3();
            this._type = ColliderShape.SHAPETYPES_HEIGHTFIELDTERRAIN;
            var bt = ILaya3D.Physics3D._bullet;
            this.needsCustomCollisionCallback = true;
            let hfdatatype = 5;
            if (heightfieldData instanceof Uint16Array) {
                hfdatatype = 3;
            }
            else if (heightfieldData instanceof Uint8Array) {
                hfdatatype = 5;
            }
            else if (heightfieldData instanceof Float32Array) {
                hfdatatype = 0;
            }
            else {
                throw 'bad heightfield data';
            }
            this.dataPtr = bt._malloc(heightfieldData.byteLength);
            let conch = window.conch;
            if (conch) {
                bt.copyJSArray(this.dataPtr, heightfieldData.buffer);
            }
            else {
                let bulletwasm = Laya.ILaya.Laya.WasmModules['bullet'];
                let buff = bulletwasm.memory.buffer;
                let dstbuff = new Uint8Array(buff, this.dataPtr, heightfieldData.byteLength);
                dstbuff.set(new Uint8Array(heightfieldData.buffer));
            }
            this._btShape = bt.btHeightfieldTerrainShape_create(heightStickWidth, heightStickLength, this.dataPtr, heightScale, minHeight, maxHeight, hfdatatype);
        }
        setMargin(margin) {
            var bt = ILaya3D.Physics3D._bullet;
            bt.btConcaveShape_setMargin(this._btShape, margin);
        }
        _setScale(value) {
            super._setScale(value);
        }
        destroy() {
            super.destroy();
            if (this.dataPtr) {
                var bt = ILaya3D.Physics3D._bullet;
                bt._free(this.dataPtr);
            }
        }
        clone() {
            debugger;
            throw 'not imp';
        }
    }

    var Script3D = Laya.Script;

    class StaticBatchSubInfo {
        constructor() {
            this.indexStart = 0;
            this.indexCount = 0;
            this.meshBounds = new Bounds(new Laya.Vector3(), new Laya.Vector3());
            this.needRender = false;
        }
    }
    class StaticBatchSubMesh extends GeometryElement {
        constructor() {
            super(Laya.MeshTopology.Triangles, Laya.DrawType.DrawElement);
            this.subInfos = [];
        }
        addSubMesh(indexCount, indexStart, bounds) {
            let info = new StaticBatchSubInfo();
            info.indexCount = indexCount;
            info.indexStart = indexStart;
            bounds.cloneTo(info.meshBounds);
            this.subInfos.push(info);
        }
        _getType() {
            return StaticBatchSubMesh._type;
        }
        _updateRenderParams(state) {
            this.clearRenderParams();
            let cameraPos = state.camera.transform.position;
            this.subInfos.sort((a, b) => {
                let centerA = a.meshBounds.getCenter();
                let distanceA = Laya.Vector3.distanceSquared(centerA, cameraPos);
                let centerB = b.meshBounds.getCenter();
                let distanceB = Laya.Vector3.distanceSquared(centerB, cameraPos);
                return distanceA - distanceB;
            });
            for (const info of this.subInfos) {
                if (info.needRender) {
                    this.setDrawElemenParams(info.indexCount, info.indexStart * this.indexByteCount);
                }
            }
        }
        _prepareRender(state) {
            return !!this.subInfos.find(info => info.needRender);
        }
        _render(state) {
            super._render(state);
        }
        destroy() {
            for (const info of this.subInfos) {
            }
            this.subInfos = null;
        }
    }
    StaticBatchSubMesh._type = GeometryElement._typeCounter++;

    const tempMatrix = new Laya.Matrix4x4;
    const TriangleIndices = [0, 1, 2];
    const InvertTriangleIndices = [0, 2, 1];
    class StaticBatchMesh {
        constructor() {
            this._bufferState = new Laya.BufferState();
            this._staticSubMeshes = new Map();
            this.bounds = new Bounds();
        }
        static create(info) {
            let staticMesh = new StaticBatchMesh();
            let vertexCount = info.vertexCount;
            let indexCount = info.indexCount;
            let vertexDec = info.vertexDec;
            let vertexFloatStride = vertexDec.vertexStride / 4;
            let vertexData = new ArrayBuffer(vertexDec.vertexStride * vertexCount);
            let vertexFloatArray = new Float32Array(vertexData);
            let mergeIndexFormat = Laya.IndexFormat.UInt16;
            let mergeIndexByteCount = 2;
            let indexArray;
            if (vertexCount > 65535) {
                mergeIndexFormat = Laya.IndexFormat.UInt32;
                mergeIndexByteCount = 4;
                indexArray = new Uint32Array(indexCount);
            }
            else {
                indexArray = new Uint16Array(indexCount);
            }
            vertexDec.getVertexElementByUsage(Laya.VertexMesh.MESH_POSITION0);
            vertexDec.getVertexElementByUsage(Laya.VertexMesh.MESH_NORMAL0);
            vertexDec.getVertexElementByUsage(Laya.VertexMesh.MESH_TEXTURECOORDINATE1);
            vertexDec.getVertexElementByUsage(Laya.VertexMesh.MESH_TANGENT0);
            let vertexDataOffset = 0;
            let vertexCountOffset = 0;
            let indexOffset = 0;
            let bounds;
            for (const render of info.renders) {
                let lightmapScaleOffset = render.lightmapScaleOffset;
                if (!bounds) {
                    bounds = staticMesh.bounds;
                    render.bounds.cloneTo(bounds);
                }
                Bounds.merge(bounds, render.bounds, bounds);
                let sp = render.owner;
                let invertFront = sp.transform._isFrontFaceInvert;
                let worldMat = sp.transform.worldMatrix;
                let normalMat = tempMatrix;
                worldMat.invert(normalMat);
                normalMat.transpose();
                let mesh = render.getMesh();
                let meshVertexCount = mesh.vertexCount;
                let meshIndexCount = mesh.indexCount;
                let meshVertexData = mesh._vertexBuffer.getFloat32Data();
                vertexFloatArray.set(meshVertexData, vertexDataOffset);
                for (let index = 0; index < meshVertexCount; index++) {
                    let elementOffset = index * vertexFloatStride;
                    for (const element of vertexDec._vertexElements) {
                        elementOffset += element.offset / 4;
                        switch (element.elementUsage) {
                            case Laya.VertexMesh.MESH_POSITION0:
                                Utils3D.transformVector3ArrayToVector3ArrayCoordinate(meshVertexData, elementOffset, worldMat, vertexFloatArray, vertexDataOffset + elementOffset);
                                break;
                            case Laya.VertexMesh.MESH_NORMAL0:
                            case Laya.VertexMesh.MESH_TANGENT0:
                                Utils3D.transformVector3ArrayToVector3ArrayNormal(meshVertexData, elementOffset, normalMat, vertexFloatArray, vertexDataOffset + elementOffset);
                                break;
                            case Laya.VertexMesh.MESH_TEXTURECOORDINATE1:
                                Utils3D.transformLightingMapTexcoordArray(meshVertexData, elementOffset, lightmapScaleOffset, vertexFloatArray, vertexDataOffset + elementOffset);
                                break;
                        }
                    }
                }
                let meshIndexData = mesh._indexBuffer.getData();
                let triangleIndices = invertFront ? InvertTriangleIndices : TriangleIndices;
                for (let index = 0; index < meshIndexCount; index += 3) {
                    indexArray[indexOffset + index] = meshIndexData[index + triangleIndices[0]] + vertexCountOffset;
                    indexArray[indexOffset + index + 1] = meshIndexData[index + triangleIndices[1]] + vertexCountOffset;
                    indexArray[indexOffset + index + 2] = meshIndexData[index + triangleIndices[2]] + vertexCountOffset;
                }
                let subMeshCount = mesh.subMeshCount;
                for (let index = 0; index < subMeshCount; index++) {
                    let material = render.sharedMaterials[index] || BlinnPhongMaterial.defaultMaterial;
                    let staticSubMesh = staticMesh._staticSubMeshes.get(material);
                    if (!staticSubMesh) {
                        staticSubMesh = new StaticBatchSubMesh();
                        staticSubMesh.indexByteCount = mergeIndexByteCount;
                        staticMesh._staticSubMeshes.set(material, staticSubMesh);
                        staticSubMesh.bufferState = staticMesh._bufferState;
                        staticSubMesh.indexFormat = mergeIndexFormat;
                    }
                    let subMesh = mesh.getSubMesh(index);
                    staticSubMesh.addSubMesh(subMesh.indexCount, subMesh._indexStart + indexOffset, render.bounds);
                }
                vertexDataOffset += meshVertexData.length;
                vertexCountOffset += meshVertexCount;
                indexOffset += meshIndexData.length;
            }
            let vertexBuffer = Laya.LayaGL.renderOBJCreate.createVertexBuffer3D(vertexData.byteLength, Laya.BufferUsage.Static, false);
            vertexBuffer.vertexDeclaration = vertexDec;
            vertexBuffer.setData(vertexData);
            let indexBuffer = Laya.LayaGL.renderOBJCreate.createIndexBuffer3D(mergeIndexFormat, indexCount, Laya.BufferUsage.Static, false);
            indexBuffer.setData(indexArray);
            staticMesh.setBuffer(vertexBuffer, indexBuffer);
            return staticMesh;
        }
        setBuffer(vertex, index) {
            let bufferState = this._bufferState;
            this._vertexBuffer = vertex;
            this._indexBuffer = index;
            bufferState.applyState([vertex], index);
        }
        destroy() {
            this._staticSubMeshes.forEach(submesh => {
                submesh.destroy();
            });
            this._staticSubMeshes.clear();
            this._staticSubMeshes = null;
            this._bufferState.destroy();
        }
    }

    class StaticBatchMeshRenderElement extends RenderElement {
        constructor() {
            super();
        }
        getInvertFront() {
            return false;
        }
    }

    class StaticBatchMeshRender extends BaseRender {
        constructor() {
            super();
            this._singleton = false;
        }
        static create(info) {
            let render = new StaticBatchMeshRender();
            render.mergeInfo = info;
            return render;
        }
        get staticMesh() {
            return this._staticMesh;
        }
        get mergeInfo() {
            return this._mergeInfo;
        }
        set mergeInfo(value) {
            this._mergeInfo = value;
            let staticMesh = StaticBatchMesh.create(value);
            this._staticMesh = staticMesh;
            this.lightmapIndex = value.lightmapIndex;
            this._staticMesh = staticMesh;
            this.geometryBounds = staticMesh.bounds;
            let meshDefines = MeshFilter._meshVerticeDefine;
            let defineDatas = this._shaderValues;
            this._getMeshDefine(staticMesh, meshDefines);
            for (const meshDef of meshDefines) {
                defineDatas.addDefine(meshDef);
            }
            this._renderElements.forEach(element => {
                element.material._removeReference();
                element.destroy();
            });
            this._renderElements = [];
            staticMesh._staticSubMeshes.forEach((subMesh, material) => {
                let element = new StaticBatchMeshRenderElement();
                this._renderElements.push(element);
                element.render = this;
                element.material = material;
                element.setGeometry(subMesh);
                material._addReference();
            });
            staticMesh.bounds.cloneTo(this.bounds);
        }
        _calculateBoundingBox() {
        }
        _renderUpdate(context, transform) {
            this._applyLightMapParams();
            this._setShaderValue(Sprite3D.WORLDMATRIX, Laya.ShaderDataType.Matrix4x4, Laya.Matrix4x4.DEFAULT);
        }
        _getMeshDefine(mesh, out) {
            let vertexElements = mesh._vertexBuffer.vertexDeclaration._vertexElements;
            for (const element of vertexElements) {
                switch (element.elementUsage) {
                    case Laya.VertexMesh.MESH_COLOR0:
                        out.push(MeshSprite3DShaderDeclaration.SHADERDEFINE_COLOR);
                        break;
                    case Laya.VertexMesh.MESH_TEXTURECOORDINATE0:
                        out.push(MeshSprite3DShaderDeclaration.SHADERDEFINE_UV0);
                        break;
                    case Laya.VertexMesh.MESH_TEXTURECOORDINATE1:
                        out.push(MeshSprite3DShaderDeclaration.SHADERDEFINE_UV1);
                        break;
                    case Laya.VertexMesh.MESH_TANGENT0:
                        out.push(MeshSprite3DShaderDeclaration.SHADERDEFINE_TANGENT);
                        break;
                }
            }
        }
        _needRender(boundFrustum, context) {
            if (boundFrustum) {
                if (boundFrustum.intersects(this.bounds)) {
                    let needRender = false;
                    this.staticMesh._staticSubMeshes.forEach(subMesh => {
                        for (const info of subMesh.subInfos) {
                            info.needRender = boundFrustum.intersects(info.meshBounds);
                            needRender = needRender || info.needRender;
                        }
                    });
                    return needRender;
                }
                return false;
            }
            else {
                return true;
            }
        }
        onEnable() {
            super.onEnable();
            this.mergeInfo.renders.forEach(render => {
                render.setRenderbitFlag(exports.RenderBitFlag.RenderBitFlag_Batch, true);
            });
        }
        onDisable() {
            super.onDisable();
            this.mergeInfo.renders.forEach(render => {
                render.setRenderbitFlag(exports.RenderBitFlag.RenderBitFlag_Batch, false);
            });
        }
        onDestroy() {
            super.onDestroy();
            this._renderElements.forEach(element => {
                element.material._removeReference();
                element.destroy();
            });
            this._renderElements = null;
            this._staticMesh.destroy();
            this._staticMesh = null;
        }
        _cloneTo(dest) {
            dest.mergeInfo = this.mergeInfo;
        }
    }

    MeshRenderer.prototype.getMesh = function () {
        return this._mesh;
    };
    class StaticMeshMergeInfo {
        constructor() {
            this._renders = [];
            this.vertexCount = 0;
            this.indexCount = 0;
        }
        static create(render) {
            let mesh = render.getMesh();
            render.owner;
            let info = new StaticMeshMergeInfo();
            info.lightmapIndex = render.lightmapIndex;
            info.receiveShadow = render.receiveShadow;
            info.vertexDec = mesh ? mesh.getVertexDeclaration() : null;
            return info;
        }
        get renders() {
            return this._renders;
        }
        match(render) {
            let mesh = render.getMesh();
            render.owner;
            let match = true;
            match = match && this.lightmapIndex == render.lightmapIndex;
            match = match && this.receiveShadow == render.receiveShadow;
            match = match && this.vertexDec == mesh.getVertexDeclaration();
            return match;
        }
        addElement(render) {
            this.renders.push(render);
            let mesh = render.getMesh();
            this.vertexCount += mesh.vertexCount;
            this.indexCount += mesh.indexCount;
        }
        destroy() {
            this._renders = null;
        }
    }

    class StaticMeshBatchManager {
        constructor() {
            this.meshVertexDecSet = new Set();
        }
        combine(renders) {
            for (const render of renders) {
                let haveMatch = false;
                for (const info of this.meshVertexDecSet) {
                    if (info.match(render)) {
                        haveMatch = true;
                        info.addElement(render);
                    }
                }
                if (!haveMatch) {
                    let info = StaticMeshMergeInfo.create(render);
                    info.addElement(render);
                    this.meshVertexDecSet.add(info);
                }
            }
            let staticRenders = [];
            for (const info of this.meshVertexDecSet) {
                staticRenders.push(StaticBatchMeshRender.create(info));
            }
            this.meshVertexDecSet.clear();
            return staticRenders;
        }
        merge(info) {
            let staticMeshRender = StaticBatchMeshRender.create(info);
            return staticMeshRender;
        }
    }

    class TransLargeUBOUtils {
        constructor(UBO, paramsMap, defautSubData) {
            this.currentlength = 0;
            this.bindUBO = UBO;
            this.defaultSubData = defautSubData;
            UBO._reset(TransLargeUBOUtils.configStartLength * this.defaultSubData.getbyteLength());
            this.subDataParamMap = paramsMap;
            this.maxlength = TransLargeUBOUtils.configStartLength;
            this.subDataMap = [];
            this.pool = [];
            this.subDataMap.push(defautSubData);
            this.currentlength++;
        }
        create() {
            if (this.pool.length > 0) {
                const re = this.pool.pop();
                re._isInPool = false;
                return re;
            }
            if (this.maxlength == this.currentlength)
                this.reset();
            let uniformMap = new Map();
            this.subDataParamMap.forEach((value, key) => {
                uniformMap.set(Laya.Shader3D.propertyNameToID(key), value);
            });
            let subdata = new Laya.SubUniformBufferData(uniformMap, this.currentlength++);
            this.subDataMap.push(subdata);
            return subdata;
        }
        recover(subModuleData) {
            if (!subModuleData._isInPool) {
                this.pool.push(subModuleData);
                subModuleData._isInPool = true;
            }
        }
        reset() {
            this.maxlength += TransLargeUBOUtils.addStep;
            this.bindUBO._reset(this.maxlength * this.defaultSubData.getbyteLength());
            this.subDataMap.forEach(element => {
                this.bindUBO.setDataByByUniformBufferDataOffset(element, element._offset);
            });
        }
        updateSubData(data) {
            this.bindUBO.setDataByByUniformBufferDataOffset(data, data._offset);
            data._needUpdate = false;
        }
        updateBindRange(data) {
            let bytelenth = data.getbyteLength();
            this.bindUBO._bindBufferRange(data._offset * bytelenth, bytelenth);
        }
        destroy() {
            this.subDataMap.forEach(element => {
                element.destroy();
            });
            delete this.subDataMap;
            delete this.pool;
            this.subDataMap = null;
            this.pool = null;
        }
    }
    TransLargeUBOUtils.configStartLength = 1024;
    TransLargeUBOUtils.addStep = 512;

    class PixelLineSprite3D extends RenderableSprite3D {
        constructor(maxCount = 2, name = null) {
            super(name);
            this._isRenderActive = false;
            this._isInRenders = false;
            this._render = this.addComponent(PixelLineRenderer);
            this._geometryFilter = this._render._pixelLineFilter;
            this._render.maxLineCount = maxCount;
            let material = this._render.material = new UnlitMaterial();
            material.enableVertexColor = true;
        }
        get maxLineCount() {
            return this._render.maxLineCount;
        }
        set maxLineCount(value) {
            this._render.maxLineCount = value;
        }
        get lineCount() {
            return this._render.lineCount;
        }
        get pixelLineRenderer() {
            return this._render;
        }
        addLine(startPosition, endPosition, startColor, endColor) {
            this._render.addLine(startPosition, endPosition, startColor, endColor);
        }
        addLines(lines) {
            this._render.addLines(lines);
        }
        removeLine(index) {
            this._render.removeLine(index);
        }
        setLine(index, startPosition, endPosition, startColor, endColor) {
            this._render.setLine(index, startPosition, endPosition, startColor, endColor);
        }
        getLine(index, out) {
            this._render.getLine(index, out);
        }
        clear() {
            this._render.clear();
        }
        _create() {
            return new Sprite3D();
        }
    }

    const _vec2 = new Laya.Vector2();
    const _ray = new Ray(new Laya.Vector3(), new Laya.Vector3());
    const _hitResult = new HitResult();
    Laya.InputManager.prototype.getSprite3DUnderPoint = function (x, y) {
        _hitResult.succeeded = false;
        _vec2.setValue(x, y);
        for (let scene of this._stage._scene3Ds) {
            let sim = scene._physicsSimulation;
            if (!sim)
                continue;
            let cameras = scene._cameraPool;
            for (let i = cameras.length - 1; i >= 0; i--) {
                let camera = cameras[i];
                let viewport = camera.viewport;
                let ratio = Laya.Config3D.pixelRatio;
                if (x >= viewport.x && y >= viewport.y && x <= viewport.width / ratio && y <= viewport.height / ratio) {
                    camera.viewportPointToRay(_vec2, _ray);
                    var sucess = sim.rayCast(_ray, _hitResult);
                    if (sucess || (camera.clearFlag === exports.CameraClearFlags.SolidColor || camera.clearFlag === exports.CameraClearFlags.Sky))
                        break;
                }
            }
            if (_hitResult.succeeded)
                return _hitResult.collider.owner;
        }
        return null;
    };

    class UI3DGeometry extends GeometryElement {
        constructor(owner) {
            super(Laya.MeshTopology.TriangleStrip, Laya.DrawType.DrawArray);
            this._owner = owner;
            this.bufferState = new Laya.BufferState();
            this._createBuffer();
            this._scale = new Laya.Vector2(1, 1);
            this._offset = new Laya.Vector2(0, 0);
            this._bound = new Bounds();
        }
        set scale(value) {
            value && value.cloneTo(this._scale);
            this._resizeVertexData();
        }
        get scale() {
            return this._scale;
        }
        set offset(value) {
            value && value.cloneTo(this._offset);
            this._resizeVertexData();
        }
        get offset() {
            return this._offset;
        }
        get bounds() {
            return this._bound;
        }
        _createBuffer() {
            var vertexDeclaration = Laya.VertexMesh.getVertexDeclaration("POSITION,NORMAL,UV");
            var halfLong = 1 / 2;
            var halfWidth = 1 / 2;
            this._vertex = new Float32Array([-halfLong, halfWidth, 0, 0, 0, 1, 0, 0, halfLong, halfWidth, 0, 0, 0, 1, 1, 0, -halfLong, -halfWidth, 0, 0, 0, 1, 0, 1, halfLong, -halfWidth, 0, 0, 0, 1, 1, 1]);
            this._index = new Uint16Array([0, 1, 2, 3, 2, 1]);
            this._vertexBuffer = Laya.LayaGL.renderOBJCreate.createVertexBuffer3D(this._vertex.length * 4, Laya.BufferUsage.Dynamic, false);
            this._vertexBuffer.vertexDeclaration = vertexDeclaration;
            this._vertexBuffer.setData(this._vertex.buffer);
            var indexBuffer = Laya.LayaGL.renderOBJCreate.createIndexBuffer3D(Laya.IndexFormat.UInt16, this._index.length, Laya.BufferUsage.Static, false);
            indexBuffer.setData(this._index);
            this.bufferState = new Laya.BufferState();
            this.bufferState.applyState([this._vertexBuffer], this._indexBuffer);
            this._bound.setExtent(new Laya.Vector3(0.5, 0.5, 0.05));
            this._bound.setCenter(new Laya.Vector3(0, 0, 0));
        }
        _resizeVertexData() {
            var halfLong = this._scale.x / 2 + this._offset.x;
            var halfWidth = this._scale.y / 2 + this._offset.y;
            this._vertex[0] = -halfLong;
            this._vertex[1] = halfWidth;
            this._vertex[8] = halfLong;
            this._vertex[9] = halfWidth;
            this._vertex[16] = -halfLong;
            this._vertex[17] = -halfWidth;
            this._vertex[24] = halfLong;
            this._vertex[25] = -halfWidth;
            this._vertexBuffer.setData(this._vertex.buffer, 0, 0, this._vertex.length * 4);
            this._bound.setExtent(new Laya.Vector3(this._scale.x / 2, this._scale.y / 2, 0.05));
            this._bound.setCenter(new Laya.Vector3(this._offset.x, this._offset.y, 0));
        }
        _updateRenderParams(state) {
            this.clearRenderParams();
            var count = 6;
            this.setDrawArrayParams(0, count);
        }
        destroy() {
            super.destroy();
            this.bufferState.destroy();
            this._vertexBuffer.destroy();
            this._indexBuffer.destroy();
            this.bufferState = null;
            this._vertexBuffer = null;
            this._indexBuffer = null;
            delete this._vertex;
            delete this._index;
        }
    }
    UI3DGeometry._type = GeometryElement._typeCounter++;

    class UI3D extends BaseRender {
        constructor() {
            super();
            this._uiPlane = new Plane(new Laya.Vector3(), 0);
        }
        set sprite(value) {
            this._uisprite = value;
            this._resizeRT(value.width, value.height);
        }
        get sprite() {
            return this._uisprite;
        }
        set scale(value) {
            this._geometry.scale = value;
        }
        get scale() {
            return this._geometry.scale;
        }
        set offset(value) {
            this._geometry.offset = value;
        }
        get offset() {
            return this._geometry.offset;
        }
        get UIRender() {
            return this._rendertexure2D;
        }
        _addRenderElement() {
            var elements = this._renderElements;
            var material = this.sharedMaterials[0];
            (material) || (material = BlinnPhongMaterial.defaultMaterial);
            var element = new RenderElement();
            element.setTransform(this.owner._transform);
            element.render = this;
            element.material = material;
            this._geometry = new UI3DGeometry(this);
            element.setGeometry(this._geometry);
            elements.push(element);
        }
        _resizeRT(width, height) {
            if (!this._rendertexure2D) {
                this._rendertexure2D = new Laya.RenderTexture2D(width, height, Laya.RenderTargetFormat.R8G8B8A8, Laya.RenderTargetFormat.None);
            }
            else {
                if (this._rendertexure2D.width == width && this._rendertexure2D.height == height) {
                    this._rendertexure2D.destroy();
                    this._rendertexure2D = new Laya.RenderTexture2D(width, height, Laya.RenderTargetFormat.R8G8B8A8, Laya.RenderTargetFormat.None);
                }
            }
        }
        _calculateBoundingBox() {
            var worldMat = this._transform.worldMatrix;
            this._geometry.bounds._tranform(worldMat, this._bounds);
        }
        _submitRT() {
            this._uisprite && this._uisprite.drawToTexture(0, 0, 0, 0, this._rendertexure2D, true);
        }
        _checkUIPos(ray) {
            let hitPoint = Picker.rayPlaneIntersection(ray, this._uiPlane);
            return hitPoint;
        }
        _changePlane() {
            Laya.Vector3.Up;
            Laya.Vector3.ForwardLH;
            this.owner.transform.worldMatrix;
        }
        _onAdded() {
            super._onAdded();
            this._addRenderElement();
        }
        _onDisable() {
            super._onDisable();
            this.owner.scene._UI3DManager.remove(this);
            this.owner.transform.off(Laya.Event.TRANSFORM_CHANGED, this, this._changePlane);
        }
        _onEnable() {
            super._onEnable();
            this.owner.scene._UI3DManager.add(this);
            this.owner.transform.on(Laya.Event.TRANSFORM_CHANGED, this, this._changePlane);
        }
        _onDestroy() {
            super._onDestroy();
        }
    }
    UI3D.temp0 = new Laya.Vector3();
    UI3D.temp1 = new Laya.Vector3();
    UI3D.temp2 = new Laya.Vector3();

    class GradientDataVector2 {
        constructor() {
            this._currentLength = 0;
            this._elements = new Float32Array(12);
        }
        get gradientCount() {
            return this._currentLength / 3;
        }
        add(key, value) {
            if (this._currentLength < 8) {
                if ((this._currentLength === 6) && ((key !== 1))) {
                    key = 1;
                    console.log("GradientDataVector2 warning:the forth key is  be force set to 1.");
                }
                this._elements[this._currentLength++] = key;
                this._elements[this._currentLength++] = value.x;
                this._elements[this._currentLength++] = value.y;
            }
            else {
                console.log("GradientDataVector2 warning:data count must lessEqual than 4");
            }
        }
        cloneTo(destObject) {
            var destGradientDataVector2 = destObject;
            destGradientDataVector2._currentLength = this._currentLength;
            var destElements = destGradientDataVector2._elements;
            for (var i = 0, n = this._elements.length; i < n; i++) {
                destElements[i] = this._elements[i];
            }
        }
        clone() {
            var destGradientDataVector2 = new GradientDataVector2();
            this.cloneTo(destGradientDataVector2);
            return destGradientDataVector2;
        }
    }

    class MaterialInstanceProperty {
        constructor() {
            this._isNeedUpdate = false;
        }
        createInstanceVertexBuffer3D() {
            this._instanceData = new Float32Array(DrawMeshInstancedCMD.maxInstanceCount * this._vertexStride);
            this._vertexBuffer = Laya.LayaGL.renderOBJCreate.createVertexBuffer3D(this._instanceData.length * 4, Laya.BufferUsage.Dynamic, false);
            this._vertexBuffer.vertexDeclaration = this._vertexDeclaration;
            this._vertexBuffer.instanceBuffer = true;
        }
        updateVertexBufferData(drawNums) {
            if (!this._isNeedUpdate)
                return;
            let instanceData = this._instanceData;
            let dataValue = this._value;
            let datalength = this._value.length;
            let data;
            let stride = this._vertexStride;
            let updateType = 0;
            if (!(this._value instanceof Float32Array)) {
                updateType = 1;
            }
            switch (updateType) {
                case 0:
                    instanceData.set(dataValue, 0);
                    break;
                case 1:
                    for (let i = 0; i < datalength; i++) {
                        data = dataValue[i];
                        data.writeTo(instanceData, i * stride);
                    }
                    break;
            }
            this._vertexBuffer.orphanStorage();
            this._vertexBuffer.setData(instanceData.buffer, 0, 0, drawNums * 4 * stride);
        }
        destroy() {
            delete this._value;
            delete this._instanceData;
            this._vertexDeclaration = null;
            this._vertexBuffer.destroy();
        }
    }

    exports.InstanceLocation = void 0;
    (function (InstanceLocation) {
        InstanceLocation[InstanceLocation["CUSTOME0"] = 12] = "CUSTOME0";
        InstanceLocation[InstanceLocation["CUSTOME1"] = 13] = "CUSTOME1";
        InstanceLocation[InstanceLocation["CUSTOME2"] = 14] = "CUSTOME2";
        InstanceLocation[InstanceLocation["CUSTOME3"] = 15] = "CUSTOME3";
    })(exports.InstanceLocation || (exports.InstanceLocation = {}));
    class MaterialInstancePropertyBlock {
        constructor() {
            this._type = 0;
            this._propertyMap = {};
        }
        _checkPropertyLegal(vertexElementFormat, propertyName, attributeLocation, prob) {
            var vecDec = prob._vertexDeclaration;
            if (vecDec._vertexElements[0]._elementFormat !== vertexElementFormat)
                throw "Data exists and format does not match";
            if (prob._name !== propertyName)
                throw "You cannot add a new property to an existing attributeLocation,Please use another attributeLocation";
        }
        _creatProperty(attributeName, arrays, vertexStride, vertexformat, attributeLocation) {
            var prob = this._propertyMap[attributeLocation] = new MaterialInstanceProperty();
            prob._name = attributeName;
            prob._value = arrays;
            prob._vertexDeclaration = new Laya.VertexDeclaration(vertexStride, [new Laya.VertexElement(0, vertexformat, attributeLocation)]);
            prob._isNeedUpdate = true;
            prob._vertexStride = vertexStride / 4;
            prob.createInstanceVertexBuffer3D();
        }
        setVectorArray(attributeName, arrays, attributeLocation) {
            var prob = this._propertyMap[attributeLocation];
            if (prob) {
                this._checkPropertyLegal(Laya.VertexElementFormat.Vector4, attributeName, attributeLocation, prob);
                prob._value = arrays;
                prob._isNeedUpdate = true;
            }
            else
                this._creatProperty(attributeName, arrays, 16, Laya.VertexElementFormat.Vector4, attributeLocation);
        }
        setVector3Array(attributeName, arrays, attributeLocation) {
            var prob = this._propertyMap[attributeLocation];
            if (prob) {
                this._checkPropertyLegal(Laya.VertexElementFormat.Vector3, attributeName, attributeLocation, prob);
                prob._value = arrays;
                prob._isNeedUpdate = true;
            }
            else
                this._creatProperty(attributeName, arrays, 12, Laya.VertexElementFormat.Vector3, attributeLocation);
        }
        setVector2Array(attributeName, arrays, attributeLocation) {
            var prob = this._propertyMap[attributeLocation];
            if (prob) {
                this._checkPropertyLegal(Laya.VertexElementFormat.Vector2, attributeName, attributeLocation, prob);
                prob._value = arrays;
                prob._isNeedUpdate = true;
            }
            else
                this._creatProperty(attributeName, arrays, 8, Laya.VertexElementFormat.Vector2, attributeLocation);
        }
        setNumberArray(attributeName, arrays, attributeLocation) {
            var prob = this._propertyMap[attributeLocation];
            if (prob) {
                this._checkPropertyLegal(Laya.VertexElementFormat.Single, attributeName, attributeLocation, prob);
                prob._value = arrays;
                prob._isNeedUpdate = true;
            }
            else
                this._creatProperty(attributeName, arrays, 4, Laya.VertexElementFormat.Single, attributeLocation);
        }
        getPropertyArray(attributeLocation) {
            var prob = this._propertyMap[attributeLocation];
            return prob ? prob._value : null;
        }
        clear() {
            for (var i in this._propertyMap) {
                this._propertyMap[i].destroy();
            }
            this._propertyMap = {};
        }
    }
    MaterialInstancePropertyBlock.INSTANCETYPE_ATTRIBUTE = 0;
    MaterialInstancePropertyBlock.INSTANCETYPE_UNIFORMBUFFER = 1;

    exports.ACESShaderLib = ACESShaderLib;
    exports.AlternateLightQueue = AlternateLightQueue;
    exports.AnimationClip = AnimationClip;
    exports.AnimationClipParser03 = AnimationClipParser03;
    exports.AnimationClipParser04 = AnimationClipParser04;
    exports.AnimationEvent = AnimationEvent;
    exports.Animator = Animator;
    exports.AnimatorController = AnimatorController;
    exports.AnimatorControllerLayer = AnimatorControllerLayer;
    exports.AnimatorPlayState = AnimatorPlayState;
    exports.AnimatorResource = AnimatorResource;
    exports.AnimatorState = AnimatorState;
    exports.AnimatorStateScript = AnimatorStateScript;
    exports.AnimatorTransition = AnimatorTransition;
    exports.AreaLightCom = AreaLightCom;
    exports.AvatarMask = AvatarMask;
    exports.AxiGamepad = AxiGamepad;
    exports.BVHCullPass = BVHCullPass;
    exports.BVHRenderBox = BVHRenderBox;
    exports.BVHRenderSpatial = BVHRenderSpatial;
    exports.BVHSceneRenderManager = BVHSceneRenderManager;
    exports.BVHSpatial = BVHSpatial;
    exports.BVHSpatialBox = BVHSpatialBox;
    exports.BVHSpatialConfig = BVHSpatialConfig;
    exports.BVHSpatialManager = BVHSpatialManager;
    exports.BaseCamera = BaseCamera;
    exports.BaseRender = BaseRender;
    exports.BaseRenderNode = BaseRenderNode;
    exports.BaseRenderQueue = BaseRenderQueue;
    exports.BaseShape = BaseShape;
    exports.BatchMark = BatchMark;
    exports.BatchRender = BatchRender;
    exports.BlinnPhongMaterial = BlinnPhongMaterial;
    exports.BlinnPhongShaderInit = BlinnPhongShaderInit;
    exports.BlitFrameBufferCMD = BlitFrameBufferCMD;
    exports.BlitScreenQuadCMD = BlitScreenQuadCMD;
    exports.BlitScreenShaderInit = BlitScreenShaderInit;
    exports.BloomEffect = BloomEffect;
    exports.BoundBox = BoundBox;
    exports.BoundFrustum = BoundFrustum;
    exports.BoundSphere = BoundSphere;
    exports.Bounds = Bounds;
    exports.BoundsImpl = BoundsImpl;
    exports.BoxColliderShape = BoxColliderShape;
    exports.BoxShape = BoxShape;
    exports.BulletInteractive = BulletInteractive;
    exports.Burst = Burst;
    exports.ButtonGamepad = ButtonGamepad;
    exports.Camera = Camera;
    exports.CameraCullInfo = CameraCullInfo;
    exports.CapsuleColliderShape = CapsuleColliderShape;
    exports.CharacterController = CharacterController;
    exports.CircleShape = CircleShape;
    exports.ClearRenderTextureCMD = ClearRenderTextureCMD;
    exports.Cluster = Cluster;
    exports.ColliderShape = ColliderShape;
    exports.Collision = Collision;
    exports.CollisionTool = CollisionTool;
    exports.CollisionUtils = CollisionUtils;
    exports.ColorGradEffect = ColorGradEffect;
    exports.ColorOverLifetime = ColorOverLifetime;
    exports.Command = Command;
    exports.CommandBuffer = CommandBuffer;
    exports.CompoundColliderShape = CompoundColliderShape;
    exports.ConeColliderShape = ConeColliderShape;
    exports.ConeShape = ConeShape;
    exports.ConfigurableConstraint = ConfigurableConstraint;
    exports.Constraint3D = Constraint3D;
    exports.ConstraintComponent = ConstraintComponent;
    exports.ContactPoint = ContactPoint;
    exports.ContainmentType = ContainmentType;
    exports.CullPassBase = CullPassBase;
    exports.CylinderColliderShape = CylinderColliderShape;
    exports.DepthCasterData = DepthCasterData;
    exports.DepthPass = DepthPass;
    exports.DirectionLight = DirectionLight;
    exports.DirectionLightCom = DirectionLightCom;
    exports.DrawMeshCMD = DrawMeshCMD;
    exports.DrawMeshInstancedCMD = DrawMeshInstancedCMD;
    exports.DrawRenderCMD = DrawRenderCMD;
    exports.EffectMaterial = EffectMaterial;
    exports.Emission = Emission;
    exports.ExtendTerrainMaterial = ExtendTerrainMaterial;
    exports.FixedConstraint = FixedConstraint;
    exports.FloatKeyframe = FloatKeyframe;
    exports.FrameOverTime = FrameOverTime;
    exports.FrustumCulling = FrustumCulling;
    exports.GaussianDoF = GaussianDoF;
    exports.GeometryElement = GeometryElement;
    exports.Gradient = Gradient;
    exports.GradientAngularVelocity = GradientAngularVelocity;
    exports.GradientColor = GradientColor;
    exports.GradientDataInt = GradientDataInt;
    exports.GradientDataNumber = GradientDataNumber;
    exports.GradientDataVector2 = GradientDataVector2;
    exports.GradientMode = GradientMode;
    exports.GradientSize = GradientSize;
    exports.GradientVelocity = GradientVelocity;
    exports.HeightfieldTerrainShape = HeightfieldTerrainShape;
    exports.HemisphereShape = HemisphereShape;
    exports.HitResult = HitResult;
    exports.ILaya3D = ILaya3D;
    exports.IndexBuffer3D = IndexBuffer3D;
    exports.InstanceBatchManager = InstanceBatchManager;
    exports.InstanceRenderElement = InstanceRenderElement;
    exports.InstanceRenderElementOBJ = InstanceRenderElementOBJ;
    exports.Keyframe = Keyframe;
    exports.KeyframeNode = KeyframeNode;
    exports.KeyframeNodeList = KeyframeNodeList;
    exports.KeyframeNodeOwner = KeyframeNodeOwner;
    exports.LODGroup = LODGroup;
    exports.LODInfo = LODInfo;
    exports.Laya3D = Laya3D;
    exports.Light = Light;
    exports.LightQueue = LightQueue;
    exports.LightSprite = LightSprite;
    exports.Lightmap = Lightmap;
    exports.LoadModelV04 = LoadModelV04;
    exports.LoadModelV05 = LoadModelV05;
    exports.Material = Material;
    exports.MaterialInstanceProperty = MaterialInstanceProperty;
    exports.MaterialInstancePropertyBlock = MaterialInstancePropertyBlock;
    exports.MaterialParser = MaterialParser;
    exports.Mesh = Mesh;
    exports.MeshColliderShape = MeshColliderShape;
    exports.MeshFilter = MeshFilter;
    exports.MeshInstanceGeometry = MeshInstanceGeometry;
    exports.MeshReader = MeshReader;
    exports.MeshRenderer = MeshRenderer;
    exports.MeshSprite3D = MeshSprite3D;
    exports.MeshSprite3DShaderDeclaration = MeshSprite3DShaderDeclaration;
    exports.NativeBaseRenderNode = NativeBaseRenderNode;
    exports.NativeBaseRenderQueue = NativeBaseRenderQueue;
    exports.NativeBounds = NativeBounds;
    exports.NativeCameraCullInfo = NativeCameraCullInfo;
    exports.NativeCommandUniformMap = NativeCommandUniformMap;
    exports.NativeCullPassBase = NativeCullPassBase;
    exports.NativeIndexBuffer3D = NativeIndexBuffer3D;
    exports.NativeInstanceRenderElementOBJ = NativeInstanceRenderElementOBJ;
    exports.NativeRenderContext3DOBJ = NativeRenderContext3DOBJ;
    exports.NativeRenderElementOBJ = NativeRenderElementOBJ;
    exports.NativeRenderGeometryElementOBJ = NativeRenderGeometryElementOBJ;
    exports.NativeRenderOBJCreateUtil = NativeRenderOBJCreateUtil;
    exports.NativeRenderState = NativeRenderState;
    exports.NativeSceneRenderManager = NativeSceneRenderManager;
    exports.NativeShaderData = NativeShaderData;
    exports.NativeShaderInstance = NativeShaderInstance;
    exports.NativeShadowCullInfo = NativeShadowCullInfo;
    exports.NativeSkinRenderElementOBJ = NativeSkinRenderElementOBJ;
    exports.NativeTransform3D = NativeTransform3D;
    exports.NativeUniformBufferObject = NativeUniformBufferObject;
    exports.NativeVertexBuffer3D = NativeVertexBuffer3D;
    exports.PBRDefaultDFG = PBRDefaultDFG;
    exports.PBRMaterial = PBRMaterial;
    exports.PBRShaderLib = PBRShaderLib;
    exports.PBRStandardMaterial = PBRStandardMaterial;
    exports.PBRStandardShaderInit = PBRStandardShaderInit;
    exports.ParseJSON = ParseJSON;
    exports.ParticleShuriKenShaderInit = ParticleShuriKenShaderInit;
    exports.Physics3D = Physics3D;
    exports.Physics3DUtils = Physics3DUtils;
    exports.PhysicsCollider = PhysicsCollider;
    exports.PhysicsComponent = PhysicsComponent;
    exports.PhysicsSettings = PhysicsSettings;
    exports.PhysicsSimulation = PhysicsSimulation;
    exports.PhysicsTriggerComponent = PhysicsTriggerComponent;
    exports.PhysicsUpdateList = PhysicsUpdateList;
    exports.Picker = Picker;
    exports.PixelLineData = PixelLineData;
    exports.PixelLineFilter = PixelLineFilter;
    exports.PixelLineMaterial = PixelLineMaterial;
    exports.PixelLineRenderer = PixelLineRenderer;
    exports.PixelLineSprite3D = PixelLineSprite3D;
    exports.PixelLineVertex = PixelLineVertex;
    exports.Plane = Plane;
    exports.PointLight = PointLight;
    exports.PointLightCom = PointLightCom;
    exports.PostProcess = PostProcess;
    exports.PostProcessEffect = PostProcessEffect;
    exports.PostProcessRenderContext = PostProcessRenderContext;
    exports.PrimitiveMesh = PrimitiveMesh;
    exports.QuaternionKeyframe = QuaternionKeyframe;
    exports.QuickSort = QuickSort;
    exports.Rand = Rand;
    exports.RandX = RandX;
    exports.Ray = Ray;
    exports.RaycastVehicle = RaycastVehicle;
    exports.RaycastWheel = RaycastWheel;
    exports.ReflectionProbe = ReflectionProbe;
    exports.ReflectionProbeManager = ReflectionProbeManager;
    exports.RenderContext3D = RenderContext3D;
    exports.RenderContext3DOBJ = RenderContext3DOBJ;
    exports.RenderElement = RenderElement;
    exports.RenderElementBatch = RenderElementBatch;
    exports.RenderElementOBJ = RenderElementOBJ;
    exports.RenderGeometryElementOBJ = RenderGeometryElementOBJ;
    exports.RenderOBJCreateUtil = RenderOBJCreateUtil;
    exports.RenderTextureCube = RenderTextureCube;
    exports.RenderableSprite3D = RenderableSprite3D;
    exports.Rigidbody3D = Rigidbody3D;
    exports.RotationOverLifetime = RotationOverLifetime;
    exports.ScalableAO = ScalableAO;
    exports.Scene3D = Scene3D;
    exports.Scene3DShaderDeclaration = Scene3DShaderDeclaration;
    exports.SceneRenderManager = SceneRenderManager;
    exports.SceneRenderManagerOBJ = SceneRenderManagerOBJ;
    exports.ScreenQuad = ScreenQuad;
    exports.Script3D = Script3D;
    exports.SetGlobalShaderDataCMD = SetGlobalShaderDataCMD;
    exports.SetRenderTargetCMD = SetRenderTargetCMD;
    exports.SetShaderDataCMD = SetShaderDataCMD;
    exports.ShaderInit3D = ShaderInit3D;
    exports.ShaderParser = ShaderParser;
    exports.ShadowCasterPass = ShadowCasterPass;
    exports.ShadowCullInfo = ShadowCullInfo;
    exports.ShadowSliceData = ShadowSliceData;
    exports.ShadowSpotData = ShadowSpotData;
    exports.ShadowUtils = ShadowUtils;
    exports.ShapeUtils = ShapeUtils;
    exports.ShuriKenParticle3D = ShuriKenParticle3D;
    exports.ShuriKenParticle3DShaderDeclaration = ShuriKenParticle3DShaderDeclaration;
    exports.ShurikenParticleData = ShurikenParticleData;
    exports.ShurikenParticleInstanceSystem = ShurikenParticleInstanceSystem;
    exports.ShurikenParticleMaterial = ShurikenParticleMaterial;
    exports.ShurikenParticleRenderer = ShurikenParticleRenderer;
    exports.ShurikenParticleSystem = ShurikenParticleSystem;
    exports.SimpleSkinnedMeshRenderer = SimpleSkinnedMeshRenderer;
    exports.SimpleSkinnedMeshSprite3D = SimpleSkinnedMeshSprite3D;
    exports.Size = Size;
    exports.SizeOverLifetime = SizeOverLifetime;
    exports.SkinRenderElement = SkinRenderElement;
    exports.SkinRenderElementOBJ = SkinRenderElementOBJ;
    exports.SkinnedMeshRenderer = SkinnedMeshRenderer;
    exports.SkinnedMeshSprite3D = SkinnedMeshSprite3D;
    exports.SkinnedMeshSprite3DShaderDeclaration = SkinnedMeshSprite3DShaderDeclaration;
    exports.SkyBox = SkyBox;
    exports.SkyBoxMaterial = SkyBoxMaterial;
    exports.SkyBoxShaderInit = SkyBoxShaderInit;
    exports.SkyDome = SkyDome;
    exports.SkyPanoramicMaterial = SkyPanoramicMaterial;
    exports.SkyPanoramicShaderInit = SkyPanoramicShaderInit;
    exports.SkyProceduralMaterial = SkyProceduralMaterial;
    exports.SkyProceduralShaderInit = SkyProceduralShaderInit;
    exports.SkyRenderer = SkyRenderer;
    exports.SphereColliderShape = SphereColliderShape;
    exports.SphereShape = SphereShape;
    exports.SphericalHarmonicsL2 = SphericalHarmonicsL2;
    exports.SphericalHarmonicsL2Generater = SphericalHarmonicsL2Generater;
    exports.SpotLight = SpotLight;
    exports.SpotLightCom = SpotLightCom;
    exports.Sprite3D = Sprite3D;
    exports.Sprite3DRenderDeclaration = Sprite3DRenderDeclaration;
    exports.StartFrame = StartFrame;
    exports.StatiVertexMergeBatchRender = StatiVertexMergeBatchRender;
    exports.StaticBatchMesh = StaticBatchMesh;
    exports.StaticBatchMeshRender = StaticBatchMeshRender;
    exports.StaticBatchMeshRenderElement = StaticBatchMeshRenderElement;
    exports.StaticBatchSubInfo = StaticBatchSubInfo;
    exports.StaticBatchSubMesh = StaticBatchSubMesh;
    exports.StaticBatchVolume = StaticBatchVolume;
    exports.StaticInstanceBatchRender = StaticInstanceBatchRender;
    exports.StaticMeshBatchManager = StaticMeshBatchManager;
    exports.StaticMeshMergeInfo = StaticMeshMergeInfo;
    exports.StaticPlaneColliderShape = StaticPlaneColliderShape;
    exports.SubMesh = SubMesh;
    exports.SubMeshInstanceBatch = SubMeshInstanceBatch;
    exports.SubMeshRenderElement = SubMeshRenderElement;
    exports.TextMesh = TextMesh;
    exports.TextureCube = TextureCube;
    exports.TextureGenerator = TextureGenerator;
    exports.TextureSheetAnimation = TextureSheetAnimation;
    exports.TrailFilter = TrailFilter;
    exports.TrailGeometry = TrailGeometry;
    exports.TrailMaterial = TrailMaterial;
    exports.TrailRenderer = TrailRenderer;
    exports.TrailShaderInit = TrailShaderInit;
    exports.TrailSprite3D = TrailSprite3D;
    exports.TrailTextureMode = TrailTextureMode;
    exports.TransLargeUBOUtils = TransLargeUBOUtils;
    exports.Transform3D = Transform3D;
    exports.UI3D = UI3D;
    exports.UI3DGeometry = UI3DGeometry;
    exports.UI3DManager = UI3DManager;
    exports.UnlitMaterial = UnlitMaterial;
    exports.UnlitShaderInit = UnlitShaderInit;
    exports.Utils3D = Utils3D;
    exports.Vector2Keyframe = Vector2Keyframe;
    exports.Vector3Keyframe = Vector3Keyframe;
    exports.Vector4Keyframe = Vector4Keyframe;
    exports.VelocityOverLifetime = VelocityOverLifetime;
    exports.VertexBuffer3D = VertexBuffer3D;
    exports.VertexPositionTerrain = VertexPositionTerrain;
    exports.VertexPositionTexture0 = VertexPositionTexture0;
    exports.VertexShuriKenParticle = VertexShuriKenParticle;
    exports.VertexShurikenParticleBillboard = VertexShurikenParticleBillboard;
    exports.VertexShurikenParticleMesh = VertexShurikenParticleMesh;
    exports.VertexTrail = VertexTrail;
    exports.Viewport = Viewport;
    exports.Volume = Volume;
    exports.VolumeManager = VolumeManager;
    exports.WaterPrimaryMaterial = WaterPrimaryMaterial;
    exports.WebXRCamera = WebXRCamera;
    exports.WebXRCameraInfo = WebXRCameraInfo;
    exports.WebXRCameraManager = WebXRCameraManager;
    exports.WebXRExperienceHelper = WebXRExperienceHelper;
    exports.WebXRInput = WebXRInput;
    exports.WebXRInputManager = WebXRInputManager;
    exports.WebXRRenderTexture = WebXRRenderTexture;
    exports.WebXRSessionManager = WebXRSessionManager;
    exports.btVehicleTuning = btVehicleTuning;
    exports.btWheelInfo = btWheelInfo;
    exports.skinnedMatrixCache = skinnedMatrixCache;
    exports.volumeIntersectInfo = volumeIntersectInfo;

})(window.Laya = window.Laya || {}, Laya);
//# sourceMappingURL=laya.d3.js.map
